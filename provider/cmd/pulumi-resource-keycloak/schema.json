{
    "name": "keycloak",
    "description": "A Pulumi package for creating and managing keycloak cloud resources.",
    "keywords": [
        "pulumi",
        "keycloak"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`keycloak` Terraform Provider](https://github.com/mrparkers/terraform-provider-keycloak).",
    "repository": "https://github.com/pulumi/pulumi-keycloak",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "namespaces": {
                "authentication": "Authentication",
                "index": "index",
                "keycloak": "Keycloak",
                "ldap": "Ldap",
                "oidc": "Oidc",
                "openid": "OpenId",
                "saml": "Saml"
            },
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true
        },
        "go": {
            "importBasePath": "github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true,
            "respectSchemaVersion": true
        },
        "nodejs": {
            "packageDescription": "A Pulumi package for creating and managing keycloak cloud resources.",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/mrparkers/terraform-provider-keycloak)\n\u003e distributed under [MIT](https://mit-license.org/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-keycloak` repo](https://github.com/pulumi/pulumi-keycloak/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-keycloak` repo](https://github.com/mrparkers/terraform-provider-keycloak/issues).",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true,
            "respectSchemaVersion": true
        },
        "python": {
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            },
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/mrparkers/terraform-provider-keycloak)\n\u003e distributed under [MIT](https://mit-license.org/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-keycloak` repo](https://github.com/pulumi/pulumi-keycloak/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-keycloak` repo](https://github.com/mrparkers/terraform-provider-keycloak/issues).",
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true,
            "pyproject": {
                "enabled": true
            }
        }
    },
    "config": {
        "variables": {
            "additionalHeaders": {
                "type": "object",
                "additionalProperties": {
                    "type": "string"
                }
            },
            "basePath": {
                "type": "string"
            },
            "clientId": {
                "type": "string"
            },
            "clientSecret": {
                "type": "string"
            },
            "clientTimeout": {
                "type": "integer",
                "description": "Timeout (in seconds) of the Keycloak client\n",
                "default": 5,
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_CLIENT_TIMEOUT"
                    ]
                }
            },
            "initialLogin": {
                "type": "boolean",
                "description": "Whether or not to login to Keycloak instance on provider initialization\n"
            },
            "password": {
                "type": "string"
            },
            "realm": {
                "type": "string"
            },
            "redHatSso": {
                "type": "boolean",
                "description": "When true, the provider will treat the Keycloak instance as a Red Hat SSO server, specifically when parsing the version\nreturned from the /serverinfo API endpoint.\n"
            },
            "rootCaCertificate": {
                "type": "string",
                "description": "Allows x509 calls using an unknown CA certificate (for development purposes)\n"
            },
            "tlsInsecureSkipVerify": {
                "type": "boolean",
                "description": "Allows ignoring insecure certificates when set to true. Defaults to false. Disabling security check is dangerous and\nshould be avoided.\n"
            },
            "url": {
                "type": "string",
                "description": "The base URL of the Keycloak instance, before `/auth`\n"
            },
            "username": {
                "type": "string"
            }
        },
        "defaults": [
            "clientId",
            "url"
        ]
    },
    "types": {
        "keycloak:index/GroupPermissionsManageMembersScope:GroupPermissionsManageMembersScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/GroupPermissionsManageMembershipScope:GroupPermissionsManageMembershipScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/GroupPermissionsManageScope:GroupPermissionsManageScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/GroupPermissionsViewMembersScope:GroupPermissionsViewMembersScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/GroupPermissionsViewScope:GroupPermissionsViewScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/RealmInternationalization:RealmInternationalization": {
            "properties": {
                "defaultLocale": {
                    "type": "string"
                },
                "supportedLocales": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object",
            "required": [
                "defaultLocale",
                "supportedLocales"
            ]
        },
        "keycloak:index/RealmOtpPolicy:RealmOtpPolicy": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "What hashing algorithm should be used to generate the OTP.\n"
                },
                "digits": {
                    "type": "integer"
                },
                "initialCounter": {
                    "type": "integer"
                },
                "lookAheadWindow": {
                    "type": "integer"
                },
                "period": {
                    "type": "integer"
                },
                "type": {
                    "type": "string",
                    "description": "OTP Type, totp for Time-Based One Time Password or hotp for counter base one time password\n"
                }
            },
            "type": "object"
        },
        "keycloak:index/RealmSecurityDefenses:RealmSecurityDefenses": {
            "properties": {
                "bruteForceDetection": {
                    "$ref": "#/types/keycloak:index/RealmSecurityDefensesBruteForceDetection:RealmSecurityDefensesBruteForceDetection"
                },
                "headers": {
                    "$ref": "#/types/keycloak:index/RealmSecurityDefensesHeaders:RealmSecurityDefensesHeaders"
                }
            },
            "type": "object"
        },
        "keycloak:index/RealmSecurityDefensesBruteForceDetection:RealmSecurityDefensesBruteForceDetection": {
            "properties": {
                "failureResetTimeSeconds": {
                    "type": "integer"
                },
                "maxFailureWaitSeconds": {
                    "type": "integer"
                },
                "maxLoginFailures": {
                    "type": "integer"
                },
                "minimumQuickLoginWaitSeconds": {
                    "type": "integer"
                },
                "permanentLockout": {
                    "type": "boolean"
                },
                "quickLoginCheckMilliSeconds": {
                    "type": "integer"
                },
                "waitIncrementSeconds": {
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "keycloak:index/RealmSecurityDefensesHeaders:RealmSecurityDefensesHeaders": {
            "properties": {
                "contentSecurityPolicy": {
                    "type": "string"
                },
                "contentSecurityPolicyReportOnly": {
                    "type": "string"
                },
                "referrerPolicy": {
                    "type": "string"
                },
                "strictTransportSecurity": {
                    "type": "string"
                },
                "xContentTypeOptions": {
                    "type": "string"
                },
                "xFrameOptions": {
                    "type": "string"
                },
                "xRobotsTag": {
                    "type": "string"
                },
                "xXssProtection": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "keycloak:index/RealmSmtpServer:RealmSmtpServer": {
            "properties": {
                "auth": {
                    "$ref": "#/types/keycloak:index/RealmSmtpServerAuth:RealmSmtpServerAuth"
                },
                "envelopeFrom": {
                    "type": "string"
                },
                "from": {
                    "type": "string"
                },
                "fromDisplayName": {
                    "type": "string"
                },
                "host": {
                    "type": "string"
                },
                "port": {
                    "type": "string"
                },
                "replyTo": {
                    "type": "string"
                },
                "replyToDisplayName": {
                    "type": "string"
                },
                "ssl": {
                    "type": "boolean"
                },
                "starttls": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "from",
                "host"
            ]
        },
        "keycloak:index/RealmSmtpServerAuth:RealmSmtpServerAuth": {
            "properties": {
                "password": {
                    "type": "string",
                    "secret": true
                },
                "username": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "password",
                "username"
            ]
        },
        "keycloak:index/RealmUserProfileAttribute:RealmUserProfileAttribute": {
            "properties": {
                "annotations": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "displayName": {
                    "type": "string",
                    "description": "The display name of the attribute.\n"
                },
                "enabledWhenScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of scopes. The attribute will only be enabled when these scopes are requested by clients.\n"
                },
                "group": {
                    "type": "string",
                    "description": "A list of groups.\n"
                },
                "name": {
                    "type": "string"
                },
                "permissions": {
                    "$ref": "#/types/keycloak:index/RealmUserProfileAttributePermissions:RealmUserProfileAttributePermissions",
                    "description": "The permissions configuration information.\n"
                },
                "requiredForRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of roles for which the attribute will be required.\n"
                },
                "requiredForScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of scopes for which the attribute will be required.\n"
                },
                "validators": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/RealmUserProfileAttributeValidator:RealmUserProfileAttributeValidator"
                    },
                    "description": "A list of validators for the attribute.\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "keycloak:index/RealmUserProfileAttributePermissions:RealmUserProfileAttributePermissions": {
            "properties": {
                "edits": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of profiles that will be able to edit the attribute. One of `admin`, `user`.\n"
                },
                "views": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of profiles that will be able to view the attribute. One of `admin`, `user`.\n"
                }
            },
            "type": "object",
            "required": [
                "edits",
                "views"
            ]
        },
        "keycloak:index/RealmUserProfileAttributeValidator:RealmUserProfileAttributeValidator": {
            "properties": {
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map defining the configuration of the validator. Values can be a String or a json object.\n"
                },
                "name": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "keycloak:index/RealmUserProfileGroup:RealmUserProfileGroup": {
            "properties": {
                "annotations": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "displayDescription": {
                    "type": "string",
                    "description": "The display description of the group.\n"
                },
                "displayHeader": {
                    "type": "string",
                    "description": "The display header of the group.\n"
                },
                "name": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "keycloak:index/RealmWebAuthnPasswordlessPolicy:RealmWebAuthnPasswordlessPolicy": {
            "properties": {
                "acceptableAaguids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "attestationConveyancePreference": {
                    "type": "string",
                    "description": "Either none, indirect or direct\n"
                },
                "authenticatorAttachment": {
                    "type": "string",
                    "description": "Either platform or cross-platform\n"
                },
                "avoidSameAuthenticatorRegister": {
                    "type": "boolean"
                },
                "createTimeout": {
                    "type": "integer"
                },
                "relyingPartyEntityName": {
                    "type": "string"
                },
                "relyingPartyId": {
                    "type": "string"
                },
                "requireResidentKey": {
                    "type": "string",
                    "description": "Either Yes or No\n"
                },
                "signatureAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Keycloak lists ES256, ES384, ES512, RS256, RS384, RS512, RS1 at the time of writing\n"
                },
                "userVerificationRequirement": {
                    "type": "string",
                    "description": "Either required, preferred or discouraged\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "signatureAlgorithms"
                    ]
                }
            }
        },
        "keycloak:index/RealmWebAuthnPolicy:RealmWebAuthnPolicy": {
            "properties": {
                "acceptableAaguids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "attestationConveyancePreference": {
                    "type": "string",
                    "description": "Either none, indirect or direct\n"
                },
                "authenticatorAttachment": {
                    "type": "string",
                    "description": "Either platform or cross-platform\n"
                },
                "avoidSameAuthenticatorRegister": {
                    "type": "boolean"
                },
                "createTimeout": {
                    "type": "integer"
                },
                "relyingPartyEntityName": {
                    "type": "string"
                },
                "relyingPartyId": {
                    "type": "string"
                },
                "requireResidentKey": {
                    "type": "string",
                    "description": "Either Yes or No\n"
                },
                "signatureAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Keycloak lists ES256, ES384, ES512, RS256, RS384, RS512, RS1 at the time of writing\n"
                },
                "userVerificationRequirement": {
                    "type": "string",
                    "description": "Either required, preferred or discouraged\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "signatureAlgorithms"
                    ]
                }
            }
        },
        "keycloak:index/UserFederatedIdentity:UserFederatedIdentity": {
            "properties": {
                "identityProvider": {
                    "type": "string"
                },
                "userId": {
                    "type": "string"
                },
                "userName": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "identityProvider",
                "userId",
                "userName"
            ]
        },
        "keycloak:index/UserInitialPassword:UserInitialPassword": {
            "properties": {
                "temporary": {
                    "type": "boolean"
                },
                "value": {
                    "type": "string",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "value"
            ]
        },
        "keycloak:index/UsersPermissionsImpersonateScope:UsersPermissionsImpersonateScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/UsersPermissionsManageGroupMembershipScope:UsersPermissionsManageGroupMembershipScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/UsersPermissionsManageScope:UsersPermissionsManageScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/UsersPermissionsMapRolesScope:UsersPermissionsMapRolesScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/UsersPermissionsUserImpersonatedScope:UsersPermissionsUserImpersonatedScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/UsersPermissionsViewScope:UsersPermissionsViewScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/getClientDescriptionConverterProtocolMapper:getClientDescriptionConverterProtocolMapper": {
            "properties": {
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "protocol": {
                    "type": "string"
                },
                "protocolMapper": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "config",
                "id",
                "name",
                "protocol",
                "protocolMapper"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmInternationalization:getRealmInternationalization": {
            "properties": {
                "defaultLocale": {
                    "type": "string"
                },
                "supportedLocales": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object",
            "required": [
                "defaultLocale",
                "supportedLocales"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmKeysKey:getRealmKeysKey": {
            "properties": {
                "algorithm": {
                    "type": "string"
                },
                "certificate": {
                    "type": "string"
                },
                "kid": {
                    "type": "string"
                },
                "providerId": {
                    "type": "string"
                },
                "providerPriority": {
                    "type": "integer"
                },
                "publicKey": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "algorithm",
                "certificate",
                "kid",
                "providerId",
                "providerPriority",
                "publicKey",
                "status",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmOtpPolicy:getRealmOtpPolicy": {
            "properties": {
                "algorithm": {
                    "type": "string"
                },
                "digits": {
                    "type": "integer"
                },
                "initialCounter": {
                    "type": "integer"
                },
                "lookAheadWindow": {
                    "type": "integer"
                },
                "period": {
                    "type": "integer"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "algorithm",
                "digits",
                "initialCounter",
                "lookAheadWindow",
                "period",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmSecurityDefense:getRealmSecurityDefense": {
            "properties": {
                "bruteForceDetections": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/getRealmSecurityDefenseBruteForceDetection:getRealmSecurityDefenseBruteForceDetection"
                    }
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/getRealmSecurityDefenseHeader:getRealmSecurityDefenseHeader"
                    }
                }
            },
            "type": "object",
            "required": [
                "bruteForceDetections",
                "headers"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmSecurityDefenseBruteForceDetection:getRealmSecurityDefenseBruteForceDetection": {
            "properties": {
                "failureResetTimeSeconds": {
                    "type": "integer"
                },
                "maxFailureWaitSeconds": {
                    "type": "integer"
                },
                "maxLoginFailures": {
                    "type": "integer"
                },
                "minimumQuickLoginWaitSeconds": {
                    "type": "integer"
                },
                "permanentLockout": {
                    "type": "boolean"
                },
                "quickLoginCheckMilliSeconds": {
                    "type": "integer"
                },
                "waitIncrementSeconds": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "failureResetTimeSeconds",
                "maxFailureWaitSeconds",
                "maxLoginFailures",
                "minimumQuickLoginWaitSeconds",
                "permanentLockout",
                "quickLoginCheckMilliSeconds",
                "waitIncrementSeconds"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmSecurityDefenseHeader:getRealmSecurityDefenseHeader": {
            "properties": {
                "contentSecurityPolicy": {
                    "type": "string"
                },
                "contentSecurityPolicyReportOnly": {
                    "type": "string"
                },
                "referrerPolicy": {
                    "type": "string"
                },
                "strictTransportSecurity": {
                    "type": "string"
                },
                "xContentTypeOptions": {
                    "type": "string"
                },
                "xFrameOptions": {
                    "type": "string"
                },
                "xRobotsTag": {
                    "type": "string"
                },
                "xXssProtection": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "contentSecurityPolicy",
                "contentSecurityPolicyReportOnly",
                "referrerPolicy",
                "strictTransportSecurity",
                "xContentTypeOptions",
                "xFrameOptions",
                "xRobotsTag",
                "xXssProtection"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmSmtpServer:getRealmSmtpServer": {
            "properties": {
                "auths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/getRealmSmtpServerAuth:getRealmSmtpServerAuth"
                    }
                },
                "envelopeFrom": {
                    "type": "string"
                },
                "from": {
                    "type": "string"
                },
                "fromDisplayName": {
                    "type": "string"
                },
                "host": {
                    "type": "string"
                },
                "port": {
                    "type": "string"
                },
                "replyTo": {
                    "type": "string"
                },
                "replyToDisplayName": {
                    "type": "string"
                },
                "ssl": {
                    "type": "boolean"
                },
                "starttls": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "auths",
                "envelopeFrom",
                "from",
                "fromDisplayName",
                "host",
                "port",
                "replyTo",
                "replyToDisplayName",
                "ssl",
                "starttls"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmSmtpServerAuth:getRealmSmtpServerAuth": {
            "properties": {
                "password": {
                    "type": "string",
                    "secret": true
                },
                "username": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "password",
                "username"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmWebAuthnPasswordlessPolicy:getRealmWebAuthnPasswordlessPolicy": {
            "properties": {
                "acceptableAaguids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "attestationConveyancePreference": {
                    "type": "string",
                    "description": "Either none, indirect or direct\n"
                },
                "authenticatorAttachment": {
                    "type": "string",
                    "description": "Either platform or cross-platform\n"
                },
                "avoidSameAuthenticatorRegister": {
                    "type": "boolean"
                },
                "createTimeout": {
                    "type": "integer"
                },
                "relyingPartyEntityName": {
                    "type": "string"
                },
                "relyingPartyId": {
                    "type": "string"
                },
                "requireResidentKey": {
                    "type": "string",
                    "description": "Either Yes or No\n"
                },
                "signatureAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Keycloak lists ES256, ES384, ES512, RS256, ES384, ES512 at the time of writing\n"
                },
                "userVerificationRequirement": {
                    "type": "string",
                    "description": "Either required, preferred or discouraged\n"
                }
            },
            "type": "object",
            "required": [
                "acceptableAaguids",
                "attestationConveyancePreference",
                "authenticatorAttachment",
                "avoidSameAuthenticatorRegister",
                "createTimeout",
                "relyingPartyEntityName",
                "relyingPartyId",
                "requireResidentKey",
                "signatureAlgorithms",
                "userVerificationRequirement"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmWebAuthnPolicy:getRealmWebAuthnPolicy": {
            "properties": {
                "acceptableAaguids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "attestationConveyancePreference": {
                    "type": "string",
                    "description": "Either none, indirect or direct\n"
                },
                "authenticatorAttachment": {
                    "type": "string",
                    "description": "Either platform or cross-platform\n"
                },
                "avoidSameAuthenticatorRegister": {
                    "type": "boolean"
                },
                "createTimeout": {
                    "type": "integer"
                },
                "relyingPartyEntityName": {
                    "type": "string"
                },
                "relyingPartyId": {
                    "type": "string"
                },
                "requireResidentKey": {
                    "type": "string",
                    "description": "Either Yes or No\n"
                },
                "signatureAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Keycloak lists ES256, ES384, ES512, RS256, ES384, ES512 at the time of writing\n"
                },
                "userVerificationRequirement": {
                    "type": "string",
                    "description": "Either required, preferred or discouraged\n"
                }
            },
            "type": "object",
            "required": [
                "acceptableAaguids",
                "attestationConveyancePreference",
                "authenticatorAttachment",
                "avoidSameAuthenticatorRegister",
                "createTimeout",
                "relyingPartyEntityName",
                "relyingPartyId",
                "requireResidentKey",
                "signatureAlgorithms",
                "userVerificationRequirement"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:ldap/UserFederationCache:UserFederationCache": {
            "properties": {
                "evictionDay": {
                    "type": "integer",
                    "description": "Day of the week the entry will become invalid on.\n"
                },
                "evictionHour": {
                    "type": "integer",
                    "description": "Hour of day the entry will become invalid on.\n"
                },
                "evictionMinute": {
                    "type": "integer",
                    "description": "Minute of day the entry will become invalid on.\n"
                },
                "maxLifespan": {
                    "type": "string",
                    "description": "Max lifespan of cache entry (duration string).\n"
                },
                "policy": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "keycloak:ldap/UserFederationKerberos:UserFederationKerberos": {
            "properties": {
                "kerberosRealm": {
                    "type": "string",
                    "description": "The name of the kerberos realm, e.g. FOO.LOCAL\n"
                },
                "keyTab": {
                    "type": "string",
                    "description": "Path to the kerberos keytab file on the server with credentials of the service principal.\n"
                },
                "serverPrincipal": {
                    "type": "string",
                    "description": "The kerberos server principal, e.g. 'HTTP/host.foo.com@FOO.LOCAL'.\n"
                },
                "useKerberosForPasswordAuthentication": {
                    "type": "boolean",
                    "description": "Use kerberos login module instead of ldap service api. Defaults to `false`.\n"
                }
            },
            "type": "object",
            "required": [
                "kerberosRealm",
                "keyTab",
                "serverPrincipal"
            ]
        },
        "keycloak:openid/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides": {
            "properties": {
                "browserId": {
                    "type": "string"
                },
                "directGrantId": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "keycloak:openid/ClientAuthorization:ClientAuthorization": {
            "properties": {
                "allowRemoteResourceManagement": {
                    "type": "boolean"
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "keepDefaults": {
                    "type": "boolean"
                },
                "policyEnforcementMode": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "policyEnforcementMode"
            ]
        },
        "keycloak:openid/ClientGroupPolicyGroup:ClientGroupPolicyGroup": {
            "properties": {
                "extendChildren": {
                    "type": "boolean"
                },
                "id": {
                    "type": "string"
                },
                "path": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "extendChildren",
                "id",
                "path"
            ]
        },
        "keycloak:openid/ClientPermissionsConfigureScope:ClientPermissionsConfigureScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "keycloak:openid/ClientPermissionsManageScope:ClientPermissionsManageScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "keycloak:openid/ClientPermissionsMapRolesClientScopeScope:ClientPermissionsMapRolesClientScopeScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "keycloak:openid/ClientPermissionsMapRolesCompositeScope:ClientPermissionsMapRolesCompositeScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "keycloak:openid/ClientPermissionsMapRolesScope:ClientPermissionsMapRolesScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "keycloak:openid/ClientPermissionsTokenExchangeScope:ClientPermissionsTokenExchangeScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "keycloak:openid/ClientPermissionsViewScope:ClientPermissionsViewScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "keycloak:openid/ClientRolePolicyRole:ClientRolePolicyRole": {
            "properties": {
                "id": {
                    "type": "string"
                },
                "required": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "id",
                "required"
            ]
        },
        "keycloak:openid/getClientAuthenticationFlowBindingOverride:getClientAuthenticationFlowBindingOverride": {
            "properties": {
                "browserId": {
                    "type": "string"
                },
                "directGrantId": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "browserId",
                "directGrantId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:openid/getClientAuthorization:getClientAuthorization": {
            "properties": {
                "allowRemoteResourceManagement": {
                    "type": "boolean"
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "keepDefaults": {
                    "type": "boolean"
                },
                "policyEnforcementMode": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "allowRemoteResourceManagement",
                "decisionStrategy",
                "keepDefaults",
                "policyEnforcementMode"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:openid/getClientServiceAccountUserFederatedIdentity:getClientServiceAccountUserFederatedIdentity": {
            "properties": {
                "identityProvider": {
                    "type": "string"
                },
                "userId": {
                    "type": "string"
                },
                "userName": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "identityProvider",
                "userId",
                "userName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:saml/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides": {
            "properties": {
                "browserId": {
                    "type": "string"
                },
                "directGrantId": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "keycloak:saml/getClientAuthenticationFlowBindingOverride:getClientAuthenticationFlowBindingOverride": {
            "properties": {
                "browserId": {
                    "type": "string"
                },
                "directGrantId": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "browserId",
                "directGrantId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the keycloak package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "additionalHeaders": {
                "type": "object",
                "additionalProperties": {
                    "type": "string"
                }
            },
            "basePath": {
                "type": "string"
            },
            "clientId": {
                "type": "string"
            },
            "clientSecret": {
                "type": "string"
            },
            "clientTimeout": {
                "type": "integer",
                "description": "Timeout (in seconds) of the Keycloak client\n"
            },
            "initialLogin": {
                "type": "boolean",
                "description": "Whether or not to login to Keycloak instance on provider initialization\n"
            },
            "password": {
                "type": "string"
            },
            "realm": {
                "type": "string"
            },
            "redHatSso": {
                "type": "boolean",
                "description": "When true, the provider will treat the Keycloak instance as a Red Hat SSO server, specifically when parsing the version\nreturned from the /serverinfo API endpoint.\n"
            },
            "rootCaCertificate": {
                "type": "string",
                "description": "Allows x509 calls using an unknown CA certificate (for development purposes)\n"
            },
            "tlsInsecureSkipVerify": {
                "type": "boolean",
                "description": "Allows ignoring insecure certificates when set to true. Defaults to false. Disabling security check is dangerous and\nshould be avoided.\n"
            },
            "url": {
                "type": "string",
                "description": "The base URL of the Keycloak instance, before `/auth`\n"
            },
            "username": {
                "type": "string"
            }
        },
        "required": [
            "clientId",
            "url"
        ],
        "inputProperties": {
            "additionalHeaders": {
                "type": "object",
                "additionalProperties": {
                    "type": "string"
                }
            },
            "basePath": {
                "type": "string"
            },
            "clientId": {
                "type": "string"
            },
            "clientSecret": {
                "type": "string"
            },
            "clientTimeout": {
                "type": "integer",
                "description": "Timeout (in seconds) of the Keycloak client\n",
                "default": 5,
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_CLIENT_TIMEOUT"
                    ]
                }
            },
            "initialLogin": {
                "type": "boolean",
                "description": "Whether or not to login to Keycloak instance on provider initialization\n"
            },
            "password": {
                "type": "string"
            },
            "realm": {
                "type": "string"
            },
            "redHatSso": {
                "type": "boolean",
                "description": "When true, the provider will treat the Keycloak instance as a Red Hat SSO server, specifically when parsing the version\nreturned from the /serverinfo API endpoint.\n"
            },
            "rootCaCertificate": {
                "type": "string",
                "description": "Allows x509 calls using an unknown CA certificate (for development purposes)\n"
            },
            "tlsInsecureSkipVerify": {
                "type": "boolean",
                "description": "Allows ignoring insecure certificates when set to true. Defaults to false. Disabling security check is dangerous and\nshould be avoided.\n"
            },
            "url": {
                "type": "string",
                "description": "The base URL of the Keycloak instance, before `/auth`\n"
            },
            "username": {
                "type": "string"
            }
        },
        "requiredInputs": [
            "clientId",
            "url"
        ]
    },
    "resources": {
        "keycloak:authentication/bindings:Bindings": {
            "description": "Allows for creating and managing realm authentication flow bindings within Keycloak.\n\n[Authentication flows](https://www.keycloak.org/docs/latest/server_admin/index.html#_authentication-flows) describe a sequence\nof actions that a user or service must perform in order to be authenticated to Keycloak. The authentication flow itself\nis a container for these actions, which are otherwise known as executions.\n\nRealms assign authentication flows to supported user flows such as `registration` and `browser`. This resource allows the\nupdating of realm authentication flow bindings to custom authentication flows created by `keycloak.authentication.Flow`.\n\nNote that you can also use the `keycloak.Realm` resource to assign authentication flow bindings at the realm level. This\nresource is useful if you would like to create a realm and an authentication flow, and assign this flow to the realm within\na single run of `pulumi up`. In any case, do not attempt to use both the arguments within the `keycloak.Realm` resource\nand this resource to manage authentication flow bindings, you should choose one or the other.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst flow = new keycloak.authentication.Flow(\"flow\", {\n    realmId: realm.id,\n    alias: \"my-flow-alias\",\n});\n// first execution\nconst executionOne = new keycloak.authentication.Execution(\"execution_one\", {\n    realmId: realm.id,\n    parentFlowAlias: flow.alias,\n    authenticator: \"auth-cookie\",\n    requirement: \"ALTERNATIVE\",\n});\n// second execution\nconst executionTwo = new keycloak.authentication.Execution(\"execution_two\", {\n    realmId: realm.id,\n    parentFlowAlias: flow.alias,\n    authenticator: \"identity-provider-redirector\",\n    requirement: \"ALTERNATIVE\",\n}, {\n    dependsOn: [executionOne],\n});\nconst browserAuthenticationBinding = new keycloak.authentication.Bindings(\"browser_authentication_binding\", {\n    realmId: realm.id,\n    browserFlow: flow.alias,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nflow = keycloak.authentication.Flow(\"flow\",\n    realm_id=realm.id,\n    alias=\"my-flow-alias\")\n# first execution\nexecution_one = keycloak.authentication.Execution(\"execution_one\",\n    realm_id=realm.id,\n    parent_flow_alias=flow.alias,\n    authenticator=\"auth-cookie\",\n    requirement=\"ALTERNATIVE\")\n# second execution\nexecution_two = keycloak.authentication.Execution(\"execution_two\",\n    realm_id=realm.id,\n    parent_flow_alias=flow.alias,\n    authenticator=\"identity-provider-redirector\",\n    requirement=\"ALTERNATIVE\",\n    opts = pulumi.ResourceOptions(depends_on=[execution_one]))\nbrowser_authentication_binding = keycloak.authentication.Bindings(\"browser_authentication_binding\",\n    realm_id=realm.id,\n    browser_flow=flow.alias)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var flow = new Keycloak.Authentication.Flow(\"flow\", new()\n    {\n        RealmId = realm.Id,\n        Alias = \"my-flow-alias\",\n    });\n\n    // first execution\n    var executionOne = new Keycloak.Authentication.Execution(\"execution_one\", new()\n    {\n        RealmId = realm.Id,\n        ParentFlowAlias = flow.Alias,\n        Authenticator = \"auth-cookie\",\n        Requirement = \"ALTERNATIVE\",\n    });\n\n    // second execution\n    var executionTwo = new Keycloak.Authentication.Execution(\"execution_two\", new()\n    {\n        RealmId = realm.Id,\n        ParentFlowAlias = flow.Alias,\n        Authenticator = \"identity-provider-redirector\",\n        Requirement = \"ALTERNATIVE\",\n    }, new CustomResourceOptions\n    {\n        DependsOn =\n        {\n            executionOne,\n        },\n    });\n\n    var browserAuthenticationBinding = new Keycloak.Authentication.Bindings(\"browser_authentication_binding\", new()\n    {\n        RealmId = realm.Id,\n        BrowserFlow = flow.Alias,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/authentication\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tflow, err := authentication.NewFlow(ctx, \"flow\", \u0026authentication.FlowArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tAlias:   pulumi.String(\"my-flow-alias\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// first execution\n\t\texecutionOne, err := authentication.NewExecution(ctx, \"execution_one\", \u0026authentication.ExecutionArgs{\n\t\t\tRealmId:         realm.ID(),\n\t\t\tParentFlowAlias: flow.Alias,\n\t\t\tAuthenticator:   pulumi.String(\"auth-cookie\"),\n\t\t\tRequirement:     pulumi.String(\"ALTERNATIVE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// second execution\n\t\t_, err = authentication.NewExecution(ctx, \"execution_two\", \u0026authentication.ExecutionArgs{\n\t\t\tRealmId:         realm.ID(),\n\t\t\tParentFlowAlias: flow.Alias,\n\t\t\tAuthenticator:   pulumi.String(\"identity-provider-redirector\"),\n\t\t\tRequirement:     pulumi.String(\"ALTERNATIVE\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\texecutionOne,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = authentication.NewBindings(ctx, \"browser_authentication_binding\", \u0026authentication.BindingsArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tBrowserFlow: flow.Alias,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.authentication.Flow;\nimport com.pulumi.keycloak.authentication.FlowArgs;\nimport com.pulumi.keycloak.authentication.Execution;\nimport com.pulumi.keycloak.authentication.ExecutionArgs;\nimport com.pulumi.keycloak.authentication.Bindings;\nimport com.pulumi.keycloak.authentication.BindingsArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var flow = new Flow(\"flow\", FlowArgs.builder()\n            .realmId(realm.id())\n            .alias(\"my-flow-alias\")\n            .build());\n\n        // first execution\n        var executionOne = new Execution(\"executionOne\", ExecutionArgs.builder()\n            .realmId(realm.id())\n            .parentFlowAlias(flow.alias())\n            .authenticator(\"auth-cookie\")\n            .requirement(\"ALTERNATIVE\")\n            .build());\n\n        // second execution\n        var executionTwo = new Execution(\"executionTwo\", ExecutionArgs.builder()\n            .realmId(realm.id())\n            .parentFlowAlias(flow.alias())\n            .authenticator(\"identity-provider-redirector\")\n            .requirement(\"ALTERNATIVE\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(executionOne)\n                .build());\n\n        var browserAuthenticationBinding = new Bindings(\"browserAuthenticationBinding\", BindingsArgs.builder()\n            .realmId(realm.id())\n            .browserFlow(flow.alias())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  flow:\n    type: keycloak:authentication:Flow\n    properties:\n      realmId: ${realm.id}\n      alias: my-flow-alias\n  # first execution\n  executionOne:\n    type: keycloak:authentication:Execution\n    name: execution_one\n    properties:\n      realmId: ${realm.id}\n      parentFlowAlias: ${flow.alias}\n      authenticator: auth-cookie\n      requirement: ALTERNATIVE\n  # second execution\n  executionTwo:\n    type: keycloak:authentication:Execution\n    name: execution_two\n    properties:\n      realmId: ${realm.id}\n      parentFlowAlias: ${flow.alias}\n      authenticator: identity-provider-redirector\n      requirement: ALTERNATIVE\n    options:\n      dependson:\n        - ${executionOne}\n  browserAuthenticationBinding:\n    type: keycloak:authentication:Bindings\n    name: browser_authentication_binding\n    properties:\n      realmId: ${realm.id}\n      browserFlow: ${flow.alias}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "browserFlow": {
                    "type": "string",
                    "description": "The alias of the flow to assign to the realm BrowserFlow.\n"
                },
                "clientAuthenticationFlow": {
                    "type": "string",
                    "description": "The alias of the flow to assign to the realm ClientAuthenticationFlow.\n"
                },
                "directGrantFlow": {
                    "type": "string",
                    "description": "The alias of the flow to assign to the realm DirectGrantFlow.\n"
                },
                "dockerAuthenticationFlow": {
                    "type": "string",
                    "description": "The alias of the flow to assign to the realm DockerAuthenticationFlow.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the authentication flow binding exists in.\n"
                },
                "registrationFlow": {
                    "type": "string",
                    "description": "The alias of the flow to assign to the realm RegistrationFlow.\n"
                },
                "resetCredentialsFlow": {
                    "type": "string",
                    "description": "The alias of the flow to assign to the realm ResetCredentialsFlow.\n"
                }
            },
            "required": [
                "browserFlow",
                "clientAuthenticationFlow",
                "directGrantFlow",
                "dockerAuthenticationFlow",
                "realmId",
                "registrationFlow",
                "resetCredentialsFlow"
            ],
            "inputProperties": {
                "browserFlow": {
                    "type": "string",
                    "description": "The alias of the flow to assign to the realm BrowserFlow.\n"
                },
                "clientAuthenticationFlow": {
                    "type": "string",
                    "description": "The alias of the flow to assign to the realm ClientAuthenticationFlow.\n"
                },
                "directGrantFlow": {
                    "type": "string",
                    "description": "The alias of the flow to assign to the realm DirectGrantFlow.\n"
                },
                "dockerAuthenticationFlow": {
                    "type": "string",
                    "description": "The alias of the flow to assign to the realm DockerAuthenticationFlow.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the authentication flow binding exists in.\n",
                    "willReplaceOnChanges": true
                },
                "registrationFlow": {
                    "type": "string",
                    "description": "The alias of the flow to assign to the realm RegistrationFlow.\n"
                },
                "resetCredentialsFlow": {
                    "type": "string",
                    "description": "The alias of the flow to assign to the realm ResetCredentialsFlow.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Bindings resources.\n",
                "properties": {
                    "browserFlow": {
                        "type": "string",
                        "description": "The alias of the flow to assign to the realm BrowserFlow.\n"
                    },
                    "clientAuthenticationFlow": {
                        "type": "string",
                        "description": "The alias of the flow to assign to the realm ClientAuthenticationFlow.\n"
                    },
                    "directGrantFlow": {
                        "type": "string",
                        "description": "The alias of the flow to assign to the realm DirectGrantFlow.\n"
                    },
                    "dockerAuthenticationFlow": {
                        "type": "string",
                        "description": "The alias of the flow to assign to the realm DockerAuthenticationFlow.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm the authentication flow binding exists in.\n",
                        "willReplaceOnChanges": true
                    },
                    "registrationFlow": {
                        "type": "string",
                        "description": "The alias of the flow to assign to the realm RegistrationFlow.\n"
                    },
                    "resetCredentialsFlow": {
                        "type": "string",
                        "description": "The alias of the flow to assign to the realm ResetCredentialsFlow.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:authentication/execution:Execution": {
            "description": "Allows for creating and managing an authentication execution within Keycloak.\n\nAn authentication execution is an action that the user or service may or may not take when authenticating through an authentication\nflow.\n\n\u003e Due to limitations in the Keycloak API, the ordering of authentication executions within a flow must be specified using `depends_on`. Authentication executions that are created first will appear first within the flow.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst flow = new keycloak.authentication.Flow(\"flow\", {\n    realmId: realm.id,\n    alias: \"my-flow-alias\",\n});\n// first execution\nconst executionOne = new keycloak.authentication.Execution(\"execution_one\", {\n    realmId: realm.id,\n    parentFlowAlias: flow.alias,\n    authenticator: \"auth-cookie\",\n    requirement: \"ALTERNATIVE\",\n});\n// second execution\nconst executionTwo = new keycloak.authentication.Execution(\"execution_two\", {\n    realmId: realm.id,\n    parentFlowAlias: flow.alias,\n    authenticator: \"identity-provider-redirector\",\n    requirement: \"ALTERNATIVE\",\n}, {\n    dependsOn: [executionOne],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nflow = keycloak.authentication.Flow(\"flow\",\n    realm_id=realm.id,\n    alias=\"my-flow-alias\")\n# first execution\nexecution_one = keycloak.authentication.Execution(\"execution_one\",\n    realm_id=realm.id,\n    parent_flow_alias=flow.alias,\n    authenticator=\"auth-cookie\",\n    requirement=\"ALTERNATIVE\")\n# second execution\nexecution_two = keycloak.authentication.Execution(\"execution_two\",\n    realm_id=realm.id,\n    parent_flow_alias=flow.alias,\n    authenticator=\"identity-provider-redirector\",\n    requirement=\"ALTERNATIVE\",\n    opts = pulumi.ResourceOptions(depends_on=[execution_one]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var flow = new Keycloak.Authentication.Flow(\"flow\", new()\n    {\n        RealmId = realm.Id,\n        Alias = \"my-flow-alias\",\n    });\n\n    // first execution\n    var executionOne = new Keycloak.Authentication.Execution(\"execution_one\", new()\n    {\n        RealmId = realm.Id,\n        ParentFlowAlias = flow.Alias,\n        Authenticator = \"auth-cookie\",\n        Requirement = \"ALTERNATIVE\",\n    });\n\n    // second execution\n    var executionTwo = new Keycloak.Authentication.Execution(\"execution_two\", new()\n    {\n        RealmId = realm.Id,\n        ParentFlowAlias = flow.Alias,\n        Authenticator = \"identity-provider-redirector\",\n        Requirement = \"ALTERNATIVE\",\n    }, new CustomResourceOptions\n    {\n        DependsOn =\n        {\n            executionOne,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/authentication\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tflow, err := authentication.NewFlow(ctx, \"flow\", \u0026authentication.FlowArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tAlias:   pulumi.String(\"my-flow-alias\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// first execution\n\t\texecutionOne, err := authentication.NewExecution(ctx, \"execution_one\", \u0026authentication.ExecutionArgs{\n\t\t\tRealmId:         realm.ID(),\n\t\t\tParentFlowAlias: flow.Alias,\n\t\t\tAuthenticator:   pulumi.String(\"auth-cookie\"),\n\t\t\tRequirement:     pulumi.String(\"ALTERNATIVE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// second execution\n\t\t_, err = authentication.NewExecution(ctx, \"execution_two\", \u0026authentication.ExecutionArgs{\n\t\t\tRealmId:         realm.ID(),\n\t\t\tParentFlowAlias: flow.Alias,\n\t\t\tAuthenticator:   pulumi.String(\"identity-provider-redirector\"),\n\t\t\tRequirement:     pulumi.String(\"ALTERNATIVE\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\texecutionOne,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.authentication.Flow;\nimport com.pulumi.keycloak.authentication.FlowArgs;\nimport com.pulumi.keycloak.authentication.Execution;\nimport com.pulumi.keycloak.authentication.ExecutionArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var flow = new Flow(\"flow\", FlowArgs.builder()\n            .realmId(realm.id())\n            .alias(\"my-flow-alias\")\n            .build());\n\n        // first execution\n        var executionOne = new Execution(\"executionOne\", ExecutionArgs.builder()\n            .realmId(realm.id())\n            .parentFlowAlias(flow.alias())\n            .authenticator(\"auth-cookie\")\n            .requirement(\"ALTERNATIVE\")\n            .build());\n\n        // second execution\n        var executionTwo = new Execution(\"executionTwo\", ExecutionArgs.builder()\n            .realmId(realm.id())\n            .parentFlowAlias(flow.alias())\n            .authenticator(\"identity-provider-redirector\")\n            .requirement(\"ALTERNATIVE\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(executionOne)\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  flow:\n    type: keycloak:authentication:Flow\n    properties:\n      realmId: ${realm.id}\n      alias: my-flow-alias\n  # first execution\n  executionOne:\n    type: keycloak:authentication:Execution\n    name: execution_one\n    properties:\n      realmId: ${realm.id}\n      parentFlowAlias: ${flow.alias}\n      authenticator: auth-cookie\n      requirement: ALTERNATIVE\n  # second execution\n  executionTwo:\n    type: keycloak:authentication:Execution\n    name: execution_two\n    properties:\n      realmId: ${realm.id}\n      parentFlowAlias: ${flow.alias}\n      authenticator: identity-provider-redirector\n      requirement: ALTERNATIVE\n    options:\n      dependson:\n        - ${executionOne}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAuthentication executions can be imported using the formats: `{{realmId}}/{{parentFlowAlias}}/{{authenticationExecutionId}}`.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:authentication/execution:Execution execution_one my-realm/my-flow-alias/30559fcf-6fb8-45ea-8c46-2b86f46ebc17\n```\n\n",
            "properties": {
                "authenticator": {
                    "type": "string",
                    "description": "The name of the authenticator. This can be found by experimenting with the GUI and looking at HTTP requests within the network tab of your browser's development tools.\n"
                },
                "parentFlowAlias": {
                    "type": "string",
                    "description": "The alias of the flow this execution is attached to.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the authentication execution exists in.\n"
                },
                "requirement": {
                    "type": "string",
                    "description": "The requirement setting, which can be one of `REQUIRED`, `ALTERNATIVE`, `OPTIONAL`, `CONDITIONAL`, or `DISABLED`. Defaults to `DISABLED`.\n"
                }
            },
            "required": [
                "authenticator",
                "parentFlowAlias",
                "realmId"
            ],
            "inputProperties": {
                "authenticator": {
                    "type": "string",
                    "description": "The name of the authenticator. This can be found by experimenting with the GUI and looking at HTTP requests within the network tab of your browser's development tools.\n",
                    "willReplaceOnChanges": true
                },
                "parentFlowAlias": {
                    "type": "string",
                    "description": "The alias of the flow this execution is attached to.\n",
                    "willReplaceOnChanges": true
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the authentication execution exists in.\n",
                    "willReplaceOnChanges": true
                },
                "requirement": {
                    "type": "string",
                    "description": "The requirement setting, which can be one of `REQUIRED`, `ALTERNATIVE`, `OPTIONAL`, `CONDITIONAL`, or `DISABLED`. Defaults to `DISABLED`.\n"
                }
            },
            "requiredInputs": [
                "authenticator",
                "parentFlowAlias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Execution resources.\n",
                "properties": {
                    "authenticator": {
                        "type": "string",
                        "description": "The name of the authenticator. This can be found by experimenting with the GUI and looking at HTTP requests within the network tab of your browser's development tools.\n",
                        "willReplaceOnChanges": true
                    },
                    "parentFlowAlias": {
                        "type": "string",
                        "description": "The alias of the flow this execution is attached to.\n",
                        "willReplaceOnChanges": true
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm the authentication execution exists in.\n",
                        "willReplaceOnChanges": true
                    },
                    "requirement": {
                        "type": "string",
                        "description": "The requirement setting, which can be one of `REQUIRED`, `ALTERNATIVE`, `OPTIONAL`, `CONDITIONAL`, or `DISABLED`. Defaults to `DISABLED`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:authentication/executionConfig:ExecutionConfig": {
            "description": "Allows for managing an authentication execution's configuration. If a particular authentication execution supports additional\nconfiguration (such as with the `identity-provider-redirector` execution), this can be managed with this resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst flow = new keycloak.authentication.Flow(\"flow\", {\n    realmId: realm.id,\n    alias: \"my-flow-alias\",\n});\nconst execution = new keycloak.authentication.Execution(\"execution\", {\n    realmId: realm.id,\n    parentFlowAlias: flow.alias,\n    authenticator: \"identity-provider-redirector\",\n});\nconst config = new keycloak.authentication.ExecutionConfig(\"config\", {\n    realmId: realm.id,\n    executionId: execution.id,\n    alias: \"my-config-alias\",\n    config: {\n        defaultProvider: \"my-config-default-idp\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nflow = keycloak.authentication.Flow(\"flow\",\n    realm_id=realm.id,\n    alias=\"my-flow-alias\")\nexecution = keycloak.authentication.Execution(\"execution\",\n    realm_id=realm.id,\n    parent_flow_alias=flow.alias,\n    authenticator=\"identity-provider-redirector\")\nconfig = keycloak.authentication.ExecutionConfig(\"config\",\n    realm_id=realm.id,\n    execution_id=execution.id,\n    alias=\"my-config-alias\",\n    config={\n        \"defaultProvider\": \"my-config-default-idp\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var flow = new Keycloak.Authentication.Flow(\"flow\", new()\n    {\n        RealmId = realm.Id,\n        Alias = \"my-flow-alias\",\n    });\n\n    var execution = new Keycloak.Authentication.Execution(\"execution\", new()\n    {\n        RealmId = realm.Id,\n        ParentFlowAlias = flow.Alias,\n        Authenticator = \"identity-provider-redirector\",\n    });\n\n    var config = new Keycloak.Authentication.ExecutionConfig(\"config\", new()\n    {\n        RealmId = realm.Id,\n        ExecutionId = execution.Id,\n        Alias = \"my-config-alias\",\n        Config = \n        {\n            { \"defaultProvider\", \"my-config-default-idp\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/authentication\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tflow, err := authentication.NewFlow(ctx, \"flow\", \u0026authentication.FlowArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tAlias:   pulumi.String(\"my-flow-alias\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texecution, err := authentication.NewExecution(ctx, \"execution\", \u0026authentication.ExecutionArgs{\n\t\t\tRealmId:         realm.ID(),\n\t\t\tParentFlowAlias: flow.Alias,\n\t\t\tAuthenticator:   pulumi.String(\"identity-provider-redirector\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = authentication.NewExecutionConfig(ctx, \"config\", \u0026authentication.ExecutionConfigArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tExecutionId: execution.ID(),\n\t\t\tAlias:       pulumi.String(\"my-config-alias\"),\n\t\t\tConfig: pulumi.StringMap{\n\t\t\t\t\"defaultProvider\": pulumi.String(\"my-config-default-idp\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.authentication.Flow;\nimport com.pulumi.keycloak.authentication.FlowArgs;\nimport com.pulumi.keycloak.authentication.Execution;\nimport com.pulumi.keycloak.authentication.ExecutionArgs;\nimport com.pulumi.keycloak.authentication.ExecutionConfig;\nimport com.pulumi.keycloak.authentication.ExecutionConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var flow = new Flow(\"flow\", FlowArgs.builder()\n            .realmId(realm.id())\n            .alias(\"my-flow-alias\")\n            .build());\n\n        var execution = new Execution(\"execution\", ExecutionArgs.builder()\n            .realmId(realm.id())\n            .parentFlowAlias(flow.alias())\n            .authenticator(\"identity-provider-redirector\")\n            .build());\n\n        var config = new ExecutionConfig(\"config\", ExecutionConfigArgs.builder()\n            .realmId(realm.id())\n            .executionId(execution.id())\n            .alias(\"my-config-alias\")\n            .config(Map.of(\"defaultProvider\", \"my-config-default-idp\"))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  flow:\n    type: keycloak:authentication:Flow\n    properties:\n      realmId: ${realm.id}\n      alias: my-flow-alias\n  execution:\n    type: keycloak:authentication:Execution\n    properties:\n      realmId: ${realm.id}\n      parentFlowAlias: ${flow.alias}\n      authenticator: identity-provider-redirector\n  config:\n    type: keycloak:authentication:ExecutionConfig\n    properties:\n      realmId: ${realm.id}\n      executionId: ${execution.id}\n      alias: my-config-alias\n      config:\n        defaultProvider: my-config-default-idp\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nConfigurations can be imported using the format `{{realm}}/{{authenticationExecutionId}}/{{authenticationExecutionConfigId}}`.\n\nIf the `authenticationExecutionId` is incorrect, the import will still be successful.\n\nA subsequent apply will change the `authenticationExecutionId` to the correct one, which causes the configuration to be replaced.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:authentication/executionConfig:ExecutionConfig config my-realm/be081463-ddbf-4b42-9eff-9c97886f24ff/30559fcf-6fb8-45ea-8c46-2b86f46ebc17\n```\n\n",
            "properties": {
                "alias": {
                    "type": "string",
                    "description": "The name of the configuration.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The configuration. Keys are specific to each configurable authentication execution and not checked when applying.\n"
                },
                "executionId": {
                    "type": "string",
                    "description": "The authentication execution this configuration is attached to.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the authentication execution exists in.\n"
                }
            },
            "required": [
                "alias",
                "config",
                "executionId",
                "realmId"
            ],
            "inputProperties": {
                "alias": {
                    "type": "string",
                    "description": "The name of the configuration.\n",
                    "willReplaceOnChanges": true
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The configuration. Keys are specific to each configurable authentication execution and not checked when applying.\n"
                },
                "executionId": {
                    "type": "string",
                    "description": "The authentication execution this configuration is attached to.\n",
                    "willReplaceOnChanges": true
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the authentication execution exists in.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "alias",
                "config",
                "executionId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ExecutionConfig resources.\n",
                "properties": {
                    "alias": {
                        "type": "string",
                        "description": "The name of the configuration.\n",
                        "willReplaceOnChanges": true
                    },
                    "config": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The configuration. Keys are specific to each configurable authentication execution and not checked when applying.\n"
                    },
                    "executionId": {
                        "type": "string",
                        "description": "The authentication execution this configuration is attached to.\n",
                        "willReplaceOnChanges": true
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm the authentication execution exists in.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:authentication/flow:Flow": {
            "description": "Allows for creating and managing an authentication flow within Keycloak.\n\n[Authentication flows](https://www.keycloak.org/docs/11.0/server_admin/index.html#_authentication-flows) describe a sequence\nof actions that a user or service must perform in order to be authenticated to Keycloak. The authentication flow itself\nis a container for these actions, which are otherwise known as executions.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst flow = new keycloak.authentication.Flow(\"flow\", {\n    realmId: realm.id,\n    alias: \"my-flow-alias\",\n});\nconst execution = new keycloak.authentication.Execution(\"execution\", {\n    realmId: realm.id,\n    parentFlowAlias: flow.alias,\n    authenticator: \"identity-provider-redirector\",\n    requirement: \"REQUIRED\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nflow = keycloak.authentication.Flow(\"flow\",\n    realm_id=realm.id,\n    alias=\"my-flow-alias\")\nexecution = keycloak.authentication.Execution(\"execution\",\n    realm_id=realm.id,\n    parent_flow_alias=flow.alias,\n    authenticator=\"identity-provider-redirector\",\n    requirement=\"REQUIRED\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var flow = new Keycloak.Authentication.Flow(\"flow\", new()\n    {\n        RealmId = realm.Id,\n        Alias = \"my-flow-alias\",\n    });\n\n    var execution = new Keycloak.Authentication.Execution(\"execution\", new()\n    {\n        RealmId = realm.Id,\n        ParentFlowAlias = flow.Alias,\n        Authenticator = \"identity-provider-redirector\",\n        Requirement = \"REQUIRED\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/authentication\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tflow, err := authentication.NewFlow(ctx, \"flow\", \u0026authentication.FlowArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tAlias:   pulumi.String(\"my-flow-alias\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = authentication.NewExecution(ctx, \"execution\", \u0026authentication.ExecutionArgs{\n\t\t\tRealmId:         realm.ID(),\n\t\t\tParentFlowAlias: flow.Alias,\n\t\t\tAuthenticator:   pulumi.String(\"identity-provider-redirector\"),\n\t\t\tRequirement:     pulumi.String(\"REQUIRED\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.authentication.Flow;\nimport com.pulumi.keycloak.authentication.FlowArgs;\nimport com.pulumi.keycloak.authentication.Execution;\nimport com.pulumi.keycloak.authentication.ExecutionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var flow = new Flow(\"flow\", FlowArgs.builder()\n            .realmId(realm.id())\n            .alias(\"my-flow-alias\")\n            .build());\n\n        var execution = new Execution(\"execution\", ExecutionArgs.builder()\n            .realmId(realm.id())\n            .parentFlowAlias(flow.alias())\n            .authenticator(\"identity-provider-redirector\")\n            .requirement(\"REQUIRED\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  flow:\n    type: keycloak:authentication:Flow\n    properties:\n      realmId: ${realm.id}\n      alias: my-flow-alias\n  execution:\n    type: keycloak:authentication:Execution\n    properties:\n      realmId: ${realm.id}\n      parentFlowAlias: ${flow.alias}\n      authenticator: identity-provider-redirector\n      requirement: REQUIRED\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAuthentication flows can be imported using the format `{{realmId}}/{{authenticationFlowId}}`. The authentication flow ID is\n\ntypically a GUID which is autogenerated when the flow is created via Keycloak.\n\nUnfortunately, it is not trivial to retrieve the authentication flow ID from the UI. The best way to do this is to visit the\n\n\"Authentication\" page in Keycloak, and use the network tab of your browser to view the response of the API call to `/auth/admin/realms/${realm}/authentication/flows`,\n\nwhich will be a list of authentication flows.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:authentication/flow:Flow flow my-realm/e9a5641e-778c-4daf-89c0-f4ef617987d1\n```\n\n",
            "properties": {
                "alias": {
                    "type": "string",
                    "description": "The alias for this authentication flow.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the authentication flow.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The type of authentication flow to create. Valid choices include `basic-flow` and `client-flow`. Defaults to `basic-flow`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that the authentication flow exists in.\n"
                }
            },
            "required": [
                "alias",
                "realmId"
            ],
            "inputProperties": {
                "alias": {
                    "type": "string",
                    "description": "The alias for this authentication flow.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the authentication flow.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The type of authentication flow to create. Valid choices include `basic-flow` and `client-flow`. Defaults to `basic-flow`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that the authentication flow exists in.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "alias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Flow resources.\n",
                "properties": {
                    "alias": {
                        "type": "string",
                        "description": "The alias for this authentication flow.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description for the authentication flow.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The type of authentication flow to create. Valid choices include `basic-flow` and `client-flow`. Defaults to `basic-flow`.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that the authentication flow exists in.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:authentication/subflow:Subflow": {
            "description": "Allows for creating and managing an authentication subflow within Keycloak.\n\nLike authentication flows, authentication subflows are containers for authentication executions.\nAs its name implies, an authentication subflow is contained in an authentication flow.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst flow = new keycloak.authentication.Flow(\"flow\", {\n    realmId: realm.id,\n    alias: \"my-flow-alias\",\n});\nconst subflow = new keycloak.authentication.Subflow(\"subflow\", {\n    realmId: realm.id,\n    alias: \"my-subflow-alias\",\n    parentFlowAlias: flow.alias,\n    providerId: \"basic-flow\",\n    requirement: \"ALTERNATIVE\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nflow = keycloak.authentication.Flow(\"flow\",\n    realm_id=realm.id,\n    alias=\"my-flow-alias\")\nsubflow = keycloak.authentication.Subflow(\"subflow\",\n    realm_id=realm.id,\n    alias=\"my-subflow-alias\",\n    parent_flow_alias=flow.alias,\n    provider_id=\"basic-flow\",\n    requirement=\"ALTERNATIVE\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var flow = new Keycloak.Authentication.Flow(\"flow\", new()\n    {\n        RealmId = realm.Id,\n        Alias = \"my-flow-alias\",\n    });\n\n    var subflow = new Keycloak.Authentication.Subflow(\"subflow\", new()\n    {\n        RealmId = realm.Id,\n        Alias = \"my-subflow-alias\",\n        ParentFlowAlias = flow.Alias,\n        ProviderId = \"basic-flow\",\n        Requirement = \"ALTERNATIVE\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/authentication\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tflow, err := authentication.NewFlow(ctx, \"flow\", \u0026authentication.FlowArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tAlias:   pulumi.String(\"my-flow-alias\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = authentication.NewSubflow(ctx, \"subflow\", \u0026authentication.SubflowArgs{\n\t\t\tRealmId:         realm.ID(),\n\t\t\tAlias:           pulumi.String(\"my-subflow-alias\"),\n\t\t\tParentFlowAlias: flow.Alias,\n\t\t\tProviderId:      pulumi.String(\"basic-flow\"),\n\t\t\tRequirement:     pulumi.String(\"ALTERNATIVE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.authentication.Flow;\nimport com.pulumi.keycloak.authentication.FlowArgs;\nimport com.pulumi.keycloak.authentication.Subflow;\nimport com.pulumi.keycloak.authentication.SubflowArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var flow = new Flow(\"flow\", FlowArgs.builder()\n            .realmId(realm.id())\n            .alias(\"my-flow-alias\")\n            .build());\n\n        var subflow = new Subflow(\"subflow\", SubflowArgs.builder()\n            .realmId(realm.id())\n            .alias(\"my-subflow-alias\")\n            .parentFlowAlias(flow.alias())\n            .providerId(\"basic-flow\")\n            .requirement(\"ALTERNATIVE\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  flow:\n    type: keycloak:authentication:Flow\n    properties:\n      realmId: ${realm.id}\n      alias: my-flow-alias\n  subflow:\n    type: keycloak:authentication:Subflow\n    properties:\n      realmId: ${realm.id}\n      alias: my-subflow-alias\n      parentFlowAlias: ${flow.alias}\n      providerId: basic-flow\n      requirement: ALTERNATIVE\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAuthentication flows can be imported using the format `{{realmId}}/{{parentFlowAlias}}/{{authenticationSubflowId}}`.\n\nThe authentication subflow ID is typically a GUID which is autogenerated when the subflow is created via Keycloak.\n\nUnfortunately, it is not trivial to retrieve the authentication subflow ID from the UI. The best way to do this is to visit the\n\n\"Authentication\" page in Keycloak, and use the network tab of your browser to view the response of the API call to\n\n`/auth/admin/realms/${realm}/authentication/flows/{flow}/executions`, which will be a list of executions, where the subflow will be.\n\n__The subflow ID is contained in the `flowID` field__ (not, as one could guess, the `id` field).\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:authentication/subflow:Subflow subflow my-realm/\"Parent Flow\"/3bad1172-bb5c-4a77-9615-c2606eb03081\n```\n\n",
            "properties": {
                "alias": {
                    "type": "string",
                    "description": "The alias for this authentication subflow.\n"
                },
                "authenticator": {
                    "type": "string",
                    "description": "The name of the authenticator. Might be needed to be set with certain custom subflows with specific\nauthenticators. In general this will remain empty.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the authentication subflow.\n"
                },
                "parentFlowAlias": {
                    "type": "string",
                    "description": "The alias for the parent authentication flow.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The type of authentication subflow to create. Valid choices include `basic-flow`, `form-flow`\nand `client-flow`. Defaults to `basic-flow`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that the authentication subflow exists in.\n"
                },
                "requirement": {
                    "type": "string",
                    "description": "The requirement setting, which can be one of `REQUIRED`, `ALTERNATIVE`, `OPTIONAL`, `CONDITIONAL`,\nor `DISABLED`. Defaults to `DISABLED`.\n"
                }
            },
            "required": [
                "alias",
                "parentFlowAlias",
                "realmId"
            ],
            "inputProperties": {
                "alias": {
                    "type": "string",
                    "description": "The alias for this authentication subflow.\n"
                },
                "authenticator": {
                    "type": "string",
                    "description": "The name of the authenticator. Might be needed to be set with certain custom subflows with specific\nauthenticators. In general this will remain empty.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "A description for the authentication subflow.\n"
                },
                "parentFlowAlias": {
                    "type": "string",
                    "description": "The alias for the parent authentication flow.\n",
                    "willReplaceOnChanges": true
                },
                "providerId": {
                    "type": "string",
                    "description": "The type of authentication subflow to create. Valid choices include `basic-flow`, `form-flow`\nand `client-flow`. Defaults to `basic-flow`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that the authentication subflow exists in.\n",
                    "willReplaceOnChanges": true
                },
                "requirement": {
                    "type": "string",
                    "description": "The requirement setting, which can be one of `REQUIRED`, `ALTERNATIVE`, `OPTIONAL`, `CONDITIONAL`,\nor `DISABLED`. Defaults to `DISABLED`.\n"
                }
            },
            "requiredInputs": [
                "alias",
                "parentFlowAlias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Subflow resources.\n",
                "properties": {
                    "alias": {
                        "type": "string",
                        "description": "The alias for this authentication subflow.\n"
                    },
                    "authenticator": {
                        "type": "string",
                        "description": "The name of the authenticator. Might be needed to be set with certain custom subflows with specific\nauthenticators. In general this will remain empty.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "A description for the authentication subflow.\n"
                    },
                    "parentFlowAlias": {
                        "type": "string",
                        "description": "The alias for the parent authentication flow.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The type of authentication subflow to create. Valid choices include `basic-flow`, `form-flow`\nand `client-flow`. Defaults to `basic-flow`.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that the authentication subflow exists in.\n",
                        "willReplaceOnChanges": true
                    },
                    "requirement": {
                        "type": "string",
                        "description": "The requirement setting, which can be one of `REQUIRED`, `ALTERNATIVE`, `OPTIONAL`, `CONDITIONAL`,\nor `DISABLED`. Defaults to `DISABLED`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/attributeImporterIdentityProviderMapper:AttributeImporterIdentityProviderMapper": {
            "description": "## # keycloak.AttributeImporterIdentityProviderMapper\n\nAllows to create and manage identity provider mappers within Keycloak.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst testMapper = new keycloak.AttributeImporterIdentityProviderMapper(\"test_mapper\", {\n    realm: \"my-realm\",\n    name: \"my-mapper\",\n    identityProviderAlias: \"idp_alias\",\n    attributeName: \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\",\n    userAttribute: \"lastName\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\ntest_mapper = keycloak.AttributeImporterIdentityProviderMapper(\"test_mapper\",\n    realm=\"my-realm\",\n    name=\"my-mapper\",\n    identity_provider_alias=\"idp_alias\",\n    attribute_name=\"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\",\n    user_attribute=\"lastName\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testMapper = new Keycloak.AttributeImporterIdentityProviderMapper(\"test_mapper\", new()\n    {\n        Realm = \"my-realm\",\n        Name = \"my-mapper\",\n        IdentityProviderAlias = \"idp_alias\",\n        AttributeName = \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\",\n        UserAttribute = \"lastName\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := keycloak.NewAttributeImporterIdentityProviderMapper(ctx, \"test_mapper\", \u0026keycloak.AttributeImporterIdentityProviderMapperArgs{\n\t\t\tRealm:                 pulumi.String(\"my-realm\"),\n\t\t\tName:                  pulumi.String(\"my-mapper\"),\n\t\t\tIdentityProviderAlias: pulumi.String(\"idp_alias\"),\n\t\t\tAttributeName:         pulumi.String(\"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\"),\n\t\t\tUserAttribute:         pulumi.String(\"lastName\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.AttributeImporterIdentityProviderMapper;\nimport com.pulumi.keycloak.AttributeImporterIdentityProviderMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testMapper = new AttributeImporterIdentityProviderMapper(\"testMapper\", AttributeImporterIdentityProviderMapperArgs.builder()\n            .realm(\"my-realm\")\n            .name(\"my-mapper\")\n            .identityProviderAlias(\"idp_alias\")\n            .attributeName(\"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\")\n            .userAttribute(\"lastName\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testMapper:\n    type: keycloak:AttributeImporterIdentityProviderMapper\n    name: test_mapper\n    properties:\n      realm: my-realm\n      name: my-mapper\n      identityProviderAlias: idp_alias\n      attributeName: http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname\n      userAttribute: lastName\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm` - (Required) The name of the realm.\n- `name` - (Required) The name of the mapper.\n- `identity_provider_alias` - (Required) The alias of the associated identity provider.\n- `user_attribute` - (Required) The user attribute name to store SAML attribute.\n- `attribute_name` - (Optional) The Name of attribute to search for in assertion. You can leave this blank and specify a friendly name instead.\n- `attribute_friendly_name` - (Optional) The friendly name of attribute to search for in assertion.  You can leave this blank and specify an attribute name instead.\n- `claim_name` - (Optional) The claim name.\n\n### Import\n\nIdentity provider mapper can be imported using the format `{{realm_id}}/{{idp_alias}}/{{idp_mapper_id}}`, where `idp_alias` is the identity provider alias, and `idp_mapper_id` is the unique ID that Keycloak\nassigns to the mapper upon creation. This value can be found in the URI when editing this mapper in the GUI, and is typically a GUID.\n\nExample:\n\n```bash\n$ terraform import keycloak_attribute_importer_identity_provider_mapper.test_mapper my-realm/my-mapper/f446db98-7133-4e30-b18a-3d28fde7ca1b\n```\n",
            "properties": {
                "attributeFriendlyName": {
                    "type": "string",
                    "description": "Attribute Friendly Name\n"
                },
                "attributeName": {
                    "type": "string",
                    "description": "Attribute Name\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "Claim Name\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "userAttribute": {
                    "type": "string",
                    "description": "User Attribute\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm",
                "userAttribute"
            ],
            "inputProperties": {
                "attributeFriendlyName": {
                    "type": "string",
                    "description": "Attribute Friendly Name\n"
                },
                "attributeName": {
                    "type": "string",
                    "description": "Attribute Name\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "Claim Name\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n",
                    "willReplaceOnChanges": true
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n",
                    "willReplaceOnChanges": true
                },
                "userAttribute": {
                    "type": "string",
                    "description": "User Attribute\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm",
                "userAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AttributeImporterIdentityProviderMapper resources.\n",
                "properties": {
                    "attributeFriendlyName": {
                        "type": "string",
                        "description": "Attribute Friendly Name\n"
                    },
                    "attributeName": {
                        "type": "string",
                        "description": "Attribute Name\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "Claim Name\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "IDP Alias\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "IDP Mapper Name\n",
                        "willReplaceOnChanges": true
                    },
                    "realm": {
                        "type": "string",
                        "description": "Realm Name\n",
                        "willReplaceOnChanges": true
                    },
                    "userAttribute": {
                        "type": "string",
                        "description": "User Attribute\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/attributeToRoleIdentityMapper:AttributeToRoleIdentityMapper": {
            "description": "Allows for creating and managing an attribute to role identity provider mapper within Keycloak.\n\n\u003e If you are using Keycloak 10 or higher, you will need to specify the `extra_config` argument in order to define a `syncMode` for the mapper.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst oidc = new keycloak.oidc.IdentityProvider(\"oidc\", {\n    realm: realm.id,\n    alias: \"oidc\",\n    authorizationUrl: \"https://example.com/auth\",\n    tokenUrl: \"https://example.com/token\",\n    clientId: \"example_id\",\n    clientSecret: \"example_token\",\n    defaultScopes: \"openid random profile\",\n});\nconst realmRole = new keycloak.Role(\"realm_role\", {\n    realmId: realm.id,\n    name: \"my-realm-role\",\n    description: \"My Realm Role\",\n});\nconst oidcAttributeToRoleIdentityMapper = new keycloak.AttributeToRoleIdentityMapper(\"oidc\", {\n    realm: realm.id,\n    name: \"role-attribute\",\n    identityProviderAlias: oidc.alias,\n    role: \"my-realm-role\",\n    claimName: \"my-claim\",\n    claimValue: \"my-value\",\n    extraConfig: {\n        syncMode: \"INHERIT\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\noidc = keycloak.oidc.IdentityProvider(\"oidc\",\n    realm=realm.id,\n    alias=\"oidc\",\n    authorization_url=\"https://example.com/auth\",\n    token_url=\"https://example.com/token\",\n    client_id=\"example_id\",\n    client_secret=\"example_token\",\n    default_scopes=\"openid random profile\")\nrealm_role = keycloak.Role(\"realm_role\",\n    realm_id=realm.id,\n    name=\"my-realm-role\",\n    description=\"My Realm Role\")\noidc_attribute_to_role_identity_mapper = keycloak.AttributeToRoleIdentityMapper(\"oidc\",\n    realm=realm.id,\n    name=\"role-attribute\",\n    identity_provider_alias=oidc.alias,\n    role=\"my-realm-role\",\n    claim_name=\"my-claim\",\n    claim_value=\"my-value\",\n    extra_config={\n        \"syncMode\": \"INHERIT\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var oidc = new Keycloak.Oidc.IdentityProvider(\"oidc\", new()\n    {\n        Realm = realm.Id,\n        Alias = \"oidc\",\n        AuthorizationUrl = \"https://example.com/auth\",\n        TokenUrl = \"https://example.com/token\",\n        ClientId = \"example_id\",\n        ClientSecret = \"example_token\",\n        DefaultScopes = \"openid random profile\",\n    });\n\n    var realmRole = new Keycloak.Role(\"realm_role\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-realm-role\",\n        Description = \"My Realm Role\",\n    });\n\n    var oidcAttributeToRoleIdentityMapper = new Keycloak.AttributeToRoleIdentityMapper(\"oidc\", new()\n    {\n        Realm = realm.Id,\n        Name = \"role-attribute\",\n        IdentityProviderAlias = oidc.Alias,\n        Role = \"my-realm-role\",\n        ClaimName = \"my-claim\",\n        ClaimValue = \"my-value\",\n        ExtraConfig = \n        {\n            { \"syncMode\", \"INHERIT\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/oidc\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\toidc, err := oidc.NewIdentityProvider(ctx, \"oidc\", \u0026oidc.IdentityProviderArgs{\n\t\t\tRealm:            realm.ID(),\n\t\t\tAlias:            pulumi.String(\"oidc\"),\n\t\t\tAuthorizationUrl: pulumi.String(\"https://example.com/auth\"),\n\t\t\tTokenUrl:         pulumi.String(\"https://example.com/token\"),\n\t\t\tClientId:         pulumi.String(\"example_id\"),\n\t\t\tClientSecret:     pulumi.String(\"example_token\"),\n\t\t\tDefaultScopes:    pulumi.String(\"openid random profile\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"realm_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tName:        pulumi.String(\"my-realm-role\"),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewAttributeToRoleIdentityMapper(ctx, \"oidc\", \u0026keycloak.AttributeToRoleIdentityMapperArgs{\n\t\t\tRealm:                 realm.ID(),\n\t\t\tName:                  pulumi.String(\"role-attribute\"),\n\t\t\tIdentityProviderAlias: oidc.Alias,\n\t\t\tRole:                  pulumi.String(\"my-realm-role\"),\n\t\t\tClaimName:             pulumi.String(\"my-claim\"),\n\t\t\tClaimValue:            pulumi.String(\"my-value\"),\n\t\t\tExtraConfig: pulumi.Map{\n\t\t\t\t\"syncMode\": pulumi.Any(\"INHERIT\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.oidc.IdentityProvider;\nimport com.pulumi.keycloak.oidc.IdentityProviderArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport com.pulumi.keycloak.AttributeToRoleIdentityMapper;\nimport com.pulumi.keycloak.AttributeToRoleIdentityMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var oidc = new IdentityProvider(\"oidc\", IdentityProviderArgs.builder()\n            .realm(realm.id())\n            .alias(\"oidc\")\n            .authorizationUrl(\"https://example.com/auth\")\n            .tokenUrl(\"https://example.com/token\")\n            .clientId(\"example_id\")\n            .clientSecret(\"example_token\")\n            .defaultScopes(\"openid random profile\")\n            .build());\n\n        var realmRole = new Role(\"realmRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-realm-role\")\n            .description(\"My Realm Role\")\n            .build());\n\n        var oidcAttributeToRoleIdentityMapper = new AttributeToRoleIdentityMapper(\"oidcAttributeToRoleIdentityMapper\", AttributeToRoleIdentityMapperArgs.builder()\n            .realm(realm.id())\n            .name(\"role-attribute\")\n            .identityProviderAlias(oidc.alias())\n            .role(\"my-realm-role\")\n            .claimName(\"my-claim\")\n            .claimValue(\"my-value\")\n            .extraConfig(Map.of(\"syncMode\", \"INHERIT\"))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  oidc:\n    type: keycloak:oidc:IdentityProvider\n    properties:\n      realm: ${realm.id}\n      alias: oidc\n      authorizationUrl: https://example.com/auth\n      tokenUrl: https://example.com/token\n      clientId: example_id\n      clientSecret: example_token\n      defaultScopes: openid random profile\n  realmRole:\n    type: keycloak:Role\n    name: realm_role\n    properties:\n      realmId: ${realm.id}\n      name: my-realm-role\n      description: My Realm Role\n  oidcAttributeToRoleIdentityMapper:\n    type: keycloak:AttributeToRoleIdentityMapper\n    name: oidc\n    properties:\n      realm: ${realm.id}\n      name: role-attribute\n      identityProviderAlias: ${oidc.alias}\n      role: my-realm-role\n      claimName: my-claim\n      claimValue: my-value\n      extraConfig:\n        syncMode: INHERIT\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nIdentity provider mappers can be imported using the format `{{realm_id}}/{{idp_alias}}/{{idp_mapper_id}}`, where `idp_alias` is the identity provider alias, and `idp_mapper_id` is the unique ID that Keycloak\n\nassigns to the mapper upon creation. This value can be found in the URI when editing this mapper in the GUI, and is typically a GUID.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:index/attributeToRoleIdentityMapper:AttributeToRoleIdentityMapper test_mapper my-realm/my-mapper/f446db98-7133-4e30-b18a-3d28fde7ca1b\n```\n\n",
            "properties": {
                "attributeFriendlyName": {
                    "type": "string",
                    "description": "Attribute Friendly Name. Conflicts with `attribute_name`.\n"
                },
                "attributeName": {
                    "type": "string",
                    "description": "Attribute Name.\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "Attribute Value.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "OIDC Claim Name\n"
                },
                "claimValue": {
                    "type": "string",
                    "description": "OIDC Claim Value\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "The alias of the associated identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the mapper.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role Name.\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm",
                "role"
            ],
            "inputProperties": {
                "attributeFriendlyName": {
                    "type": "string",
                    "description": "Attribute Friendly Name. Conflicts with `attribute_name`.\n"
                },
                "attributeName": {
                    "type": "string",
                    "description": "Attribute Name.\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "Attribute Value.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "OIDC Claim Name\n"
                },
                "claimValue": {
                    "type": "string",
                    "description": "OIDC Claim Value\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "The alias of the associated identity provider.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the mapper.\n",
                    "willReplaceOnChanges": true
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm.\n",
                    "willReplaceOnChanges": true
                },
                "role": {
                    "type": "string",
                    "description": "Role Name.\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm",
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AttributeToRoleIdentityMapper resources.\n",
                "properties": {
                    "attributeFriendlyName": {
                        "type": "string",
                        "description": "Attribute Friendly Name. Conflicts with `attribute_name`.\n"
                    },
                    "attributeName": {
                        "type": "string",
                        "description": "Attribute Name.\n"
                    },
                    "attributeValue": {
                        "type": "string",
                        "description": "Attribute Value.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "OIDC Claim Name\n"
                    },
                    "claimValue": {
                        "type": "string",
                        "description": "OIDC Claim Value\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "The alias of the associated identity provider.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the mapper.\n",
                        "willReplaceOnChanges": true
                    },
                    "realm": {
                        "type": "string",
                        "description": "The name of the realm.\n",
                        "willReplaceOnChanges": true
                    },
                    "role": {
                        "type": "string",
                        "description": "Role Name.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/customIdentityProviderMapping:CustomIdentityProviderMapping": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst oidc = new keycloak.oidc.IdentityProvider(\"oidc\", {\n    realm: realm.id,\n    alias: \"oidc\",\n    authorizationUrl: \"https://example.com/auth\",\n    tokenUrl: \"https://example.com/token\",\n    clientId: \"example_id\",\n    clientSecret: \"example_token\",\n    defaultScopes: \"openid random profile\",\n});\nconst oidcCustomIdentityProviderMapping = new keycloak.CustomIdentityProviderMapping(\"oidc\", {\n    realm: realm.id,\n    name: \"email-attribute-importer\",\n    identityProviderAlias: oidc.alias,\n    identityProviderMapper: \"%s-user-attribute-idp-mapper\",\n    extraConfig: {\n        syncMode: \"INHERIT\",\n        Claim: \"my-email-claim\",\n        UserAttribute: \"email\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\noidc = keycloak.oidc.IdentityProvider(\"oidc\",\n    realm=realm.id,\n    alias=\"oidc\",\n    authorization_url=\"https://example.com/auth\",\n    token_url=\"https://example.com/token\",\n    client_id=\"example_id\",\n    client_secret=\"example_token\",\n    default_scopes=\"openid random profile\")\noidc_custom_identity_provider_mapping = keycloak.CustomIdentityProviderMapping(\"oidc\",\n    realm=realm.id,\n    name=\"email-attribute-importer\",\n    identity_provider_alias=oidc.alias,\n    identity_provider_mapper=\"%s-user-attribute-idp-mapper\",\n    extra_config={\n        \"syncMode\": \"INHERIT\",\n        \"Claim\": \"my-email-claim\",\n        \"UserAttribute\": \"email\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var oidc = new Keycloak.Oidc.IdentityProvider(\"oidc\", new()\n    {\n        Realm = realm.Id,\n        Alias = \"oidc\",\n        AuthorizationUrl = \"https://example.com/auth\",\n        TokenUrl = \"https://example.com/token\",\n        ClientId = \"example_id\",\n        ClientSecret = \"example_token\",\n        DefaultScopes = \"openid random profile\",\n    });\n\n    var oidcCustomIdentityProviderMapping = new Keycloak.CustomIdentityProviderMapping(\"oidc\", new()\n    {\n        Realm = realm.Id,\n        Name = \"email-attribute-importer\",\n        IdentityProviderAlias = oidc.Alias,\n        IdentityProviderMapper = \"%s-user-attribute-idp-mapper\",\n        ExtraConfig = \n        {\n            { \"syncMode\", \"INHERIT\" },\n            { \"Claim\", \"my-email-claim\" },\n            { \"UserAttribute\", \"email\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/oidc\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\toidc, err := oidc.NewIdentityProvider(ctx, \"oidc\", \u0026oidc.IdentityProviderArgs{\n\t\t\tRealm:            realm.ID(),\n\t\t\tAlias:            pulumi.String(\"oidc\"),\n\t\t\tAuthorizationUrl: pulumi.String(\"https://example.com/auth\"),\n\t\t\tTokenUrl:         pulumi.String(\"https://example.com/token\"),\n\t\t\tClientId:         pulumi.String(\"example_id\"),\n\t\t\tClientSecret:     pulumi.String(\"example_token\"),\n\t\t\tDefaultScopes:    pulumi.String(\"openid random profile\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewCustomIdentityProviderMapping(ctx, \"oidc\", \u0026keycloak.CustomIdentityProviderMappingArgs{\n\t\t\tRealm:                  realm.ID(),\n\t\t\tName:                   pulumi.String(\"email-attribute-importer\"),\n\t\t\tIdentityProviderAlias:  oidc.Alias,\n\t\t\tIdentityProviderMapper: pulumi.String(\"%s-user-attribute-idp-mapper\"),\n\t\t\tExtraConfig: pulumi.Map{\n\t\t\t\t\"syncMode\":      pulumi.Any(\"INHERIT\"),\n\t\t\t\t\"Claim\":         pulumi.Any(\"my-email-claim\"),\n\t\t\t\t\"UserAttribute\": pulumi.Any(\"email\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.oidc.IdentityProvider;\nimport com.pulumi.keycloak.oidc.IdentityProviderArgs;\nimport com.pulumi.keycloak.CustomIdentityProviderMapping;\nimport com.pulumi.keycloak.CustomIdentityProviderMappingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var oidc = new IdentityProvider(\"oidc\", IdentityProviderArgs.builder()\n            .realm(realm.id())\n            .alias(\"oidc\")\n            .authorizationUrl(\"https://example.com/auth\")\n            .tokenUrl(\"https://example.com/token\")\n            .clientId(\"example_id\")\n            .clientSecret(\"example_token\")\n            .defaultScopes(\"openid random profile\")\n            .build());\n\n        var oidcCustomIdentityProviderMapping = new CustomIdentityProviderMapping(\"oidcCustomIdentityProviderMapping\", CustomIdentityProviderMappingArgs.builder()\n            .realm(realm.id())\n            .name(\"email-attribute-importer\")\n            .identityProviderAlias(oidc.alias())\n            .identityProviderMapper(\"%s-user-attribute-idp-mapper\")\n            .extraConfig(Map.ofEntries(\n                Map.entry(\"syncMode\", \"INHERIT\"),\n                Map.entry(\"Claim\", \"my-email-claim\"),\n                Map.entry(\"UserAttribute\", \"email\")\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  oidc:\n    type: keycloak:oidc:IdentityProvider\n    properties:\n      realm: ${realm.id}\n      alias: oidc\n      authorizationUrl: https://example.com/auth\n      tokenUrl: https://example.com/token\n      clientId: example_id\n      clientSecret: example_token\n      defaultScopes: openid random profile\n  oidcCustomIdentityProviderMapping:\n    type: keycloak:CustomIdentityProviderMapping\n    name: oidc\n    properties:\n      realm: ${realm.id}\n      name: email-attribute-importer\n      identityProviderAlias: ${oidc.alias}\n      identityProviderMapper: '%s-user-attribute-idp-mapper'\n      extraConfig:\n        syncMode: INHERIT\n        Claim: my-email-claim\n        UserAttribute: email\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nIdentity provider mappers can be imported using the format `{{realm_id}}/{{idp_alias}}/{{idp_mapper_id}}`, where `idp_alias` is the identity provider alias, and `idp_mapper_id` is the unique ID that Keycloak\n\nassigns to the mapper upon creation. This value can be found in the URI when editing this mapper in the GUI, and is typically a GUID.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:index/customIdentityProviderMapping:CustomIdentityProviderMapping test_mapper my-realm/my-mapper/f446db98-7133-4e30-b18a-3d28fde7ca1b\n```\n\n",
            "properties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "The alias of the associated identity provider.\n"
                },
                "identityProviderMapper": {
                    "type": "string",
                    "description": "The type of the identity provider mapper. This can be a format string that includes a `%s` - this will be replaced by the provider id.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the mapper.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm.\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "identityProviderMapper",
                "name",
                "realm"
            ],
            "inputProperties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "The alias of the associated identity provider.\n",
                    "willReplaceOnChanges": true
                },
                "identityProviderMapper": {
                    "type": "string",
                    "description": "The type of the identity provider mapper. This can be a format string that includes a `%s` - this will be replaced by the provider id.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the mapper.\n",
                    "willReplaceOnChanges": true
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "identityProviderMapper",
                "realm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomIdentityProviderMapping resources.\n",
                "properties": {
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "The alias of the associated identity provider.\n",
                        "willReplaceOnChanges": true
                    },
                    "identityProviderMapper": {
                        "type": "string",
                        "description": "The type of the identity provider mapper. This can be a format string that includes a `%s` - this will be replaced by the provider id.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the mapper.\n",
                        "willReplaceOnChanges": true
                    },
                    "realm": {
                        "type": "string",
                        "description": "The name of the realm.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/customUserFederation:CustomUserFederation": {
            "description": "## # keycloak.CustomUserFederation\n\nAllows for creating and managing custom user federation providers within Keycloak.\n\nA custom user federation provider is an implementation of Keycloak's\n[User Storage SPI](https://www.keycloak.org/docs/4.2/server_development/index.html#_user-storage-spi).\nAn example of this implementation can be found here.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"test\",\n    enabled: true,\n});\nconst customUserFederation = new keycloak.CustomUserFederation(\"custom_user_federation\", {\n    name: \"custom\",\n    realmId: realm.id,\n    providerId: \"custom\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"test\",\n    enabled=True)\ncustom_user_federation = keycloak.CustomUserFederation(\"custom_user_federation\",\n    name=\"custom\",\n    realm_id=realm.id,\n    provider_id=\"custom\",\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"test\",\n        Enabled = true,\n    });\n\n    var customUserFederation = new Keycloak.CustomUserFederation(\"custom_user_federation\", new()\n    {\n        Name = \"custom\",\n        RealmId = realm.Id,\n        ProviderId = \"custom\",\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"test\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewCustomUserFederation(ctx, \"custom_user_federation\", \u0026keycloak.CustomUserFederationArgs{\n\t\t\tName:       pulumi.String(\"custom\"),\n\t\t\tRealmId:    realm.ID(),\n\t\t\tProviderId: pulumi.String(\"custom\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.CustomUserFederation;\nimport com.pulumi.keycloak.CustomUserFederationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"test\")\n            .enabled(true)\n            .build());\n\n        var customUserFederation = new CustomUserFederation(\"customUserFederation\", CustomUserFederationArgs.builder()\n            .name(\"custom\")\n            .realmId(realm.id())\n            .providerId(\"custom\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: test\n      enabled: true\n  customUserFederation:\n    type: keycloak:CustomUserFederation\n    name: custom_user_federation\n    properties:\n      name: custom\n      realmId: ${realm.id}\n      providerId: custom\n      enabled: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm that this provider will provide user federation for.\n- `name` - (Required) Display name of the provider when displayed in the console.\n- `provider_id` - (Required) The unique ID of the custom provider, specified in the `getId` implementation for the `UserStorageProviderFactory` interface.\n- `enabled` - (Optional) When `false`, this provider will not be used when performing queries for users. Defaults to `true`.\n- `priority` - (Optional) Priority of this provider when looking up users. Lower values are first. Defaults to `0`.\n- `cache_policy` - (Optional) Can be one of `DEFAULT`, `EVICT_DAILY`, `EVICT_WEEKLY`, `MAX_LIFESPAN`, or `NO_CACHE`. Defaults to `DEFAULT`.\n\n### Import\n\nCustom user federation providers can be imported using the format `{{realm_id}}/{{custom_user_federation_id}}`.\nThe ID of the custom user federation provider can be found within the Keycloak GUI and is typically a GUID:\n\n```bash\n$ terraform import keycloak_custom_user_federation.custom_user_federation my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860\n```\n",
            "properties": {
                "cachePolicy": {
                    "type": "string"
                },
                "changedSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync changed users, in seconds. Omit this property to disable periodic changed users\nsync.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When false, this provider will not be used when performing queries for users.\n"
                },
                "fullSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync all users, in seconds. Omit this property to disable periodic full sync.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the provider when displayed in the console.\n"
                },
                "parentId": {
                    "type": "string",
                    "description": "The parent_id of the generated component. will use realm_id if not specified.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of this provider when looking up users. Lower values are first.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The unique ID of the custom provider, specified in the `getId` implementation for the UserStorageProviderFactory\ninterface\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm (name) this provider will provide user federation for.\n"
                }
            },
            "required": [
                "name",
                "parentId",
                "providerId",
                "realmId"
            ],
            "inputProperties": {
                "cachePolicy": {
                    "type": "string"
                },
                "changedSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync changed users, in seconds. Omit this property to disable periodic changed users\nsync.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When false, this provider will not be used when performing queries for users.\n"
                },
                "fullSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync all users, in seconds. Omit this property to disable periodic full sync.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the provider when displayed in the console.\n"
                },
                "parentId": {
                    "type": "string",
                    "description": "The parent_id of the generated component. will use realm_id if not specified.\n",
                    "willReplaceOnChanges": true
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of this provider when looking up users. Lower values are first.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The unique ID of the custom provider, specified in the `getId` implementation for the UserStorageProviderFactory\ninterface\n",
                    "willReplaceOnChanges": true
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm (name) this provider will provide user federation for.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "providerId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomUserFederation resources.\n",
                "properties": {
                    "cachePolicy": {
                        "type": "string"
                    },
                    "changedSyncPeriod": {
                        "type": "integer",
                        "description": "How frequently Keycloak should sync changed users, in seconds. Omit this property to disable periodic changed users\nsync.\n"
                    },
                    "config": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When false, this provider will not be used when performing queries for users.\n"
                    },
                    "fullSyncPeriod": {
                        "type": "integer",
                        "description": "How frequently Keycloak should sync all users, in seconds. Omit this property to disable periodic full sync.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the provider when displayed in the console.\n"
                    },
                    "parentId": {
                        "type": "string",
                        "description": "The parent_id of the generated component. will use realm_id if not specified.\n",
                        "willReplaceOnChanges": true
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority of this provider when looking up users. Lower values are first.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The unique ID of the custom provider, specified in the `getId` implementation for the UserStorageProviderFactory\ninterface\n",
                        "willReplaceOnChanges": true
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm (name) this provider will provide user federation for.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/defaultGroups:DefaultGroups": {
            "description": "## # keycloak.DefaultGroups\n\nAllows for managing a realm's default groups.\n\nNote that you should not use `keycloak.DefaultGroups` with a group with memberships managed\nby `keycloak.GroupMemberships`.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst group = new keycloak.Group(\"group\", {\n    realmId: realm.id,\n    name: \"my-group\",\n});\nconst _default = new keycloak.DefaultGroups(\"default\", {\n    realmId: realm.id,\n    groupIds: [group.id],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\ngroup = keycloak.Group(\"group\",\n    realm_id=realm.id,\n    name=\"my-group\")\ndefault = keycloak.DefaultGroups(\"default\",\n    realm_id=realm.id,\n    group_ids=[group.id])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var @group = new Keycloak.Group(\"group\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-group\",\n    });\n\n    var @default = new Keycloak.DefaultGroups(\"default\", new()\n    {\n        RealmId = realm.Id,\n        GroupIds = new[]\n        {\n            @group.Id,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgroup, err := keycloak.NewGroup(ctx, \"group\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"my-group\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewDefaultGroups(ctx, \"default\", \u0026keycloak.DefaultGroupsArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tGroupIds: pulumi.StringArray{\n\t\t\t\tgroup.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.Group;\nimport com.pulumi.keycloak.GroupArgs;\nimport com.pulumi.keycloak.DefaultGroups;\nimport com.pulumi.keycloak.DefaultGroupsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var group = new Group(\"group\", GroupArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-group\")\n            .build());\n\n        var default_ = new DefaultGroups(\"default\", DefaultGroupsArgs.builder()\n            .realmId(realm.id())\n            .groupIds(group.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  group:\n    type: keycloak:Group\n    properties:\n      realmId: ${realm.id}\n      name: my-group\n  default:\n    type: keycloak:DefaultGroups\n    properties:\n      realmId: ${realm.id}\n      groupIds:\n        - ${group.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this group exists in.\n- `group_ids` - (Required) A set of group ids that should be default groups on the realm referenced by `realm_id`.\n\n### Import\n\nGroups can be imported using the format `{{realm_id}}` where `realm_id` is the realm the group exists in.\n\nExample:\n\n```bash\n$ terraform import keycloak_default_groups.default my-realm\n```\n",
            "properties": {
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "groupIds",
                "realmId"
            ],
            "inputProperties": {
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "groupIds",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DefaultGroups resources.\n",
                "properties": {
                    "groupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/defaultRoles:DefaultRoles": {
            "description": "Allows managing default realm roles within Keycloak.\n\nNote: This feature was added in Keycloak v13, so this resource will not work on older versions of Keycloak.\n\n## Example Usage\n\n### Realm Role)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst defaultRoles = new keycloak.DefaultRoles(\"default_roles\", {\n    realmId: realm.id,\n    defaultRoles: [\"uma_authorization\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\ndefault_roles = keycloak.DefaultRoles(\"default_roles\",\n    realm_id=realm.id,\n    default_roles=[\"uma_authorization\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var defaultRoles = new Keycloak.DefaultRoles(\"default_roles\", new()\n    {\n        RealmId = realm.Id,\n        RoleNames = new[]\n        {\n            \"uma_authorization\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewDefaultRoles(ctx, \"default_roles\", \u0026keycloak.DefaultRolesArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tDefaultRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"uma_authorization\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.DefaultRoles;\nimport com.pulumi.keycloak.DefaultRolesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var defaultRoles = new DefaultRoles(\"defaultRoles\", DefaultRolesArgs.builder()\n            .realmId(realm.id())\n            .defaultRoles(\"uma_authorization\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  defaultRoles:\n    type: keycloak:DefaultRoles\n    name: default_roles\n    properties:\n      realmId: ${realm.id}\n      defaultRoles:\n        - uma_authorization\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nDefault roles can be imported using the format `{{realm_id}}/{{default_role_id}}`, where `default_role_id` is the unique ID of the composite\n\nrole that Keycloak uses to control default realm level roles. The ID is not easy to find in the GUI, but it appears in the dev tools when editing\n\nthe default roles.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:index/defaultRoles:DefaultRoles default_roles my-realm/a04c35c2-e95a-4dc5-bd32-e83a21be9e7d\n```\n\n",
            "properties": {
                "defaultRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Realm level roles assigned to new users by default.\n",
                    "language": {
                        "csharp": {
                            "name": "RoleNames"
                        }
                    }
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this role exists within.\n"
                }
            },
            "required": [
                "defaultRoles",
                "realmId"
            ],
            "inputProperties": {
                "defaultRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Realm level roles assigned to new users by default.\n",
                    "language": {
                        "csharp": {
                            "name": "RoleNames"
                        }
                    }
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this role exists within.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "defaultRoles",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DefaultRoles resources.\n",
                "properties": {
                    "defaultRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Realm level roles assigned to new users by default.\n",
                        "language": {
                            "csharp": {
                                "name": "RoleNames"
                            }
                        }
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this role exists within.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/genericClientProtocolMapper:GenericClientProtocolMapper": {
            "description": "## # keycloak.GenericClientProtocolMapper\n\nAllows for creating and managing protocol mapper for both types of clients (openid-connect and saml) within Keycloak.\n\nThere are two uses cases for using this resource:\n* If you implemented a custom protocol mapper, this resource can be used to configure it\n* If the provider doesn't support a particular protocol mapper, this resource can be used instead.\n\nDue to the generic nature of this mapper, it is less user-friendly and more prone to configuration errors. \nTherefore, if possible, a specific mapper should be used.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClient = new keycloak.saml.Client(\"saml_client\", {\n    realmId: realm.id,\n    clientId: \"test-client\",\n});\nconst samlHardcodeAttributeMapper = new keycloak.GenericClientProtocolMapper(\"saml_hardcode_attribute_mapper\", {\n    realmId: realm.id,\n    clientId: samlClient.id,\n    name: \"tes-mapper\",\n    protocol: \"saml\",\n    protocolMapper: \"saml-hardcode-attribute-mapper\",\n    config: {\n        \"attribute.name\": \"name\",\n        \"attribute.nameformat\": \"Basic\",\n        \"attribute.value\": \"value\",\n        \"friendly.name\": \"display name\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client = keycloak.saml.Client(\"saml_client\",\n    realm_id=realm.id,\n    client_id=\"test-client\")\nsaml_hardcode_attribute_mapper = keycloak.GenericClientProtocolMapper(\"saml_hardcode_attribute_mapper\",\n    realm_id=realm.id,\n    client_id=saml_client.id,\n    name=\"tes-mapper\",\n    protocol=\"saml\",\n    protocol_mapper=\"saml-hardcode-attribute-mapper\",\n    config={\n        \"attribute.name\": \"name\",\n        \"attribute.nameformat\": \"Basic\",\n        \"attribute.value\": \"value\",\n        \"friendly.name\": \"display name\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var samlClient = new Keycloak.Saml.Client(\"saml_client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"test-client\",\n    });\n\n    var samlHardcodeAttributeMapper = new Keycloak.GenericClientProtocolMapper(\"saml_hardcode_attribute_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = samlClient.Id,\n        Name = \"tes-mapper\",\n        Protocol = \"saml\",\n        ProtocolMapper = \"saml-hardcode-attribute-mapper\",\n        Config = \n        {\n            { \"attribute.name\", \"name\" },\n            { \"attribute.nameformat\", \"Basic\" },\n            { \"attribute.value\", \"value\" },\n            { \"friendly.name\", \"display name\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsamlClient, err := saml.NewClient(ctx, \"saml_client\", \u0026saml.ClientArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: pulumi.String(\"test-client\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientProtocolMapper(ctx, \"saml_hardcode_attribute_mapper\", \u0026keycloak.GenericClientProtocolMapperArgs{\n\t\t\tRealmId:        realm.ID(),\n\t\t\tClientId:       samlClient.ID(),\n\t\t\tName:           pulumi.String(\"tes-mapper\"),\n\t\t\tProtocol:       pulumi.String(\"saml\"),\n\t\t\tProtocolMapper: pulumi.String(\"saml-hardcode-attribute-mapper\"),\n\t\t\tConfig: pulumi.Map{\n\t\t\t\t\"attribute.name\":       pulumi.Any(\"name\"),\n\t\t\t\t\"attribute.nameformat\": pulumi.Any(\"Basic\"),\n\t\t\t\t\"attribute.value\":      pulumi.Any(\"value\"),\n\t\t\t\t\"friendly.name\":        pulumi.Any(\"display name\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.saml.Client;\nimport com.pulumi.keycloak.saml.ClientArgs;\nimport com.pulumi.keycloak.GenericClientProtocolMapper;\nimport com.pulumi.keycloak.GenericClientProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var samlClient = new Client(\"samlClient\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"test-client\")\n            .build());\n\n        var samlHardcodeAttributeMapper = new GenericClientProtocolMapper(\"samlHardcodeAttributeMapper\", GenericClientProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(samlClient.id())\n            .name(\"tes-mapper\")\n            .protocol(\"saml\")\n            .protocolMapper(\"saml-hardcode-attribute-mapper\")\n            .config(Map.ofEntries(\n                Map.entry(\"attribute.name\", \"name\"),\n                Map.entry(\"attribute.nameformat\", \"Basic\"),\n                Map.entry(\"attribute.value\", \"value\"),\n                Map.entry(\"friendly.name\", \"display name\")\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  samlClient:\n    type: keycloak:saml:Client\n    name: saml_client\n    properties:\n      realmId: ${realm.id}\n      clientId: test-client\n  samlHardcodeAttributeMapper:\n    type: keycloak:GenericClientProtocolMapper\n    name: saml_hardcode_attribute_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${samlClient.id}\n      name: tes-mapper\n      protocol: saml\n      protocolMapper: saml-hardcode-attribute-mapper\n      config:\n        attribute.name: name\n        attribute.nameformat: Basic\n        attribute.value: value\n        friendly.name: display name\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required) The client this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `protocol` - (Required) The type of client (either `openid-connect` or `saml`). The type must match the type of the client.\n- `protocol_mapper` - (Required) The name of the protocol mapper. The protocol mapper must be\n   compatible with the specified client.\n- `config` - (Required) A map with key / value pairs for configuring the protocol mapper. The supported keys depends on the protocol mapper.\n\n### Import\n\nProtocol mappers can be imported using the following format: `{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}`\n\nExample:\n\n```bash\n$ terraform import keycloak_generic_client_protocol_mapper.saml_hardcode_attribute_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The protocol of the client (openid-connect / saml).\n"
                },
                "protocolMapper": {
                    "type": "string",
                    "description": "The type of the protocol mapper.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                }
            },
            "required": [
                "config",
                "name",
                "protocol",
                "protocolMapper",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n",
                    "willReplaceOnChanges": true
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n",
                    "willReplaceOnChanges": true
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n",
                    "willReplaceOnChanges": true
                },
                "protocol": {
                    "type": "string",
                    "description": "The protocol of the client (openid-connect / saml).\n",
                    "willReplaceOnChanges": true
                },
                "protocolMapper": {
                    "type": "string",
                    "description": "The type of the protocol mapper.\n",
                    "willReplaceOnChanges": true
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "config",
                "protocol",
                "protocolMapper",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GenericClientProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n",
                        "willReplaceOnChanges": true
                    },
                    "config": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n",
                        "willReplaceOnChanges": true
                    },
                    "protocol": {
                        "type": "string",
                        "description": "The protocol of the client (openid-connect / saml).\n",
                        "willReplaceOnChanges": true
                    },
                    "protocolMapper": {
                        "type": "string",
                        "description": "The type of the protocol mapper.\n",
                        "willReplaceOnChanges": true
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/genericClientRoleMapper:GenericClientRoleMapper": {
            "description": "!\u003e **WARNING:** This resource is deprecated and will be removed in the next major version. Please use `keycloak.GenericRoleMapper` instead.\n\nAllow for creating and managing a client's scope mappings within Keycloak.\n\nBy default, all the user role mappings of the user are added as claims within the token (OIDC) or assertion (SAML). When\n`full_scope_allowed` is set to `false` for a client, role scope mapping allows you to limit the roles that get declared\ninside an access token for a client.\n\n## Example Usage\n\n### Realm Role To Client)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    name: \"client\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst realmRole = new keycloak.Role(\"realm_role\", {\n    realmId: realm.id,\n    name: \"my-realm-role\",\n    description: \"My Realm Role\",\n});\nconst clientRoleMapper = new keycloak.GenericClientRoleMapper(\"client_role_mapper\", {\n    realmId: realm.id,\n    clientId: client.id,\n    roleId: realmRole.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    name=\"client\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nrealm_role = keycloak.Role(\"realm_role\",\n    realm_id=realm.id,\n    name=\"my-realm-role\",\n    description=\"My Realm Role\")\nclient_role_mapper = keycloak.GenericClientRoleMapper(\"client_role_mapper\",\n    realm_id=realm.id,\n    client_id=client.id,\n    role_id=realm_role.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var client = new Keycloak.OpenId.Client(\"client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"client\",\n        Name = \"client\",\n        Enabled = true,\n        AccessType = \"BEARER-ONLY\",\n    });\n\n    var realmRole = new Keycloak.Role(\"realm_role\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-realm-role\",\n        Description = \"My Realm Role\",\n    });\n\n    var clientRoleMapper = new Keycloak.GenericClientRoleMapper(\"client_role_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = client.Id,\n        RoleId = realmRole.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tName:       pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmRole, err := keycloak.NewRole(ctx, \"realm_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tName:        pulumi.String(\"my-realm-role\"),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientRoleMapper(ctx, \"client_role_mapper\", \u0026keycloak.GenericClientRoleMapperArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: client.ID(),\n\t\t\tRoleId:   realmRole.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport com.pulumi.keycloak.GenericClientRoleMapper;\nimport com.pulumi.keycloak.GenericClientRoleMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var client = new Client(\"client\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"client\")\n            .name(\"client\")\n            .enabled(true)\n            .accessType(\"BEARER-ONLY\")\n            .build());\n\n        var realmRole = new Role(\"realmRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-realm-role\")\n            .description(\"My Realm Role\")\n            .build());\n\n        var clientRoleMapper = new GenericClientRoleMapper(\"clientRoleMapper\", GenericClientRoleMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(client.id())\n            .roleId(realmRole.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  client:\n    type: keycloak:openid:Client\n    properties:\n      realmId: ${realm.id}\n      clientId: client\n      name: client\n      enabled: true\n      accessType: BEARER-ONLY\n  realmRole:\n    type: keycloak:Role\n    name: realm_role\n    properties:\n      realmId: ${realm.id}\n      name: my-realm-role\n      description: My Realm Role\n  clientRoleMapper:\n    type: keycloak:GenericClientRoleMapper\n    name: client_role_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${client.id}\n      roleId: ${realmRole.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Client Role To Client)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientA = new keycloak.openid.Client(\"client_a\", {\n    realmId: realm.id,\n    clientId: \"client-a\",\n    name: \"client-a\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n    fullScopeAllowed: false,\n});\nconst clientRoleA = new keycloak.Role(\"client_role_a\", {\n    realmId: realm.id,\n    clientId: clientA.id,\n    name: \"my-client-role\",\n    description: \"My Client Role\",\n});\nconst clientB = new keycloak.openid.Client(\"client_b\", {\n    realmId: realm.id,\n    clientId: \"client-b\",\n    name: \"client-b\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst clientRoleB = new keycloak.Role(\"client_role_b\", {\n    realmId: realm.id,\n    clientId: clientB.id,\n    name: \"my-client-role\",\n    description: \"My Client Role\",\n});\nconst clientBRoleMapper = new keycloak.GenericClientRoleMapper(\"client_b_role_mapper\", {\n    realmId: realm.id,\n    clientId: clientB.id,\n    roleId: clientRoleA.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_a = keycloak.openid.Client(\"client_a\",\n    realm_id=realm.id,\n    client_id=\"client-a\",\n    name=\"client-a\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\",\n    full_scope_allowed=False)\nclient_role_a = keycloak.Role(\"client_role_a\",\n    realm_id=realm.id,\n    client_id=client_a.id,\n    name=\"my-client-role\",\n    description=\"My Client Role\")\nclient_b = keycloak.openid.Client(\"client_b\",\n    realm_id=realm.id,\n    client_id=\"client-b\",\n    name=\"client-b\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nclient_role_b = keycloak.Role(\"client_role_b\",\n    realm_id=realm.id,\n    client_id=client_b.id,\n    name=\"my-client-role\",\n    description=\"My Client Role\")\nclient_b_role_mapper = keycloak.GenericClientRoleMapper(\"client_b_role_mapper\",\n    realm_id=realm.id,\n    client_id=client_b.id,\n    role_id=client_role_a.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var clientA = new Keycloak.OpenId.Client(\"client_a\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"client-a\",\n        Name = \"client-a\",\n        Enabled = true,\n        AccessType = \"BEARER-ONLY\",\n        FullScopeAllowed = false,\n    });\n\n    var clientRoleA = new Keycloak.Role(\"client_role_a\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = clientA.Id,\n        Name = \"my-client-role\",\n        Description = \"My Client Role\",\n    });\n\n    var clientB = new Keycloak.OpenId.Client(\"client_b\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"client-b\",\n        Name = \"client-b\",\n        Enabled = true,\n        AccessType = \"BEARER-ONLY\",\n    });\n\n    var clientRoleB = new Keycloak.Role(\"client_role_b\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = clientB.Id,\n        Name = \"my-client-role\",\n        Description = \"My Client Role\",\n    });\n\n    var clientBRoleMapper = new Keycloak.GenericClientRoleMapper(\"client_b_role_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = clientB.Id,\n        RoleId = clientRoleA.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientA, err := openid.NewClient(ctx, \"client_a\", \u0026openid.ClientArgs{\n\t\t\tRealmId:          realm.ID(),\n\t\t\tClientId:         pulumi.String(\"client-a\"),\n\t\t\tName:             pulumi.String(\"client-a\"),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t\tAccessType:       pulumi.String(\"BEARER-ONLY\"),\n\t\t\tFullScopeAllowed: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientRoleA, err := keycloak.NewRole(ctx, \"client_role_a\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    clientA.ID(),\n\t\t\tName:        pulumi.String(\"my-client-role\"),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientB, err := openid.NewClient(ctx, \"client_b\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client-b\"),\n\t\t\tName:       pulumi.String(\"client-b\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"client_role_b\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    clientB.ID(),\n\t\t\tName:        pulumi.String(\"my-client-role\"),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientRoleMapper(ctx, \"client_b_role_mapper\", \u0026keycloak.GenericClientRoleMapperArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: clientB.ID(),\n\t\t\tRoleId:   clientRoleA.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport com.pulumi.keycloak.GenericClientRoleMapper;\nimport com.pulumi.keycloak.GenericClientRoleMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var clientA = new Client(\"clientA\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"client-a\")\n            .name(\"client-a\")\n            .enabled(true)\n            .accessType(\"BEARER-ONLY\")\n            .fullScopeAllowed(false)\n            .build());\n\n        var clientRoleA = new Role(\"clientRoleA\", RoleArgs.builder()\n            .realmId(realm.id())\n            .clientId(clientA.id())\n            .name(\"my-client-role\")\n            .description(\"My Client Role\")\n            .build());\n\n        var clientB = new Client(\"clientB\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"client-b\")\n            .name(\"client-b\")\n            .enabled(true)\n            .accessType(\"BEARER-ONLY\")\n            .build());\n\n        var clientRoleB = new Role(\"clientRoleB\", RoleArgs.builder()\n            .realmId(realm.id())\n            .clientId(clientB.id())\n            .name(\"my-client-role\")\n            .description(\"My Client Role\")\n            .build());\n\n        var clientBRoleMapper = new GenericClientRoleMapper(\"clientBRoleMapper\", GenericClientRoleMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(clientB.id())\n            .roleId(clientRoleA.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  clientA:\n    type: keycloak:openid:Client\n    name: client_a\n    properties:\n      realmId: ${realm.id}\n      clientId: client-a\n      name: client-a\n      enabled: true\n      accessType: BEARER-ONLY\n      fullScopeAllowed: false\n  clientRoleA:\n    type: keycloak:Role\n    name: client_role_a\n    properties:\n      realmId: ${realm.id}\n      clientId: ${clientA.id}\n      name: my-client-role\n      description: My Client Role\n  clientB:\n    type: keycloak:openid:Client\n    name: client_b\n    properties:\n      realmId: ${realm.id}\n      clientId: client-b\n      name: client-b\n      enabled: true\n      accessType: BEARER-ONLY\n  clientRoleB:\n    type: keycloak:Role\n    name: client_role_b\n    properties:\n      realmId: ${realm.id}\n      clientId: ${clientB.id}\n      name: my-client-role\n      description: My Client Role\n  clientBRoleMapper:\n    type: keycloak:GenericClientRoleMapper\n    name: client_b_role_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${clientB.id}\n      roleId: ${clientRoleA.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Realm Role To Client Scope)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n    name: \"my-client-scope\",\n});\nconst realmRole = new keycloak.Role(\"realm_role\", {\n    realmId: realm.id,\n    name: \"my-realm-role\",\n    description: \"My Realm Role\",\n});\nconst clientRoleMapper = new keycloak.GenericClientRoleMapper(\"client_role_mapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    roleId: realmRole.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"client_scope\",\n    realm_id=realm.id,\n    name=\"my-client-scope\")\nrealm_role = keycloak.Role(\"realm_role\",\n    realm_id=realm.id,\n    name=\"my-realm-role\",\n    description=\"My Realm Role\")\nclient_role_mapper = keycloak.GenericClientRoleMapper(\"client_role_mapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    role_id=realm_role.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var clientScope = new Keycloak.OpenId.ClientScope(\"client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-client-scope\",\n    });\n\n    var realmRole = new Keycloak.Role(\"realm_role\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-realm-role\",\n        Description = \"My Realm Role\",\n    });\n\n    var clientRoleMapper = new Keycloak.GenericClientRoleMapper(\"client_role_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientScopeId = clientScope.Id,\n        RoleId = realmRole.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"my-client-scope\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmRole, err := keycloak.NewRole(ctx, \"realm_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tName:        pulumi.String(\"my-realm-role\"),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientRoleMapper(ctx, \"client_role_mapper\", \u0026keycloak.GenericClientRoleMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tRoleId:        realmRole.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport com.pulumi.keycloak.GenericClientRoleMapper;\nimport com.pulumi.keycloak.GenericClientRoleMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var clientScope = new ClientScope(\"clientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-client-scope\")\n            .build());\n\n        var realmRole = new Role(\"realmRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-realm-role\")\n            .description(\"My Realm Role\")\n            .build());\n\n        var clientRoleMapper = new GenericClientRoleMapper(\"clientRoleMapper\", GenericClientRoleMapperArgs.builder()\n            .realmId(realm.id())\n            .clientScopeId(clientScope.id())\n            .roleId(realmRole.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  clientScope:\n    type: keycloak:openid:ClientScope\n    name: client_scope\n    properties:\n      realmId: ${realm.id}\n      name: my-client-scope\n  realmRole:\n    type: keycloak:Role\n    name: realm_role\n    properties:\n      realmId: ${realm.id}\n      name: my-realm-role\n      description: My Realm Role\n  clientRoleMapper:\n    type: keycloak:GenericClientRoleMapper\n    name: client_role_mapper\n    properties:\n      realmId: ${realm.id}\n      clientScopeId: ${clientScope.id}\n      roleId: ${realmRole.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Client Role To Client Scope)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    name: \"client\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst clientRole = new keycloak.Role(\"client_role\", {\n    realmId: realm.id,\n    clientId: client.id,\n    name: \"my-client-role\",\n    description: \"My Client Role\",\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n    name: \"my-client-scope\",\n});\nconst clientBRoleMapper = new keycloak.GenericClientRoleMapper(\"client_b_role_mapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    roleId: clientRole.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    name=\"client\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nclient_role = keycloak.Role(\"client_role\",\n    realm_id=realm.id,\n    client_id=client.id,\n    name=\"my-client-role\",\n    description=\"My Client Role\")\nclient_scope = keycloak.openid.ClientScope(\"client_scope\",\n    realm_id=realm.id,\n    name=\"my-client-scope\")\nclient_b_role_mapper = keycloak.GenericClientRoleMapper(\"client_b_role_mapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    role_id=client_role.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var client = new Keycloak.OpenId.Client(\"client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"client\",\n        Name = \"client\",\n        Enabled = true,\n        AccessType = \"BEARER-ONLY\",\n    });\n\n    var clientRole = new Keycloak.Role(\"client_role\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = client.Id,\n        Name = \"my-client-role\",\n        Description = \"My Client Role\",\n    });\n\n    var clientScope = new Keycloak.OpenId.ClientScope(\"client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-client-scope\",\n    });\n\n    var clientBRoleMapper = new Keycloak.GenericClientRoleMapper(\"client_b_role_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientScopeId = clientScope.Id,\n        RoleId = clientRole.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tName:       pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientRole, err := keycloak.NewRole(ctx, \"client_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    client.ID(),\n\t\t\tName:        pulumi.String(\"my-client-role\"),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"my-client-scope\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientRoleMapper(ctx, \"client_b_role_mapper\", \u0026keycloak.GenericClientRoleMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tRoleId:        clientRole.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport com.pulumi.keycloak.GenericClientRoleMapper;\nimport com.pulumi.keycloak.GenericClientRoleMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var client = new Client(\"client\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"client\")\n            .name(\"client\")\n            .enabled(true)\n            .accessType(\"BEARER-ONLY\")\n            .build());\n\n        var clientRole = new Role(\"clientRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .clientId(client.id())\n            .name(\"my-client-role\")\n            .description(\"My Client Role\")\n            .build());\n\n        var clientScope = new ClientScope(\"clientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-client-scope\")\n            .build());\n\n        var clientBRoleMapper = new GenericClientRoleMapper(\"clientBRoleMapper\", GenericClientRoleMapperArgs.builder()\n            .realmId(realm.id())\n            .clientScopeId(clientScope.id())\n            .roleId(clientRole.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  client:\n    type: keycloak:openid:Client\n    properties:\n      realmId: ${realm.id}\n      clientId: client\n      name: client\n      enabled: true\n      accessType: BEARER-ONLY\n  clientRole:\n    type: keycloak:Role\n    name: client_role\n    properties:\n      realmId: ${realm.id}\n      clientId: ${client.id}\n      name: my-client-role\n      description: My Client Role\n  clientScope:\n    type: keycloak:openid:ClientScope\n    name: client_scope\n    properties:\n      realmId: ${realm.id}\n      name: my-client-scope\n  clientBRoleMapper:\n    type: keycloak:GenericClientRoleMapper\n    name: client_b_role_mapper\n    properties:\n      realmId: ${realm.id}\n      clientScopeId: ${clientScope.id}\n      roleId: ${clientRole.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nGeneric client role mappers can be imported using one of the following two formats:\n\n- When mapping a role to a client, use the format `{{realmId}}/client/{{clientId}}/scope-mappings/{{roleClientId}}/{{roleId}}`\n\n- When mapping a role to a client scope, use the format `{{realmId}}/client-scope/{{clientScopeId}}/scope-mappings/{{roleClientId}}/{{roleId}}`\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:index/genericClientRoleMapper:GenericClientRoleMapper client_role_mapper my-realm/client/23888550-5dcd-41f6-85ba-554233021e9c/scope-mappings/ce51f004-bdfb-4dd5-a963-c4487d2dec5b/ff3aa49f-bc07-4030-8783-41918c3614a3\n```\n\n",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client this role mapper should be added to. Conflicts with `client_scope_id`. This argument is required if `client_scope_id` is not set.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The ID of the client scope this role mapper should be added to. Conflicts with `client_id`. This argument is required if `client_id` is not set.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this role mapper exists within.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to be added to this role mapper.\n"
                }
            },
            "required": [
                "realmId",
                "roleId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client this role mapper should be added to. Conflicts with `client_scope_id`. This argument is required if `client_scope_id` is not set.\n",
                    "willReplaceOnChanges": true
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The ID of the client scope this role mapper should be added to. Conflicts with `client_id`. This argument is required if `client_id` is not set.\n",
                    "willReplaceOnChanges": true
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this role mapper exists within.\n",
                    "willReplaceOnChanges": true
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to be added to this role mapper.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "realmId",
                "roleId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GenericClientRoleMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The ID of the client this role mapper should be added to. Conflicts with `client_scope_id`. This argument is required if `client_scope_id` is not set.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The ID of the client scope this role mapper should be added to. Conflicts with `client_id`. This argument is required if `client_id` is not set.\n",
                        "willReplaceOnChanges": true
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this role mapper exists within.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The ID of the role to be added to this role mapper.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/genericProtocolMapper:GenericProtocolMapper": {
            "description": "Allows for creating and managing protocol mappers for both types of clients (openid-connect and saml) within Keycloak.\n\nThere are two uses cases for using this resource:\n* If you implemented a custom protocol mapper, this resource can be used to configure it\n* If the provider doesn't support a particular protocol mapper, this resource can be used instead.\n\nDue to the generic nature of this mapper, it is less user-friendly and more prone to configuration errors.\nTherefore, if possible, a specific mapper should be used instead.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClient = new keycloak.saml.Client(\"saml_client\", {\n    realmId: realm.id,\n    clientId: \"test-client\",\n});\nconst samlHardcodeAttributeMapper = new keycloak.GenericProtocolMapper(\"saml_hardcode_attribute_mapper\", {\n    realmId: realm.id,\n    clientId: samlClient.id,\n    name: \"test-mapper\",\n    protocol: \"saml\",\n    protocolMapper: \"saml-hardcode-attribute-mapper\",\n    config: {\n        \"attribute.name\": \"name\",\n        \"attribute.nameformat\": \"Basic\",\n        \"attribute.value\": \"value\",\n        \"friendly.name\": \"display name\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client = keycloak.saml.Client(\"saml_client\",\n    realm_id=realm.id,\n    client_id=\"test-client\")\nsaml_hardcode_attribute_mapper = keycloak.GenericProtocolMapper(\"saml_hardcode_attribute_mapper\",\n    realm_id=realm.id,\n    client_id=saml_client.id,\n    name=\"test-mapper\",\n    protocol=\"saml\",\n    protocol_mapper=\"saml-hardcode-attribute-mapper\",\n    config={\n        \"attribute.name\": \"name\",\n        \"attribute.nameformat\": \"Basic\",\n        \"attribute.value\": \"value\",\n        \"friendly.name\": \"display name\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var samlClient = new Keycloak.Saml.Client(\"saml_client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"test-client\",\n    });\n\n    var samlHardcodeAttributeMapper = new Keycloak.GenericProtocolMapper(\"saml_hardcode_attribute_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = samlClient.Id,\n        Name = \"test-mapper\",\n        Protocol = \"saml\",\n        ProtocolMapper = \"saml-hardcode-attribute-mapper\",\n        Config = \n        {\n            { \"attribute.name\", \"name\" },\n            { \"attribute.nameformat\", \"Basic\" },\n            { \"attribute.value\", \"value\" },\n            { \"friendly.name\", \"display name\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsamlClient, err := saml.NewClient(ctx, \"saml_client\", \u0026saml.ClientArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: pulumi.String(\"test-client\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericProtocolMapper(ctx, \"saml_hardcode_attribute_mapper\", \u0026keycloak.GenericProtocolMapperArgs{\n\t\t\tRealmId:        realm.ID(),\n\t\t\tClientId:       samlClient.ID(),\n\t\t\tName:           pulumi.String(\"test-mapper\"),\n\t\t\tProtocol:       pulumi.String(\"saml\"),\n\t\t\tProtocolMapper: pulumi.String(\"saml-hardcode-attribute-mapper\"),\n\t\t\tConfig: pulumi.Map{\n\t\t\t\t\"attribute.name\":       pulumi.Any(\"name\"),\n\t\t\t\t\"attribute.nameformat\": pulumi.Any(\"Basic\"),\n\t\t\t\t\"attribute.value\":      pulumi.Any(\"value\"),\n\t\t\t\t\"friendly.name\":        pulumi.Any(\"display name\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.saml.Client;\nimport com.pulumi.keycloak.saml.ClientArgs;\nimport com.pulumi.keycloak.GenericProtocolMapper;\nimport com.pulumi.keycloak.GenericProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var samlClient = new Client(\"samlClient\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"test-client\")\n            .build());\n\n        var samlHardcodeAttributeMapper = new GenericProtocolMapper(\"samlHardcodeAttributeMapper\", GenericProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(samlClient.id())\n            .name(\"test-mapper\")\n            .protocol(\"saml\")\n            .protocolMapper(\"saml-hardcode-attribute-mapper\")\n            .config(Map.ofEntries(\n                Map.entry(\"attribute.name\", \"name\"),\n                Map.entry(\"attribute.nameformat\", \"Basic\"),\n                Map.entry(\"attribute.value\", \"value\"),\n                Map.entry(\"friendly.name\", \"display name\")\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  samlClient:\n    type: keycloak:saml:Client\n    name: saml_client\n    properties:\n      realmId: ${realm.id}\n      clientId: test-client\n  samlHardcodeAttributeMapper:\n    type: keycloak:GenericProtocolMapper\n    name: saml_hardcode_attribute_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${samlClient.id}\n      name: test-mapper\n      protocol: saml\n      protocolMapper: saml-hardcode-attribute-mapper\n      config:\n        attribute.name: name\n        attribute.nameformat: Basic\n        attribute.value: value\n        friendly.name: display name\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nProtocol mappers can be imported using the following format: `{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}`\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:index/genericProtocolMapper:GenericProtocolMapper saml_hardcode_attribute_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client this protocol mapper should be added to. Conflicts with `client_scope_id`. This argument is required if `client_scope_id` is not set.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The ID of the client scope this protocol mapper should be added to. Conflicts with `client_id`. This argument is required if `client_id` is not set.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map with key / value pairs for configuring the protocol mapper. The supported keys depends on the protocol mapper.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The type of client (either `openid-connect` or `saml`). The type must match the type of the client.\n"
                },
                "protocolMapper": {
                    "type": "string",
                    "description": "The name of the protocol mapper. The protocol mapper must be compatible with the specified client.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "required": [
                "config",
                "name",
                "protocol",
                "protocolMapper",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client this protocol mapper should be added to. Conflicts with `client_scope_id`. This argument is required if `client_scope_id` is not set.\n",
                    "willReplaceOnChanges": true
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The ID of the client scope this protocol mapper should be added to. Conflicts with `client_id`. This argument is required if `client_id` is not set.\n",
                    "willReplaceOnChanges": true
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map with key / value pairs for configuring the protocol mapper. The supported keys depends on the protocol mapper.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n",
                    "willReplaceOnChanges": true
                },
                "protocol": {
                    "type": "string",
                    "description": "The type of client (either `openid-connect` or `saml`). The type must match the type of the client.\n",
                    "willReplaceOnChanges": true
                },
                "protocolMapper": {
                    "type": "string",
                    "description": "The name of the protocol mapper. The protocol mapper must be compatible with the specified client.\n",
                    "willReplaceOnChanges": true
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "config",
                "protocol",
                "protocolMapper",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GenericProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The ID of the client this protocol mapper should be added to. Conflicts with `client_scope_id`. This argument is required if `client_scope_id` is not set.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The ID of the client scope this protocol mapper should be added to. Conflicts with `client_id`. This argument is required if `client_id` is not set.\n",
                        "willReplaceOnChanges": true
                    },
                    "config": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map with key / value pairs for configuring the protocol mapper. The supported keys depends on the protocol mapper.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n",
                        "willReplaceOnChanges": true
                    },
                    "protocol": {
                        "type": "string",
                        "description": "The type of client (either `openid-connect` or `saml`). The type must match the type of the client.\n",
                        "willReplaceOnChanges": true
                    },
                    "protocolMapper": {
                        "type": "string",
                        "description": "The name of the protocol mapper. The protocol mapper must be compatible with the specified client.\n",
                        "willReplaceOnChanges": true
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/genericRoleMapper:GenericRoleMapper": {
            "description": "Allow for creating and managing a client's or client scope's role mappings within Keycloak.\n\nBy default, all the user role mappings of the user are added as claims within the token (OIDC) or assertion (SAML). When\n`full_scope_allowed` is set to `false` for a client, role scope mapping allows you to limit the roles that get declared\ninside an access token for a client.\n\n## Example Usage\n\n### Realm Role To Client)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    name: \"client\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst realmRole = new keycloak.Role(\"realm_role\", {\n    realmId: realm.id,\n    name: \"my-realm-role\",\n    description: \"My Realm Role\",\n});\nconst clientRoleMapper = new keycloak.GenericRoleMapper(\"client_role_mapper\", {\n    realmId: realm.id,\n    clientId: client.id,\n    roleId: realmRole.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    name=\"client\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nrealm_role = keycloak.Role(\"realm_role\",\n    realm_id=realm.id,\n    name=\"my-realm-role\",\n    description=\"My Realm Role\")\nclient_role_mapper = keycloak.GenericRoleMapper(\"client_role_mapper\",\n    realm_id=realm.id,\n    client_id=client.id,\n    role_id=realm_role.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var client = new Keycloak.OpenId.Client(\"client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"client\",\n        Name = \"client\",\n        Enabled = true,\n        AccessType = \"BEARER-ONLY\",\n    });\n\n    var realmRole = new Keycloak.Role(\"realm_role\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-realm-role\",\n        Description = \"My Realm Role\",\n    });\n\n    var clientRoleMapper = new Keycloak.GenericRoleMapper(\"client_role_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = client.Id,\n        RoleId = realmRole.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tName:       pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmRole, err := keycloak.NewRole(ctx, \"realm_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tName:        pulumi.String(\"my-realm-role\"),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericRoleMapper(ctx, \"client_role_mapper\", \u0026keycloak.GenericRoleMapperArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: client.ID(),\n\t\t\tRoleId:   realmRole.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport com.pulumi.keycloak.GenericRoleMapper;\nimport com.pulumi.keycloak.GenericRoleMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var client = new Client(\"client\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"client\")\n            .name(\"client\")\n            .enabled(true)\n            .accessType(\"BEARER-ONLY\")\n            .build());\n\n        var realmRole = new Role(\"realmRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-realm-role\")\n            .description(\"My Realm Role\")\n            .build());\n\n        var clientRoleMapper = new GenericRoleMapper(\"clientRoleMapper\", GenericRoleMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(client.id())\n            .roleId(realmRole.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  client:\n    type: keycloak:openid:Client\n    properties:\n      realmId: ${realm.id}\n      clientId: client\n      name: client\n      enabled: true\n      accessType: BEARER-ONLY\n  realmRole:\n    type: keycloak:Role\n    name: realm_role\n    properties:\n      realmId: ${realm.id}\n      name: my-realm-role\n      description: My Realm Role\n  clientRoleMapper:\n    type: keycloak:GenericRoleMapper\n    name: client_role_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${client.id}\n      roleId: ${realmRole.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Client Role To Client)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientA = new keycloak.openid.Client(\"client_a\", {\n    realmId: realm.id,\n    clientId: \"client-a\",\n    name: \"client-a\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n    fullScopeAllowed: false,\n});\nconst clientRoleA = new keycloak.Role(\"client_role_a\", {\n    realmId: realm.id,\n    clientId: clientA.id,\n    name: \"my-client-role\",\n    description: \"My Client Role\",\n});\nconst clientB = new keycloak.openid.Client(\"client_b\", {\n    realmId: realm.id,\n    clientId: \"client-b\",\n    name: \"client-b\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst clientRoleB = new keycloak.Role(\"client_role_b\", {\n    realmId: realm.id,\n    clientId: clientB.id,\n    name: \"my-client-role\",\n    description: \"My Client Role\",\n});\nconst clientBRoleMapper = new keycloak.GenericRoleMapper(\"client_b_role_mapper\", {\n    realmId: realm.id,\n    clientId: clientB.id,\n    roleId: clientRoleA.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_a = keycloak.openid.Client(\"client_a\",\n    realm_id=realm.id,\n    client_id=\"client-a\",\n    name=\"client-a\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\",\n    full_scope_allowed=False)\nclient_role_a = keycloak.Role(\"client_role_a\",\n    realm_id=realm.id,\n    client_id=client_a.id,\n    name=\"my-client-role\",\n    description=\"My Client Role\")\nclient_b = keycloak.openid.Client(\"client_b\",\n    realm_id=realm.id,\n    client_id=\"client-b\",\n    name=\"client-b\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nclient_role_b = keycloak.Role(\"client_role_b\",\n    realm_id=realm.id,\n    client_id=client_b.id,\n    name=\"my-client-role\",\n    description=\"My Client Role\")\nclient_b_role_mapper = keycloak.GenericRoleMapper(\"client_b_role_mapper\",\n    realm_id=realm.id,\n    client_id=client_b.id,\n    role_id=client_role_a.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var clientA = new Keycloak.OpenId.Client(\"client_a\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"client-a\",\n        Name = \"client-a\",\n        Enabled = true,\n        AccessType = \"BEARER-ONLY\",\n        FullScopeAllowed = false,\n    });\n\n    var clientRoleA = new Keycloak.Role(\"client_role_a\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = clientA.Id,\n        Name = \"my-client-role\",\n        Description = \"My Client Role\",\n    });\n\n    var clientB = new Keycloak.OpenId.Client(\"client_b\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"client-b\",\n        Name = \"client-b\",\n        Enabled = true,\n        AccessType = \"BEARER-ONLY\",\n    });\n\n    var clientRoleB = new Keycloak.Role(\"client_role_b\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = clientB.Id,\n        Name = \"my-client-role\",\n        Description = \"My Client Role\",\n    });\n\n    var clientBRoleMapper = new Keycloak.GenericRoleMapper(\"client_b_role_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = clientB.Id,\n        RoleId = clientRoleA.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientA, err := openid.NewClient(ctx, \"client_a\", \u0026openid.ClientArgs{\n\t\t\tRealmId:          realm.ID(),\n\t\t\tClientId:         pulumi.String(\"client-a\"),\n\t\t\tName:             pulumi.String(\"client-a\"),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t\tAccessType:       pulumi.String(\"BEARER-ONLY\"),\n\t\t\tFullScopeAllowed: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientRoleA, err := keycloak.NewRole(ctx, \"client_role_a\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    clientA.ID(),\n\t\t\tName:        pulumi.String(\"my-client-role\"),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientB, err := openid.NewClient(ctx, \"client_b\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client-b\"),\n\t\t\tName:       pulumi.String(\"client-b\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"client_role_b\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    clientB.ID(),\n\t\t\tName:        pulumi.String(\"my-client-role\"),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericRoleMapper(ctx, \"client_b_role_mapper\", \u0026keycloak.GenericRoleMapperArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: clientB.ID(),\n\t\t\tRoleId:   clientRoleA.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport com.pulumi.keycloak.GenericRoleMapper;\nimport com.pulumi.keycloak.GenericRoleMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var clientA = new Client(\"clientA\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"client-a\")\n            .name(\"client-a\")\n            .enabled(true)\n            .accessType(\"BEARER-ONLY\")\n            .fullScopeAllowed(false)\n            .build());\n\n        var clientRoleA = new Role(\"clientRoleA\", RoleArgs.builder()\n            .realmId(realm.id())\n            .clientId(clientA.id())\n            .name(\"my-client-role\")\n            .description(\"My Client Role\")\n            .build());\n\n        var clientB = new Client(\"clientB\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"client-b\")\n            .name(\"client-b\")\n            .enabled(true)\n            .accessType(\"BEARER-ONLY\")\n            .build());\n\n        var clientRoleB = new Role(\"clientRoleB\", RoleArgs.builder()\n            .realmId(realm.id())\n            .clientId(clientB.id())\n            .name(\"my-client-role\")\n            .description(\"My Client Role\")\n            .build());\n\n        var clientBRoleMapper = new GenericRoleMapper(\"clientBRoleMapper\", GenericRoleMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(clientB.id())\n            .roleId(clientRoleA.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  clientA:\n    type: keycloak:openid:Client\n    name: client_a\n    properties:\n      realmId: ${realm.id}\n      clientId: client-a\n      name: client-a\n      enabled: true\n      accessType: BEARER-ONLY\n      fullScopeAllowed: false\n  clientRoleA:\n    type: keycloak:Role\n    name: client_role_a\n    properties:\n      realmId: ${realm.id}\n      clientId: ${clientA.id}\n      name: my-client-role\n      description: My Client Role\n  clientB:\n    type: keycloak:openid:Client\n    name: client_b\n    properties:\n      realmId: ${realm.id}\n      clientId: client-b\n      name: client-b\n      enabled: true\n      accessType: BEARER-ONLY\n  clientRoleB:\n    type: keycloak:Role\n    name: client_role_b\n    properties:\n      realmId: ${realm.id}\n      clientId: ${clientB.id}\n      name: my-client-role\n      description: My Client Role\n  clientBRoleMapper:\n    type: keycloak:GenericRoleMapper\n    name: client_b_role_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${clientB.id}\n      roleId: ${clientRoleA.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Realm Role To Client Scope)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n    name: \"my-client-scope\",\n});\nconst realmRole = new keycloak.Role(\"realm_role\", {\n    realmId: realm.id,\n    name: \"my-realm-role\",\n    description: \"My Realm Role\",\n});\nconst clientRoleMapper = new keycloak.GenericRoleMapper(\"client_role_mapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    roleId: realmRole.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"client_scope\",\n    realm_id=realm.id,\n    name=\"my-client-scope\")\nrealm_role = keycloak.Role(\"realm_role\",\n    realm_id=realm.id,\n    name=\"my-realm-role\",\n    description=\"My Realm Role\")\nclient_role_mapper = keycloak.GenericRoleMapper(\"client_role_mapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    role_id=realm_role.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var clientScope = new Keycloak.OpenId.ClientScope(\"client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-client-scope\",\n    });\n\n    var realmRole = new Keycloak.Role(\"realm_role\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-realm-role\",\n        Description = \"My Realm Role\",\n    });\n\n    var clientRoleMapper = new Keycloak.GenericRoleMapper(\"client_role_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientScopeId = clientScope.Id,\n        RoleId = realmRole.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"my-client-scope\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmRole, err := keycloak.NewRole(ctx, \"realm_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tName:        pulumi.String(\"my-realm-role\"),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericRoleMapper(ctx, \"client_role_mapper\", \u0026keycloak.GenericRoleMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tRoleId:        realmRole.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport com.pulumi.keycloak.GenericRoleMapper;\nimport com.pulumi.keycloak.GenericRoleMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var clientScope = new ClientScope(\"clientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-client-scope\")\n            .build());\n\n        var realmRole = new Role(\"realmRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-realm-role\")\n            .description(\"My Realm Role\")\n            .build());\n\n        var clientRoleMapper = new GenericRoleMapper(\"clientRoleMapper\", GenericRoleMapperArgs.builder()\n            .realmId(realm.id())\n            .clientScopeId(clientScope.id())\n            .roleId(realmRole.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  clientScope:\n    type: keycloak:openid:ClientScope\n    name: client_scope\n    properties:\n      realmId: ${realm.id}\n      name: my-client-scope\n  realmRole:\n    type: keycloak:Role\n    name: realm_role\n    properties:\n      realmId: ${realm.id}\n      name: my-realm-role\n      description: My Realm Role\n  clientRoleMapper:\n    type: keycloak:GenericRoleMapper\n    name: client_role_mapper\n    properties:\n      realmId: ${realm.id}\n      clientScopeId: ${clientScope.id}\n      roleId: ${realmRole.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Client Role To Client Scope)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    name: \"client\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst clientRole = new keycloak.Role(\"client_role\", {\n    realmId: realm.id,\n    clientId: client.id,\n    name: \"my-client-role\",\n    description: \"My Client Role\",\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n    name: \"my-client-scope\",\n});\nconst clientBRoleMapper = new keycloak.GenericRoleMapper(\"client_b_role_mapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    roleId: clientRole.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    name=\"client\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nclient_role = keycloak.Role(\"client_role\",\n    realm_id=realm.id,\n    client_id=client.id,\n    name=\"my-client-role\",\n    description=\"My Client Role\")\nclient_scope = keycloak.openid.ClientScope(\"client_scope\",\n    realm_id=realm.id,\n    name=\"my-client-scope\")\nclient_b_role_mapper = keycloak.GenericRoleMapper(\"client_b_role_mapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    role_id=client_role.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var client = new Keycloak.OpenId.Client(\"client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"client\",\n        Name = \"client\",\n        Enabled = true,\n        AccessType = \"BEARER-ONLY\",\n    });\n\n    var clientRole = new Keycloak.Role(\"client_role\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = client.Id,\n        Name = \"my-client-role\",\n        Description = \"My Client Role\",\n    });\n\n    var clientScope = new Keycloak.OpenId.ClientScope(\"client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-client-scope\",\n    });\n\n    var clientBRoleMapper = new Keycloak.GenericRoleMapper(\"client_b_role_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientScopeId = clientScope.Id,\n        RoleId = clientRole.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tName:       pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientRole, err := keycloak.NewRole(ctx, \"client_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    client.ID(),\n\t\t\tName:        pulumi.String(\"my-client-role\"),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"my-client-scope\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericRoleMapper(ctx, \"client_b_role_mapper\", \u0026keycloak.GenericRoleMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tRoleId:        clientRole.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport com.pulumi.keycloak.GenericRoleMapper;\nimport com.pulumi.keycloak.GenericRoleMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var client = new Client(\"client\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"client\")\n            .name(\"client\")\n            .enabled(true)\n            .accessType(\"BEARER-ONLY\")\n            .build());\n\n        var clientRole = new Role(\"clientRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .clientId(client.id())\n            .name(\"my-client-role\")\n            .description(\"My Client Role\")\n            .build());\n\n        var clientScope = new ClientScope(\"clientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-client-scope\")\n            .build());\n\n        var clientBRoleMapper = new GenericRoleMapper(\"clientBRoleMapper\", GenericRoleMapperArgs.builder()\n            .realmId(realm.id())\n            .clientScopeId(clientScope.id())\n            .roleId(clientRole.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  client:\n    type: keycloak:openid:Client\n    properties:\n      realmId: ${realm.id}\n      clientId: client\n      name: client\n      enabled: true\n      accessType: BEARER-ONLY\n  clientRole:\n    type: keycloak:Role\n    name: client_role\n    properties:\n      realmId: ${realm.id}\n      clientId: ${client.id}\n      name: my-client-role\n      description: My Client Role\n  clientScope:\n    type: keycloak:openid:ClientScope\n    name: client_scope\n    properties:\n      realmId: ${realm.id}\n      name: my-client-scope\n  clientBRoleMapper:\n    type: keycloak:GenericRoleMapper\n    name: client_b_role_mapper\n    properties:\n      realmId: ${realm.id}\n      clientScopeId: ${clientScope.id}\n      roleId: ${clientRole.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nGeneric client role mappers can be imported using one of the following two formats:\n\n- When mapping a role to a client, use the format `{{realmId}}/client/{{clientId}}/scope-mappings/{{roleClientId}}/{{roleId}}`\n\n- When mapping a role to a client scope, use the format `{{realmId}}/client-scope/{{clientScopeId}}/scope-mappings/{{roleClientId}}/{{roleId}}`\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:index/genericRoleMapper:GenericRoleMapper client_role_mapper my-realm/client/23888550-5dcd-41f6-85ba-554233021e9c/scope-mappings/ce51f004-bdfb-4dd5-a963-c4487d2dec5b/ff3aa49f-bc07-4030-8783-41918c3614a3\n```\n\n",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client this role mapper should be added to. Conflicts with `client_scope_id`. This argument is required if `client_scope_id` is not set.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The ID of the client scope this role mapper should be added to. Conflicts with `client_id`. This argument is required if `client_id` is not set.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this role mapper exists within.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to be added to this role mapper.\n"
                }
            },
            "required": [
                "realmId",
                "roleId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client this role mapper should be added to. Conflicts with `client_scope_id`. This argument is required if `client_scope_id` is not set.\n",
                    "willReplaceOnChanges": true
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The ID of the client scope this role mapper should be added to. Conflicts with `client_id`. This argument is required if `client_id` is not set.\n",
                    "willReplaceOnChanges": true
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this role mapper exists within.\n",
                    "willReplaceOnChanges": true
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to be added to this role mapper.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "realmId",
                "roleId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GenericRoleMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The ID of the client this role mapper should be added to. Conflicts with `client_scope_id`. This argument is required if `client_scope_id` is not set.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The ID of the client scope this role mapper should be added to. Conflicts with `client_id`. This argument is required if `client_id` is not set.\n",
                        "willReplaceOnChanges": true
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this role mapper exists within.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The ID of the role to be added to this role mapper.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/group:Group": {
            "description": "## # keycloak.Group\n\nAllows for creating and managing Groups within Keycloak.\n\nGroups provide a logical wrapping for users within Keycloak. Users within a\ngroup can share attributes and roles, and group membership can be mapped\nto a claim.\n\nAttributes can also be defined on Groups.\n\nGroups can also be federated from external data sources, such as LDAP or Active Directory.\nThis resource **should not** be used to manage groups that were created this way.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst parentGroup = new keycloak.Group(\"parent_group\", {\n    realmId: realm.id,\n    name: \"parent-group\",\n});\nconst childGroup = new keycloak.Group(\"child_group\", {\n    realmId: realm.id,\n    parentId: parentGroup.id,\n    name: \"child-group\",\n});\nconst childGroupWithOptionalAttributes = new keycloak.Group(\"child_group_with_optional_attributes\", {\n    realmId: realm.id,\n    parentId: parentGroup.id,\n    name: \"child-group-with-optional-attributes\",\n    attributes: {\n        key1: \"value1\",\n        key2: \"value2\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nparent_group = keycloak.Group(\"parent_group\",\n    realm_id=realm.id,\n    name=\"parent-group\")\nchild_group = keycloak.Group(\"child_group\",\n    realm_id=realm.id,\n    parent_id=parent_group.id,\n    name=\"child-group\")\nchild_group_with_optional_attributes = keycloak.Group(\"child_group_with_optional_attributes\",\n    realm_id=realm.id,\n    parent_id=parent_group.id,\n    name=\"child-group-with-optional-attributes\",\n    attributes={\n        \"key1\": \"value1\",\n        \"key2\": \"value2\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var parentGroup = new Keycloak.Group(\"parent_group\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"parent-group\",\n    });\n\n    var childGroup = new Keycloak.Group(\"child_group\", new()\n    {\n        RealmId = realm.Id,\n        ParentId = parentGroup.Id,\n        Name = \"child-group\",\n    });\n\n    var childGroupWithOptionalAttributes = new Keycloak.Group(\"child_group_with_optional_attributes\", new()\n    {\n        RealmId = realm.Id,\n        ParentId = parentGroup.Id,\n        Name = \"child-group-with-optional-attributes\",\n        Attributes = \n        {\n            { \"key1\", \"value1\" },\n            { \"key2\", \"value2\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tparentGroup, err := keycloak.NewGroup(ctx, \"parent_group\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"parent-group\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGroup(ctx, \"child_group\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tParentId: parentGroup.ID(),\n\t\t\tName:     pulumi.String(\"child-group\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGroup(ctx, \"child_group_with_optional_attributes\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tParentId: parentGroup.ID(),\n\t\t\tName:     pulumi.String(\"child-group-with-optional-attributes\"),\n\t\t\tAttributes: pulumi.Map{\n\t\t\t\t\"key1\": pulumi.Any(\"value1\"),\n\t\t\t\t\"key2\": pulumi.Any(\"value2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.Group;\nimport com.pulumi.keycloak.GroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var parentGroup = new Group(\"parentGroup\", GroupArgs.builder()\n            .realmId(realm.id())\n            .name(\"parent-group\")\n            .build());\n\n        var childGroup = new Group(\"childGroup\", GroupArgs.builder()\n            .realmId(realm.id())\n            .parentId(parentGroup.id())\n            .name(\"child-group\")\n            .build());\n\n        var childGroupWithOptionalAttributes = new Group(\"childGroupWithOptionalAttributes\", GroupArgs.builder()\n            .realmId(realm.id())\n            .parentId(parentGroup.id())\n            .name(\"child-group-with-optional-attributes\")\n            .attributes(Map.ofEntries(\n                Map.entry(\"key1\", \"value1\"),\n                Map.entry(\"key2\", \"value2\")\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  parentGroup:\n    type: keycloak:Group\n    name: parent_group\n    properties:\n      realmId: ${realm.id}\n      name: parent-group\n  childGroup:\n    type: keycloak:Group\n    name: child_group\n    properties:\n      realmId: ${realm.id}\n      parentId: ${parentGroup.id}\n      name: child-group\n  childGroupWithOptionalAttributes:\n    type: keycloak:Group\n    name: child_group_with_optional_attributes\n    properties:\n      realmId: ${realm.id}\n      parentId: ${parentGroup.id}\n      name: child-group-with-optional-attributes\n      attributes:\n        key1: value1\n        key2: value2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this group exists in.\n- `parent_id` - (Optional) The ID of this group's parent. If omitted, this group will be defined at the root level.\n- `name` - (Required) The name of the group.\n- `attributes` - (Optional) A dict of key/value pairs to set as custom attributes for the group.\n\n### Attributes Reference\n\nIn addition to the arguments listed above, the following computed attributes are exported:\n\n- `path` - The complete path of the group. For example, the child group's path in the example configuration would be `/parent-group/child-group`.\n\n### Import\n\nGroups can be imported using the format `{{realm_id}}/{{group_id}}`, where `group_id` is the unique ID that Keycloak\nassigns to the group upon creation. This value can be found in the URI when editing this group in the GUI, and is typically a GUID.\n\nExample:\n\n```bash\n$ terraform import keycloak_group.child_group my-realm/934a4a4e-28bd-4703-a0fa-332df153aabd\n```\n",
            "properties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "name": {
                    "type": "string"
                },
                "parentId": {
                    "type": "string"
                },
                "path": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "path",
                "realmId"
            ],
            "inputProperties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "name": {
                    "type": "string"
                },
                "parentId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Group resources.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "name": {
                        "type": "string"
                    },
                    "parentId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/groupMemberships:GroupMemberships": {
            "description": "## # keycloak.GroupMemberships\n\nAllows for managing a Keycloak group's members.\n\nNote that this resource attempts to be an **authoritative** source over group members.\nWhen this resource takes control over a group's members, users that are manually added\nto the group will be removed, and users that are manually removed from the group will\nbe added upon the next run of `pulumi up`.  Eventually, a non-authoritative resource\nfor group membership will be added to this provider.\n\nAlso note that you should not use `keycloak.GroupMemberships` with a group has been assigned\nas a default group via `keycloak.DefaultGroups`.\n\nThis resource **should not** be used to control membership of a group that has its members\nfederated from an external source via group mapping.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst group = new keycloak.Group(\"group\", {\n    realmId: realm.id,\n    name: \"my-group\",\n});\nconst user = new keycloak.User(\"user\", {\n    realmId: realm.id,\n    username: \"my-user\",\n});\nconst groupMembers = new keycloak.GroupMemberships(\"group_members\", {\n    realmId: realm.id,\n    groupId: group.id,\n    members: [user.username],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\ngroup = keycloak.Group(\"group\",\n    realm_id=realm.id,\n    name=\"my-group\")\nuser = keycloak.User(\"user\",\n    realm_id=realm.id,\n    username=\"my-user\")\ngroup_members = keycloak.GroupMemberships(\"group_members\",\n    realm_id=realm.id,\n    group_id=group.id,\n    members=[user.username])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var @group = new Keycloak.Group(\"group\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-group\",\n    });\n\n    var user = new Keycloak.User(\"user\", new()\n    {\n        RealmId = realm.Id,\n        Username = \"my-user\",\n    });\n\n    var groupMembers = new Keycloak.GroupMemberships(\"group_members\", new()\n    {\n        RealmId = realm.Id,\n        GroupId = @group.Id,\n        Members = new[]\n        {\n            user.Username,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgroup, err := keycloak.NewGroup(ctx, \"group\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"my-group\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuser, err := keycloak.NewUser(ctx, \"user\", \u0026keycloak.UserArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tUsername: pulumi.String(\"my-user\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGroupMemberships(ctx, \"group_members\", \u0026keycloak.GroupMembershipsArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tGroupId: group.ID(),\n\t\t\tMembers: pulumi.StringArray{\n\t\t\t\tuser.Username,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.Group;\nimport com.pulumi.keycloak.GroupArgs;\nimport com.pulumi.keycloak.User;\nimport com.pulumi.keycloak.UserArgs;\nimport com.pulumi.keycloak.GroupMemberships;\nimport com.pulumi.keycloak.GroupMembershipsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var group = new Group(\"group\", GroupArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-group\")\n            .build());\n\n        var user = new User(\"user\", UserArgs.builder()\n            .realmId(realm.id())\n            .username(\"my-user\")\n            .build());\n\n        var groupMembers = new GroupMemberships(\"groupMembers\", GroupMembershipsArgs.builder()\n            .realmId(realm.id())\n            .groupId(group.id())\n            .members(user.username())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  group:\n    type: keycloak:Group\n    properties:\n      realmId: ${realm.id}\n      name: my-group\n  user:\n    type: keycloak:User\n    properties:\n      realmId: ${realm.id}\n      username: my-user\n  groupMembers:\n    type: keycloak:GroupMemberships\n    name: group_members\n    properties:\n      realmId: ${realm.id}\n      groupId: ${group.id}\n      members:\n        - ${user.username}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this group exists in.\n- `group_id` - (Required) The ID of the group this resource should manage memberships for.\n- `members` - (Required) An array of usernames that belong to this group.\n\n### Import\n\nThis resource does not support import. Instead of importing, feel free to create this resource\nas if it did not already exist on the server.\n",
            "properties": {
                "groupId": {
                    "type": "string"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "members",
                "realmId"
            ],
            "inputProperties": {
                "groupId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "members": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "members",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupMemberships resources.\n",
                "properties": {
                    "groupId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "members": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/groupPermissions:GroupPermissions": {
            "description": "Allows you to manage all group Scope Based Permissions https://www.keycloak.org/docs/latest/server_admin/#group.\n\nThis is part of a preview Keycloak feature: `admin_fine_grained_authz` (see https://www.keycloak.org/docs/latest/server_admin/#_fine_grain_permissions).\nThis feature can be enabled with the Keycloak option `-Dkeycloak.profile.feature.admin_fine_grained_authz=enabled`. See the\nexample `docker-compose.yml` file for an example.\n\nWhen enabling Roles Permissions, Keycloak does several things automatically:\n1. Enable Authorization on built-in `realm-management` client (if not already enabled).\n1. Create a resource representing the role permissions.\n1. Create scopes `view`, `manage`, `view-members`, `manage-members`, `manage-membership`.\n1. Create all scope based permission for the scopes and role resource\n",
            "properties": {
                "authorizationResourceServerId": {
                    "type": "string",
                    "description": "Resource server id representing the realm management client on which this permission is managed\n"
                },
                "enabled": {
                    "type": "boolean"
                },
                "groupId": {
                    "type": "string"
                },
                "manageMembersScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsManageMembersScope:GroupPermissionsManageMembersScope"
                },
                "manageMembershipScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsManageMembershipScope:GroupPermissionsManageMembershipScope"
                },
                "manageScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsManageScope:GroupPermissionsManageScope"
                },
                "realmId": {
                    "type": "string"
                },
                "viewMembersScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsViewMembersScope:GroupPermissionsViewMembersScope"
                },
                "viewScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsViewScope:GroupPermissionsViewScope"
                }
            },
            "required": [
                "authorizationResourceServerId",
                "enabled",
                "groupId",
                "realmId"
            ],
            "inputProperties": {
                "groupId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "manageMembersScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsManageMembersScope:GroupPermissionsManageMembersScope"
                },
                "manageMembershipScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsManageMembershipScope:GroupPermissionsManageMembershipScope"
                },
                "manageScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsManageScope:GroupPermissionsManageScope"
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "viewMembersScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsViewMembersScope:GroupPermissionsViewMembersScope"
                },
                "viewScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsViewScope:GroupPermissionsViewScope"
                }
            },
            "requiredInputs": [
                "groupId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupPermissions resources.\n",
                "properties": {
                    "authorizationResourceServerId": {
                        "type": "string",
                        "description": "Resource server id representing the realm management client on which this permission is managed\n"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "groupId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "manageMembersScope": {
                        "$ref": "#/types/keycloak:index/GroupPermissionsManageMembersScope:GroupPermissionsManageMembersScope"
                    },
                    "manageMembershipScope": {
                        "$ref": "#/types/keycloak:index/GroupPermissionsManageMembershipScope:GroupPermissionsManageMembershipScope"
                    },
                    "manageScope": {
                        "$ref": "#/types/keycloak:index/GroupPermissionsManageScope:GroupPermissionsManageScope"
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "viewMembersScope": {
                        "$ref": "#/types/keycloak:index/GroupPermissionsViewMembersScope:GroupPermissionsViewMembersScope"
                    },
                    "viewScope": {
                        "$ref": "#/types/keycloak:index/GroupPermissionsViewScope:GroupPermissionsViewScope"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/groupRoles:GroupRoles": {
            "description": "## # keycloak.GroupRoles\n\nAllows you to manage roles assigned to a Keycloak group.\n\nNote that this resource attempts to be an **authoritative** source over\ngroup roles. When this resource takes control over a group's roles,\nroles that are manually added to the group will be removed, and roles\nthat are manually removed from the group will be added upon the next run\nof `pulumi up`.\n\nNote that when assigning composite roles to a group, you may see a\nnon-empty plan following a `pulumi up` if you assign a role and a\ncomposite that includes that role to the same group.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst realmRole = new keycloak.Role(\"realm_role\", {\n    realmId: realm.id,\n    name: \"my-realm-role\",\n    description: \"My Realm Role\",\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    name: \"client\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst clientRole = new keycloak.Role(\"client_role\", {\n    realmId: realm.id,\n    clientId: clientKeycloakClient.id,\n    name: \"my-client-role\",\n    description: \"My Client Role\",\n});\nconst group = new keycloak.Group(\"group\", {\n    realmId: realm.id,\n    name: \"my-group\",\n});\nconst groupRoles = new keycloak.GroupRoles(\"group_roles\", {\n    realmId: realm.id,\n    groupId: group.id,\n    roleIds: [\n        realmRole.id,\n        clientRole.id,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrealm_role = keycloak.Role(\"realm_role\",\n    realm_id=realm.id,\n    name=\"my-realm-role\",\n    description=\"My Realm Role\")\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    name=\"client\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nclient_role = keycloak.Role(\"client_role\",\n    realm_id=realm.id,\n    client_id=client_keycloak_client[\"id\"],\n    name=\"my-client-role\",\n    description=\"My Client Role\")\ngroup = keycloak.Group(\"group\",\n    realm_id=realm.id,\n    name=\"my-group\")\ngroup_roles = keycloak.GroupRoles(\"group_roles\",\n    realm_id=realm.id,\n    group_id=group.id,\n    role_ids=[\n        realm_role.id,\n        client_role.id,\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var realmRole = new Keycloak.Role(\"realm_role\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-realm-role\",\n        Description = \"My Realm Role\",\n    });\n\n    var client = new Keycloak.OpenId.Client(\"client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"client\",\n        Name = \"client\",\n        Enabled = true,\n        AccessType = \"BEARER-ONLY\",\n    });\n\n    var clientRole = new Keycloak.Role(\"client_role\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = clientKeycloakClient.Id,\n        Name = \"my-client-role\",\n        Description = \"My Client Role\",\n    });\n\n    var @group = new Keycloak.Group(\"group\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-group\",\n    });\n\n    var groupRoles = new Keycloak.GroupRoles(\"group_roles\", new()\n    {\n        RealmId = realm.Id,\n        GroupId = @group.Id,\n        RoleIds = new[]\n        {\n            realmRole.Id,\n            clientRole.Id,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmRole, err := keycloak.NewRole(ctx, \"realm_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tName:        pulumi.String(\"my-realm-role\"),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tName:       pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientRole, err := keycloak.NewRole(ctx, \"client_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    pulumi.Any(clientKeycloakClient.Id),\n\t\t\tName:        pulumi.String(\"my-client-role\"),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgroup, err := keycloak.NewGroup(ctx, \"group\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"my-group\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGroupRoles(ctx, \"group_roles\", \u0026keycloak.GroupRolesArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tGroupId: group.ID(),\n\t\t\tRoleIds: pulumi.StringArray{\n\t\t\t\trealmRole.ID(),\n\t\t\t\tclientRole.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.Group;\nimport com.pulumi.keycloak.GroupArgs;\nimport com.pulumi.keycloak.GroupRoles;\nimport com.pulumi.keycloak.GroupRolesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var realmRole = new Role(\"realmRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-realm-role\")\n            .description(\"My Realm Role\")\n            .build());\n\n        var client = new Client(\"client\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"client\")\n            .name(\"client\")\n            .enabled(true)\n            .accessType(\"BEARER-ONLY\")\n            .build());\n\n        var clientRole = new Role(\"clientRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .clientId(clientKeycloakClient.id())\n            .name(\"my-client-role\")\n            .description(\"My Client Role\")\n            .build());\n\n        var group = new Group(\"group\", GroupArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-group\")\n            .build());\n\n        var groupRoles = new GroupRoles(\"groupRoles\", GroupRolesArgs.builder()\n            .realmId(realm.id())\n            .groupId(group.id())\n            .roleIds(            \n                realmRole.id(),\n                clientRole.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  realmRole:\n    type: keycloak:Role\n    name: realm_role\n    properties:\n      realmId: ${realm.id}\n      name: my-realm-role\n      description: My Realm Role\n  client:\n    type: keycloak:openid:Client\n    properties:\n      realmId: ${realm.id}\n      clientId: client\n      name: client\n      enabled: true\n      accessType: BEARER-ONLY\n  clientRole:\n    type: keycloak:Role\n    name: client_role\n    properties:\n      realmId: ${realm.id}\n      clientId: ${clientKeycloakClient.id}\n      name: my-client-role\n      description: My Client Role\n  group:\n    type: keycloak:Group\n    properties:\n      realmId: ${realm.id}\n      name: my-group\n  groupRoles:\n    type: keycloak:GroupRoles\n    name: group_roles\n    properties:\n      realmId: ${realm.id}\n      groupId: ${group.id}\n      roleIds:\n        - ${realmRole.id}\n        - ${clientRole.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this group exists in.\n- `group_id` - (Required) The ID of the group this resource should\n  manage roles for.\n- `role_ids` - (Required) A list of role IDs to map to the group\n\n### Import\n\nThis resource can be imported using the format\n`{{realm_id}}/{{group_id}}`, where `group_id` is the unique ID that\nKeycloak assigns to the group upon creation. This value can be found in\nthe URI when editing this group in the GUI, and is typically a GUID.\n\nExample:\n\n```bash\n$ terraform import keycloak_group_roles.group_roles my-realm/18cc6b87-2ce7-4e59-bdc8-b9d49ec98a94\n```\n",
            "properties": {
                "exhaustive": {
                    "type": "boolean"
                },
                "groupId": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "groupId",
                "realmId",
                "roleIds"
            ],
            "inputProperties": {
                "exhaustive": {
                    "type": "boolean"
                },
                "groupId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "requiredInputs": [
                "groupId",
                "realmId",
                "roleIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupRoles resources.\n",
                "properties": {
                    "exhaustive": {
                        "type": "boolean"
                    },
                    "groupId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "roleIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/hardcodedAttributeIdentityProviderMapper:HardcodedAttributeIdentityProviderMapper": {
            "description": "Allows for creating and managing hardcoded attribute mappers for Keycloak identity provider.\n\nThe identity provider hardcoded attribute mapper will set the specified value to the IDP attribute.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst oidc = new keycloak.oidc.IdentityProvider(\"oidc\", {\n    realm: realm.id,\n    alias: \"my-idp\",\n    authorizationUrl: \"https://authorizationurl.com\",\n    clientId: \"clientID\",\n    clientSecret: \"clientSecret\",\n    tokenUrl: \"https://tokenurl.com\",\n});\nconst oidcHardcodedAttributeIdentityProviderMapper = new keycloak.HardcodedAttributeIdentityProviderMapper(\"oidc\", {\n    realm: realm.id,\n    name: \"hardcodedUserSessionAttribute\",\n    identityProviderAlias: oidc.alias,\n    attributeName: \"attribute\",\n    attributeValue: \"value\",\n    userSession: true,\n    extraConfig: {\n        syncMode: \"INHERIT\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\noidc = keycloak.oidc.IdentityProvider(\"oidc\",\n    realm=realm.id,\n    alias=\"my-idp\",\n    authorization_url=\"https://authorizationurl.com\",\n    client_id=\"clientID\",\n    client_secret=\"clientSecret\",\n    token_url=\"https://tokenurl.com\")\noidc_hardcoded_attribute_identity_provider_mapper = keycloak.HardcodedAttributeIdentityProviderMapper(\"oidc\",\n    realm=realm.id,\n    name=\"hardcodedUserSessionAttribute\",\n    identity_provider_alias=oidc.alias,\n    attribute_name=\"attribute\",\n    attribute_value=\"value\",\n    user_session=True,\n    extra_config={\n        \"syncMode\": \"INHERIT\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var oidc = new Keycloak.Oidc.IdentityProvider(\"oidc\", new()\n    {\n        Realm = realm.Id,\n        Alias = \"my-idp\",\n        AuthorizationUrl = \"https://authorizationurl.com\",\n        ClientId = \"clientID\",\n        ClientSecret = \"clientSecret\",\n        TokenUrl = \"https://tokenurl.com\",\n    });\n\n    var oidcHardcodedAttributeIdentityProviderMapper = new Keycloak.HardcodedAttributeIdentityProviderMapper(\"oidc\", new()\n    {\n        Realm = realm.Id,\n        Name = \"hardcodedUserSessionAttribute\",\n        IdentityProviderAlias = oidc.Alias,\n        AttributeName = \"attribute\",\n        AttributeValue = \"value\",\n        UserSession = true,\n        ExtraConfig = \n        {\n            { \"syncMode\", \"INHERIT\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/oidc\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\toidc, err := oidc.NewIdentityProvider(ctx, \"oidc\", \u0026oidc.IdentityProviderArgs{\n\t\t\tRealm:            realm.ID(),\n\t\t\tAlias:            pulumi.String(\"my-idp\"),\n\t\t\tAuthorizationUrl: pulumi.String(\"https://authorizationurl.com\"),\n\t\t\tClientId:         pulumi.String(\"clientID\"),\n\t\t\tClientSecret:     pulumi.String(\"clientSecret\"),\n\t\t\tTokenUrl:         pulumi.String(\"https://tokenurl.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewHardcodedAttributeIdentityProviderMapper(ctx, \"oidc\", \u0026keycloak.HardcodedAttributeIdentityProviderMapperArgs{\n\t\t\tRealm:                 realm.ID(),\n\t\t\tName:                  pulumi.String(\"hardcodedUserSessionAttribute\"),\n\t\t\tIdentityProviderAlias: oidc.Alias,\n\t\t\tAttributeName:         pulumi.String(\"attribute\"),\n\t\t\tAttributeValue:        pulumi.String(\"value\"),\n\t\t\tUserSession:           pulumi.Bool(true),\n\t\t\tExtraConfig: pulumi.Map{\n\t\t\t\t\"syncMode\": pulumi.Any(\"INHERIT\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.oidc.IdentityProvider;\nimport com.pulumi.keycloak.oidc.IdentityProviderArgs;\nimport com.pulumi.keycloak.HardcodedAttributeIdentityProviderMapper;\nimport com.pulumi.keycloak.HardcodedAttributeIdentityProviderMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var oidc = new IdentityProvider(\"oidc\", IdentityProviderArgs.builder()\n            .realm(realm.id())\n            .alias(\"my-idp\")\n            .authorizationUrl(\"https://authorizationurl.com\")\n            .clientId(\"clientID\")\n            .clientSecret(\"clientSecret\")\n            .tokenUrl(\"https://tokenurl.com\")\n            .build());\n\n        var oidcHardcodedAttributeIdentityProviderMapper = new HardcodedAttributeIdentityProviderMapper(\"oidcHardcodedAttributeIdentityProviderMapper\", HardcodedAttributeIdentityProviderMapperArgs.builder()\n            .realm(realm.id())\n            .name(\"hardcodedUserSessionAttribute\")\n            .identityProviderAlias(oidc.alias())\n            .attributeName(\"attribute\")\n            .attributeValue(\"value\")\n            .userSession(true)\n            .extraConfig(Map.of(\"syncMode\", \"INHERIT\"))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  oidc:\n    type: keycloak:oidc:IdentityProvider\n    properties:\n      realm: ${realm.id}\n      alias: my-idp\n      authorizationUrl: https://authorizationurl.com\n      clientId: clientID\n      clientSecret: clientSecret\n      tokenUrl: https://tokenurl.com\n  oidcHardcodedAttributeIdentityProviderMapper:\n    type: keycloak:HardcodedAttributeIdentityProviderMapper\n    name: oidc\n    properties:\n      realm: ${realm.id}\n      name: hardcodedUserSessionAttribute\n      identityProviderAlias: ${oidc.alias}\n      attributeName: attribute\n      attributeValue: value\n      userSession: true\n      extraConfig:\n        syncMode: INHERIT\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "attributeName": {
                    "type": "string",
                    "description": "The name of the IDP attribute to set.\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "The value to set to the attribute. You can hardcode any value like 'foo'.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "The IDP alias of the attribute to set.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The realm ID that this mapper will exist in.\n"
                },
                "userSession": {
                    "type": "boolean",
                    "description": "Is Attribute related to a User Session.\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm",
                "userSession"
            ],
            "inputProperties": {
                "attributeName": {
                    "type": "string",
                    "description": "The name of the IDP attribute to set.\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "The value to set to the attribute. You can hardcode any value like 'foo'.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "The IDP alias of the attribute to set.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n",
                    "willReplaceOnChanges": true
                },
                "realm": {
                    "type": "string",
                    "description": "The realm ID that this mapper will exist in.\n",
                    "willReplaceOnChanges": true
                },
                "userSession": {
                    "type": "boolean",
                    "description": "Is Attribute related to a User Session.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm",
                "userSession"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedAttributeIdentityProviderMapper resources.\n",
                "properties": {
                    "attributeName": {
                        "type": "string",
                        "description": "The name of the IDP attribute to set.\n"
                    },
                    "attributeValue": {
                        "type": "string",
                        "description": "The value to set to the attribute. You can hardcode any value like 'foo'.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "The IDP alias of the attribute to set.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n",
                        "willReplaceOnChanges": true
                    },
                    "realm": {
                        "type": "string",
                        "description": "The realm ID that this mapper will exist in.\n",
                        "willReplaceOnChanges": true
                    },
                    "userSession": {
                        "type": "boolean",
                        "description": "Is Attribute related to a User Session.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/hardcodedRoleIdentityMapper:HardcodedRoleIdentityMapper": {
            "description": "Allows for creating and managing hardcoded role mappers for Keycloak identity provider.\n\nThe identity provider hardcoded role mapper grants a specified Keycloak role to each Keycloak user from the LDAP provider.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst oidc = new keycloak.oidc.IdentityProvider(\"oidc\", {\n    realm: realm.id,\n    alias: \"my-idp\",\n    authorizationUrl: \"https://authorizationurl.com\",\n    clientId: \"clientID\",\n    clientSecret: \"clientSecret\",\n    tokenUrl: \"https://tokenurl.com\",\n});\nconst realmRole = new keycloak.Role(\"realm_role\", {\n    realmId: realm.id,\n    name: \"my-realm-role\",\n    description: \"My Realm Role\",\n});\nconst oidcHardcodedRoleIdentityMapper = new keycloak.HardcodedRoleIdentityMapper(\"oidc\", {\n    realm: realm.id,\n    name: \"hardcodedRole\",\n    identityProviderAlias: oidc.alias,\n    role: \"my-realm-role\",\n    extraConfig: {\n        syncMode: \"INHERIT\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\noidc = keycloak.oidc.IdentityProvider(\"oidc\",\n    realm=realm.id,\n    alias=\"my-idp\",\n    authorization_url=\"https://authorizationurl.com\",\n    client_id=\"clientID\",\n    client_secret=\"clientSecret\",\n    token_url=\"https://tokenurl.com\")\nrealm_role = keycloak.Role(\"realm_role\",\n    realm_id=realm.id,\n    name=\"my-realm-role\",\n    description=\"My Realm Role\")\noidc_hardcoded_role_identity_mapper = keycloak.HardcodedRoleIdentityMapper(\"oidc\",\n    realm=realm.id,\n    name=\"hardcodedRole\",\n    identity_provider_alias=oidc.alias,\n    role=\"my-realm-role\",\n    extra_config={\n        \"syncMode\": \"INHERIT\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var oidc = new Keycloak.Oidc.IdentityProvider(\"oidc\", new()\n    {\n        Realm = realm.Id,\n        Alias = \"my-idp\",\n        AuthorizationUrl = \"https://authorizationurl.com\",\n        ClientId = \"clientID\",\n        ClientSecret = \"clientSecret\",\n        TokenUrl = \"https://tokenurl.com\",\n    });\n\n    var realmRole = new Keycloak.Role(\"realm_role\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-realm-role\",\n        Description = \"My Realm Role\",\n    });\n\n    var oidcHardcodedRoleIdentityMapper = new Keycloak.HardcodedRoleIdentityMapper(\"oidc\", new()\n    {\n        Realm = realm.Id,\n        Name = \"hardcodedRole\",\n        IdentityProviderAlias = oidc.Alias,\n        Role = \"my-realm-role\",\n        ExtraConfig = \n        {\n            { \"syncMode\", \"INHERIT\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/oidc\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\toidc, err := oidc.NewIdentityProvider(ctx, \"oidc\", \u0026oidc.IdentityProviderArgs{\n\t\t\tRealm:            realm.ID(),\n\t\t\tAlias:            pulumi.String(\"my-idp\"),\n\t\t\tAuthorizationUrl: pulumi.String(\"https://authorizationurl.com\"),\n\t\t\tClientId:         pulumi.String(\"clientID\"),\n\t\t\tClientSecret:     pulumi.String(\"clientSecret\"),\n\t\t\tTokenUrl:         pulumi.String(\"https://tokenurl.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"realm_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tName:        pulumi.String(\"my-realm-role\"),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewHardcodedRoleIdentityMapper(ctx, \"oidc\", \u0026keycloak.HardcodedRoleIdentityMapperArgs{\n\t\t\tRealm:                 realm.ID(),\n\t\t\tName:                  pulumi.String(\"hardcodedRole\"),\n\t\t\tIdentityProviderAlias: oidc.Alias,\n\t\t\tRole:                  pulumi.String(\"my-realm-role\"),\n\t\t\tExtraConfig: pulumi.Map{\n\t\t\t\t\"syncMode\": pulumi.Any(\"INHERIT\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.oidc.IdentityProvider;\nimport com.pulumi.keycloak.oidc.IdentityProviderArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport com.pulumi.keycloak.HardcodedRoleIdentityMapper;\nimport com.pulumi.keycloak.HardcodedRoleIdentityMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var oidc = new IdentityProvider(\"oidc\", IdentityProviderArgs.builder()\n            .realm(realm.id())\n            .alias(\"my-idp\")\n            .authorizationUrl(\"https://authorizationurl.com\")\n            .clientId(\"clientID\")\n            .clientSecret(\"clientSecret\")\n            .tokenUrl(\"https://tokenurl.com\")\n            .build());\n\n        var realmRole = new Role(\"realmRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-realm-role\")\n            .description(\"My Realm Role\")\n            .build());\n\n        var oidcHardcodedRoleIdentityMapper = new HardcodedRoleIdentityMapper(\"oidcHardcodedRoleIdentityMapper\", HardcodedRoleIdentityMapperArgs.builder()\n            .realm(realm.id())\n            .name(\"hardcodedRole\")\n            .identityProviderAlias(oidc.alias())\n            .role(\"my-realm-role\")\n            .extraConfig(Map.of(\"syncMode\", \"INHERIT\"))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  oidc:\n    type: keycloak:oidc:IdentityProvider\n    properties:\n      realm: ${realm.id}\n      alias: my-idp\n      authorizationUrl: https://authorizationurl.com\n      clientId: clientID\n      clientSecret: clientSecret\n      tokenUrl: https://tokenurl.com\n  realmRole:\n    type: keycloak:Role\n    name: realm_role\n    properties:\n      realmId: ${realm.id}\n      name: my-realm-role\n      description: My Realm Role\n  oidcHardcodedRoleIdentityMapper:\n    type: keycloak:HardcodedRoleIdentityMapper\n    name: oidc\n    properties:\n      realm: ${realm.id}\n      name: hardcodedRole\n      identityProviderAlias: ${oidc.alias}\n      role: my-realm-role\n      extraConfig:\n        syncMode: INHERIT\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "The IDP alias of the attribute to set.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The realm ID that this mapper will exist in.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role which should be assigned to the users.\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm"
            ],
            "inputProperties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "The IDP alias of the attribute to set.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n",
                    "willReplaceOnChanges": true
                },
                "realm": {
                    "type": "string",
                    "description": "The realm ID that this mapper will exist in.\n",
                    "willReplaceOnChanges": true
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role which should be assigned to the users.\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedRoleIdentityMapper resources.\n",
                "properties": {
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "The IDP alias of the attribute to set.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n",
                        "willReplaceOnChanges": true
                    },
                    "realm": {
                        "type": "string",
                        "description": "The realm ID that this mapper will exist in.\n",
                        "willReplaceOnChanges": true
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the role which should be assigned to the users.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/identityProviderTokenExchangeScopePermission:IdentityProviderTokenExchangeScopePermission": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst tokenExchangeRealm = new keycloak.Realm(\"token_exchange_realm\", {\n    realm: \"token-exchange_destination_realm\",\n    enabled: true,\n});\nconst tokenExchangeMyOidcIdp = new keycloak.oidc.IdentityProvider(\"token_exchange_my_oidc_idp\", {\n    realm: tokenExchangeRealm.id,\n    alias: \"myIdp\",\n    authorizationUrl: \"http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/auth\",\n    tokenUrl: \"http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/token\",\n    clientId: \"clientId\",\n    clientSecret: \"secret\",\n    defaultScopes: \"openid\",\n});\nconst token_exchangeWebappClient = new keycloak.openid.Client(\"token-exchange_webapp_client\", {\n    realmId: tokenExchangeRealm.id,\n    name: \"webapp_client\",\n    clientId: \"webapp_client\",\n    clientSecret: \"secret\",\n    description: \"a webapp client on the destination realm\",\n    accessType: \"CONFIDENTIAL\",\n    standardFlowEnabled: true,\n    validRedirectUris: [\"http://localhost:8080/*\"],\n});\n//relevant part\nconst oidcIdpPermission = new keycloak.IdentityProviderTokenExchangeScopePermission(\"oidc_idp_permission\", {\n    realmId: tokenExchangeRealm.id,\n    providerAlias: tokenExchangeMyOidcIdp.alias,\n    policyType: \"client\",\n    clients: [token_exchangeWebappClient.id],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\ntoken_exchange_realm = keycloak.Realm(\"token_exchange_realm\",\n    realm=\"token-exchange_destination_realm\",\n    enabled=True)\ntoken_exchange_my_oidc_idp = keycloak.oidc.IdentityProvider(\"token_exchange_my_oidc_idp\",\n    realm=token_exchange_realm.id,\n    alias=\"myIdp\",\n    authorization_url=\"http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/auth\",\n    token_url=\"http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/token\",\n    client_id=\"clientId\",\n    client_secret=\"secret\",\n    default_scopes=\"openid\")\ntoken_exchange_webapp_client = keycloak.openid.Client(\"token-exchange_webapp_client\",\n    realm_id=token_exchange_realm.id,\n    name=\"webapp_client\",\n    client_id=\"webapp_client\",\n    client_secret=\"secret\",\n    description=\"a webapp client on the destination realm\",\n    access_type=\"CONFIDENTIAL\",\n    standard_flow_enabled=True,\n    valid_redirect_uris=[\"http://localhost:8080/*\"])\n#relevant part\noidc_idp_permission = keycloak.IdentityProviderTokenExchangeScopePermission(\"oidc_idp_permission\",\n    realm_id=token_exchange_realm.id,\n    provider_alias=token_exchange_my_oidc_idp.alias,\n    policy_type=\"client\",\n    clients=[token_exchange_webapp_client.id])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var tokenExchangeRealm = new Keycloak.Realm(\"token_exchange_realm\", new()\n    {\n        RealmName = \"token-exchange_destination_realm\",\n        Enabled = true,\n    });\n\n    var tokenExchangeMyOidcIdp = new Keycloak.Oidc.IdentityProvider(\"token_exchange_my_oidc_idp\", new()\n    {\n        Realm = tokenExchangeRealm.Id,\n        Alias = \"myIdp\",\n        AuthorizationUrl = \"http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/auth\",\n        TokenUrl = \"http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/token\",\n        ClientId = \"clientId\",\n        ClientSecret = \"secret\",\n        DefaultScopes = \"openid\",\n    });\n\n    var token_exchangeWebappClient = new Keycloak.OpenId.Client(\"token-exchange_webapp_client\", new()\n    {\n        RealmId = tokenExchangeRealm.Id,\n        Name = \"webapp_client\",\n        ClientId = \"webapp_client\",\n        ClientSecret = \"secret\",\n        Description = \"a webapp client on the destination realm\",\n        AccessType = \"CONFIDENTIAL\",\n        StandardFlowEnabled = true,\n        ValidRedirectUris = new[]\n        {\n            \"http://localhost:8080/*\",\n        },\n    });\n\n    //relevant part\n    var oidcIdpPermission = new Keycloak.IdentityProviderTokenExchangeScopePermission(\"oidc_idp_permission\", new()\n    {\n        RealmId = tokenExchangeRealm.Id,\n        ProviderAlias = tokenExchangeMyOidcIdp.Alias,\n        PolicyType = \"client\",\n        Clients = new[]\n        {\n            token_exchangeWebappClient.Id,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/oidc\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttokenExchangeRealm, err := keycloak.NewRealm(ctx, \"token_exchange_realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"token-exchange_destination_realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttokenExchangeMyOidcIdp, err := oidc.NewIdentityProvider(ctx, \"token_exchange_my_oidc_idp\", \u0026oidc.IdentityProviderArgs{\n\t\t\tRealm:            tokenExchangeRealm.ID(),\n\t\t\tAlias:            pulumi.String(\"myIdp\"),\n\t\t\tAuthorizationUrl: pulumi.String(\"http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/auth\"),\n\t\t\tTokenUrl:         pulumi.String(\"http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/token\"),\n\t\t\tClientId:         pulumi.String(\"clientId\"),\n\t\t\tClientSecret:     pulumi.String(\"secret\"),\n\t\t\tDefaultScopes:    pulumi.String(\"openid\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClient(ctx, \"token-exchange_webapp_client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:             tokenExchangeRealm.ID(),\n\t\t\tName:                pulumi.String(\"webapp_client\"),\n\t\t\tClientId:            pulumi.String(\"webapp_client\"),\n\t\t\tClientSecret:        pulumi.String(\"secret\"),\n\t\t\tDescription:         pulumi.String(\"a webapp client on the destination realm\"),\n\t\t\tAccessType:          pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tStandardFlowEnabled: pulumi.Bool(true),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/*\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// relevant part\n\t\t_, err = keycloak.NewIdentityProviderTokenExchangeScopePermission(ctx, \"oidc_idp_permission\", \u0026keycloak.IdentityProviderTokenExchangeScopePermissionArgs{\n\t\t\tRealmId:       tokenExchangeRealm.ID(),\n\t\t\tProviderAlias: tokenExchangeMyOidcIdp.Alias,\n\t\t\tPolicyType:    pulumi.String(\"client\"),\n\t\t\tClients: pulumi.StringArray{\n\t\t\t\ttoken_exchangeWebappClient.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.oidc.IdentityProvider;\nimport com.pulumi.keycloak.oidc.IdentityProviderArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.IdentityProviderTokenExchangeScopePermission;\nimport com.pulumi.keycloak.IdentityProviderTokenExchangeScopePermissionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var tokenExchangeRealm = new Realm(\"tokenExchangeRealm\", RealmArgs.builder()\n            .realm(\"token-exchange_destination_realm\")\n            .enabled(true)\n            .build());\n\n        var tokenExchangeMyOidcIdp = new IdentityProvider(\"tokenExchangeMyOidcIdp\", IdentityProviderArgs.builder()\n            .realm(tokenExchangeRealm.id())\n            .alias(\"myIdp\")\n            .authorizationUrl(\"http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/auth\")\n            .tokenUrl(\"http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/token\")\n            .clientId(\"clientId\")\n            .clientSecret(\"secret\")\n            .defaultScopes(\"openid\")\n            .build());\n\n        var token_exchangeWebappClient = new Client(\"token-exchangeWebappClient\", ClientArgs.builder()\n            .realmId(tokenExchangeRealm.id())\n            .name(\"webapp_client\")\n            .clientId(\"webapp_client\")\n            .clientSecret(\"secret\")\n            .description(\"a webapp client on the destination realm\")\n            .accessType(\"CONFIDENTIAL\")\n            .standardFlowEnabled(true)\n            .validRedirectUris(\"http://localhost:8080/*\")\n            .build());\n\n        //relevant part\n        var oidcIdpPermission = new IdentityProviderTokenExchangeScopePermission(\"oidcIdpPermission\", IdentityProviderTokenExchangeScopePermissionArgs.builder()\n            .realmId(tokenExchangeRealm.id())\n            .providerAlias(tokenExchangeMyOidcIdp.alias())\n            .policyType(\"client\")\n            .clients(token_exchangeWebappClient.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  tokenExchangeRealm:\n    type: keycloak:Realm\n    name: token_exchange_realm\n    properties:\n      realm: token-exchange_destination_realm\n      enabled: true\n  tokenExchangeMyOidcIdp:\n    type: keycloak:oidc:IdentityProvider\n    name: token_exchange_my_oidc_idp\n    properties:\n      realm: ${tokenExchangeRealm.id}\n      alias: myIdp\n      authorizationUrl: http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/auth\n      tokenUrl: http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/token\n      clientId: clientId\n      clientSecret: secret\n      defaultScopes: openid\n  token-exchangeWebappClient:\n    type: keycloak:openid:Client\n    name: token-exchange_webapp_client\n    properties:\n      realmId: ${tokenExchangeRealm.id}\n      name: webapp_client\n      clientId: webapp_client\n      clientSecret: secret\n      description: a webapp client on the destination realm\n      accessType: CONFIDENTIAL\n      standardFlowEnabled: true\n      validRedirectUris:\n        - http://localhost:8080/*\n  # relevant part\n  oidcIdpPermission:\n    type: keycloak:IdentityProviderTokenExchangeScopePermission\n    name: oidc_idp_permission\n    properties:\n      realmId: ${tokenExchangeRealm.id}\n      providerAlias: ${tokenExchangeMyOidcIdp.alias}\n      policyType: client\n      clients:\n        - ${[\"token-exchangeWebappClient\"].id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nThis resource can be imported using the format `{{realm_id}}/{{provider_alias}}`, where `provider_alias` is the alias that\n\nyou assign to the identity provider upon creation.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:index/identityProviderTokenExchangeScopePermission:IdentityProviderTokenExchangeScopePermission oidc_idp_permission my-realm/myIdp\n```\n\n",
            "properties": {
                "authorizationIdpResourceId": {
                    "type": "string",
                    "description": "(Computed) Resource ID representing the identity provider, this automatically created by keycloak.\n"
                },
                "authorizationResourceServerId": {
                    "type": "string",
                    "description": "(Computed) Resource server ID representing the realm management client on which this permission is managed.\n"
                },
                "authorizationTokenExchangeScopePermissionId": {
                    "type": "string",
                    "description": "(Computed) Permission ID representing the Permission with scope 'Token Exchange' and the resource 'authorization_idp_resource_id', this automatically created by keycloak, the policy ID will be set on this permission.\n"
                },
                "clients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IDs of the clients for which a policy will be created and set on scope based token exchange permission.\n"
                },
                "policyId": {
                    "type": "string",
                    "description": "(Computed) Policy ID that will be set on the scope based token exchange permission automatically created by enabling permissions on the reference identity provider.\n"
                },
                "policyType": {
                    "type": "string",
                    "description": "Defaults to \"client\" This is also the only value policy type supported by this provider.\n"
                },
                "providerAlias": {
                    "type": "string",
                    "description": "Alias of the identity provider.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that the identity provider exists in.\n"
                }
            },
            "required": [
                "authorizationIdpResourceId",
                "authorizationResourceServerId",
                "authorizationTokenExchangeScopePermissionId",
                "clients",
                "policyId",
                "providerAlias",
                "realmId"
            ],
            "inputProperties": {
                "clients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IDs of the clients for which a policy will be created and set on scope based token exchange permission.\n"
                },
                "policyType": {
                    "type": "string",
                    "description": "Defaults to \"client\" This is also the only value policy type supported by this provider.\n"
                },
                "providerAlias": {
                    "type": "string",
                    "description": "Alias of the identity provider.\n",
                    "willReplaceOnChanges": true
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that the identity provider exists in.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clients",
                "providerAlias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IdentityProviderTokenExchangeScopePermission resources.\n",
                "properties": {
                    "authorizationIdpResourceId": {
                        "type": "string",
                        "description": "(Computed) Resource ID representing the identity provider, this automatically created by keycloak.\n"
                    },
                    "authorizationResourceServerId": {
                        "type": "string",
                        "description": "(Computed) Resource server ID representing the realm management client on which this permission is managed.\n"
                    },
                    "authorizationTokenExchangeScopePermissionId": {
                        "type": "string",
                        "description": "(Computed) Permission ID representing the Permission with scope 'Token Exchange' and the resource 'authorization_idp_resource_id', this automatically created by keycloak, the policy ID will be set on this permission.\n"
                    },
                    "clients": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of IDs of the clients for which a policy will be created and set on scope based token exchange permission.\n"
                    },
                    "policyId": {
                        "type": "string",
                        "description": "(Computed) Policy ID that will be set on the scope based token exchange permission automatically created by enabling permissions on the reference identity provider.\n"
                    },
                    "policyType": {
                        "type": "string",
                        "description": "Defaults to \"client\" This is also the only value policy type supported by this provider.\n"
                    },
                    "providerAlias": {
                        "type": "string",
                        "description": "Alias of the identity provider.\n",
                        "willReplaceOnChanges": true
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that the identity provider exists in.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realm:Realm": {
            "properties": {
                "accessCodeLifespan": {
                    "type": "string"
                },
                "accessCodeLifespanLogin": {
                    "type": "string"
                },
                "accessCodeLifespanUserAction": {
                    "type": "string"
                },
                "accessTokenLifespan": {
                    "type": "string"
                },
                "accessTokenLifespanForImplicitFlow": {
                    "type": "string"
                },
                "accountTheme": {
                    "type": "string"
                },
                "actionTokenGeneratedByAdminLifespan": {
                    "type": "string"
                },
                "actionTokenGeneratedByUserLifespan": {
                    "type": "string"
                },
                "adminTheme": {
                    "type": "string"
                },
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "browserFlow": {
                    "type": "string",
                    "description": "Which flow should be used for BrowserFlow\n"
                },
                "clientAuthenticationFlow": {
                    "type": "string",
                    "description": "Which flow should be used for ClientAuthenticationFlow\n"
                },
                "clientSessionIdleTimeout": {
                    "type": "string"
                },
                "clientSessionMaxLifespan": {
                    "type": "string"
                },
                "defaultDefaultClientScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "defaultOptionalClientScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "defaultSignatureAlgorithm": {
                    "type": "string"
                },
                "directGrantFlow": {
                    "type": "string",
                    "description": "Which flow should be used for DirectGrantFlow\n"
                },
                "displayName": {
                    "type": "string"
                },
                "displayNameHtml": {
                    "type": "string"
                },
                "dockerAuthenticationFlow": {
                    "type": "string",
                    "description": "Which flow should be used for DockerAuthenticationFlow\n"
                },
                "duplicateEmailsAllowed": {
                    "type": "boolean"
                },
                "editUsernameAllowed": {
                    "type": "boolean"
                },
                "emailTheme": {
                    "type": "string"
                },
                "enabled": {
                    "type": "boolean"
                },
                "internalId": {
                    "type": "string"
                },
                "internationalization": {
                    "$ref": "#/types/keycloak:index/RealmInternationalization:RealmInternationalization"
                },
                "loginTheme": {
                    "type": "string"
                },
                "loginWithEmailAllowed": {
                    "type": "boolean"
                },
                "oauth2DeviceCodeLifespan": {
                    "type": "string"
                },
                "oauth2DevicePollingInterval": {
                    "type": "integer"
                },
                "offlineSessionIdleTimeout": {
                    "type": "string"
                },
                "offlineSessionMaxLifespan": {
                    "type": "string"
                },
                "offlineSessionMaxLifespanEnabled": {
                    "type": "boolean"
                },
                "otpPolicy": {
                    "$ref": "#/types/keycloak:index/RealmOtpPolicy:RealmOtpPolicy"
                },
                "passwordPolicy": {
                    "type": "string",
                    "description": "String that represents the passwordPolicies that are in place. Each policy is separated with \" and \". Supported policies\ncan be found in the server-info providers page. example: \"upperCase(1) and length(8) and forceExpiredPasswordChange(365)\nand notUsername(undefined)\"\n"
                },
                "realm": {
                    "type": "string",
                    "language": {
                        "csharp": {
                            "name": "RealmName"
                        }
                    }
                },
                "refreshTokenMaxReuse": {
                    "type": "integer"
                },
                "registrationAllowed": {
                    "type": "boolean"
                },
                "registrationEmailAsUsername": {
                    "type": "boolean"
                },
                "registrationFlow": {
                    "type": "string",
                    "description": "Which flow should be used for RegistrationFlow\n"
                },
                "rememberMe": {
                    "type": "boolean"
                },
                "resetCredentialsFlow": {
                    "type": "string",
                    "description": "Which flow should be used for ResetCredentialsFlow\n"
                },
                "resetPasswordAllowed": {
                    "type": "boolean"
                },
                "revokeRefreshToken": {
                    "type": "boolean"
                },
                "securityDefenses": {
                    "$ref": "#/types/keycloak:index/RealmSecurityDefenses:RealmSecurityDefenses"
                },
                "smtpServer": {
                    "$ref": "#/types/keycloak:index/RealmSmtpServer:RealmSmtpServer"
                },
                "sslRequired": {
                    "type": "string",
                    "description": "SSL Required: Values can be 'none', 'external' or 'all'.\n"
                },
                "ssoSessionIdleTimeout": {
                    "type": "string"
                },
                "ssoSessionIdleTimeoutRememberMe": {
                    "type": "string"
                },
                "ssoSessionMaxLifespan": {
                    "type": "string"
                },
                "ssoSessionMaxLifespanRememberMe": {
                    "type": "string"
                },
                "userManagedAccess": {
                    "type": "boolean"
                },
                "verifyEmail": {
                    "type": "boolean"
                },
                "webAuthnPasswordlessPolicy": {
                    "$ref": "#/types/keycloak:index/RealmWebAuthnPasswordlessPolicy:RealmWebAuthnPasswordlessPolicy"
                },
                "webAuthnPolicy": {
                    "$ref": "#/types/keycloak:index/RealmWebAuthnPolicy:RealmWebAuthnPolicy"
                }
            },
            "required": [
                "accessCodeLifespan",
                "accessCodeLifespanLogin",
                "accessCodeLifespanUserAction",
                "accessTokenLifespan",
                "accessTokenLifespanForImplicitFlow",
                "actionTokenGeneratedByAdminLifespan",
                "actionTokenGeneratedByUserLifespan",
                "browserFlow",
                "clientAuthenticationFlow",
                "clientSessionIdleTimeout",
                "clientSessionMaxLifespan",
                "directGrantFlow",
                "dockerAuthenticationFlow",
                "duplicateEmailsAllowed",
                "editUsernameAllowed",
                "internalId",
                "loginWithEmailAllowed",
                "oauth2DeviceCodeLifespan",
                "oauth2DevicePollingInterval",
                "offlineSessionIdleTimeout",
                "offlineSessionMaxLifespan",
                "otpPolicy",
                "realm",
                "registrationAllowed",
                "registrationEmailAsUsername",
                "registrationFlow",
                "rememberMe",
                "resetCredentialsFlow",
                "resetPasswordAllowed",
                "ssoSessionIdleTimeout",
                "ssoSessionIdleTimeoutRememberMe",
                "ssoSessionMaxLifespan",
                "ssoSessionMaxLifespanRememberMe",
                "verifyEmail",
                "webAuthnPasswordlessPolicy",
                "webAuthnPolicy"
            ],
            "inputProperties": {
                "accessCodeLifespan": {
                    "type": "string"
                },
                "accessCodeLifespanLogin": {
                    "type": "string"
                },
                "accessCodeLifespanUserAction": {
                    "type": "string"
                },
                "accessTokenLifespan": {
                    "type": "string"
                },
                "accessTokenLifespanForImplicitFlow": {
                    "type": "string"
                },
                "accountTheme": {
                    "type": "string"
                },
                "actionTokenGeneratedByAdminLifespan": {
                    "type": "string"
                },
                "actionTokenGeneratedByUserLifespan": {
                    "type": "string"
                },
                "adminTheme": {
                    "type": "string"
                },
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "browserFlow": {
                    "type": "string",
                    "description": "Which flow should be used for BrowserFlow\n"
                },
                "clientAuthenticationFlow": {
                    "type": "string",
                    "description": "Which flow should be used for ClientAuthenticationFlow\n"
                },
                "clientSessionIdleTimeout": {
                    "type": "string"
                },
                "clientSessionMaxLifespan": {
                    "type": "string"
                },
                "defaultDefaultClientScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "defaultOptionalClientScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "defaultSignatureAlgorithm": {
                    "type": "string"
                },
                "directGrantFlow": {
                    "type": "string",
                    "description": "Which flow should be used for DirectGrantFlow\n"
                },
                "displayName": {
                    "type": "string"
                },
                "displayNameHtml": {
                    "type": "string"
                },
                "dockerAuthenticationFlow": {
                    "type": "string",
                    "description": "Which flow should be used for DockerAuthenticationFlow\n"
                },
                "duplicateEmailsAllowed": {
                    "type": "boolean"
                },
                "editUsernameAllowed": {
                    "type": "boolean"
                },
                "emailTheme": {
                    "type": "string"
                },
                "enabled": {
                    "type": "boolean"
                },
                "internalId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "internationalization": {
                    "$ref": "#/types/keycloak:index/RealmInternationalization:RealmInternationalization"
                },
                "loginTheme": {
                    "type": "string"
                },
                "loginWithEmailAllowed": {
                    "type": "boolean"
                },
                "oauth2DeviceCodeLifespan": {
                    "type": "string"
                },
                "oauth2DevicePollingInterval": {
                    "type": "integer"
                },
                "offlineSessionIdleTimeout": {
                    "type": "string"
                },
                "offlineSessionMaxLifespan": {
                    "type": "string"
                },
                "offlineSessionMaxLifespanEnabled": {
                    "type": "boolean"
                },
                "otpPolicy": {
                    "$ref": "#/types/keycloak:index/RealmOtpPolicy:RealmOtpPolicy"
                },
                "passwordPolicy": {
                    "type": "string",
                    "description": "String that represents the passwordPolicies that are in place. Each policy is separated with \" and \". Supported policies\ncan be found in the server-info providers page. example: \"upperCase(1) and length(8) and forceExpiredPasswordChange(365)\nand notUsername(undefined)\"\n"
                },
                "realm": {
                    "type": "string",
                    "language": {
                        "csharp": {
                            "name": "RealmName"
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "refreshTokenMaxReuse": {
                    "type": "integer"
                },
                "registrationAllowed": {
                    "type": "boolean"
                },
                "registrationEmailAsUsername": {
                    "type": "boolean"
                },
                "registrationFlow": {
                    "type": "string",
                    "description": "Which flow should be used for RegistrationFlow\n"
                },
                "rememberMe": {
                    "type": "boolean"
                },
                "resetCredentialsFlow": {
                    "type": "string",
                    "description": "Which flow should be used for ResetCredentialsFlow\n"
                },
                "resetPasswordAllowed": {
                    "type": "boolean"
                },
                "revokeRefreshToken": {
                    "type": "boolean"
                },
                "securityDefenses": {
                    "$ref": "#/types/keycloak:index/RealmSecurityDefenses:RealmSecurityDefenses"
                },
                "smtpServer": {
                    "$ref": "#/types/keycloak:index/RealmSmtpServer:RealmSmtpServer"
                },
                "sslRequired": {
                    "type": "string",
                    "description": "SSL Required: Values can be 'none', 'external' or 'all'.\n"
                },
                "ssoSessionIdleTimeout": {
                    "type": "string"
                },
                "ssoSessionIdleTimeoutRememberMe": {
                    "type": "string"
                },
                "ssoSessionMaxLifespan": {
                    "type": "string"
                },
                "ssoSessionMaxLifespanRememberMe": {
                    "type": "string"
                },
                "userManagedAccess": {
                    "type": "boolean"
                },
                "verifyEmail": {
                    "type": "boolean"
                },
                "webAuthnPasswordlessPolicy": {
                    "$ref": "#/types/keycloak:index/RealmWebAuthnPasswordlessPolicy:RealmWebAuthnPasswordlessPolicy"
                },
                "webAuthnPolicy": {
                    "$ref": "#/types/keycloak:index/RealmWebAuthnPolicy:RealmWebAuthnPolicy"
                }
            },
            "requiredInputs": [
                "realm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Realm resources.\n",
                "properties": {
                    "accessCodeLifespan": {
                        "type": "string"
                    },
                    "accessCodeLifespanLogin": {
                        "type": "string"
                    },
                    "accessCodeLifespanUserAction": {
                        "type": "string"
                    },
                    "accessTokenLifespan": {
                        "type": "string"
                    },
                    "accessTokenLifespanForImplicitFlow": {
                        "type": "string"
                    },
                    "accountTheme": {
                        "type": "string"
                    },
                    "actionTokenGeneratedByAdminLifespan": {
                        "type": "string"
                    },
                    "actionTokenGeneratedByUserLifespan": {
                        "type": "string"
                    },
                    "adminTheme": {
                        "type": "string"
                    },
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "browserFlow": {
                        "type": "string",
                        "description": "Which flow should be used for BrowserFlow\n"
                    },
                    "clientAuthenticationFlow": {
                        "type": "string",
                        "description": "Which flow should be used for ClientAuthenticationFlow\n"
                    },
                    "clientSessionIdleTimeout": {
                        "type": "string"
                    },
                    "clientSessionMaxLifespan": {
                        "type": "string"
                    },
                    "defaultDefaultClientScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "defaultOptionalClientScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "defaultSignatureAlgorithm": {
                        "type": "string"
                    },
                    "directGrantFlow": {
                        "type": "string",
                        "description": "Which flow should be used for DirectGrantFlow\n"
                    },
                    "displayName": {
                        "type": "string"
                    },
                    "displayNameHtml": {
                        "type": "string"
                    },
                    "dockerAuthenticationFlow": {
                        "type": "string",
                        "description": "Which flow should be used for DockerAuthenticationFlow\n"
                    },
                    "duplicateEmailsAllowed": {
                        "type": "boolean"
                    },
                    "editUsernameAllowed": {
                        "type": "boolean"
                    },
                    "emailTheme": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "internalId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "internationalization": {
                        "$ref": "#/types/keycloak:index/RealmInternationalization:RealmInternationalization"
                    },
                    "loginTheme": {
                        "type": "string"
                    },
                    "loginWithEmailAllowed": {
                        "type": "boolean"
                    },
                    "oauth2DeviceCodeLifespan": {
                        "type": "string"
                    },
                    "oauth2DevicePollingInterval": {
                        "type": "integer"
                    },
                    "offlineSessionIdleTimeout": {
                        "type": "string"
                    },
                    "offlineSessionMaxLifespan": {
                        "type": "string"
                    },
                    "offlineSessionMaxLifespanEnabled": {
                        "type": "boolean"
                    },
                    "otpPolicy": {
                        "$ref": "#/types/keycloak:index/RealmOtpPolicy:RealmOtpPolicy"
                    },
                    "passwordPolicy": {
                        "type": "string",
                        "description": "String that represents the passwordPolicies that are in place. Each policy is separated with \" and \". Supported policies\ncan be found in the server-info providers page. example: \"upperCase(1) and length(8) and forceExpiredPasswordChange(365)\nand notUsername(undefined)\"\n"
                    },
                    "realm": {
                        "type": "string",
                        "language": {
                            "csharp": {
                                "name": "RealmName"
                            }
                        },
                        "willReplaceOnChanges": true
                    },
                    "refreshTokenMaxReuse": {
                        "type": "integer"
                    },
                    "registrationAllowed": {
                        "type": "boolean"
                    },
                    "registrationEmailAsUsername": {
                        "type": "boolean"
                    },
                    "registrationFlow": {
                        "type": "string",
                        "description": "Which flow should be used for RegistrationFlow\n"
                    },
                    "rememberMe": {
                        "type": "boolean"
                    },
                    "resetCredentialsFlow": {
                        "type": "string",
                        "description": "Which flow should be used for ResetCredentialsFlow\n"
                    },
                    "resetPasswordAllowed": {
                        "type": "boolean"
                    },
                    "revokeRefreshToken": {
                        "type": "boolean"
                    },
                    "securityDefenses": {
                        "$ref": "#/types/keycloak:index/RealmSecurityDefenses:RealmSecurityDefenses"
                    },
                    "smtpServer": {
                        "$ref": "#/types/keycloak:index/RealmSmtpServer:RealmSmtpServer"
                    },
                    "sslRequired": {
                        "type": "string",
                        "description": "SSL Required: Values can be 'none', 'external' or 'all'.\n"
                    },
                    "ssoSessionIdleTimeout": {
                        "type": "string"
                    },
                    "ssoSessionIdleTimeoutRememberMe": {
                        "type": "string"
                    },
                    "ssoSessionMaxLifespan": {
                        "type": "string"
                    },
                    "ssoSessionMaxLifespanRememberMe": {
                        "type": "string"
                    },
                    "userManagedAccess": {
                        "type": "boolean"
                    },
                    "verifyEmail": {
                        "type": "boolean"
                    },
                    "webAuthnPasswordlessPolicy": {
                        "$ref": "#/types/keycloak:index/RealmWebAuthnPasswordlessPolicy:RealmWebAuthnPasswordlessPolicy"
                    },
                    "webAuthnPolicy": {
                        "$ref": "#/types/keycloak:index/RealmWebAuthnPolicy:RealmWebAuthnPolicy"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realmEvents:RealmEvents": {
            "description": "## # keycloak.RealmEvents\n\nAllows for managing Realm Events settings within Keycloak.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {realm: \"test\"});\nconst realmEvents = new keycloak.RealmEvents(\"realm_events\", {\n    realmId: realm.id,\n    eventsEnabled: true,\n    eventsExpiration: 3600,\n    adminEventsEnabled: true,\n    adminEventsDetailsEnabled: true,\n    enabledEventTypes: [\n        \"LOGIN\",\n        \"LOGOUT\",\n    ],\n    eventsListeners: [\"jboss-logging\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\", realm=\"test\")\nrealm_events = keycloak.RealmEvents(\"realm_events\",\n    realm_id=realm.id,\n    events_enabled=True,\n    events_expiration=3600,\n    admin_events_enabled=True,\n    admin_events_details_enabled=True,\n    enabled_event_types=[\n        \"LOGIN\",\n        \"LOGOUT\",\n    ],\n    events_listeners=[\"jboss-logging\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"test\",\n    });\n\n    var realmEvents = new Keycloak.RealmEvents(\"realm_events\", new()\n    {\n        RealmId = realm.Id,\n        EventsEnabled = true,\n        EventsExpiration = 3600,\n        AdminEventsEnabled = true,\n        AdminEventsDetailsEnabled = true,\n        EnabledEventTypes = new[]\n        {\n            \"LOGIN\",\n            \"LOGOUT\",\n        },\n        EventsListeners = new[]\n        {\n            \"jboss-logging\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm: pulumi.String(\"test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRealmEvents(ctx, \"realm_events\", \u0026keycloak.RealmEventsArgs{\n\t\t\tRealmId:                   realm.ID(),\n\t\t\tEventsEnabled:             pulumi.Bool(true),\n\t\t\tEventsExpiration:          pulumi.Int(3600),\n\t\t\tAdminEventsEnabled:        pulumi.Bool(true),\n\t\t\tAdminEventsDetailsEnabled: pulumi.Bool(true),\n\t\t\tEnabledEventTypes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"LOGIN\"),\n\t\t\t\tpulumi.String(\"LOGOUT\"),\n\t\t\t},\n\t\t\tEventsListeners: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"jboss-logging\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.RealmEvents;\nimport com.pulumi.keycloak.RealmEventsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"test\")\n            .build());\n\n        var realmEvents = new RealmEvents(\"realmEvents\", RealmEventsArgs.builder()\n            .realmId(realm.id())\n            .eventsEnabled(true)\n            .eventsExpiration(3600)\n            .adminEventsEnabled(true)\n            .adminEventsDetailsEnabled(true)\n            .enabledEventTypes(            \n                \"LOGIN\",\n                \"LOGOUT\")\n            .eventsListeners(\"jboss-logging\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: test\n  realmEvents:\n    type: keycloak:RealmEvents\n    name: realm_events\n    properties:\n      realmId: ${realm.id}\n      eventsEnabled: true\n      eventsExpiration: 3600\n      adminEventsEnabled: true\n      adminEventsDetailsEnabled: true # When omitted or left empty, keycloak will enable all event types\n      enabledEventTypes:\n        - LOGIN\n        - LOGOUT\n      eventsListeners:\n        - jboss-logging\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The name of the realm the event settings apply to.\n- `admin_events_enabled` - (Optional) When true, admin events are saved to the database, making them available through the admin console. Defaults to `false`.\n- `admin_events_details_enabled` - (Optional) When true, saved admin events will included detailed information for create/update requests. Defaults to `false`.\n- `events_enabled` - (Optional) When true, events from `enabled_event_types` are saved to the database, making them available through the admin console. Defaults to `false`.\n- `events_expiration` - (Optional) The amount of time in seconds events will be saved in the database. Defaults to `0` or never.\n- `enabled_event_types` - (Optional) The event types that will be saved to the database. Omitting this field enables all event types. Defaults to `[]` or all event types.\n- `events_listeners` - (Optional) The event listeners that events should be sent to. Defaults to `[]` or none. Note that new realms enable the `jboss-logging` listener by default, and this resource will remove that unless it is specified.\n",
            "properties": {
                "adminEventsDetailsEnabled": {
                    "type": "boolean"
                },
                "adminEventsEnabled": {
                    "type": "boolean"
                },
                "enabledEventTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "eventsEnabled": {
                    "type": "boolean"
                },
                "eventsExpiration": {
                    "type": "integer"
                },
                "eventsListeners": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "realmId"
            ],
            "inputProperties": {
                "adminEventsDetailsEnabled": {
                    "type": "boolean"
                },
                "adminEventsEnabled": {
                    "type": "boolean"
                },
                "enabledEventTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "eventsEnabled": {
                    "type": "boolean"
                },
                "eventsExpiration": {
                    "type": "integer"
                },
                "eventsListeners": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RealmEvents resources.\n",
                "properties": {
                    "adminEventsDetailsEnabled": {
                        "type": "boolean"
                    },
                    "adminEventsEnabled": {
                        "type": "boolean"
                    },
                    "enabledEventTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "eventsEnabled": {
                        "type": "boolean"
                    },
                    "eventsExpiration": {
                        "type": "integer"
                    },
                    "eventsListeners": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realmKeystoreAesGenerated:RealmKeystoreAesGenerated": {
            "description": "Allows for creating and managing `aes-generated` Realm keystores within Keycloak.\n\nA realm keystore manages generated key pairs that are used by Keycloak to perform cryptographic signatures and encryption.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {realm: \"my-realm\"});\nconst keystoreAesGenerated = new keycloak.RealmKeystoreAesGenerated(\"keystore_aes_generated\", {\n    name: \"my-aes-generated-key\",\n    realmId: realm.id,\n    enabled: true,\n    active: true,\n    priority: 100,\n    secretSize: 16,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\", realm=\"my-realm\")\nkeystore_aes_generated = keycloak.RealmKeystoreAesGenerated(\"keystore_aes_generated\",\n    name=\"my-aes-generated-key\",\n    realm_id=realm.id,\n    enabled=True,\n    active=True,\n    priority=100,\n    secret_size=16)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n    });\n\n    var keystoreAesGenerated = new Keycloak.RealmKeystoreAesGenerated(\"keystore_aes_generated\", new()\n    {\n        Name = \"my-aes-generated-key\",\n        RealmId = realm.Id,\n        Enabled = true,\n        Active = true,\n        Priority = 100,\n        SecretSize = 16,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm: pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRealmKeystoreAesGenerated(ctx, \"keystore_aes_generated\", \u0026keycloak.RealmKeystoreAesGeneratedArgs{\n\t\t\tName:       pulumi.String(\"my-aes-generated-key\"),\n\t\t\tRealmId:    realm.ID(),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tActive:     pulumi.Bool(true),\n\t\t\tPriority:   pulumi.Int(100),\n\t\t\tSecretSize: pulumi.Int(16),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.RealmKeystoreAesGenerated;\nimport com.pulumi.keycloak.RealmKeystoreAesGeneratedArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .build());\n\n        var keystoreAesGenerated = new RealmKeystoreAesGenerated(\"keystoreAesGenerated\", RealmKeystoreAesGeneratedArgs.builder()\n            .name(\"my-aes-generated-key\")\n            .realmId(realm.id())\n            .enabled(true)\n            .active(true)\n            .priority(100)\n            .secretSize(16)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n  keystoreAesGenerated:\n    type: keycloak:RealmKeystoreAesGenerated\n    name: keystore_aes_generated\n    properties:\n      name: my-aes-generated-key\n      realmId: ${realm.id}\n      enabled: true\n      active: true\n      priority: 100\n      secretSize: 16\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nRealm keys can be imported using realm name and keystore id, you can find it in web UI.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:index/realmKeystoreAesGenerated:RealmKeystoreAesGenerated keystore_aes_generated my-realm/618cfba7-49aa-4c09-9a19-2f699b576f0b\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n"
                },
                "secretSize": {
                    "type": "integer",
                    "description": "Size in bytes for the generated AES Key. Size 16 is for AES-128, Size 24 for AES-192 and Size 32 for AES-256. WARN: Bigger keys then 128 bits are not allowed on some JDK implementations. Defaults to `16`.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n",
                    "willReplaceOnChanges": true
                },
                "secretSize": {
                    "type": "integer",
                    "description": "Size in bytes for the generated AES Key. Size 16 is for AES-128, Size 24 for AES-192 and Size 32 for AES-256. WARN: Bigger keys then 128 bits are not allowed on some JDK implementations. Defaults to `16`.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RealmKeystoreAesGenerated resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of provider when linked in admin console.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority for the provider. Defaults to `0`\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this keystore exists in.\n",
                        "willReplaceOnChanges": true
                    },
                    "secretSize": {
                        "type": "integer",
                        "description": "Size in bytes for the generated AES Key. Size 16 is for AES-128, Size 24 for AES-192 and Size 32 for AES-256. WARN: Bigger keys then 128 bits are not allowed on some JDK implementations. Defaults to `16`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realmKeystoreEcdsaGenerated:RealmKeystoreEcdsaGenerated": {
            "description": "Allows for creating and managing `acdsa_generated` Realm keystores within Keycloak.\n\nA realm keystore manages generated key pairs that are used by Keycloak to perform cryptographic signatures and encryption.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {realm: \"my-realm\"});\nconst keystoreEcdsaGenerated = new keycloak.RealmKeystoreEcdsaGenerated(\"keystore_ecdsa_generated\", {\n    name: \"my-ecdsa-generated-key\",\n    realmId: realm.id,\n    enabled: true,\n    active: true,\n    priority: 100,\n    ellipticCurveKey: \"P-256\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\", realm=\"my-realm\")\nkeystore_ecdsa_generated = keycloak.RealmKeystoreEcdsaGenerated(\"keystore_ecdsa_generated\",\n    name=\"my-ecdsa-generated-key\",\n    realm_id=realm.id,\n    enabled=True,\n    active=True,\n    priority=100,\n    elliptic_curve_key=\"P-256\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n    });\n\n    var keystoreEcdsaGenerated = new Keycloak.RealmKeystoreEcdsaGenerated(\"keystore_ecdsa_generated\", new()\n    {\n        Name = \"my-ecdsa-generated-key\",\n        RealmId = realm.Id,\n        Enabled = true,\n        Active = true,\n        Priority = 100,\n        EllipticCurveKey = \"P-256\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm: pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRealmKeystoreEcdsaGenerated(ctx, \"keystore_ecdsa_generated\", \u0026keycloak.RealmKeystoreEcdsaGeneratedArgs{\n\t\t\tName:             pulumi.String(\"my-ecdsa-generated-key\"),\n\t\t\tRealmId:          realm.ID(),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t\tActive:           pulumi.Bool(true),\n\t\t\tPriority:         pulumi.Int(100),\n\t\t\tEllipticCurveKey: pulumi.String(\"P-256\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.RealmKeystoreEcdsaGenerated;\nimport com.pulumi.keycloak.RealmKeystoreEcdsaGeneratedArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .build());\n\n        var keystoreEcdsaGenerated = new RealmKeystoreEcdsaGenerated(\"keystoreEcdsaGenerated\", RealmKeystoreEcdsaGeneratedArgs.builder()\n            .name(\"my-ecdsa-generated-key\")\n            .realmId(realm.id())\n            .enabled(true)\n            .active(true)\n            .priority(100)\n            .ellipticCurveKey(\"P-256\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n  keystoreEcdsaGenerated:\n    type: keycloak:RealmKeystoreEcdsaGenerated\n    name: keystore_ecdsa_generated\n    properties:\n      name: my-ecdsa-generated-key\n      realmId: ${realm.id}\n      enabled: true\n      active: true\n      priority: 100\n      ellipticCurveKey: P-256\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nRealm keys can be imported using realm name and keystore id, you can find it in web UI.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:index/realmKeystoreEcdsaGenerated:RealmKeystoreEcdsaGenerated keystore_ecdsa_generated my-realm/618cfba7-49aa-4c09-9a19-2f699b576f0b\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "ellipticCurveKey": {
                    "type": "string",
                    "description": "Elliptic Curve used in ECDSA. Defaults to `P-256`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "ellipticCurveKey": {
                    "type": "string",
                    "description": "Elliptic Curve used in ECDSA. Defaults to `P-256`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RealmKeystoreEcdsaGenerated resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                    },
                    "ellipticCurveKey": {
                        "type": "string",
                        "description": "Elliptic Curve used in ECDSA. Defaults to `P-256`.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of provider when linked in admin console.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority for the provider. Defaults to `0`\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this keystore exists in.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realmKeystoreHmacGenerated:RealmKeystoreHmacGenerated": {
            "description": "Allows for creating and managing `hmac-generated` Realm keystores within Keycloak.\n\nA realm keystore manages generated key pairs that are used by Keycloak to perform cryptographic signatures and encryption.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {realm: \"my-realm\"});\nconst keystoreHmacGenerated = new keycloak.RealmKeystoreHmacGenerated(\"keystore_hmac_generated\", {\n    name: \"my-hmac-generated-key\",\n    realmId: realm.id,\n    enabled: true,\n    active: true,\n    priority: 100,\n    algorithm: \"HS256\",\n    secretSize: 64,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\", realm=\"my-realm\")\nkeystore_hmac_generated = keycloak.RealmKeystoreHmacGenerated(\"keystore_hmac_generated\",\n    name=\"my-hmac-generated-key\",\n    realm_id=realm.id,\n    enabled=True,\n    active=True,\n    priority=100,\n    algorithm=\"HS256\",\n    secret_size=64)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n    });\n\n    var keystoreHmacGenerated = new Keycloak.RealmKeystoreHmacGenerated(\"keystore_hmac_generated\", new()\n    {\n        Name = \"my-hmac-generated-key\",\n        RealmId = realm.Id,\n        Enabled = true,\n        Active = true,\n        Priority = 100,\n        Algorithm = \"HS256\",\n        SecretSize = 64,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm: pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRealmKeystoreHmacGenerated(ctx, \"keystore_hmac_generated\", \u0026keycloak.RealmKeystoreHmacGeneratedArgs{\n\t\t\tName:       pulumi.String(\"my-hmac-generated-key\"),\n\t\t\tRealmId:    realm.ID(),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tActive:     pulumi.Bool(true),\n\t\t\tPriority:   pulumi.Int(100),\n\t\t\tAlgorithm:  pulumi.String(\"HS256\"),\n\t\t\tSecretSize: pulumi.Int(64),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.RealmKeystoreHmacGenerated;\nimport com.pulumi.keycloak.RealmKeystoreHmacGeneratedArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .build());\n\n        var keystoreHmacGenerated = new RealmKeystoreHmacGenerated(\"keystoreHmacGenerated\", RealmKeystoreHmacGeneratedArgs.builder()\n            .name(\"my-hmac-generated-key\")\n            .realmId(realm.id())\n            .enabled(true)\n            .active(true)\n            .priority(100)\n            .algorithm(\"HS256\")\n            .secretSize(64)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n  keystoreHmacGenerated:\n    type: keycloak:RealmKeystoreHmacGenerated\n    name: keystore_hmac_generated\n    properties:\n      name: my-hmac-generated-key\n      realmId: ${realm.id}\n      enabled: true\n      active: true\n      priority: 100\n      algorithm: HS256\n      secretSize: 64\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nRealm keys can be imported using realm name and keystore id, you can find it in web UI.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:index/realmKeystoreHmacGenerated:RealmKeystoreHmacGenerated keystore_hmac_generated my-realm/618cfba7-49aa-4c09-9a19-2f699b576f0b\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "algorithm": {
                    "type": "string",
                    "description": "Intended algorithm for the key. Defaults to `HS256`\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n"
                },
                "secretSize": {
                    "type": "integer",
                    "description": "Size in bytes for the generated secret. Defaults to `64`.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "algorithm": {
                    "type": "string",
                    "description": "Intended algorithm for the key. Defaults to `HS256`\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n",
                    "willReplaceOnChanges": true
                },
                "secretSize": {
                    "type": "integer",
                    "description": "Size in bytes for the generated secret. Defaults to `64`.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RealmKeystoreHmacGenerated resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                    },
                    "algorithm": {
                        "type": "string",
                        "description": "Intended algorithm for the key. Defaults to `HS256`\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of provider when linked in admin console.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority for the provider. Defaults to `0`\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this keystore exists in.\n",
                        "willReplaceOnChanges": true
                    },
                    "secretSize": {
                        "type": "integer",
                        "description": "Size in bytes for the generated secret. Defaults to `64`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realmKeystoreJavaGenerated:RealmKeystoreJavaGenerated": {
            "description": "Allows for creating and managing `java-keystore` Realm keystores within Keycloak.\n\nA realm keystore manages generated key pairs that are used by Keycloak to perform cryptographic signatures and encryption.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {realm: \"my-realm\"});\nconst javaKeystore = new keycloak.RealmKeystoreJavaGenerated(\"java_keystore\", {\n    name: \"my-java-keystore\",\n    realmId: realm.id,\n    enabled: true,\n    active: true,\n    keystore: \"\u003cpath to your keystore\u003e\",\n    keystorePassword: \"\u003cpassword for keystore\u003e\",\n    keyAlias: \"\u003calias for the private key\u003e\",\n    keyPassword: \"\u003cpassword for the private key\u003e\",\n    priority: 100,\n    algorithm: \"RS256\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\", realm=\"my-realm\")\njava_keystore = keycloak.RealmKeystoreJavaGenerated(\"java_keystore\",\n    name=\"my-java-keystore\",\n    realm_id=realm.id,\n    enabled=True,\n    active=True,\n    keystore=\"\u003cpath to your keystore\u003e\",\n    keystore_password=\"\u003cpassword for keystore\u003e\",\n    key_alias=\"\u003calias for the private key\u003e\",\n    key_password=\"\u003cpassword for the private key\u003e\",\n    priority=100,\n    algorithm=\"RS256\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n    });\n\n    var javaKeystore = new Keycloak.RealmKeystoreJavaGenerated(\"java_keystore\", new()\n    {\n        Name = \"my-java-keystore\",\n        RealmId = realm.Id,\n        Enabled = true,\n        Active = true,\n        Keystore = \"\u003cpath to your keystore\u003e\",\n        KeystorePassword = \"\u003cpassword for keystore\u003e\",\n        KeyAlias = \"\u003calias for the private key\u003e\",\n        KeyPassword = \"\u003cpassword for the private key\u003e\",\n        Priority = 100,\n        Algorithm = \"RS256\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm: pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRealmKeystoreJavaGenerated(ctx, \"java_keystore\", \u0026keycloak.RealmKeystoreJavaGeneratedArgs{\n\t\t\tName:             pulumi.String(\"my-java-keystore\"),\n\t\t\tRealmId:          realm.ID(),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t\tActive:           pulumi.Bool(true),\n\t\t\tKeystore:         pulumi.String(\"\u003cpath to your keystore\u003e\"),\n\t\t\tKeystorePassword: pulumi.String(\"\u003cpassword for keystore\u003e\"),\n\t\t\tKeyAlias:         pulumi.String(\"\u003calias for the private key\u003e\"),\n\t\t\tKeyPassword:      pulumi.String(\"\u003cpassword for the private key\u003e\"),\n\t\t\tPriority:         pulumi.Int(100),\n\t\t\tAlgorithm:        pulumi.String(\"RS256\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.RealmKeystoreJavaGenerated;\nimport com.pulumi.keycloak.RealmKeystoreJavaGeneratedArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .build());\n\n        var javaKeystore = new RealmKeystoreJavaGenerated(\"javaKeystore\", RealmKeystoreJavaGeneratedArgs.builder()\n            .name(\"my-java-keystore\")\n            .realmId(realm.id())\n            .enabled(true)\n            .active(true)\n            .keystore(\"\u003cpath to your keystore\u003e\")\n            .keystorePassword(\"\u003cpassword for keystore\u003e\")\n            .keyAlias(\"\u003calias for the private key\u003e\")\n            .keyPassword(\"\u003cpassword for the private key\u003e\")\n            .priority(100)\n            .algorithm(\"RS256\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n  javaKeystore:\n    type: keycloak:RealmKeystoreJavaGenerated\n    name: java_keystore\n    properties:\n      name: my-java-keystore\n      realmId: ${realm.id}\n      enabled: true\n      active: true\n      keystore: \u003cpath to your keystore\u003e\n      keystorePassword: \u003cpassword for keystore\u003e\n      keyAlias: \u003calias for the private key\u003e\n      keyPassword: \u003cpassword for the private key\u003e\n      priority: 100\n      algorithm: RS256\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nRealm keys can be imported using realm name and keystore id, you can find it in web UI.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:index/realmKeystoreJavaGenerated:RealmKeystoreJavaGenerated java_keystore my-realm/618cfba7-49aa-4c09-9a19-2f699b576f0b\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "algorithm": {
                    "type": "string",
                    "description": "Intended algorithm for the key. Defaults to `RS256`\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "keyAlias": {
                    "type": "string",
                    "description": "Alias for the private key.\n"
                },
                "keyPassword": {
                    "type": "string",
                    "description": "Password for the private key.\n"
                },
                "keystore": {
                    "type": "string",
                    "description": "Path to keys file on keycloak instance.\n"
                },
                "keystorePassword": {
                    "type": "string",
                    "description": "Password for the keys.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n"
                }
            },
            "required": [
                "keyAlias",
                "keyPassword",
                "keystore",
                "keystorePassword",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "algorithm": {
                    "type": "string",
                    "description": "Intended algorithm for the key. Defaults to `RS256`\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "keyAlias": {
                    "type": "string",
                    "description": "Alias for the private key.\n"
                },
                "keyPassword": {
                    "type": "string",
                    "description": "Password for the private key.\n"
                },
                "keystore": {
                    "type": "string",
                    "description": "Path to keys file on keycloak instance.\n"
                },
                "keystorePassword": {
                    "type": "string",
                    "description": "Password for the keys.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "keyAlias",
                "keyPassword",
                "keystore",
                "keystorePassword",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RealmKeystoreJavaGenerated resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                    },
                    "algorithm": {
                        "type": "string",
                        "description": "Intended algorithm for the key. Defaults to `RS256`\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                    },
                    "keyAlias": {
                        "type": "string",
                        "description": "Alias for the private key.\n"
                    },
                    "keyPassword": {
                        "type": "string",
                        "description": "Password for the private key.\n"
                    },
                    "keystore": {
                        "type": "string",
                        "description": "Path to keys file on keycloak instance.\n"
                    },
                    "keystorePassword": {
                        "type": "string",
                        "description": "Password for the keys.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of provider when linked in admin console.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority for the provider. Defaults to `0`\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this keystore exists in.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realmKeystoreRsa:RealmKeystoreRsa": {
            "description": "Allows for creating and managing `rsa` Realm keystores within Keycloak.\n\nA realm keystore manages generated key pairs that are used by Keycloak to perform cryptographic signatures and encryption.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n  keystoreRsa:\n    type: keycloak:RealmKeystoreRsa\n    name: keystore_rsa\n    properties:\n      name: my-rsa-key\n      realmId: ${realm.id}\n      enabled: true\n      active: true\n      privateKey: \u003cyour rsa private key\u003e\n      certificate: \u003cyour certificate\u003e\n      priority: 100\n      algorithm: RS256\n      keystoreSize: 2048\n      providerId: rsa\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nRealm keys can be imported using realm name and keystore id, you can find it in web UI.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:index/realmKeystoreRsa:RealmKeystoreRsa keystore_rsa my-realm/618cfba7-49aa-4c09-9a19-2f699b576f0b\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "algorithm": {
                    "type": "string",
                    "description": "Intended algorithm for the key. Defaults to `RS256`. Use `RSA-OAEP` for encryption keys\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "X509 Certificate encoded in PEM format.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "Private RSA Key encoded in PEM format.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "Use `rsa` for signing keys, `rsa-enc` for encryption keys\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n"
                }
            },
            "required": [
                "certificate",
                "name",
                "privateKey",
                "realmId"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "algorithm": {
                    "type": "string",
                    "description": "Intended algorithm for the key. Defaults to `RS256`. Use `RSA-OAEP` for encryption keys\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "X509 Certificate encoded in PEM format.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "Private RSA Key encoded in PEM format.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "Use `rsa` for signing keys, `rsa-enc` for encryption keys\n",
                    "willReplaceOnChanges": true
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "certificate",
                "privateKey",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RealmKeystoreRsa resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                    },
                    "algorithm": {
                        "type": "string",
                        "description": "Intended algorithm for the key. Defaults to `RS256`. Use `RSA-OAEP` for encryption keys\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "X509 Certificate encoded in PEM format.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of provider when linked in admin console.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority for the provider. Defaults to `0`\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "Private RSA Key encoded in PEM format.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "Use `rsa` for signing keys, `rsa-enc` for encryption keys\n",
                        "willReplaceOnChanges": true
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this keystore exists in.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realmKeystoreRsaGenerated:RealmKeystoreRsaGenerated": {
            "description": "Allows for creating and managing `rsa-generated` Realm keystores within Keycloak.\n\nA realm keystore manages generated key pairs that are used by Keycloak to perform cryptographic signatures and encryption.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {realm: \"my-realm\"});\nconst keystoreRsaGenerated = new keycloak.RealmKeystoreRsaGenerated(\"keystore_rsa_generated\", {\n    name: \"my-rsa-generated-key\",\n    realmId: realm.id,\n    enabled: true,\n    active: true,\n    priority: 100,\n    algorithm: \"RS256\",\n    keySize: 2048,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\", realm=\"my-realm\")\nkeystore_rsa_generated = keycloak.RealmKeystoreRsaGenerated(\"keystore_rsa_generated\",\n    name=\"my-rsa-generated-key\",\n    realm_id=realm.id,\n    enabled=True,\n    active=True,\n    priority=100,\n    algorithm=\"RS256\",\n    key_size=2048)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n    });\n\n    var keystoreRsaGenerated = new Keycloak.RealmKeystoreRsaGenerated(\"keystore_rsa_generated\", new()\n    {\n        Name = \"my-rsa-generated-key\",\n        RealmId = realm.Id,\n        Enabled = true,\n        Active = true,\n        Priority = 100,\n        Algorithm = \"RS256\",\n        KeySize = 2048,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm: pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRealmKeystoreRsaGenerated(ctx, \"keystore_rsa_generated\", \u0026keycloak.RealmKeystoreRsaGeneratedArgs{\n\t\t\tName:      pulumi.String(\"my-rsa-generated-key\"),\n\t\t\tRealmId:   realm.ID(),\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tActive:    pulumi.Bool(true),\n\t\t\tPriority:  pulumi.Int(100),\n\t\t\tAlgorithm: pulumi.String(\"RS256\"),\n\t\t\tKeySize:   pulumi.Int(2048),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.RealmKeystoreRsaGenerated;\nimport com.pulumi.keycloak.RealmKeystoreRsaGeneratedArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .build());\n\n        var keystoreRsaGenerated = new RealmKeystoreRsaGenerated(\"keystoreRsaGenerated\", RealmKeystoreRsaGeneratedArgs.builder()\n            .name(\"my-rsa-generated-key\")\n            .realmId(realm.id())\n            .enabled(true)\n            .active(true)\n            .priority(100)\n            .algorithm(\"RS256\")\n            .keySize(2048)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n  keystoreRsaGenerated:\n    type: keycloak:RealmKeystoreRsaGenerated\n    name: keystore_rsa_generated\n    properties:\n      name: my-rsa-generated-key\n      realmId: ${realm.id}\n      enabled: true\n      active: true\n      priority: 100\n      algorithm: RS256\n      keySize: 2048\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nRealm keys can be imported using realm name and keystore id, you can find it in web UI.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:index/realmKeystoreRsaGenerated:RealmKeystoreRsaGenerated keystore_rsa_generated my-realm/618cfba7-49aa-4c09-9a19-2f699b576f0b\n```\n\n",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "algorithm": {
                    "type": "string",
                    "description": "Intended algorithm for the key. Defaults to `RS256`\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "keySize": {
                    "type": "integer",
                    "description": "Size for the generated keys. Defaults to `2048`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "algorithm": {
                    "type": "string",
                    "description": "Intended algorithm for the key. Defaults to `RS256`\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "keySize": {
                    "type": "integer",
                    "description": "Size for the generated keys. Defaults to `2048`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RealmKeystoreRsaGenerated resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                    },
                    "algorithm": {
                        "type": "string",
                        "description": "Intended algorithm for the key. Defaults to `RS256`\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                    },
                    "keySize": {
                        "type": "integer",
                        "description": "Size for the generated keys. Defaults to `2048`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of provider when linked in admin console.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority for the provider. Defaults to `0`\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this keystore exists in.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realmUserProfile:RealmUserProfile": {
            "description": "Allows for managing Realm User Profiles within Keycloak.\n\nA user profile defines a schema for representing user attributes and how they are managed within a realm.\nThis is a preview feature, hence not fully supported and disabled by default.\nTo enable it, start the server with one of the following flags:\n- WildFly distribution: `-Dkeycloak.profile.feature.declarative_user_profile=enabled`\n- Quarkus distribution: `--features=preview` or `--features=declarative-user-profile`\n\nThe realm linked to the `keycloak.RealmUserProfile` resource must have the user profile feature enabled.\nIt can be done via the administration UI, or by setting the `userProfileEnabled` realm attribute to `true`.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    attributes: {\n        userProfileEnabled: true,\n    },\n});\nconst userprofile = new keycloak.RealmUserProfile(\"userprofile\", {\n    realmId: myRealm.id,\n    attributes: [\n        {\n            name: \"field1\",\n            displayName: \"Field 1\",\n            group: \"group1\",\n            enabledWhenScopes: [\"offline_access\"],\n            requiredForRoles: [\"user\"],\n            requiredForScopes: [\"offline_access\"],\n            permissions: {\n                views: [\n                    \"admin\",\n                    \"user\",\n                ],\n                edits: [\n                    \"admin\",\n                    \"user\",\n                ],\n            },\n            validators: [\n                {\n                    name: \"person-name-prohibited-characters\",\n                },\n                {\n                    name: \"pattern\",\n                    config: {\n                        pattern: \"^[a-z]+$\",\n                        \"error-message\": \"Nope\",\n                    },\n                },\n            ],\n            annotations: {\n                foo: \"bar\",\n            },\n        },\n        {\n            name: \"field2\",\n            validators: [{\n                name: \"options\",\n                config: {\n                    options: JSON.stringify([\"opt1\"]),\n                },\n            }],\n            annotations: {\n                foo: JSON.stringify({\n                    key: \"val\",\n                }),\n            },\n        },\n    ],\n    groups: [\n        {\n            name: \"group1\",\n            displayHeader: \"Group 1\",\n            displayDescription: \"A first group\",\n            annotations: {\n                foo: \"bar\",\n                foo2: JSON.stringify({\n                    key: \"val\",\n                }),\n            },\n        },\n        {\n            name: \"group2\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    attributes={\n        \"userProfileEnabled\": True,\n    })\nuserprofile = keycloak.RealmUserProfile(\"userprofile\",\n    realm_id=my_realm[\"id\"],\n    attributes=[\n        keycloak.RealmUserProfileAttributeArgs(\n            name=\"field1\",\n            display_name=\"Field 1\",\n            group=\"group1\",\n            enabled_when_scopes=[\"offline_access\"],\n            required_for_roles=[\"user\"],\n            required_for_scopes=[\"offline_access\"],\n            permissions=keycloak.RealmUserProfileAttributePermissionsArgs(\n                views=[\n                    \"admin\",\n                    \"user\",\n                ],\n                edits=[\n                    \"admin\",\n                    \"user\",\n                ],\n            ),\n            validators=[\n                keycloak.RealmUserProfileAttributeValidatorArgs(\n                    name=\"person-name-prohibited-characters\",\n                ),\n                keycloak.RealmUserProfileAttributeValidatorArgs(\n                    name=\"pattern\",\n                    config={\n                        \"pattern\": \"^[a-z]+$\",\n                        \"error-message\": \"Nope\",\n                    },\n                ),\n            ],\n            annotations={\n                \"foo\": \"bar\",\n            },\n        ),\n        keycloak.RealmUserProfileAttributeArgs(\n            name=\"field2\",\n            validators=[keycloak.RealmUserProfileAttributeValidatorArgs(\n                name=\"options\",\n                config={\n                    \"options\": json.dumps([\"opt1\"]),\n                },\n            )],\n            annotations={\n                \"foo\": json.dumps({\n                    \"key\": \"val\",\n                }),\n            },\n        ),\n    ],\n    groups=[\n        keycloak.RealmUserProfileGroupArgs(\n            name=\"group1\",\n            display_header=\"Group 1\",\n            display_description=\"A first group\",\n            annotations={\n                \"foo\": \"bar\",\n                \"foo2\": json.dumps({\n                    \"key\": \"val\",\n                }),\n            },\n        ),\n        keycloak.RealmUserProfileGroupArgs(\n            name=\"group2\",\n        ),\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Attributes = \n        {\n            { \"userProfileEnabled\", true },\n        },\n    });\n\n    var userprofile = new Keycloak.RealmUserProfile(\"userprofile\", new()\n    {\n        RealmId = myRealm.Id,\n        Attributes = new[]\n        {\n            new Keycloak.Inputs.RealmUserProfileAttributeArgs\n            {\n                Name = \"field1\",\n                DisplayName = \"Field 1\",\n                Group = \"group1\",\n                EnabledWhenScopes = new[]\n                {\n                    \"offline_access\",\n                },\n                RequiredForRoles = new[]\n                {\n                    \"user\",\n                },\n                RequiredForScopes = new[]\n                {\n                    \"offline_access\",\n                },\n                Permissions = new Keycloak.Inputs.RealmUserProfileAttributePermissionsArgs\n                {\n                    Views = new[]\n                    {\n                        \"admin\",\n                        \"user\",\n                    },\n                    Edits = new[]\n                    {\n                        \"admin\",\n                        \"user\",\n                    },\n                },\n                Validators = new[]\n                {\n                    new Keycloak.Inputs.RealmUserProfileAttributeValidatorArgs\n                    {\n                        Name = \"person-name-prohibited-characters\",\n                    },\n                    new Keycloak.Inputs.RealmUserProfileAttributeValidatorArgs\n                    {\n                        Name = \"pattern\",\n                        Config = \n                        {\n                            { \"pattern\", \"^[a-z]+$\" },\n                            { \"error-message\", \"Nope\" },\n                        },\n                    },\n                },\n                Annotations = \n                {\n                    { \"foo\", \"bar\" },\n                },\n            },\n            new Keycloak.Inputs.RealmUserProfileAttributeArgs\n            {\n                Name = \"field2\",\n                Validators = new[]\n                {\n                    new Keycloak.Inputs.RealmUserProfileAttributeValidatorArgs\n                    {\n                        Name = \"options\",\n                        Config = \n                        {\n                            { \"options\", JsonSerializer.Serialize(new[]\n                            {\n                                \"opt1\",\n                            }) },\n                        },\n                    },\n                },\n                Annotations = \n                {\n                    { \"foo\", JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n                    {\n                        [\"key\"] = \"val\",\n                    }) },\n                },\n            },\n        },\n        Groups = new[]\n        {\n            new Keycloak.Inputs.RealmUserProfileGroupArgs\n            {\n                Name = \"group1\",\n                DisplayHeader = \"Group 1\",\n                DisplayDescription = \"A first group\",\n                Annotations = \n                {\n                    { \"foo\", \"bar\" },\n                    { \"foo2\", JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n                    {\n                        [\"key\"] = \"val\",\n                    }) },\n                },\n            },\n            new Keycloak.Inputs.RealmUserProfileGroupArgs\n            {\n                Name = \"group2\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm: pulumi.String(\"my-realm\"),\n\t\t\tAttributes: pulumi.Map{\n\t\t\t\t\"userProfileEnabled\": pulumi.Any(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON0, err := json.Marshal([]string{\n\t\t\t\"opt1\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\ttmpJSON1, err := json.Marshal(map[string]interface{}{\n\t\t\t\"key\": \"val\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson1 := string(tmpJSON1)\n\t\ttmpJSON2, err := json.Marshal(map[string]interface{}{\n\t\t\t\"key\": \"val\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson2 := string(tmpJSON2)\n\t\t_, err = keycloak.NewRealmUserProfile(ctx, \"userprofile\", \u0026keycloak.RealmUserProfileArgs{\n\t\t\tRealmId: pulumi.Any(myRealm.Id),\n\t\t\tAttributes: keycloak.RealmUserProfileAttributeArray{\n\t\t\t\t\u0026keycloak.RealmUserProfileAttributeArgs{\n\t\t\t\t\tName:        pulumi.String(\"field1\"),\n\t\t\t\t\tDisplayName: pulumi.String(\"Field 1\"),\n\t\t\t\t\tGroup:       pulumi.String(\"group1\"),\n\t\t\t\t\tEnabledWhenScopes: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"offline_access\"),\n\t\t\t\t\t},\n\t\t\t\t\tRequiredForRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"user\"),\n\t\t\t\t\t},\n\t\t\t\t\tRequiredForScopes: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"offline_access\"),\n\t\t\t\t\t},\n\t\t\t\t\tPermissions: \u0026keycloak.RealmUserProfileAttributePermissionsArgs{\n\t\t\t\t\t\tViews: pulumi.StringArray{\n\t\t\t\t\t\t\tpulumi.String(\"admin\"),\n\t\t\t\t\t\t\tpulumi.String(\"user\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tEdits: pulumi.StringArray{\n\t\t\t\t\t\t\tpulumi.String(\"admin\"),\n\t\t\t\t\t\t\tpulumi.String(\"user\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tValidators: keycloak.RealmUserProfileAttributeValidatorArray{\n\t\t\t\t\t\t\u0026keycloak.RealmUserProfileAttributeValidatorArgs{\n\t\t\t\t\t\t\tName: pulumi.String(\"person-name-prohibited-characters\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\u0026keycloak.RealmUserProfileAttributeValidatorArgs{\n\t\t\t\t\t\t\tName: pulumi.String(\"pattern\"),\n\t\t\t\t\t\t\tConfig: pulumi.StringMap{\n\t\t\t\t\t\t\t\t\"pattern\":       pulumi.String(\"^[a-z]+$\"),\n\t\t\t\t\t\t\t\t\"error-message\": pulumi.String(\"Nope\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tAnnotations: pulumi.StringMap{\n\t\t\t\t\t\t\"foo\": pulumi.String(\"bar\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026keycloak.RealmUserProfileAttributeArgs{\n\t\t\t\t\tName: pulumi.String(\"field2\"),\n\t\t\t\t\tValidators: keycloak.RealmUserProfileAttributeValidatorArray{\n\t\t\t\t\t\t\u0026keycloak.RealmUserProfileAttributeValidatorArgs{\n\t\t\t\t\t\t\tName: pulumi.String(\"options\"),\n\t\t\t\t\t\t\tConfig: pulumi.StringMap{\n\t\t\t\t\t\t\t\t\"options\": pulumi.String(json0),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tAnnotations: pulumi.StringMap{\n\t\t\t\t\t\t\"foo\": pulumi.String(json1),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tGroups: keycloak.RealmUserProfileGroupArray{\n\t\t\t\t\u0026keycloak.RealmUserProfileGroupArgs{\n\t\t\t\t\tName:               pulumi.String(\"group1\"),\n\t\t\t\t\tDisplayHeader:      pulumi.String(\"Group 1\"),\n\t\t\t\t\tDisplayDescription: pulumi.String(\"A first group\"),\n\t\t\t\t\tAnnotations: pulumi.StringMap{\n\t\t\t\t\t\t\"foo\":  pulumi.String(\"bar\"),\n\t\t\t\t\t\t\"foo2\": pulumi.String(json2),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026keycloak.RealmUserProfileGroupArgs{\n\t\t\t\t\tName: pulumi.String(\"group2\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.RealmUserProfile;\nimport com.pulumi.keycloak.RealmUserProfileArgs;\nimport com.pulumi.keycloak.inputs.RealmUserProfileAttributeArgs;\nimport com.pulumi.keycloak.inputs.RealmUserProfileAttributePermissionsArgs;\nimport com.pulumi.keycloak.inputs.RealmUserProfileGroupArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .attributes(Map.of(\"userProfileEnabled\", true))\n            .build());\n\n        var userprofile = new RealmUserProfile(\"userprofile\", RealmUserProfileArgs.builder()\n            .realmId(myRealm.id())\n            .attributes(            \n                RealmUserProfileAttributeArgs.builder()\n                    .name(\"field1\")\n                    .displayName(\"Field 1\")\n                    .group(\"group1\")\n                    .enabledWhenScopes(\"offline_access\")\n                    .requiredForRoles(\"user\")\n                    .requiredForScopes(\"offline_access\")\n                    .permissions(RealmUserProfileAttributePermissionsArgs.builder()\n                        .views(                        \n                            \"admin\",\n                            \"user\")\n                        .edits(                        \n                            \"admin\",\n                            \"user\")\n                        .build())\n                    .validators(                    \n                        RealmUserProfileAttributeValidatorArgs.builder()\n                            .name(\"person-name-prohibited-characters\")\n                            .build(),\n                        RealmUserProfileAttributeValidatorArgs.builder()\n                            .name(\"pattern\")\n                            .config(Map.ofEntries(\n                                Map.entry(\"pattern\", \"^[a-z]+$\"),\n                                Map.entry(\"error-message\", \"Nope\")\n                            ))\n                            .build())\n                    .annotations(Map.of(\"foo\", \"bar\"))\n                    .build(),\n                RealmUserProfileAttributeArgs.builder()\n                    .name(\"field2\")\n                    .validators(RealmUserProfileAttributeValidatorArgs.builder()\n                        .name(\"options\")\n                        .config(Map.of(\"options\", serializeJson(\n                            jsonArray(\"opt1\"))))\n                        .build())\n                    .annotations(Map.of(\"foo\", serializeJson(\n                        jsonObject(\n                            jsonProperty(\"key\", \"val\")\n                        ))))\n                    .build())\n            .groups(            \n                RealmUserProfileGroupArgs.builder()\n                    .name(\"group1\")\n                    .displayHeader(\"Group 1\")\n                    .displayDescription(\"A first group\")\n                    .annotations(Map.ofEntries(\n                        Map.entry(\"foo\", \"bar\"),\n                        Map.entry(\"foo2\", serializeJson(\n                            jsonObject(\n                                jsonProperty(\"key\", \"val\")\n                            )))\n                    ))\n                    .build(),\n                RealmUserProfileGroupArgs.builder()\n                    .name(\"group2\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      attributes:\n        userProfileEnabled: true\n  userprofile:\n    type: keycloak:RealmUserProfile\n    properties:\n      realmId: ${myRealm.id}\n      attributes:\n        - name: field1\n          displayName: Field 1\n          group: group1\n          enabledWhenScopes:\n            - offline_access\n          requiredForRoles:\n            - user\n          requiredForScopes:\n            - offline_access\n          permissions:\n            views:\n              - admin\n              - user\n            edits:\n              - admin\n              - user\n          validators:\n            - name: person-name-prohibited-characters\n            - name: pattern\n              config:\n                pattern: ^[a-z]+$\n                error-message: Nope\n          annotations:\n            foo: bar\n        - name: field2\n          validators:\n            - name: options\n              config:\n                options:\n                  fn::toJSON:\n                    - opt1\n          annotations:\n            foo:\n              fn::toJSON:\n                key: val\n      groups:\n        - name: group1\n          displayHeader: Group 1\n          displayDescription: A first group\n          annotations:\n            foo: bar\n            foo2:\n              fn::toJSON:\n                key: val\n        - name: group2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nThis resource currently does not support importing.\n\n",
            "properties": {
                "attributes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/RealmUserProfileAttribute:RealmUserProfileAttribute"
                    },
                    "description": "An ordered list of attributes.\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/RealmUserProfileGroup:RealmUserProfileGroup"
                    },
                    "description": "A list of groups.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The ID of the realm the user profile applies to.\n"
                }
            },
            "required": [
                "realmId"
            ],
            "inputProperties": {
                "attributes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/RealmUserProfileAttribute:RealmUserProfileAttribute"
                    },
                    "description": "An ordered list of attributes.\n"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/RealmUserProfileGroup:RealmUserProfileGroup"
                    },
                    "description": "A list of groups.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The ID of the realm the user profile applies to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RealmUserProfile resources.\n",
                "properties": {
                    "attributes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/RealmUserProfileAttribute:RealmUserProfileAttribute"
                        },
                        "description": "An ordered list of attributes.\n"
                    },
                    "groups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/RealmUserProfileGroup:RealmUserProfileGroup"
                        },
                        "description": "A list of groups.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The ID of the realm the user profile applies to.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/requiredAction:RequiredAction": {
            "description": "Allows for creating and managing required actions within Keycloak.\n\n[Required actions](https://www.keycloak.org/docs/latest/server_admin/#con-required-actions_server_administration_guide) specify actions required before the first login of all new users.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst requiredAction = new keycloak.RequiredAction(\"required_action\", {\n    realmId: realm.realm,\n    alias: \"webauthn-register\",\n    enabled: true,\n    name: \"Webauthn Register\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrequired_action = keycloak.RequiredAction(\"required_action\",\n    realm_id=realm.realm,\n    alias=\"webauthn-register\",\n    enabled=True,\n    name=\"Webauthn Register\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var requiredAction = new Keycloak.RequiredAction(\"required_action\", new()\n    {\n        RealmId = realm.RealmName,\n        Alias = \"webauthn-register\",\n        Enabled = true,\n        Name = \"Webauthn Register\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRequiredAction(ctx, \"required_action\", \u0026keycloak.RequiredActionArgs{\n\t\t\tRealmId: realm.Realm,\n\t\t\tAlias:   pulumi.String(\"webauthn-register\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t\tName:    pulumi.String(\"Webauthn Register\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.RequiredAction;\nimport com.pulumi.keycloak.RequiredActionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var requiredAction = new RequiredAction(\"requiredAction\", RequiredActionArgs.builder()\n            .realmId(realm.realm())\n            .alias(\"webauthn-register\")\n            .enabled(true)\n            .name(\"Webauthn Register\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  requiredAction:\n    type: keycloak:RequiredAction\n    name: required_action\n    properties:\n      realmId: ${realm.realm}\n      alias: webauthn-register\n      enabled: true\n      name: Webauthn Register\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAuthentication executions can be imported using the formats: `{{realm}}/{{alias}}`.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:index/requiredAction:RequiredAction required_action my-realm/my-default-action-alias\n```\n\n",
            "properties": {
                "alias": {
                    "type": "string",
                    "description": "The alias of the action to attach as a required action.\n"
                },
                "defaultAction": {
                    "type": "boolean",
                    "description": "When `true`, the required action is set as the default action for new users. Defaults to `false`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, the required action is not enabled for new users. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the required action.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the required action.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the required action exists in.\n"
                }
            },
            "required": [
                "alias",
                "name",
                "priority",
                "realmId"
            ],
            "inputProperties": {
                "alias": {
                    "type": "string",
                    "description": "The alias of the action to attach as a required action.\n"
                },
                "defaultAction": {
                    "type": "boolean",
                    "description": "When `true`, the required action is set as the default action for new users. Defaults to `false`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, the required action is not enabled for new users. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the required action.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "The priority of the required action.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the required action exists in.\n"
                }
            },
            "requiredInputs": [
                "alias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RequiredAction resources.\n",
                "properties": {
                    "alias": {
                        "type": "string",
                        "description": "The alias of the action to attach as a required action.\n"
                    },
                    "defaultAction": {
                        "type": "boolean",
                        "description": "When `true`, the required action is set as the default action for new users. Defaults to `false`.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, the required action is not enabled for new users. Defaults to `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the required action.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "The priority of the required action.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm the required action exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/role:Role": {
            "description": "## # keycloak.Role\n\nAllows for creating and managing roles within Keycloak.\n\nRoles allow you define privileges within Keycloak and map them to users\nand groups.\n\n### Example Usage (Realm role)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst realmRole = new keycloak.Role(\"realm_role\", {\n    realmId: realm.id,\n    name: \"my-realm-role\",\n    description: \"My Realm Role\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrealm_role = keycloak.Role(\"realm_role\",\n    realm_id=realm.id,\n    name=\"my-realm-role\",\n    description=\"My Realm Role\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var realmRole = new Keycloak.Role(\"realm_role\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-realm-role\",\n        Description = \"My Realm Role\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"realm_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tName:        pulumi.String(\"my-realm-role\"),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var realmRole = new Role(\"realmRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-realm-role\")\n            .description(\"My Realm Role\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  realmRole:\n    type: keycloak:Role\n    name: realm_role\n    properties:\n      realmId: ${realm.id}\n      name: my-realm-role\n      description: My Realm Role\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Usage (Client role)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    name: \"client\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst clientRole = new keycloak.Role(\"client_role\", {\n    realmId: realm.id,\n    clientId: clientKeycloakClient.id,\n    name: \"my-client-role\",\n    description: \"My Client Role\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    name=\"client\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nclient_role = keycloak.Role(\"client_role\",\n    realm_id=realm.id,\n    client_id=client_keycloak_client[\"id\"],\n    name=\"my-client-role\",\n    description=\"My Client Role\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var client = new Keycloak.OpenId.Client(\"client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"client\",\n        Name = \"client\",\n        Enabled = true,\n        AccessType = \"BEARER-ONLY\",\n    });\n\n    var clientRole = new Keycloak.Role(\"client_role\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = clientKeycloakClient.Id,\n        Name = \"my-client-role\",\n        Description = \"My Client Role\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tName:       pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"client_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    pulumi.Any(clientKeycloakClient.Id),\n\t\t\tName:        pulumi.String(\"my-client-role\"),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var client = new Client(\"client\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"client\")\n            .name(\"client\")\n            .enabled(true)\n            .accessType(\"BEARER-ONLY\")\n            .build());\n\n        var clientRole = new Role(\"clientRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .clientId(clientKeycloakClient.id())\n            .name(\"my-client-role\")\n            .description(\"My Client Role\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  client:\n    type: keycloak:openid:Client\n    properties:\n      realmId: ${realm.id}\n      clientId: client\n      name: client\n      enabled: true\n      accessType: BEARER-ONLY\n  clientRole:\n    type: keycloak:Role\n    name: client_role\n    properties:\n      realmId: ${realm.id}\n      clientId: ${clientKeycloakClient.id}\n      name: my-client-role\n      description: My Client Role\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Usage (Composite role)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\n// realm roles\nconst createRole = new keycloak.Role(\"create_role\", {\n    realmId: realm.id,\n    name: \"create\",\n});\nconst readRole = new keycloak.Role(\"read_role\", {\n    realmId: realm.id,\n    name: \"read\",\n});\nconst updateRole = new keycloak.Role(\"update_role\", {\n    realmId: realm.id,\n    name: \"update\",\n});\nconst deleteRole = new keycloak.Role(\"delete_role\", {\n    realmId: realm.id,\n    name: \"delete\",\n});\n// client role\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    name: \"client\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst clientRole = new keycloak.Role(\"client_role\", {\n    realmId: realm.id,\n    clientId: clientKeycloakClient.id,\n    name: \"my-client-role\",\n    description: \"My Client Role\",\n});\nconst adminRole = new keycloak.Role(\"admin_role\", {\n    realmId: realm.id,\n    name: \"admin\",\n    compositeRoles: [\n        \"{keycloak_role.create_role.id}\",\n        \"{keycloak_role.read_role.id}\",\n        \"{keycloak_role.update_role.id}\",\n        \"{keycloak_role.delete_role.id}\",\n        \"{keycloak_role.client_role.id}\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\n# realm roles\ncreate_role = keycloak.Role(\"create_role\",\n    realm_id=realm.id,\n    name=\"create\")\nread_role = keycloak.Role(\"read_role\",\n    realm_id=realm.id,\n    name=\"read\")\nupdate_role = keycloak.Role(\"update_role\",\n    realm_id=realm.id,\n    name=\"update\")\ndelete_role = keycloak.Role(\"delete_role\",\n    realm_id=realm.id,\n    name=\"delete\")\n# client role\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    name=\"client\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nclient_role = keycloak.Role(\"client_role\",\n    realm_id=realm.id,\n    client_id=client_keycloak_client[\"id\"],\n    name=\"my-client-role\",\n    description=\"My Client Role\")\nadmin_role = keycloak.Role(\"admin_role\",\n    realm_id=realm.id,\n    name=\"admin\",\n    composite_roles=[\n        \"{keycloak_role.create_role.id}\",\n        \"{keycloak_role.read_role.id}\",\n        \"{keycloak_role.update_role.id}\",\n        \"{keycloak_role.delete_role.id}\",\n        \"{keycloak_role.client_role.id}\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    // realm roles\n    var createRole = new Keycloak.Role(\"create_role\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"create\",\n    });\n\n    var readRole = new Keycloak.Role(\"read_role\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"read\",\n    });\n\n    var updateRole = new Keycloak.Role(\"update_role\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"update\",\n    });\n\n    var deleteRole = new Keycloak.Role(\"delete_role\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"delete\",\n    });\n\n    // client role\n    var client = new Keycloak.OpenId.Client(\"client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"client\",\n        Name = \"client\",\n        Enabled = true,\n        AccessType = \"BEARER-ONLY\",\n    });\n\n    var clientRole = new Keycloak.Role(\"client_role\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = clientKeycloakClient.Id,\n        Name = \"my-client-role\",\n        Description = \"My Client Role\",\n    });\n\n    var adminRole = new Keycloak.Role(\"admin_role\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"admin\",\n        CompositeRoles = new[]\n        {\n            \"{keycloak_role.create_role.id}\",\n            \"{keycloak_role.read_role.id}\",\n            \"{keycloak_role.update_role.id}\",\n            \"{keycloak_role.delete_role.id}\",\n            \"{keycloak_role.client_role.id}\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// realm roles\n\t\t_, err = keycloak.NewRole(ctx, \"create_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"create\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"read_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"read\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"update_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"update\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"delete_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"delete\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// client role\n\t\t_, err = openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tName:       pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"client_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    pulumi.Any(clientKeycloakClient.Id),\n\t\t\tName:        pulumi.String(\"my-client-role\"),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"admin_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"admin\"),\n\t\t\tCompositeRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"{keycloak_role.create_role.id}\"),\n\t\t\t\tpulumi.String(\"{keycloak_role.read_role.id}\"),\n\t\t\t\tpulumi.String(\"{keycloak_role.update_role.id}\"),\n\t\t\t\tpulumi.String(\"{keycloak_role.delete_role.id}\"),\n\t\t\t\tpulumi.String(\"{keycloak_role.client_role.id}\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        // realm roles\n        var createRole = new Role(\"createRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .name(\"create\")\n            .build());\n\n        var readRole = new Role(\"readRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .name(\"read\")\n            .build());\n\n        var updateRole = new Role(\"updateRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .name(\"update\")\n            .build());\n\n        var deleteRole = new Role(\"deleteRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .name(\"delete\")\n            .build());\n\n        // client role\n        var client = new Client(\"client\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"client\")\n            .name(\"client\")\n            .enabled(true)\n            .accessType(\"BEARER-ONLY\")\n            .build());\n\n        var clientRole = new Role(\"clientRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .clientId(clientKeycloakClient.id())\n            .name(\"my-client-role\")\n            .description(\"My Client Role\")\n            .build());\n\n        var adminRole = new Role(\"adminRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .name(\"admin\")\n            .compositeRoles(            \n                \"{keycloak_role.create_role.id}\",\n                \"{keycloak_role.read_role.id}\",\n                \"{keycloak_role.update_role.id}\",\n                \"{keycloak_role.delete_role.id}\",\n                \"{keycloak_role.client_role.id}\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  # realm roles\n  createRole:\n    type: keycloak:Role\n    name: create_role\n    properties:\n      realmId: ${realm.id}\n      name: create\n  readRole:\n    type: keycloak:Role\n    name: read_role\n    properties:\n      realmId: ${realm.id}\n      name: read\n  updateRole:\n    type: keycloak:Role\n    name: update_role\n    properties:\n      realmId: ${realm.id}\n      name: update\n  deleteRole:\n    type: keycloak:Role\n    name: delete_role\n    properties:\n      realmId: ${realm.id}\n      name: delete\n  # client role\n  client:\n    type: keycloak:openid:Client\n    properties:\n      realmId: ${realm.id}\n      clientId: client\n      name: client\n      enabled: true\n      accessType: BEARER-ONLY\n  clientRole:\n    type: keycloak:Role\n    name: client_role\n    properties:\n      realmId: ${realm.id}\n      clientId: ${clientKeycloakClient.id}\n      name: my-client-role\n      description: My Client Role\n  adminRole:\n    type: keycloak:Role\n    name: admin_role\n    properties:\n      realmId: ${realm.id}\n      name: admin\n      compositeRoles:\n        - '{keycloak_role.create_role.id}'\n        - '{keycloak_role.read_role.id}'\n        - '{keycloak_role.update_role.id}'\n        - '{keycloak_role.delete_role.id}'\n        - '{keycloak_role.client_role.id}'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this role exists within.\n- `client_id` - (Optional) When specified, this role will be created as\n  a client role attached to the client with the provided ID\n- `name` - (Required) The name of the role\n- `description` - (Optional) The description of the role\n- `composite_roles` - (Optional) When specified, this role will be a\n  composite role, composed of all roles that have an ID present within\n  this list.\n\n\n### Import\n\nRoles can be imported using the format `{{realm_id}}/{{role_id}}`, where\n`role_id` is the unique ID that Keycloak assigns to the role. The ID is\nnot easy to find in the GUI, but it appears in the URL when editing the\nrole.\n\nExample:\n\n```bash\n$ terraform import keycloak_role.role my-realm/7e8cf32a-8acb-4d34-89c4-04fb1d10ccad\n```\n",
            "properties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "clientId": {
                    "type": "string"
                },
                "compositeRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "clientId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "compositeRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Role resources.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "clientId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "compositeRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "description": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/user:User": {
            "description": "## # keycloak.User\n\nAllows for creating and managing Users within Keycloak.\n\nThis resource was created primarily to enable the acceptance tests for the `keycloak.Group` resource.\nCreating users within Keycloak is not recommended. Instead, users should be federated from external sources\nby configuring user federation providers or identity providers.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst user = new keycloak.User(\"user\", {\n    realmId: realm.id,\n    username: \"bob\",\n    enabled: true,\n    email: \"bob@domain.com\",\n    firstName: \"Bob\",\n    lastName: \"Bobson\",\n});\nconst userWithInitialPassword = new keycloak.User(\"user_with_initial_password\", {\n    realmId: realm.id,\n    username: \"alice\",\n    enabled: true,\n    email: \"alice@domain.com\",\n    firstName: \"Alice\",\n    lastName: \"Aliceberg\",\n    initialPassword: {\n        value: \"some password\",\n        temporary: true,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nuser = keycloak.User(\"user\",\n    realm_id=realm.id,\n    username=\"bob\",\n    enabled=True,\n    email=\"bob@domain.com\",\n    first_name=\"Bob\",\n    last_name=\"Bobson\")\nuser_with_initial_password = keycloak.User(\"user_with_initial_password\",\n    realm_id=realm.id,\n    username=\"alice\",\n    enabled=True,\n    email=\"alice@domain.com\",\n    first_name=\"Alice\",\n    last_name=\"Aliceberg\",\n    initial_password=keycloak.UserInitialPasswordArgs(\n        value=\"some password\",\n        temporary=True,\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var user = new Keycloak.User(\"user\", new()\n    {\n        RealmId = realm.Id,\n        Username = \"bob\",\n        Enabled = true,\n        Email = \"bob@domain.com\",\n        FirstName = \"Bob\",\n        LastName = \"Bobson\",\n    });\n\n    var userWithInitialPassword = new Keycloak.User(\"user_with_initial_password\", new()\n    {\n        RealmId = realm.Id,\n        Username = \"alice\",\n        Enabled = true,\n        Email = \"alice@domain.com\",\n        FirstName = \"Alice\",\n        LastName = \"Aliceberg\",\n        InitialPassword = new Keycloak.Inputs.UserInitialPasswordArgs\n        {\n            Value = \"some password\",\n            Temporary = true,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewUser(ctx, \"user\", \u0026keycloak.UserArgs{\n\t\t\tRealmId:   realm.ID(),\n\t\t\tUsername:  pulumi.String(\"bob\"),\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tEmail:     pulumi.String(\"bob@domain.com\"),\n\t\t\tFirstName: pulumi.String(\"Bob\"),\n\t\t\tLastName:  pulumi.String(\"Bobson\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewUser(ctx, \"user_with_initial_password\", \u0026keycloak.UserArgs{\n\t\t\tRealmId:   realm.ID(),\n\t\t\tUsername:  pulumi.String(\"alice\"),\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tEmail:     pulumi.String(\"alice@domain.com\"),\n\t\t\tFirstName: pulumi.String(\"Alice\"),\n\t\t\tLastName:  pulumi.String(\"Aliceberg\"),\n\t\t\tInitialPassword: \u0026keycloak.UserInitialPasswordArgs{\n\t\t\t\tValue:     pulumi.String(\"some password\"),\n\t\t\t\tTemporary: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.User;\nimport com.pulumi.keycloak.UserArgs;\nimport com.pulumi.keycloak.inputs.UserInitialPasswordArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var user = new User(\"user\", UserArgs.builder()\n            .realmId(realm.id())\n            .username(\"bob\")\n            .enabled(true)\n            .email(\"bob@domain.com\")\n            .firstName(\"Bob\")\n            .lastName(\"Bobson\")\n            .build());\n\n        var userWithInitialPassword = new User(\"userWithInitialPassword\", UserArgs.builder()\n            .realmId(realm.id())\n            .username(\"alice\")\n            .enabled(true)\n            .email(\"alice@domain.com\")\n            .firstName(\"Alice\")\n            .lastName(\"Aliceberg\")\n            .initialPassword(UserInitialPasswordArgs.builder()\n                .value(\"some password\")\n                .temporary(true)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  user:\n    type: keycloak:User\n    properties:\n      realmId: ${realm.id}\n      username: bob\n      enabled: true\n      email: bob@domain.com\n      firstName: Bob\n      lastName: Bobson\n  userWithInitialPassword:\n    type: keycloak:User\n    name: user_with_initial_password\n    properties:\n      realmId: ${realm.id}\n      username: alice\n      enabled: true\n      email: alice@domain.com\n      firstName: Alice\n      lastName: Aliceberg\n      initialPassword:\n        value: some password\n        temporary: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this user belongs to.\n- `username` - (Required) The unique username of this user.\n- `initial_password` (Optional) When given, the user's initial password will be set.\n   This attribute is only respected during initial user creation.\n    - `value` (Required) The initial password.\n    - `temporary` (Optional) If set to `true`, the initial password is set up for renewal on first use. Default to `false`.\n- `enabled` - (Optional) When false, this user cannot log in. Defaults to `true`.\n- `email` - (Optional) The user's email.\n- `first_name` - (Optional) The user's first name.\n- `last_name` - (Optional) The user's last name.\n\n### Import\n\nUsers can be imported using the format `{{realm_id}}/{{user_id}}`, where `user_id` is the unique ID that Keycloak\nassigns to the user upon creation. This value can be found in the GUI when editing the user.\n\nExample:\n\n```bash\n$ terraform import keycloak_user.user my-realm/60c3f971-b1d3-4b3a-9035-d16d7540a5e4\n```\n",
            "properties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "email": {
                    "type": "string"
                },
                "emailVerified": {
                    "type": "boolean"
                },
                "enabled": {
                    "type": "boolean"
                },
                "federatedIdentities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/UserFederatedIdentity:UserFederatedIdentity"
                    }
                },
                "firstName": {
                    "type": "string"
                },
                "initialPassword": {
                    "$ref": "#/types/keycloak:index/UserInitialPassword:UserInitialPassword"
                },
                "lastName": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "requiredActions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "username": {
                    "type": "string"
                }
            },
            "required": [
                "realmId",
                "username"
            ],
            "inputProperties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "email": {
                    "type": "string"
                },
                "emailVerified": {
                    "type": "boolean"
                },
                "enabled": {
                    "type": "boolean"
                },
                "federatedIdentities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/UserFederatedIdentity:UserFederatedIdentity"
                    }
                },
                "firstName": {
                    "type": "string"
                },
                "initialPassword": {
                    "$ref": "#/types/keycloak:index/UserInitialPassword:UserInitialPassword"
                },
                "lastName": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "requiredActions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "username": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "realmId",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering User resources.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "email": {
                        "type": "string"
                    },
                    "emailVerified": {
                        "type": "boolean"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "federatedIdentities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/UserFederatedIdentity:UserFederatedIdentity"
                        }
                    },
                    "firstName": {
                        "type": "string"
                    },
                    "initialPassword": {
                        "$ref": "#/types/keycloak:index/UserInitialPassword:UserInitialPassword"
                    },
                    "lastName": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "requiredActions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "username": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/userGroups:UserGroups": {
            "description": "Allows for managing a Keycloak user's groups.\n\nIf `exhaustive` is true, this resource attempts to be an **authoritative** source over user groups: groups that are manually added to the user will be removed, and groups that are manually removed from the user group will be added upon the next run of `pulumi up`.\nIf `exhaustive` is false, this resource is a partial assignation of groups to a user. As a result, you can get multiple `keycloak.UserGroups` for the same `user_id`.\n\n\n## Example Usage\n\n### Exhaustive Groups)\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst group = new keycloak.Group(\"group\", {\n    realmId: realm.id,\n    name: \"foo\",\n});\nconst user = new keycloak.User(\"user\", {\n    realmId: realm.id,\n    username: \"my-user\",\n});\nconst userGroups = new keycloak.UserGroups(\"user_groups\", {\n    realmId: realm.id,\n    userId: user.id,\n    groupIds: [group.id],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\ngroup = keycloak.Group(\"group\",\n    realm_id=realm.id,\n    name=\"foo\")\nuser = keycloak.User(\"user\",\n    realm_id=realm.id,\n    username=\"my-user\")\nuser_groups = keycloak.UserGroups(\"user_groups\",\n    realm_id=realm.id,\n    user_id=user.id,\n    group_ids=[group.id])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var @group = new Keycloak.Group(\"group\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"foo\",\n    });\n\n    var user = new Keycloak.User(\"user\", new()\n    {\n        RealmId = realm.Id,\n        Username = \"my-user\",\n    });\n\n    var userGroups = new Keycloak.UserGroups(\"user_groups\", new()\n    {\n        RealmId = realm.Id,\n        UserId = user.Id,\n        GroupIds = new[]\n        {\n            @group.Id,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgroup, err := keycloak.NewGroup(ctx, \"group\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuser, err := keycloak.NewUser(ctx, \"user\", \u0026keycloak.UserArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tUsername: pulumi.String(\"my-user\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewUserGroups(ctx, \"user_groups\", \u0026keycloak.UserGroupsArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tUserId:  user.ID(),\n\t\t\tGroupIds: pulumi.StringArray{\n\t\t\t\tgroup.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.Group;\nimport com.pulumi.keycloak.GroupArgs;\nimport com.pulumi.keycloak.User;\nimport com.pulumi.keycloak.UserArgs;\nimport com.pulumi.keycloak.UserGroups;\nimport com.pulumi.keycloak.UserGroupsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var group = new Group(\"group\", GroupArgs.builder()\n            .realmId(realm.id())\n            .name(\"foo\")\n            .build());\n\n        var user = new User(\"user\", UserArgs.builder()\n            .realmId(realm.id())\n            .username(\"my-user\")\n            .build());\n\n        var userGroups = new UserGroups(\"userGroups\", UserGroupsArgs.builder()\n            .realmId(realm.id())\n            .userId(user.id())\n            .groupIds(group.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  group:\n    type: keycloak:Group\n    properties:\n      realmId: ${realm.id}\n      name: foo\n  user:\n    type: keycloak:User\n    properties:\n      realmId: ${realm.id}\n      username: my-user\n  userGroups:\n    type: keycloak:UserGroups\n    name: user_groups\n    properties:\n      realmId: ${realm.id}\n      userId: ${user.id}\n      groupIds:\n        - ${group.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n",
            "properties": {
                "exhaustive": {
                    "type": "boolean",
                    "description": "Indicates if the list of the user's groups is exhaustive. In this case, groups that are manually added to the user will be removed. Defaults to `true`.\n"
                },
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of group IDs that the user is member of.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "The ID of the user this resource should manage groups for.\n"
                }
            },
            "required": [
                "groupIds",
                "realmId",
                "userId"
            ],
            "inputProperties": {
                "exhaustive": {
                    "type": "boolean",
                    "description": "Indicates if the list of the user's groups is exhaustive. In this case, groups that are manually added to the user will be removed. Defaults to `true`.\n"
                },
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of group IDs that the user is member of.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n",
                    "willReplaceOnChanges": true
                },
                "userId": {
                    "type": "string",
                    "description": "The ID of the user this resource should manage groups for.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "groupIds",
                "realmId",
                "userId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserGroups resources.\n",
                "properties": {
                    "exhaustive": {
                        "type": "boolean",
                        "description": "Indicates if the list of the user's groups is exhaustive. In this case, groups that are manually added to the user will be removed. Defaults to `true`.\n"
                    },
                    "groupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of group IDs that the user is member of.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this group exists in.\n",
                        "willReplaceOnChanges": true
                    },
                    "userId": {
                        "type": "string",
                        "description": "The ID of the user this resource should manage groups for.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/userRoles:UserRoles": {
            "description": "Allows you to manage roles assigned to a Keycloak user.\n\nIf `exhaustive` is true, this resource attempts to be an **authoritative** source over user roles: roles that are manually added to the user will be removed, and roles that are manually removed from the\nuser will be added upon the next run of `pulumi up`.\nIf `exhaustive` is false, this resource is a partial assignation of roles to a user. As a result, you can use multiple `keycloak.UserRoles` for the same `user_id`.\n\nNote that when assigning composite roles to a user, you may see a non-empty plan following a `pulumi up` if you assign\na role and a composite that includes that role to the same user.\n\n## Example Usage\n\n### Exhaustive Roles)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst realmRole = new keycloak.Role(\"realm_role\", {\n    realmId: realm.id,\n    name: \"my-realm-role\",\n    description: \"My Realm Role\",\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    name: \"client\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst clientRole = new keycloak.Role(\"client_role\", {\n    realmId: realm.id,\n    clientId: clientKeycloakClient.id,\n    name: \"my-client-role\",\n    description: \"My Client Role\",\n});\nconst user = new keycloak.User(\"user\", {\n    realmId: realm.id,\n    username: \"bob\",\n    enabled: true,\n    email: \"bob@domain.com\",\n    firstName: \"Bob\",\n    lastName: \"Bobson\",\n});\nconst userRoles = new keycloak.UserRoles(\"user_roles\", {\n    realmId: realm.id,\n    userId: user.id,\n    roleIds: [\n        realmRole.id,\n        clientRole.id,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrealm_role = keycloak.Role(\"realm_role\",\n    realm_id=realm.id,\n    name=\"my-realm-role\",\n    description=\"My Realm Role\")\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    name=\"client\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nclient_role = keycloak.Role(\"client_role\",\n    realm_id=realm.id,\n    client_id=client_keycloak_client[\"id\"],\n    name=\"my-client-role\",\n    description=\"My Client Role\")\nuser = keycloak.User(\"user\",\n    realm_id=realm.id,\n    username=\"bob\",\n    enabled=True,\n    email=\"bob@domain.com\",\n    first_name=\"Bob\",\n    last_name=\"Bobson\")\nuser_roles = keycloak.UserRoles(\"user_roles\",\n    realm_id=realm.id,\n    user_id=user.id,\n    role_ids=[\n        realm_role.id,\n        client_role.id,\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var realmRole = new Keycloak.Role(\"realm_role\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-realm-role\",\n        Description = \"My Realm Role\",\n    });\n\n    var client = new Keycloak.OpenId.Client(\"client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"client\",\n        Name = \"client\",\n        Enabled = true,\n        AccessType = \"BEARER-ONLY\",\n    });\n\n    var clientRole = new Keycloak.Role(\"client_role\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = clientKeycloakClient.Id,\n        Name = \"my-client-role\",\n        Description = \"My Client Role\",\n    });\n\n    var user = new Keycloak.User(\"user\", new()\n    {\n        RealmId = realm.Id,\n        Username = \"bob\",\n        Enabled = true,\n        Email = \"bob@domain.com\",\n        FirstName = \"Bob\",\n        LastName = \"Bobson\",\n    });\n\n    var userRoles = new Keycloak.UserRoles(\"user_roles\", new()\n    {\n        RealmId = realm.Id,\n        UserId = user.Id,\n        RoleIds = new[]\n        {\n            realmRole.Id,\n            clientRole.Id,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmRole, err := keycloak.NewRole(ctx, \"realm_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tName:        pulumi.String(\"my-realm-role\"),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tName:       pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientRole, err := keycloak.NewRole(ctx, \"client_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    pulumi.Any(clientKeycloakClient.Id),\n\t\t\tName:        pulumi.String(\"my-client-role\"),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuser, err := keycloak.NewUser(ctx, \"user\", \u0026keycloak.UserArgs{\n\t\t\tRealmId:   realm.ID(),\n\t\t\tUsername:  pulumi.String(\"bob\"),\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tEmail:     pulumi.String(\"bob@domain.com\"),\n\t\t\tFirstName: pulumi.String(\"Bob\"),\n\t\t\tLastName:  pulumi.String(\"Bobson\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewUserRoles(ctx, \"user_roles\", \u0026keycloak.UserRolesArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tUserId:  user.ID(),\n\t\t\tRoleIds: pulumi.StringArray{\n\t\t\t\trealmRole.ID(),\n\t\t\t\tclientRole.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.User;\nimport com.pulumi.keycloak.UserArgs;\nimport com.pulumi.keycloak.UserRoles;\nimport com.pulumi.keycloak.UserRolesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var realmRole = new Role(\"realmRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-realm-role\")\n            .description(\"My Realm Role\")\n            .build());\n\n        var client = new Client(\"client\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"client\")\n            .name(\"client\")\n            .enabled(true)\n            .accessType(\"BEARER-ONLY\")\n            .build());\n\n        var clientRole = new Role(\"clientRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .clientId(clientKeycloakClient.id())\n            .name(\"my-client-role\")\n            .description(\"My Client Role\")\n            .build());\n\n        var user = new User(\"user\", UserArgs.builder()\n            .realmId(realm.id())\n            .username(\"bob\")\n            .enabled(true)\n            .email(\"bob@domain.com\")\n            .firstName(\"Bob\")\n            .lastName(\"Bobson\")\n            .build());\n\n        var userRoles = new UserRoles(\"userRoles\", UserRolesArgs.builder()\n            .realmId(realm.id())\n            .userId(user.id())\n            .roleIds(            \n                realmRole.id(),\n                clientRole.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  realmRole:\n    type: keycloak:Role\n    name: realm_role\n    properties:\n      realmId: ${realm.id}\n      name: my-realm-role\n      description: My Realm Role\n  client:\n    type: keycloak:openid:Client\n    properties:\n      realmId: ${realm.id}\n      clientId: client\n      name: client\n      enabled: true\n      accessType: BEARER-ONLY\n  clientRole:\n    type: keycloak:Role\n    name: client_role\n    properties:\n      realmId: ${realm.id}\n      clientId: ${clientKeycloakClient.id}\n      name: my-client-role\n      description: My Client Role\n  user:\n    type: keycloak:User\n    properties:\n      realmId: ${realm.id}\n      username: bob\n      enabled: true\n      email: bob@domain.com\n      firstName: Bob\n      lastName: Bobson\n  userRoles:\n    type: keycloak:UserRoles\n    name: user_roles\n    properties:\n      realmId: ${realm.id}\n      userId: ${user.id}\n      roleIds:\n        - ${realmRole.id}\n        - ${clientRole.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nThis resource can be imported using the format `{{realm_id}}/{{user_id}}`, where `user_id` is the unique ID that Keycloak\n\nassigns to the user upon creation. This value can be found in the GUI when editing the user, and is typically a GUID.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:index/userRoles:UserRoles user_roles my-realm/b0ae6924-1bd5-4655-9e38-dae7c5e42924\n```\n\n",
            "properties": {
                "exhaustive": {
                    "type": "boolean",
                    "description": "Indicates if the list of roles is exhaustive. In this case, roles that are manually added to the user will be removed. Defaults to `true`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this user exists in.\n"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of role IDs to map to the user\n"
                },
                "userId": {
                    "type": "string",
                    "description": "The ID of the user this resource should manage roles for.\n"
                }
            },
            "required": [
                "realmId",
                "roleIds",
                "userId"
            ],
            "inputProperties": {
                "exhaustive": {
                    "type": "boolean",
                    "description": "Indicates if the list of roles is exhaustive. In this case, roles that are manually added to the user will be removed. Defaults to `true`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this user exists in.\n",
                    "willReplaceOnChanges": true
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of role IDs to map to the user\n"
                },
                "userId": {
                    "type": "string",
                    "description": "The ID of the user this resource should manage roles for.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "realmId",
                "roleIds",
                "userId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserRoles resources.\n",
                "properties": {
                    "exhaustive": {
                        "type": "boolean",
                        "description": "Indicates if the list of roles is exhaustive. In this case, roles that are manually added to the user will be removed. Defaults to `true`.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this user exists in.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of role IDs to map to the user\n"
                    },
                    "userId": {
                        "type": "string",
                        "description": "The ID of the user this resource should manage roles for.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/userTemplateImporterIdentityProviderMapper:UserTemplateImporterIdentityProviderMapper": {
            "description": "Allows for creating and managing an username template importer identity provider mapper within Keycloak.\n\nThe username template importer mapper can be used to map externally defined OIDC claims or SAML attributes with a template to the username of the imported Keycloak user:\n\n- Substitutions are enclosed in \\${}. For example: '\\${ALIAS}.\\${CLAIM.sub}'. ALIAS is the provider alias. CLAIM.\\\u003cNAME\\\u003e references an ID or Access token claim.\n\n\u003e If you are using Keycloak 10 or higher, you will need to specify the `extra_config` argument in order to define a `syncMode` for the mapper.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst oidc = new keycloak.oidc.IdentityProvider(\"oidc\", {\n    realm: realm.id,\n    alias: \"oidc\",\n    authorizationUrl: \"https://example.com/auth\",\n    tokenUrl: \"https://example.com/token\",\n    clientId: \"example_id\",\n    clientSecret: \"example_token\",\n    defaultScopes: \"openid random profile\",\n});\nconst usernameImporter = new keycloak.UserTemplateImporterIdentityProviderMapper(\"username_importer\", {\n    realm: realm.id,\n    name: \"username-template-importer\",\n    identityProviderAlias: oidc.alias,\n    template: \"${ALIAS}.${CLAIM.email}\",\n    extraConfig: {\n        syncMode: \"INHERIT\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\noidc = keycloak.oidc.IdentityProvider(\"oidc\",\n    realm=realm.id,\n    alias=\"oidc\",\n    authorization_url=\"https://example.com/auth\",\n    token_url=\"https://example.com/token\",\n    client_id=\"example_id\",\n    client_secret=\"example_token\",\n    default_scopes=\"openid random profile\")\nusername_importer = keycloak.UserTemplateImporterIdentityProviderMapper(\"username_importer\",\n    realm=realm.id,\n    name=\"username-template-importer\",\n    identity_provider_alias=oidc.alias,\n    template=\"${ALIAS}.${CLAIM.email}\",\n    extra_config={\n        \"syncMode\": \"INHERIT\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var oidc = new Keycloak.Oidc.IdentityProvider(\"oidc\", new()\n    {\n        Realm = realm.Id,\n        Alias = \"oidc\",\n        AuthorizationUrl = \"https://example.com/auth\",\n        TokenUrl = \"https://example.com/token\",\n        ClientId = \"example_id\",\n        ClientSecret = \"example_token\",\n        DefaultScopes = \"openid random profile\",\n    });\n\n    var usernameImporter = new Keycloak.UserTemplateImporterIdentityProviderMapper(\"username_importer\", new()\n    {\n        Realm = realm.Id,\n        Name = \"username-template-importer\",\n        IdentityProviderAlias = oidc.Alias,\n        Template = \"${ALIAS}.${CLAIM.email}\",\n        ExtraConfig = \n        {\n            { \"syncMode\", \"INHERIT\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/oidc\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\toidc, err := oidc.NewIdentityProvider(ctx, \"oidc\", \u0026oidc.IdentityProviderArgs{\n\t\t\tRealm:            realm.ID(),\n\t\t\tAlias:            pulumi.String(\"oidc\"),\n\t\t\tAuthorizationUrl: pulumi.String(\"https://example.com/auth\"),\n\t\t\tTokenUrl:         pulumi.String(\"https://example.com/token\"),\n\t\t\tClientId:         pulumi.String(\"example_id\"),\n\t\t\tClientSecret:     pulumi.String(\"example_token\"),\n\t\t\tDefaultScopes:    pulumi.String(\"openid random profile\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewUserTemplateImporterIdentityProviderMapper(ctx, \"username_importer\", \u0026keycloak.UserTemplateImporterIdentityProviderMapperArgs{\n\t\t\tRealm:                 realm.ID(),\n\t\t\tName:                  pulumi.String(\"username-template-importer\"),\n\t\t\tIdentityProviderAlias: oidc.Alias,\n\t\t\tTemplate:              pulumi.String(\"${ALIAS}.${CLAIM.email}\"),\n\t\t\tExtraConfig: pulumi.Map{\n\t\t\t\t\"syncMode\": pulumi.Any(\"INHERIT\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.oidc.IdentityProvider;\nimport com.pulumi.keycloak.oidc.IdentityProviderArgs;\nimport com.pulumi.keycloak.UserTemplateImporterIdentityProviderMapper;\nimport com.pulumi.keycloak.UserTemplateImporterIdentityProviderMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var oidc = new IdentityProvider(\"oidc\", IdentityProviderArgs.builder()\n            .realm(realm.id())\n            .alias(\"oidc\")\n            .authorizationUrl(\"https://example.com/auth\")\n            .tokenUrl(\"https://example.com/token\")\n            .clientId(\"example_id\")\n            .clientSecret(\"example_token\")\n            .defaultScopes(\"openid random profile\")\n            .build());\n\n        var usernameImporter = new UserTemplateImporterIdentityProviderMapper(\"usernameImporter\", UserTemplateImporterIdentityProviderMapperArgs.builder()\n            .realm(realm.id())\n            .name(\"username-template-importer\")\n            .identityProviderAlias(oidc.alias())\n            .template(\"${ALIAS}.${CLAIM.email}\")\n            .extraConfig(Map.of(\"syncMode\", \"INHERIT\"))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  oidc:\n    type: keycloak:oidc:IdentityProvider\n    properties:\n      realm: ${realm.id}\n      alias: oidc\n      authorizationUrl: https://example.com/auth\n      tokenUrl: https://example.com/token\n      clientId: example_id\n      clientSecret: example_token\n      defaultScopes: openid random profile\n  usernameImporter:\n    type: keycloak:UserTemplateImporterIdentityProviderMapper\n    name: username_importer\n    properties:\n      realm: ${realm.id}\n      name: username-template-importer\n      identityProviderAlias: ${oidc.alias}\n      template: ${ALIAS}.${CLAIM.email}\n      extraConfig:\n        syncMode: INHERIT\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nIdentity provider mappers can be imported using the format `{{realm_id}}/{{idp_alias}}/{{idp_mapper_id}}`, where `idp_alias` is the identity provider alias, and `idp_mapper_id` is the unique ID that Keycloak\n\nassigns to the mapper upon creation. This value can be found in the URI when editing this mapper in the GUI, and is typically a GUID.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:index/userTemplateImporterIdentityProviderMapper:UserTemplateImporterIdentityProviderMapper username_importer my-realm/my-mapper/f446db98-7133-4e30-b18a-3d28fde7ca1b\n```\n\n",
            "properties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "The alias of the associated identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the mapper.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm.\n"
                },
                "template": {
                    "type": "string",
                    "description": "Template to use to format the username to import. Substitutions are enclosed in \\${}. For example: '\\$\\${ALIAS}.\\$\\${CLAIM.sub}'. ALIAS is the provider alias. CLAIM.\\\u003cNAME\\\u003e references an ID or Access token claim.\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm"
            ],
            "inputProperties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "The alias of the associated identity provider.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the mapper.\n",
                    "willReplaceOnChanges": true
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm.\n",
                    "willReplaceOnChanges": true
                },
                "template": {
                    "type": "string",
                    "description": "Template to use to format the username to import. Substitutions are enclosed in \\${}. For example: '\\$\\${ALIAS}.\\$\\${CLAIM.sub}'. ALIAS is the provider alias. CLAIM.\\\u003cNAME\\\u003e references an ID or Access token claim.\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserTemplateImporterIdentityProviderMapper resources.\n",
                "properties": {
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "The alias of the associated identity provider.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the mapper.\n",
                        "willReplaceOnChanges": true
                    },
                    "realm": {
                        "type": "string",
                        "description": "The name of the realm.\n",
                        "willReplaceOnChanges": true
                    },
                    "template": {
                        "type": "string",
                        "description": "Template to use to format the username to import. Substitutions are enclosed in \\${}. For example: '\\$\\${ALIAS}.\\$\\${CLAIM.sub}'. ALIAS is the provider alias. CLAIM.\\\u003cNAME\\\u003e references an ID or Access token claim.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/usersPermissions:UsersPermissions": {
            "description": "Allows you to manage fine-grained permissions for all users in a realm: https://www.keycloak.org/docs/latest/server_admin/#_users-permissions\n\nThis is part of a preview Keycloak feature: `admin_fine_grained_authz` (see https://www.keycloak.org/docs/latest/server_admin/#_fine_grain_permissions).\nThis feature can be enabled with the Keycloak option `-Dkeycloak.profile.feature.admin_fine_grained_authz=enabled`. See the\nexample `docker-compose.yml` file for an example.\n\nWhen enabling fine-grained permissions for users, Keycloak does several things automatically:\n1. Enable Authorization on built-in `realm-management` client (if not already enabled).\n1. Create a resource representing the users permissions.\n1. Create scopes `view`, `manage`, `map-roles`, `manage-group-membership`, `impersonate`, and `user-impersonated`.\n1. Create all scope based permission for the scopes and users resources.\n\n\u003e This resource should only be created once per realm.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n  # enable permissions for realm-management client\n  realmManagementPermission:\n    type: keycloak:openid:ClientPermissions\n    name: realm_management_permission\n    properties:\n      realmId: ${realm.id}\n      clientId: ${realmManagement.id}\n      enabled: true\n  # creating a user to use with the keycloak_openid_client_user_policy resource\n  test:\n    type: keycloak:User\n    properties:\n      realmId: ${realm.id}\n      username: test-user\n      email: test-user@fakedomain.com\n      firstName: Testy\n      lastName: Tester\n  testClientUserPolicy:\n    type: keycloak:openid:ClientUserPolicy\n    name: test\n    properties:\n      realmId: ${realm.id}\n      resourceServerId: ${realmManagement.id}\n      name: client_user_policy_test\n      users:\n        - ${test.id}\n      logic: POSITIVE\n      decisionStrategy: UNANIMOUS\n    options:\n      dependson:\n        - ${realmManagementPermission}\n  usersPermissions:\n    type: keycloak:UsersPermissions\n    name: users_permissions\n    properties:\n      realmId: ${realm.id}\n      viewScope:\n        policies:\n          - ${testClientUserPolicy.id}\n        description: description\n        decisionStrategy: UNANIMOUS\n      manageScope:\n        policies:\n          - ${testClientUserPolicy.id}\n        description: description\n        decisionStrategy: UNANIMOUS\n      mapRolesScope:\n        policies:\n          - ${testClientUserPolicy.id}\n        description: description\n        decisionStrategy: UNANIMOUS\n      manageGroupMembershipScope:\n        policies:\n          - ${testClientUserPolicy.id}\n        description: description\n        decisionStrategy: UNANIMOUS\n      impersonateScope:\n        policies:\n          - ${testClientUserPolicy.id}\n        description: description\n        decisionStrategy: UNANIMOUS\n      userImpersonatedScope:\n        policies:\n          - ${testClientUserPolicy.id}\n        description: description\n        decisionStrategy: UNANIMOUS\nvariables:\n  realmManagement:\n    fn::invoke:\n      Function: keycloak:openid:getClient\n      Arguments:\n        realmId: ${realm.id}\n        clientId: realm-management\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm in which to manage fine-grained user permissions.\n\nEach of the scopes that can be managed are defined below:\n\n- `view_scope` - (Optional) When specified, set the scope based view permission.\n- `manage_scope` - (Optional) When specified, set the scope based manage permission.\n- `map_roles_scope` - (Optional) When specified, set the scope based map_roles permission.\n- `manage_group_membership_scope` - (Optional) When specified, set the scope based manage_group_membership permission.\n- `impersonate_scope` - (Optional) When specified, set the scope based impersonate permission.\n- `user_impersonated_scope` - (Optional) When specified, set the scope based user_impersonated permission.\n\nThe configuration block for each of these scopes supports the following arguments:\n\n- `policies` - (Optional) Assigned policies to the permission. Each element within this list should be a policy ID.\n- `description` - (Optional) Description of the permission.\n- `decision_strategy` - (Optional) Decision strategy of the permission.\n\n### Attributes Reference\n\nIn addition to the arguments listed above, the following computed attributes are exported:\n\n- `enabled` - When true, this indicates that fine-grained user permissions are enabled. This will always be `true`.\n- `authorization_resource_server_id` - Resource server id representing the realm management client on which these permissions are managed.\n",
            "properties": {
                "authorizationResourceServerId": {
                    "type": "string",
                    "description": "Resource server id representing the realm management client on which this permission is managed\n"
                },
                "enabled": {
                    "type": "boolean"
                },
                "impersonateScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsImpersonateScope:UsersPermissionsImpersonateScope"
                },
                "manageGroupMembershipScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsManageGroupMembershipScope:UsersPermissionsManageGroupMembershipScope"
                },
                "manageScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsManageScope:UsersPermissionsManageScope"
                },
                "mapRolesScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsMapRolesScope:UsersPermissionsMapRolesScope"
                },
                "realmId": {
                    "type": "string"
                },
                "userImpersonatedScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsUserImpersonatedScope:UsersPermissionsUserImpersonatedScope"
                },
                "viewScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsViewScope:UsersPermissionsViewScope"
                }
            },
            "required": [
                "authorizationResourceServerId",
                "enabled",
                "realmId"
            ],
            "inputProperties": {
                "impersonateScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsImpersonateScope:UsersPermissionsImpersonateScope"
                },
                "manageGroupMembershipScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsManageGroupMembershipScope:UsersPermissionsManageGroupMembershipScope"
                },
                "manageScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsManageScope:UsersPermissionsManageScope"
                },
                "mapRolesScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsMapRolesScope:UsersPermissionsMapRolesScope"
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "userImpersonatedScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsUserImpersonatedScope:UsersPermissionsUserImpersonatedScope"
                },
                "viewScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsViewScope:UsersPermissionsViewScope"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UsersPermissions resources.\n",
                "properties": {
                    "authorizationResourceServerId": {
                        "type": "string",
                        "description": "Resource server id representing the realm management client on which this permission is managed\n"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "impersonateScope": {
                        "$ref": "#/types/keycloak:index/UsersPermissionsImpersonateScope:UsersPermissionsImpersonateScope"
                    },
                    "manageGroupMembershipScope": {
                        "$ref": "#/types/keycloak:index/UsersPermissionsManageGroupMembershipScope:UsersPermissionsManageGroupMembershipScope"
                    },
                    "manageScope": {
                        "$ref": "#/types/keycloak:index/UsersPermissionsManageScope:UsersPermissionsManageScope"
                    },
                    "mapRolesScope": {
                        "$ref": "#/types/keycloak:index/UsersPermissionsMapRolesScope:UsersPermissionsMapRolesScope"
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "userImpersonatedScope": {
                        "$ref": "#/types/keycloak:index/UsersPermissionsUserImpersonatedScope:UsersPermissionsUserImpersonatedScope"
                    },
                    "viewScope": {
                        "$ref": "#/types/keycloak:index/UsersPermissionsViewScope:UsersPermissionsViewScope"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/customMapper:CustomMapper": {
            "description": "Allows for creating and managing custom attribute mappers for Keycloak users federated via LDAP.\n\nThe LDAP custom mapper is implemented and deployed into Keycloak as a custom provider. This resource allows to\nspecify the custom id and custom implementation class of the self-implemented attribute mapper as well as additional\nproperties via config map.\n\nThe custom mapper should already be deployed into keycloak in order to be correctly configured.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldap_user_federation\", {\n    name: \"openldap\",\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst customMapper = new keycloak.ldap.CustomMapper(\"custom_mapper\", {\n    name: \"custom-mapper\",\n    realmId: openldap.realmId,\n    ldapUserFederationId: openldap.id,\n    providerId: \"custom-provider-registered-in-keycloak\",\n    providerType: \"com.example.custom.ldap.mappers.CustomMapper\",\n    config: {\n        \"attribute.name\": \"name\",\n        \"attribute.value\": \"value\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldap_user_federation\",\n    name=\"openldap\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\ncustom_mapper = keycloak.ldap.CustomMapper(\"custom_mapper\",\n    name=\"custom-mapper\",\n    realm_id=openldap[\"realmId\"],\n    ldap_user_federation_id=openldap[\"id\"],\n    provider_id=\"custom-provider-registered-in-keycloak\",\n    provider_type=\"com.example.custom.ldap.mappers.CustomMapper\",\n    config={\n        \"attribute.name\": \"name\",\n        \"attribute.value\": \"value\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldap_user_federation\", new()\n    {\n        Name = \"openldap\",\n        RealmId = realm.Id,\n        UsernameLdapAttribute = \"cn\",\n        RdnLdapAttribute = \"cn\",\n        UuidLdapAttribute = \"entryDN\",\n        UserObjectClasses = new[]\n        {\n            \"simpleSecurityObject\",\n            \"organizationalRole\",\n        },\n        ConnectionUrl = \"ldap://openldap\",\n        UsersDn = \"dc=example,dc=org\",\n        BindDn = \"cn=admin,dc=example,dc=org\",\n        BindCredential = \"admin\",\n    });\n\n    var customMapper = new Keycloak.Ldap.CustomMapper(\"custom_mapper\", new()\n    {\n        Name = \"custom-mapper\",\n        RealmId = openldap.RealmId,\n        LdapUserFederationId = openldap.Id,\n        ProviderId = \"custom-provider-registered-in-keycloak\",\n        ProviderType = \"com.example.custom.ldap.mappers.CustomMapper\",\n        Config = \n        {\n            { \"attribute.name\", \"name\" },\n            { \"attribute.value\", \"value\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewUserFederation(ctx, \"ldap_user_federation\", \u0026ldap.UserFederationArgs{\n\t\t\tName:                  pulumi.String(\"openldap\"),\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewCustomMapper(ctx, \"custom_mapper\", \u0026ldap.CustomMapperArgs{\n\t\t\tName:                 pulumi.String(\"custom-mapper\"),\n\t\t\tRealmId:              pulumi.Any(openldap.RealmId),\n\t\t\tLdapUserFederationId: pulumi.Any(openldap.Id),\n\t\t\tProviderId:           pulumi.String(\"custom-provider-registered-in-keycloak\"),\n\t\t\tProviderType:         pulumi.String(\"com.example.custom.ldap.mappers.CustomMapper\"),\n\t\t\tConfig: pulumi.Map{\n\t\t\t\t\"attribute.name\":  pulumi.Any(\"name\"),\n\t\t\t\t\"attribute.value\": pulumi.Any(\"value\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.ldap.UserFederation;\nimport com.pulumi.keycloak.ldap.UserFederationArgs;\nimport com.pulumi.keycloak.ldap.CustomMapper;\nimport com.pulumi.keycloak.ldap.CustomMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var ldapUserFederation = new UserFederation(\"ldapUserFederation\", UserFederationArgs.builder()\n            .name(\"openldap\")\n            .realmId(realm.id())\n            .usernameLdapAttribute(\"cn\")\n            .rdnLdapAttribute(\"cn\")\n            .uuidLdapAttribute(\"entryDN\")\n            .userObjectClasses(            \n                \"simpleSecurityObject\",\n                \"organizationalRole\")\n            .connectionUrl(\"ldap://openldap\")\n            .usersDn(\"dc=example,dc=org\")\n            .bindDn(\"cn=admin,dc=example,dc=org\")\n            .bindCredential(\"admin\")\n            .build());\n\n        var customMapper = new CustomMapper(\"customMapper\", CustomMapperArgs.builder()\n            .name(\"custom-mapper\")\n            .realmId(openldap.realmId())\n            .ldapUserFederationId(openldap.id())\n            .providerId(\"custom-provider-registered-in-keycloak\")\n            .providerType(\"com.example.custom.ldap.mappers.CustomMapper\")\n            .config(Map.ofEntries(\n                Map.entry(\"attribute.name\", \"name\"),\n                Map.entry(\"attribute.value\", \"value\")\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  ldapUserFederation:\n    type: keycloak:ldap:UserFederation\n    name: ldap_user_federation\n    properties:\n      name: openldap\n      realmId: ${realm.id}\n      usernameLdapAttribute: cn\n      rdnLdapAttribute: cn\n      uuidLdapAttribute: entryDN\n      userObjectClasses:\n        - simpleSecurityObject\n        - organizationalRole\n      connectionUrl: ldap://openldap\n      usersDn: dc=example,dc=org\n      bindDn: cn=admin,dc=example,dc=org\n      bindCredential: admin\n  customMapper:\n    type: keycloak:ldap:CustomMapper\n    name: custom_mapper\n    properties:\n      name: custom-mapper\n      realmId: ${openldap.realmId}\n      ldapUserFederationId: ${openldap.id}\n      providerId: custom-provider-registered-in-keycloak\n      providerType: com.example.custom.ldap.mappers.CustomMapper\n      config:\n        attribute.name: name\n        attribute.value: value\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nLDAP mappers can be imported using the format `{{realm_id}}/{{ldap_user_federation_id}}/{{ldap_mapper_id}}`.\n\nThe ID of the LDAP user federation provider and the mapper can be found within the Keycloak GUI, and they are typically GUIDs.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:ldap/customMapper:CustomMapper custom_mapper my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860/3d923ece-1a91-4bf7-adaf-3b82f2a12b67\n```\n\n",
            "properties": {
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map with key / value pairs for configuring the LDAP mapper. The supported keys depend on the protocol mapper.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The id of the LDAP mapper implemented in MapperFactory.\n"
                },
                "providerType": {
                    "type": "string",
                    "description": "The fully-qualified Java class name of the custom LDAP mapper.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                }
            },
            "required": [
                "ldapUserFederationId",
                "name",
                "providerId",
                "providerType",
                "realmId"
            ],
            "inputProperties": {
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map with key / value pairs for configuring the LDAP mapper. The supported keys depend on the protocol mapper.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The id of the LDAP mapper implemented in MapperFactory.\n",
                    "willReplaceOnChanges": true
                },
                "providerType": {
                    "type": "string",
                    "description": "The fully-qualified Java class name of the custom LDAP mapper.\n",
                    "willReplaceOnChanges": true
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "ldapUserFederationId",
                "providerId",
                "providerType",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomMapper resources.\n",
                "properties": {
                    "config": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map with key / value pairs for configuring the LDAP mapper. The supported keys depend on the protocol mapper.\n"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ID of the LDAP user federation provider to attach this mapper to.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The id of the LDAP mapper implemented in MapperFactory.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerType": {
                        "type": "string",
                        "description": "The fully-qualified Java class name of the custom LDAP mapper.\n",
                        "willReplaceOnChanges": true
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this LDAP mapper will exist in.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/fullNameMapper:FullNameMapper": {
            "description": "## # keycloak.ldap.FullNameMapper\n\nAllows for creating and managing full name mappers for Keycloak users federated\nvia LDAP.\n\nThe LDAP full name mapper can map a user's full name from an LDAP attribute\nto the first and last name attributes of a Keycloak user.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"test\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldap_user_federation\", {\n    name: \"openldap\",\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst ldapFullNameMapper = new keycloak.ldap.FullNameMapper(\"ldap_full_name_mapper\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    name: \"full-name-mapper\",\n    ldapFullNameAttribute: \"cn\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"test\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldap_user_federation\",\n    name=\"openldap\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nldap_full_name_mapper = keycloak.ldap.FullNameMapper(\"ldap_full_name_mapper\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    name=\"full-name-mapper\",\n    ldap_full_name_attribute=\"cn\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"test\",\n        Enabled = true,\n    });\n\n    var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldap_user_federation\", new()\n    {\n        Name = \"openldap\",\n        RealmId = realm.Id,\n        UsernameLdapAttribute = \"cn\",\n        RdnLdapAttribute = \"cn\",\n        UuidLdapAttribute = \"entryDN\",\n        UserObjectClasses = new[]\n        {\n            \"simpleSecurityObject\",\n            \"organizationalRole\",\n        },\n        ConnectionUrl = \"ldap://openldap\",\n        UsersDn = \"dc=example,dc=org\",\n        BindDn = \"cn=admin,dc=example,dc=org\",\n        BindCredential = \"admin\",\n    });\n\n    var ldapFullNameMapper = new Keycloak.Ldap.FullNameMapper(\"ldap_full_name_mapper\", new()\n    {\n        RealmId = realm.Id,\n        LdapUserFederationId = ldapUserFederation.Id,\n        Name = \"full-name-mapper\",\n        LdapFullNameAttribute = \"cn\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"test\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldap_user_federation\", \u0026ldap.UserFederationArgs{\n\t\t\tName:                  pulumi.String(\"openldap\"),\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewFullNameMapper(ctx, \"ldap_full_name_mapper\", \u0026ldap.FullNameMapperArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tLdapUserFederationId:  ldapUserFederation.ID(),\n\t\t\tName:                  pulumi.String(\"full-name-mapper\"),\n\t\t\tLdapFullNameAttribute: pulumi.String(\"cn\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.ldap.UserFederation;\nimport com.pulumi.keycloak.ldap.UserFederationArgs;\nimport com.pulumi.keycloak.ldap.FullNameMapper;\nimport com.pulumi.keycloak.ldap.FullNameMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"test\")\n            .enabled(true)\n            .build());\n\n        var ldapUserFederation = new UserFederation(\"ldapUserFederation\", UserFederationArgs.builder()\n            .name(\"openldap\")\n            .realmId(realm.id())\n            .usernameLdapAttribute(\"cn\")\n            .rdnLdapAttribute(\"cn\")\n            .uuidLdapAttribute(\"entryDN\")\n            .userObjectClasses(            \n                \"simpleSecurityObject\",\n                \"organizationalRole\")\n            .connectionUrl(\"ldap://openldap\")\n            .usersDn(\"dc=example,dc=org\")\n            .bindDn(\"cn=admin,dc=example,dc=org\")\n            .bindCredential(\"admin\")\n            .build());\n\n        var ldapFullNameMapper = new FullNameMapper(\"ldapFullNameMapper\", FullNameMapperArgs.builder()\n            .realmId(realm.id())\n            .ldapUserFederationId(ldapUserFederation.id())\n            .name(\"full-name-mapper\")\n            .ldapFullNameAttribute(\"cn\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: test\n      enabled: true\n  ldapUserFederation:\n    type: keycloak:ldap:UserFederation\n    name: ldap_user_federation\n    properties:\n      name: openldap\n      realmId: ${realm.id}\n      usernameLdapAttribute: cn\n      rdnLdapAttribute: cn\n      uuidLdapAttribute: entryDN\n      userObjectClasses:\n        - simpleSecurityObject\n        - organizationalRole\n      connectionUrl: ldap://openldap\n      usersDn: dc=example,dc=org\n      bindDn: cn=admin,dc=example,dc=org\n      bindCredential: admin\n  ldapFullNameMapper:\n    type: keycloak:ldap:FullNameMapper\n    name: ldap_full_name_mapper\n    properties:\n      realmId: ${realm.id}\n      ldapUserFederationId: ${ldapUserFederation.id}\n      name: full-name-mapper\n      ldapFullNameAttribute: cn\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm that this LDAP mapper will exist in.\n- `ldap_user_federation_id` - (Required) The ID of the LDAP user federation provider to attach this mapper to.\n- `name` - (Required) Display name of this mapper when displayed in the console.\n- `ldap_full_name_attribute` - (Required) The name of the LDAP attribute containing the user's full name.\n- `read_only` - (Optional) When `true`, updates to a user within Keycloak will not be written back to LDAP. Defaults to `false`.\n- `write_only` - (Optional) When `true`, this mapper will only be used to write updates to LDAP. Defaults to `false`.\n\n### Import\n\nLDAP mappers can be imported using the format `{{realm_id}}/{{ldap_user_federation_id}}/{{ldap_mapper_id}}`.\nThe ID of the LDAP user federation provider and the mapper can be found within\nthe Keycloak GUI, and they are typically GUIDs:\n\n```bash\n$ terraform import keycloak_ldap_full_name_mapper.ldap_full_name_mapper my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860/3d923ece-1a91-4bf7-adaf-3b82f2a12b67\n```\n",
            "properties": {
                "ldapFullNameAttribute": {
                    "type": "string"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "readOnly": {
                    "type": "boolean"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                },
                "writeOnly": {
                    "type": "boolean"
                }
            },
            "required": [
                "ldapFullNameAttribute",
                "ldapUserFederationId",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "ldapFullNameAttribute": {
                    "type": "string"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "readOnly": {
                    "type": "boolean"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n",
                    "willReplaceOnChanges": true
                },
                "writeOnly": {
                    "type": "boolean"
                }
            },
            "requiredInputs": [
                "ldapFullNameAttribute",
                "ldapUserFederationId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FullNameMapper resources.\n",
                "properties": {
                    "ldapFullNameAttribute": {
                        "type": "string"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ldap user federation provider to attach this mapper to.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the mapper when displayed in the console.\n"
                    },
                    "readOnly": {
                        "type": "boolean"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm in which the ldap user federation provider exists.\n",
                        "willReplaceOnChanges": true
                    },
                    "writeOnly": {
                        "type": "boolean"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/groupMapper:GroupMapper": {
            "description": "## # keycloak.ldap.GroupMapper\n\nAllows for creating and managing group mappers for Keycloak users federated\nvia LDAP.\n\nThe LDAP group mapper can be used to map an LDAP user's groups from some DN\nto Keycloak groups. This group mapper will also create the groups within Keycloak\nif they do not already exist.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"test\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldap_user_federation\", {\n    name: \"openldap\",\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst ldapGroupMapper = new keycloak.ldap.GroupMapper(\"ldap_group_mapper\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    name: \"group-mapper\",\n    ldapGroupsDn: \"dc=example,dc=org\",\n    groupNameLdapAttribute: \"cn\",\n    groupObjectClasses: [\"groupOfNames\"],\n    membershipAttributeType: \"DN\",\n    membershipLdapAttribute: \"member\",\n    membershipUserLdapAttribute: \"cn\",\n    memberofLdapAttribute: \"memberOf\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"test\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldap_user_federation\",\n    name=\"openldap\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nldap_group_mapper = keycloak.ldap.GroupMapper(\"ldap_group_mapper\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    name=\"group-mapper\",\n    ldap_groups_dn=\"dc=example,dc=org\",\n    group_name_ldap_attribute=\"cn\",\n    group_object_classes=[\"groupOfNames\"],\n    membership_attribute_type=\"DN\",\n    membership_ldap_attribute=\"member\",\n    membership_user_ldap_attribute=\"cn\",\n    memberof_ldap_attribute=\"memberOf\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"test\",\n        Enabled = true,\n    });\n\n    var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldap_user_federation\", new()\n    {\n        Name = \"openldap\",\n        RealmId = realm.Id,\n        UsernameLdapAttribute = \"cn\",\n        RdnLdapAttribute = \"cn\",\n        UuidLdapAttribute = \"entryDN\",\n        UserObjectClasses = new[]\n        {\n            \"simpleSecurityObject\",\n            \"organizationalRole\",\n        },\n        ConnectionUrl = \"ldap://openldap\",\n        UsersDn = \"dc=example,dc=org\",\n        BindDn = \"cn=admin,dc=example,dc=org\",\n        BindCredential = \"admin\",\n    });\n\n    var ldapGroupMapper = new Keycloak.Ldap.GroupMapper(\"ldap_group_mapper\", new()\n    {\n        RealmId = realm.Id,\n        LdapUserFederationId = ldapUserFederation.Id,\n        Name = \"group-mapper\",\n        LdapGroupsDn = \"dc=example,dc=org\",\n        GroupNameLdapAttribute = \"cn\",\n        GroupObjectClasses = new[]\n        {\n            \"groupOfNames\",\n        },\n        MembershipAttributeType = \"DN\",\n        MembershipLdapAttribute = \"member\",\n        MembershipUserLdapAttribute = \"cn\",\n        MemberofLdapAttribute = \"memberOf\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"test\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldap_user_federation\", \u0026ldap.UserFederationArgs{\n\t\t\tName:                  pulumi.String(\"openldap\"),\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewGroupMapper(ctx, \"ldap_group_mapper\", \u0026ldap.GroupMapperArgs{\n\t\t\tRealmId:                realm.ID(),\n\t\t\tLdapUserFederationId:   ldapUserFederation.ID(),\n\t\t\tName:                   pulumi.String(\"group-mapper\"),\n\t\t\tLdapGroupsDn:           pulumi.String(\"dc=example,dc=org\"),\n\t\t\tGroupNameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tGroupObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"groupOfNames\"),\n\t\t\t},\n\t\t\tMembershipAttributeType:     pulumi.String(\"DN\"),\n\t\t\tMembershipLdapAttribute:     pulumi.String(\"member\"),\n\t\t\tMembershipUserLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tMemberofLdapAttribute:       pulumi.String(\"memberOf\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.ldap.UserFederation;\nimport com.pulumi.keycloak.ldap.UserFederationArgs;\nimport com.pulumi.keycloak.ldap.GroupMapper;\nimport com.pulumi.keycloak.ldap.GroupMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"test\")\n            .enabled(true)\n            .build());\n\n        var ldapUserFederation = new UserFederation(\"ldapUserFederation\", UserFederationArgs.builder()\n            .name(\"openldap\")\n            .realmId(realm.id())\n            .usernameLdapAttribute(\"cn\")\n            .rdnLdapAttribute(\"cn\")\n            .uuidLdapAttribute(\"entryDN\")\n            .userObjectClasses(            \n                \"simpleSecurityObject\",\n                \"organizationalRole\")\n            .connectionUrl(\"ldap://openldap\")\n            .usersDn(\"dc=example,dc=org\")\n            .bindDn(\"cn=admin,dc=example,dc=org\")\n            .bindCredential(\"admin\")\n            .build());\n\n        var ldapGroupMapper = new GroupMapper(\"ldapGroupMapper\", GroupMapperArgs.builder()\n            .realmId(realm.id())\n            .ldapUserFederationId(ldapUserFederation.id())\n            .name(\"group-mapper\")\n            .ldapGroupsDn(\"dc=example,dc=org\")\n            .groupNameLdapAttribute(\"cn\")\n            .groupObjectClasses(\"groupOfNames\")\n            .membershipAttributeType(\"DN\")\n            .membershipLdapAttribute(\"member\")\n            .membershipUserLdapAttribute(\"cn\")\n            .memberofLdapAttribute(\"memberOf\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: test\n      enabled: true\n  ldapUserFederation:\n    type: keycloak:ldap:UserFederation\n    name: ldap_user_federation\n    properties:\n      name: openldap\n      realmId: ${realm.id}\n      usernameLdapAttribute: cn\n      rdnLdapAttribute: cn\n      uuidLdapAttribute: entryDN\n      userObjectClasses:\n        - simpleSecurityObject\n        - organizationalRole\n      connectionUrl: ldap://openldap\n      usersDn: dc=example,dc=org\n      bindDn: cn=admin,dc=example,dc=org\n      bindCredential: admin\n  ldapGroupMapper:\n    type: keycloak:ldap:GroupMapper\n    name: ldap_group_mapper\n    properties:\n      realmId: ${realm.id}\n      ldapUserFederationId: ${ldapUserFederation.id}\n      name: group-mapper\n      ldapGroupsDn: dc=example,dc=org\n      groupNameLdapAttribute: cn\n      groupObjectClasses:\n        - groupOfNames\n      membershipAttributeType: DN\n      membershipLdapAttribute: member\n      membershipUserLdapAttribute: cn\n      memberofLdapAttribute: memberOf\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm that this LDAP mapper will exist in.\n- `ldap_user_federation_id` - (Required) The ID of the LDAP user federation provider to attach this mapper to.\n- `name` - (Required) Display name of this mapper when displayed in the console.\n- `ldap_groups_dn` - (Required) The LDAP DN where groups can be found.\n- `group_name_ldap_attribute` - (Required) The name of the LDAP attribute that is used in group objects for the name and RDN of the group. Typically `cn`.\n- `group_object_classes` - (Required) Array of strings representing the object classes for the group. Must contain at least one.\n- `preserve_group_inheritance` - (Optional) When `true`, group inheritance will be propagated from LDAP to Keycloak. When `false`, all LDAP groups will be propagated as top level groups within Keycloak.\n- `ignore_missing_groups` - (Optional) When `true`, missing groups in the hierarchy will be ignored.\n- `membership_ldap_attribute` - (Required) The name of the LDAP attribute that is used for membership mappings.\n- `membership_attribute_type` - (Optional) Can be one of `DN` or `UID`. Defaults to `DN`.\n- `membership_user_ldap_attribute` - (Required) The name of the LDAP attribute on a user that is used for membership mappings.\n- `groups_ldap_filter` - (Optional) When specified, adds an additional custom filter to be used when querying for groups. Must start with `(` and end with `)`.\n- `mode` - (Optional) Can be one of `READ_ONLY` or `LDAP_ONLY`. Defaults to `READ_ONLY`.\n- `user_roles_retrieve_strategy` - (Optional) Can be one of `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE`, `GET_GROUPS_FROM_USER_MEMBEROF_ATTRIBUTE`, or `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE_RECURSIVELY`. Defaults to `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE`.\n- `memberof_ldap_attribute` - (Optional) Specifies the name of the LDAP attribute on the LDAP user that contains the groups the user is a member of. Defaults to `memberOf`.\n- `mapped_group_attributes` - (Optional) Array of strings representing attributes on the LDAP group which will be mapped to attributes on the Keycloak group.\n- `drop_non_existing_groups_during_sync` - (Optional) When `true`, groups that no longer exist within LDAP will be dropped in Keycloak during sync. Defaults to `false`.\n\n### Import\n\nLDAP mappers can be imported using the format `{{realm_id}}/{{ldap_user_federation_id}}/{{ldap_mapper_id}}`.\nThe ID of the LDAP user federation provider and the mapper can be found within\nthe Keycloak GUI, and they are typically GUIDs:\n\n```bash\n$ terraform import keycloak_ldap_group_mapper.ldap_group_mapper my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860/3d923ece-1a91-4bf7-adaf-3b82f2a12b67\n```\n",
            "properties": {
                "dropNonExistingGroupsDuringSync": {
                    "type": "boolean"
                },
                "groupNameLdapAttribute": {
                    "type": "string"
                },
                "groupObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "groupsLdapFilter": {
                    "type": "string"
                },
                "groupsPath": {
                    "type": "string"
                },
                "ignoreMissingGroups": {
                    "type": "boolean"
                },
                "ldapGroupsDn": {
                    "type": "string"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "mappedGroupAttributes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "memberofLdapAttribute": {
                    "type": "string"
                },
                "membershipAttributeType": {
                    "type": "string"
                },
                "membershipLdapAttribute": {
                    "type": "string"
                },
                "membershipUserLdapAttribute": {
                    "type": "string"
                },
                "mode": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "preserveGroupInheritance": {
                    "type": "boolean"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                },
                "userRolesRetrieveStrategy": {
                    "type": "string"
                }
            },
            "required": [
                "groupNameLdapAttribute",
                "groupObjectClasses",
                "groupsPath",
                "ldapGroupsDn",
                "ldapUserFederationId",
                "membershipLdapAttribute",
                "membershipUserLdapAttribute",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "dropNonExistingGroupsDuringSync": {
                    "type": "boolean"
                },
                "groupNameLdapAttribute": {
                    "type": "string"
                },
                "groupObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "groupsLdapFilter": {
                    "type": "string"
                },
                "groupsPath": {
                    "type": "string"
                },
                "ignoreMissingGroups": {
                    "type": "boolean"
                },
                "ldapGroupsDn": {
                    "type": "string"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n",
                    "willReplaceOnChanges": true
                },
                "mappedGroupAttributes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "memberofLdapAttribute": {
                    "type": "string"
                },
                "membershipAttributeType": {
                    "type": "string"
                },
                "membershipLdapAttribute": {
                    "type": "string"
                },
                "membershipUserLdapAttribute": {
                    "type": "string"
                },
                "mode": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "preserveGroupInheritance": {
                    "type": "boolean"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n",
                    "willReplaceOnChanges": true
                },
                "userRolesRetrieveStrategy": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "groupNameLdapAttribute",
                "groupObjectClasses",
                "ldapGroupsDn",
                "ldapUserFederationId",
                "membershipLdapAttribute",
                "membershipUserLdapAttribute",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupMapper resources.\n",
                "properties": {
                    "dropNonExistingGroupsDuringSync": {
                        "type": "boolean"
                    },
                    "groupNameLdapAttribute": {
                        "type": "string"
                    },
                    "groupObjectClasses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "groupsLdapFilter": {
                        "type": "string"
                    },
                    "groupsPath": {
                        "type": "string"
                    },
                    "ignoreMissingGroups": {
                        "type": "boolean"
                    },
                    "ldapGroupsDn": {
                        "type": "string"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ldap user federation provider to attach this mapper to.\n",
                        "willReplaceOnChanges": true
                    },
                    "mappedGroupAttributes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "memberofLdapAttribute": {
                        "type": "string"
                    },
                    "membershipAttributeType": {
                        "type": "string"
                    },
                    "membershipLdapAttribute": {
                        "type": "string"
                    },
                    "membershipUserLdapAttribute": {
                        "type": "string"
                    },
                    "mode": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the mapper when displayed in the console.\n"
                    },
                    "preserveGroupInheritance": {
                        "type": "boolean"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm in which the ldap user federation provider exists.\n",
                        "willReplaceOnChanges": true
                    },
                    "userRolesRetrieveStrategy": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/hardcodedAttributeMapper:HardcodedAttributeMapper": {
            "description": "Allows for creating and managing hardcoded attribute mappers for Keycloak users federated via LDAP.\n\nThe LDAP hardcoded attribute mapper will set the specified value to the LDAP attribute.\n\n**NOTE**: This mapper only works when the `sync_registrations` attribute on the `keycloak.ldap.UserFederation` resource is set to `true`.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldap_user_federation\", {\n    name: \"openldap\",\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n    syncRegistrations: true,\n});\nconst assignBarToFoo = new keycloak.ldap.HardcodedAttributeMapper(\"assign_bar_to_foo\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    name: \"assign-foo-to-bar\",\n    attributeName: \"foo\",\n    attributeValue: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldap_user_federation\",\n    name=\"openldap\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\",\n    sync_registrations=True)\nassign_bar_to_foo = keycloak.ldap.HardcodedAttributeMapper(\"assign_bar_to_foo\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    name=\"assign-foo-to-bar\",\n    attribute_name=\"foo\",\n    attribute_value=\"bar\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldap_user_federation\", new()\n    {\n        Name = \"openldap\",\n        RealmId = realm.Id,\n        UsernameLdapAttribute = \"cn\",\n        RdnLdapAttribute = \"cn\",\n        UuidLdapAttribute = \"entryDN\",\n        UserObjectClasses = new[]\n        {\n            \"simpleSecurityObject\",\n            \"organizationalRole\",\n        },\n        ConnectionUrl = \"ldap://openldap\",\n        UsersDn = \"dc=example,dc=org\",\n        BindDn = \"cn=admin,dc=example,dc=org\",\n        BindCredential = \"admin\",\n        SyncRegistrations = true,\n    });\n\n    var assignBarToFoo = new Keycloak.Ldap.HardcodedAttributeMapper(\"assign_bar_to_foo\", new()\n    {\n        RealmId = realm.Id,\n        LdapUserFederationId = ldapUserFederation.Id,\n        Name = \"assign-foo-to-bar\",\n        AttributeName = \"foo\",\n        AttributeValue = \"bar\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldap_user_federation\", \u0026ldap.UserFederationArgs{\n\t\t\tName:                  pulumi.String(\"openldap\"),\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:     pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:           pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:            pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential:    pulumi.String(\"admin\"),\n\t\t\tSyncRegistrations: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewHardcodedAttributeMapper(ctx, \"assign_bar_to_foo\", \u0026ldap.HardcodedAttributeMapperArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t\tName:                 pulumi.String(\"assign-foo-to-bar\"),\n\t\t\tAttributeName:        pulumi.String(\"foo\"),\n\t\t\tAttributeValue:       pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.ldap.UserFederation;\nimport com.pulumi.keycloak.ldap.UserFederationArgs;\nimport com.pulumi.keycloak.ldap.HardcodedAttributeMapper;\nimport com.pulumi.keycloak.ldap.HardcodedAttributeMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var ldapUserFederation = new UserFederation(\"ldapUserFederation\", UserFederationArgs.builder()\n            .name(\"openldap\")\n            .realmId(realm.id())\n            .usernameLdapAttribute(\"cn\")\n            .rdnLdapAttribute(\"cn\")\n            .uuidLdapAttribute(\"entryDN\")\n            .userObjectClasses(            \n                \"simpleSecurityObject\",\n                \"organizationalRole\")\n            .connectionUrl(\"ldap://openldap\")\n            .usersDn(\"dc=example,dc=org\")\n            .bindDn(\"cn=admin,dc=example,dc=org\")\n            .bindCredential(\"admin\")\n            .syncRegistrations(true)\n            .build());\n\n        var assignBarToFoo = new HardcodedAttributeMapper(\"assignBarToFoo\", HardcodedAttributeMapperArgs.builder()\n            .realmId(realm.id())\n            .ldapUserFederationId(ldapUserFederation.id())\n            .name(\"assign-foo-to-bar\")\n            .attributeName(\"foo\")\n            .attributeValue(\"bar\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  ldapUserFederation:\n    type: keycloak:ldap:UserFederation\n    name: ldap_user_federation\n    properties:\n      name: openldap\n      realmId: ${realm.id}\n      usernameLdapAttribute: cn\n      rdnLdapAttribute: cn\n      uuidLdapAttribute: entryDN\n      userObjectClasses:\n        - simpleSecurityObject\n        - organizationalRole\n      connectionUrl: ldap://openldap\n      usersDn: dc=example,dc=org\n      bindDn: cn=admin,dc=example,dc=org\n      bindCredential: admin\n      syncRegistrations: true\n  assignBarToFoo:\n    type: keycloak:ldap:HardcodedAttributeMapper\n    name: assign_bar_to_foo\n    properties:\n      realmId: ${realm.id}\n      ldapUserFederationId: ${ldapUserFederation.id}\n      name: assign-foo-to-bar\n      attributeName: foo\n      attributeValue: bar\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nLDAP mappers can be imported using the format `{{realm_id}}/{{ldap_user_federation_id}}/{{ldap_mapper_id}}`.\n\nThe ID of the LDAP user federation provider and the mapper can be found within the Keycloak GUI, and they are typically GUIDs.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:ldap/hardcodedAttributeMapper:HardcodedAttributeMapper assign_bar_to_foo my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860/3d923ece-1a91-4bf7-adaf-3b82f2a12b67\n```\n\n",
            "properties": {
                "attributeName": {
                    "type": "string",
                    "description": "The name of the LDAP attribute to set.\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "The value to set to the LDAP attribute. You can hardcode any value like 'foo'.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                }
            },
            "required": [
                "attributeName",
                "attributeValue",
                "ldapUserFederationId",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "attributeName": {
                    "type": "string",
                    "description": "The name of the LDAP attribute to set.\n",
                    "willReplaceOnChanges": true
                },
                "attributeValue": {
                    "type": "string",
                    "description": "The value to set to the LDAP attribute. You can hardcode any value like 'foo'.\n",
                    "willReplaceOnChanges": true
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "attributeName",
                "attributeValue",
                "ldapUserFederationId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedAttributeMapper resources.\n",
                "properties": {
                    "attributeName": {
                        "type": "string",
                        "description": "The name of the LDAP attribute to set.\n",
                        "willReplaceOnChanges": true
                    },
                    "attributeValue": {
                        "type": "string",
                        "description": "The value to set to the LDAP attribute. You can hardcode any value like 'foo'.\n",
                        "willReplaceOnChanges": true
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ID of the LDAP user federation provider to attach this mapper to.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this LDAP mapper will exist in.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/hardcodedGroupMapper:HardcodedGroupMapper": {
            "description": "Allows for creating and managing hardcoded group mappers for Keycloak users federated via LDAP.\n\nThe LDAP hardcoded group mapper will grant a specified Keycloak group to each Keycloak user linked with LDAP.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldap_user_federation\", {\n    name: \"openldap\",\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst realmGroup = new keycloak.Group(\"realm_group\", {\n    realmId: realm.id,\n    name: \"my-group\",\n});\nconst assignGroupToUsers = new keycloak.ldap.HardcodedGroupMapper(\"assign_group_to_users\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    name: \"assign-group-to-users\",\n    group: realmGroup.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldap_user_federation\",\n    name=\"openldap\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nrealm_group = keycloak.Group(\"realm_group\",\n    realm_id=realm.id,\n    name=\"my-group\")\nassign_group_to_users = keycloak.ldap.HardcodedGroupMapper(\"assign_group_to_users\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    name=\"assign-group-to-users\",\n    group=realm_group.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldap_user_federation\", new()\n    {\n        Name = \"openldap\",\n        RealmId = realm.Id,\n        UsernameLdapAttribute = \"cn\",\n        RdnLdapAttribute = \"cn\",\n        UuidLdapAttribute = \"entryDN\",\n        UserObjectClasses = new[]\n        {\n            \"simpleSecurityObject\",\n            \"organizationalRole\",\n        },\n        ConnectionUrl = \"ldap://openldap\",\n        UsersDn = \"dc=example,dc=org\",\n        BindDn = \"cn=admin,dc=example,dc=org\",\n        BindCredential = \"admin\",\n    });\n\n    var realmGroup = new Keycloak.Group(\"realm_group\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-group\",\n    });\n\n    var assignGroupToUsers = new Keycloak.Ldap.HardcodedGroupMapper(\"assign_group_to_users\", new()\n    {\n        RealmId = realm.Id,\n        LdapUserFederationId = ldapUserFederation.Id,\n        Name = \"assign-group-to-users\",\n        Group = realmGroup.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldap_user_federation\", \u0026ldap.UserFederationArgs{\n\t\t\tName:                  pulumi.String(\"openldap\"),\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmGroup, err := keycloak.NewGroup(ctx, \"realm_group\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"my-group\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewHardcodedGroupMapper(ctx, \"assign_group_to_users\", \u0026ldap.HardcodedGroupMapperArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t\tName:                 pulumi.String(\"assign-group-to-users\"),\n\t\t\tGroup:                realmGroup.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.ldap.UserFederation;\nimport com.pulumi.keycloak.ldap.UserFederationArgs;\nimport com.pulumi.keycloak.Group;\nimport com.pulumi.keycloak.GroupArgs;\nimport com.pulumi.keycloak.ldap.HardcodedGroupMapper;\nimport com.pulumi.keycloak.ldap.HardcodedGroupMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var ldapUserFederation = new UserFederation(\"ldapUserFederation\", UserFederationArgs.builder()\n            .name(\"openldap\")\n            .realmId(realm.id())\n            .usernameLdapAttribute(\"cn\")\n            .rdnLdapAttribute(\"cn\")\n            .uuidLdapAttribute(\"entryDN\")\n            .userObjectClasses(            \n                \"simpleSecurityObject\",\n                \"organizationalRole\")\n            .connectionUrl(\"ldap://openldap\")\n            .usersDn(\"dc=example,dc=org\")\n            .bindDn(\"cn=admin,dc=example,dc=org\")\n            .bindCredential(\"admin\")\n            .build());\n\n        var realmGroup = new Group(\"realmGroup\", GroupArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-group\")\n            .build());\n\n        var assignGroupToUsers = new HardcodedGroupMapper(\"assignGroupToUsers\", HardcodedGroupMapperArgs.builder()\n            .realmId(realm.id())\n            .ldapUserFederationId(ldapUserFederation.id())\n            .name(\"assign-group-to-users\")\n            .group(realmGroup.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  ldapUserFederation:\n    type: keycloak:ldap:UserFederation\n    name: ldap_user_federation\n    properties:\n      name: openldap\n      realmId: ${realm.id}\n      usernameLdapAttribute: cn\n      rdnLdapAttribute: cn\n      uuidLdapAttribute: entryDN\n      userObjectClasses:\n        - simpleSecurityObject\n        - organizationalRole\n      connectionUrl: ldap://openldap\n      usersDn: dc=example,dc=org\n      bindDn: cn=admin,dc=example,dc=org\n      bindCredential: admin\n  realmGroup:\n    type: keycloak:Group\n    name: realm_group\n    properties:\n      realmId: ${realm.id}\n      name: my-group\n  assignGroupToUsers:\n    type: keycloak:ldap:HardcodedGroupMapper\n    name: assign_group_to_users\n    properties:\n      realmId: ${realm.id}\n      ldapUserFederationId: ${ldapUserFederation.id}\n      name: assign-group-to-users\n      group: ${realmGroup.name}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nLDAP mappers can be imported using the format `{{realm_id}}/{{ldap_user_federation_id}}/{{ldap_mapper_id}}`.\n\nThe ID of the LDAP user federation provider and the mapper can be found within the Keycloak GUI, and they are typically GUIDs.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:ldap/hardcodedGroupMapper:HardcodedGroupMapper assign_group_to_users my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860/3d923ece-1a91-4bf7-adaf-3b82f2a12b67\n```\n\n",
            "properties": {
                "group": {
                    "type": "string",
                    "description": "The name of the group which should be assigned to the users.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                }
            },
            "required": [
                "group",
                "ldapUserFederationId",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "group": {
                    "type": "string",
                    "description": "The name of the group which should be assigned to the users.\n",
                    "willReplaceOnChanges": true
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "group",
                "ldapUserFederationId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedGroupMapper resources.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "description": "The name of the group which should be assigned to the users.\n",
                        "willReplaceOnChanges": true
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ID of the LDAP user federation provider to attach this mapper to.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this LDAP mapper will exist in.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/hardcodedRoleMapper:HardcodedRoleMapper": {
            "description": "## # keycloak.ldap.HardcodedRoleMapper\n\nThis mapper will grant a specified Keycloak role to each Keycloak user linked with LDAP.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"test\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldap_user_federation\", {\n    name: \"openldap\",\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst assignAdminRoleToAllUsers = new keycloak.ldap.HardcodedRoleMapper(\"assign_admin_role_to_all_users\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    name: \"assign-admin-role-to-all-users\",\n    role: \"admin\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"test\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldap_user_federation\",\n    name=\"openldap\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nassign_admin_role_to_all_users = keycloak.ldap.HardcodedRoleMapper(\"assign_admin_role_to_all_users\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    name=\"assign-admin-role-to-all-users\",\n    role=\"admin\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"test\",\n        Enabled = true,\n    });\n\n    var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldap_user_federation\", new()\n    {\n        Name = \"openldap\",\n        RealmId = realm.Id,\n        UsernameLdapAttribute = \"cn\",\n        RdnLdapAttribute = \"cn\",\n        UuidLdapAttribute = \"entryDN\",\n        UserObjectClasses = new[]\n        {\n            \"simpleSecurityObject\",\n            \"organizationalRole\",\n        },\n        ConnectionUrl = \"ldap://openldap\",\n        UsersDn = \"dc=example,dc=org\",\n        BindDn = \"cn=admin,dc=example,dc=org\",\n        BindCredential = \"admin\",\n    });\n\n    var assignAdminRoleToAllUsers = new Keycloak.Ldap.HardcodedRoleMapper(\"assign_admin_role_to_all_users\", new()\n    {\n        RealmId = realm.Id,\n        LdapUserFederationId = ldapUserFederation.Id,\n        Name = \"assign-admin-role-to-all-users\",\n        Role = \"admin\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"test\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldap_user_federation\", \u0026ldap.UserFederationArgs{\n\t\t\tName:                  pulumi.String(\"openldap\"),\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewHardcodedRoleMapper(ctx, \"assign_admin_role_to_all_users\", \u0026ldap.HardcodedRoleMapperArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t\tName:                 pulumi.String(\"assign-admin-role-to-all-users\"),\n\t\t\tRole:                 pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.ldap.UserFederation;\nimport com.pulumi.keycloak.ldap.UserFederationArgs;\nimport com.pulumi.keycloak.ldap.HardcodedRoleMapper;\nimport com.pulumi.keycloak.ldap.HardcodedRoleMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"test\")\n            .enabled(true)\n            .build());\n\n        var ldapUserFederation = new UserFederation(\"ldapUserFederation\", UserFederationArgs.builder()\n            .name(\"openldap\")\n            .realmId(realm.id())\n            .usernameLdapAttribute(\"cn\")\n            .rdnLdapAttribute(\"cn\")\n            .uuidLdapAttribute(\"entryDN\")\n            .userObjectClasses(            \n                \"simpleSecurityObject\",\n                \"organizationalRole\")\n            .connectionUrl(\"ldap://openldap\")\n            .usersDn(\"dc=example,dc=org\")\n            .bindDn(\"cn=admin,dc=example,dc=org\")\n            .bindCredential(\"admin\")\n            .build());\n\n        var assignAdminRoleToAllUsers = new HardcodedRoleMapper(\"assignAdminRoleToAllUsers\", HardcodedRoleMapperArgs.builder()\n            .realmId(realm.id())\n            .ldapUserFederationId(ldapUserFederation.id())\n            .name(\"assign-admin-role-to-all-users\")\n            .role(\"admin\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: test\n      enabled: true\n  ldapUserFederation:\n    type: keycloak:ldap:UserFederation\n    name: ldap_user_federation\n    properties:\n      name: openldap\n      realmId: ${realm.id}\n      usernameLdapAttribute: cn\n      rdnLdapAttribute: cn\n      uuidLdapAttribute: entryDN\n      userObjectClasses:\n        - simpleSecurityObject\n        - organizationalRole\n      connectionUrl: ldap://openldap\n      usersDn: dc=example,dc=org\n      bindDn: cn=admin,dc=example,dc=org\n      bindCredential: admin\n  assignAdminRoleToAllUsers:\n    type: keycloak:ldap:HardcodedRoleMapper\n    name: assign_admin_role_to_all_users\n    properties:\n      realmId: ${realm.id}\n      ldapUserFederationId: ${ldapUserFederation.id}\n      name: assign-admin-role-to-all-users\n      role: admin\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm that this LDAP mapper will exist in.\n- `ldap_user_federation_id` - (Required) The ID of the LDAP user federation provider to attach this mapper to.\n- `name` - (Required) Display name of this mapper when displayed in the console.\n- `role` - (Required) The role which should be assigned to the users.\n\n### Import\n\nLDAP mappers can be imported using the format `{{realm_id}}/{{ldap_user_federation_id}}/{{ldap_mapper_id}}`.\nThe ID of the LDAP user federation provider and the mapper can be found within\nthe Keycloak GUI, and they are typically GUIDs:\n\n```bash\n$ terraform import keycloak_ldap_hardcoded_role_mapper.ldap_hardcoded_role_mapper my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860/3d923ece-1a91-4bf7-adaf-3b82f2a12b67\n```\n",
            "properties": {
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role to grant to user.\n"
                }
            },
            "required": [
                "ldapUserFederationId",
                "name",
                "realmId",
                "role"
            ],
            "inputProperties": {
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n",
                    "willReplaceOnChanges": true
                },
                "role": {
                    "type": "string",
                    "description": "Role to grant to user.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "ldapUserFederationId",
                "realmId",
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedRoleMapper resources.\n",
                "properties": {
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ldap user federation provider to attach this mapper to.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm in which the ldap user federation provider exists.\n",
                        "willReplaceOnChanges": true
                    },
                    "role": {
                        "type": "string",
                        "description": "Role to grant to user.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/msadLdsUserAccountControlMapper:MsadLdsUserAccountControlMapper": {
            "description": "Allows for creating and managing MSAD-LDS user account control mappers for Keycloak\nusers federated via LDAP.\n\nThe MSAD-LDS (Microsoft Active Directory Lightweight Directory Service) user account control mapper is specific\nto LDAP user federation providers that are pulling from AD-LDS, and it can propagate\nAD-LDS user state to Keycloak in order to enforce settings like expired passwords\nor disabled accounts.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldap_user_federation\", {\n    name: \"ad\",\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"objectGUID\",\n    userObjectClasses: [\n        \"person\",\n        \"organizationalPerson\",\n        \"user\",\n    ],\n    connectionUrl: \"ldap://my-ad-server\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst msadLdsUserAccountControlMapper = new keycloak.ldap.MsadLdsUserAccountControlMapper(\"msad_lds_user_account_control_mapper\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    name: \"msad-lds-user-account-control-mapper\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldap_user_federation\",\n    name=\"ad\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"objectGUID\",\n    user_object_classes=[\n        \"person\",\n        \"organizationalPerson\",\n        \"user\",\n    ],\n    connection_url=\"ldap://my-ad-server\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nmsad_lds_user_account_control_mapper = keycloak.ldap.MsadLdsUserAccountControlMapper(\"msad_lds_user_account_control_mapper\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    name=\"msad-lds-user-account-control-mapper\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldap_user_federation\", new()\n    {\n        Name = \"ad\",\n        RealmId = realm.Id,\n        UsernameLdapAttribute = \"cn\",\n        RdnLdapAttribute = \"cn\",\n        UuidLdapAttribute = \"objectGUID\",\n        UserObjectClasses = new[]\n        {\n            \"person\",\n            \"organizationalPerson\",\n            \"user\",\n        },\n        ConnectionUrl = \"ldap://my-ad-server\",\n        UsersDn = \"dc=example,dc=org\",\n        BindDn = \"cn=admin,dc=example,dc=org\",\n        BindCredential = \"admin\",\n    });\n\n    var msadLdsUserAccountControlMapper = new Keycloak.Ldap.MsadLdsUserAccountControlMapper(\"msad_lds_user_account_control_mapper\", new()\n    {\n        RealmId = realm.Id,\n        LdapUserFederationId = ldapUserFederation.Id,\n        Name = \"msad-lds-user-account-control-mapper\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldap_user_federation\", \u0026ldap.UserFederationArgs{\n\t\t\tName:                  pulumi.String(\"ad\"),\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"objectGUID\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"person\"),\n\t\t\t\tpulumi.String(\"organizationalPerson\"),\n\t\t\t\tpulumi.String(\"user\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://my-ad-server\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewMsadLdsUserAccountControlMapper(ctx, \"msad_lds_user_account_control_mapper\", \u0026ldap.MsadLdsUserAccountControlMapperArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t\tName:                 pulumi.String(\"msad-lds-user-account-control-mapper\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.ldap.UserFederation;\nimport com.pulumi.keycloak.ldap.UserFederationArgs;\nimport com.pulumi.keycloak.ldap.MsadLdsUserAccountControlMapper;\nimport com.pulumi.keycloak.ldap.MsadLdsUserAccountControlMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var ldapUserFederation = new UserFederation(\"ldapUserFederation\", UserFederationArgs.builder()\n            .name(\"ad\")\n            .realmId(realm.id())\n            .usernameLdapAttribute(\"cn\")\n            .rdnLdapAttribute(\"cn\")\n            .uuidLdapAttribute(\"objectGUID\")\n            .userObjectClasses(            \n                \"person\",\n                \"organizationalPerson\",\n                \"user\")\n            .connectionUrl(\"ldap://my-ad-server\")\n            .usersDn(\"dc=example,dc=org\")\n            .bindDn(\"cn=admin,dc=example,dc=org\")\n            .bindCredential(\"admin\")\n            .build());\n\n        var msadLdsUserAccountControlMapper = new MsadLdsUserAccountControlMapper(\"msadLdsUserAccountControlMapper\", MsadLdsUserAccountControlMapperArgs.builder()\n            .realmId(realm.id())\n            .ldapUserFederationId(ldapUserFederation.id())\n            .name(\"msad-lds-user-account-control-mapper\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  ldapUserFederation:\n    type: keycloak:ldap:UserFederation\n    name: ldap_user_federation\n    properties:\n      name: ad\n      realmId: ${realm.id}\n      usernameLdapAttribute: cn\n      rdnLdapAttribute: cn\n      uuidLdapAttribute: objectGUID\n      userObjectClasses:\n        - person\n        - organizationalPerson\n        - user\n      connectionUrl: ldap://my-ad-server\n      usersDn: dc=example,dc=org\n      bindDn: cn=admin,dc=example,dc=org\n      bindCredential: admin\n  msadLdsUserAccountControlMapper:\n    type: keycloak:ldap:MsadLdsUserAccountControlMapper\n    name: msad_lds_user_account_control_mapper\n    properties:\n      realmId: ${realm.id}\n      ldapUserFederationId: ${ldapUserFederation.id}\n      name: msad-lds-user-account-control-mapper\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nLDAP mappers can be imported using the format `{{realm_id}}/{{ldap_user_federation_id}}/{{ldap_mapper_id}}`.\n\nThe ID of the LDAP user federation provider and the mapper can be found within the Keycloak GUI, and they are typically GUIDs.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:ldap/msadLdsUserAccountControlMapper:MsadLdsUserAccountControlMapper msad_lds_user_account_control_mapper my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860/3d923ece-1a91-4bf7-adaf-3b82f2a12b67\n```\n\n",
            "properties": {
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                }
            },
            "required": [
                "ldapUserFederationId",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "ldapUserFederationId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MsadLdsUserAccountControlMapper resources.\n",
                "properties": {
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ID of the LDAP user federation provider to attach this mapper to.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this LDAP mapper will exist in.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/msadUserAccountControlMapper:MsadUserAccountControlMapper": {
            "description": "## # keycloak.ldap.MsadUserAccountControlMapper\n\nAllows for creating and managing MSAD user account control mappers for Keycloak\nusers federated via LDAP.\n\nThe MSAD (Microsoft Active Directory) user account control mapper is specific\nto LDAP user federation providers that are pulling from AD, and it can propagate\nAD user state to Keycloak in order to enforce settings like expired passwords\nor disabled accounts.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"test\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldap_user_federation\", {\n    name: \"ad\",\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"objectGUID\",\n    userObjectClasses: [\n        \"person\",\n        \"organizationalPerson\",\n        \"user\",\n    ],\n    connectionUrl: \"ldap://my-ad-server\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst msadUserAccountControlMapper = new keycloak.ldap.MsadUserAccountControlMapper(\"msad_user_account_control_mapper\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    name: \"msad-user-account-control-mapper\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"test\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldap_user_federation\",\n    name=\"ad\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"objectGUID\",\n    user_object_classes=[\n        \"person\",\n        \"organizationalPerson\",\n        \"user\",\n    ],\n    connection_url=\"ldap://my-ad-server\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nmsad_user_account_control_mapper = keycloak.ldap.MsadUserAccountControlMapper(\"msad_user_account_control_mapper\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    name=\"msad-user-account-control-mapper\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"test\",\n        Enabled = true,\n    });\n\n    var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldap_user_federation\", new()\n    {\n        Name = \"ad\",\n        RealmId = realm.Id,\n        UsernameLdapAttribute = \"cn\",\n        RdnLdapAttribute = \"cn\",\n        UuidLdapAttribute = \"objectGUID\",\n        UserObjectClasses = new[]\n        {\n            \"person\",\n            \"organizationalPerson\",\n            \"user\",\n        },\n        ConnectionUrl = \"ldap://my-ad-server\",\n        UsersDn = \"dc=example,dc=org\",\n        BindDn = \"cn=admin,dc=example,dc=org\",\n        BindCredential = \"admin\",\n    });\n\n    var msadUserAccountControlMapper = new Keycloak.Ldap.MsadUserAccountControlMapper(\"msad_user_account_control_mapper\", new()\n    {\n        RealmId = realm.Id,\n        LdapUserFederationId = ldapUserFederation.Id,\n        Name = \"msad-user-account-control-mapper\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"test\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldap_user_federation\", \u0026ldap.UserFederationArgs{\n\t\t\tName:                  pulumi.String(\"ad\"),\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"objectGUID\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"person\"),\n\t\t\t\tpulumi.String(\"organizationalPerson\"),\n\t\t\t\tpulumi.String(\"user\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://my-ad-server\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewMsadUserAccountControlMapper(ctx, \"msad_user_account_control_mapper\", \u0026ldap.MsadUserAccountControlMapperArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t\tName:                 pulumi.String(\"msad-user-account-control-mapper\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.ldap.UserFederation;\nimport com.pulumi.keycloak.ldap.UserFederationArgs;\nimport com.pulumi.keycloak.ldap.MsadUserAccountControlMapper;\nimport com.pulumi.keycloak.ldap.MsadUserAccountControlMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"test\")\n            .enabled(true)\n            .build());\n\n        var ldapUserFederation = new UserFederation(\"ldapUserFederation\", UserFederationArgs.builder()\n            .name(\"ad\")\n            .realmId(realm.id())\n            .usernameLdapAttribute(\"cn\")\n            .rdnLdapAttribute(\"cn\")\n            .uuidLdapAttribute(\"objectGUID\")\n            .userObjectClasses(            \n                \"person\",\n                \"organizationalPerson\",\n                \"user\")\n            .connectionUrl(\"ldap://my-ad-server\")\n            .usersDn(\"dc=example,dc=org\")\n            .bindDn(\"cn=admin,dc=example,dc=org\")\n            .bindCredential(\"admin\")\n            .build());\n\n        var msadUserAccountControlMapper = new MsadUserAccountControlMapper(\"msadUserAccountControlMapper\", MsadUserAccountControlMapperArgs.builder()\n            .realmId(realm.id())\n            .ldapUserFederationId(ldapUserFederation.id())\n            .name(\"msad-user-account-control-mapper\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: test\n      enabled: true\n  ldapUserFederation:\n    type: keycloak:ldap:UserFederation\n    name: ldap_user_federation\n    properties:\n      name: ad\n      realmId: ${realm.id}\n      usernameLdapAttribute: cn\n      rdnLdapAttribute: cn\n      uuidLdapAttribute: objectGUID\n      userObjectClasses:\n        - person\n        - organizationalPerson\n        - user\n      connectionUrl: ldap://my-ad-server\n      usersDn: dc=example,dc=org\n      bindDn: cn=admin,dc=example,dc=org\n      bindCredential: admin\n  msadUserAccountControlMapper:\n    type: keycloak:ldap:MsadUserAccountControlMapper\n    name: msad_user_account_control_mapper\n    properties:\n      realmId: ${realm.id}\n      ldapUserFederationId: ${ldapUserFederation.id}\n      name: msad-user-account-control-mapper\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm that this LDAP mapper will exist in.\n- `ldap_user_federation_id` - (Required) The ID of the LDAP user federation provider to attach this mapper to.\n- `name` - (Required) Display name of this mapper when displayed in the console.\n- `ldap_password_policy_hints_enabled` - (Optional) When `true`, advanced password policies, such as password hints and previous password history will be used when writing new passwords to AD. Defaults to `false`.\n\n### Import\n\nLDAP mappers can be imported using the format `{{realm_id}}/{{ldap_user_federation_id}}/{{ldap_mapper_id}}`.\nThe ID of the LDAP user federation provider and the mapper can be found within\nthe Keycloak GUI, and they are typically GUIDs:\n\n```bash\n$ terraform import keycloak_ldap_msad_user_account_control_mapper.msad_user_account_control_mapper my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860/3d923ece-1a91-4bf7-adaf-3b82f2a12b67\n```\n",
            "properties": {
                "ldapPasswordPolicyHintsEnabled": {
                    "type": "boolean"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                }
            },
            "required": [
                "ldapUserFederationId",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "ldapPasswordPolicyHintsEnabled": {
                    "type": "boolean"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "ldapUserFederationId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MsadUserAccountControlMapper resources.\n",
                "properties": {
                    "ldapPasswordPolicyHintsEnabled": {
                        "type": "boolean"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ldap user federation provider to attach this mapper to.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm in which the ldap user federation provider exists.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/roleMapper:RoleMapper": {
            "description": "Allows for creating and managing role mappers for Keycloak users federated via LDAP.\n\nThe LDAP group mapper can be used to map an LDAP user's roles from some DN to Keycloak roles.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldap_user_federation\", {\n    name: \"openldap\",\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst ldapRoleMapper = new keycloak.ldap.RoleMapper(\"ldap_role_mapper\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    name: \"role-mapper\",\n    ldapRolesDn: \"dc=example,dc=org\",\n    roleNameLdapAttribute: \"cn\",\n    roleObjectClasses: [\"groupOfNames\"],\n    membershipAttributeType: \"DN\",\n    membershipLdapAttribute: \"member\",\n    membershipUserLdapAttribute: \"cn\",\n    userRolesRetrieveStrategy: \"GET_ROLES_FROM_USER_MEMBEROF_ATTRIBUTE\",\n    memberofLdapAttribute: \"memberOf\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldap_user_federation\",\n    name=\"openldap\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nldap_role_mapper = keycloak.ldap.RoleMapper(\"ldap_role_mapper\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    name=\"role-mapper\",\n    ldap_roles_dn=\"dc=example,dc=org\",\n    role_name_ldap_attribute=\"cn\",\n    role_object_classes=[\"groupOfNames\"],\n    membership_attribute_type=\"DN\",\n    membership_ldap_attribute=\"member\",\n    membership_user_ldap_attribute=\"cn\",\n    user_roles_retrieve_strategy=\"GET_ROLES_FROM_USER_MEMBEROF_ATTRIBUTE\",\n    memberof_ldap_attribute=\"memberOf\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldap_user_federation\", new()\n    {\n        Name = \"openldap\",\n        RealmId = realm.Id,\n        UsernameLdapAttribute = \"cn\",\n        RdnLdapAttribute = \"cn\",\n        UuidLdapAttribute = \"entryDN\",\n        UserObjectClasses = new[]\n        {\n            \"simpleSecurityObject\",\n            \"organizationalRole\",\n        },\n        ConnectionUrl = \"ldap://openldap\",\n        UsersDn = \"dc=example,dc=org\",\n        BindDn = \"cn=admin,dc=example,dc=org\",\n        BindCredential = \"admin\",\n    });\n\n    var ldapRoleMapper = new Keycloak.Ldap.RoleMapper(\"ldap_role_mapper\", new()\n    {\n        RealmId = realm.Id,\n        LdapUserFederationId = ldapUserFederation.Id,\n        Name = \"role-mapper\",\n        LdapRolesDn = \"dc=example,dc=org\",\n        RoleNameLdapAttribute = \"cn\",\n        RoleObjectClasses = new[]\n        {\n            \"groupOfNames\",\n        },\n        MembershipAttributeType = \"DN\",\n        MembershipLdapAttribute = \"member\",\n        MembershipUserLdapAttribute = \"cn\",\n        UserRolesRetrieveStrategy = \"GET_ROLES_FROM_USER_MEMBEROF_ATTRIBUTE\",\n        MemberofLdapAttribute = \"memberOf\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldap_user_federation\", \u0026ldap.UserFederationArgs{\n\t\t\tName:                  pulumi.String(\"openldap\"),\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewRoleMapper(ctx, \"ldap_role_mapper\", \u0026ldap.RoleMapperArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tLdapUserFederationId:  ldapUserFederation.ID(),\n\t\t\tName:                  pulumi.String(\"role-mapper\"),\n\t\t\tLdapRolesDn:           pulumi.String(\"dc=example,dc=org\"),\n\t\t\tRoleNameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRoleObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"groupOfNames\"),\n\t\t\t},\n\t\t\tMembershipAttributeType:     pulumi.String(\"DN\"),\n\t\t\tMembershipLdapAttribute:     pulumi.String(\"member\"),\n\t\t\tMembershipUserLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tUserRolesRetrieveStrategy:   pulumi.String(\"GET_ROLES_FROM_USER_MEMBEROF_ATTRIBUTE\"),\n\t\t\tMemberofLdapAttribute:       pulumi.String(\"memberOf\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.ldap.UserFederation;\nimport com.pulumi.keycloak.ldap.UserFederationArgs;\nimport com.pulumi.keycloak.ldap.RoleMapper;\nimport com.pulumi.keycloak.ldap.RoleMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var ldapUserFederation = new UserFederation(\"ldapUserFederation\", UserFederationArgs.builder()\n            .name(\"openldap\")\n            .realmId(realm.id())\n            .usernameLdapAttribute(\"cn\")\n            .rdnLdapAttribute(\"cn\")\n            .uuidLdapAttribute(\"entryDN\")\n            .userObjectClasses(            \n                \"simpleSecurityObject\",\n                \"organizationalRole\")\n            .connectionUrl(\"ldap://openldap\")\n            .usersDn(\"dc=example,dc=org\")\n            .bindDn(\"cn=admin,dc=example,dc=org\")\n            .bindCredential(\"admin\")\n            .build());\n\n        var ldapRoleMapper = new RoleMapper(\"ldapRoleMapper\", RoleMapperArgs.builder()\n            .realmId(realm.id())\n            .ldapUserFederationId(ldapUserFederation.id())\n            .name(\"role-mapper\")\n            .ldapRolesDn(\"dc=example,dc=org\")\n            .roleNameLdapAttribute(\"cn\")\n            .roleObjectClasses(\"groupOfNames\")\n            .membershipAttributeType(\"DN\")\n            .membershipLdapAttribute(\"member\")\n            .membershipUserLdapAttribute(\"cn\")\n            .userRolesRetrieveStrategy(\"GET_ROLES_FROM_USER_MEMBEROF_ATTRIBUTE\")\n            .memberofLdapAttribute(\"memberOf\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  ldapUserFederation:\n    type: keycloak:ldap:UserFederation\n    name: ldap_user_federation\n    properties:\n      name: openldap\n      realmId: ${realm.id}\n      usernameLdapAttribute: cn\n      rdnLdapAttribute: cn\n      uuidLdapAttribute: entryDN\n      userObjectClasses:\n        - simpleSecurityObject\n        - organizationalRole\n      connectionUrl: ldap://openldap\n      usersDn: dc=example,dc=org\n      bindDn: cn=admin,dc=example,dc=org\n      bindCredential: admin\n  ldapRoleMapper:\n    type: keycloak:ldap:RoleMapper\n    name: ldap_role_mapper\n    properties:\n      realmId: ${realm.id}\n      ldapUserFederationId: ${ldapUserFederation.id}\n      name: role-mapper\n      ldapRolesDn: dc=example,dc=org\n      roleNameLdapAttribute: cn\n      roleObjectClasses:\n        - groupOfNames\n      membershipAttributeType: DN\n      membershipLdapAttribute: member\n      membershipUserLdapAttribute: cn\n      userRolesRetrieveStrategy: GET_ROLES_FROM_USER_MEMBEROF_ATTRIBUTE\n      memberofLdapAttribute: memberOf\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nLDAP mappers can be imported using the format `{{realm_id}}/{{ldap_user_federation_id}}/{{ldap_mapper_id}}`.\n\nThe ID of the LDAP user federation provider and the mapper can be found within the Keycloak GUI, and they are typically GUIDs.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:ldap/roleMapper:RoleMapper ldap_role_mapper my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860/3d923ece-1a91-4bf7-adaf-3b82f2a12b67\n```\n\n",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "When specified, LDAP role mappings will be mapped to client role mappings tied to this client ID. Can only be set if `use_realm_roles_mapping` is `false`.\n"
                },
                "ldapRolesDn": {
                    "type": "string",
                    "description": "The LDAP DN where roles can be found.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "memberofLdapAttribute": {
                    "type": "string",
                    "description": "Specifies the name of the LDAP attribute on the LDAP user that contains the roles the user has. Defaults to `memberOf`. This is only used when\n"
                },
                "membershipAttributeType": {
                    "type": "string",
                    "description": "Can be one of `DN` or `UID`. Defaults to `DN`.\n"
                },
                "membershipLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute that is used for membership mappings.\n"
                },
                "membershipUserLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute on a user that is used for membership mappings.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Can be one of `READ_ONLY`, `LDAP_ONLY` or `IMPORT`. Defaults to `READ_ONLY`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                },
                "roleNameLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute that is used in role objects for the name and RDN of the role. Typically `cn`.\n"
                },
                "roleObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings representing the object classes for the role. Must contain at least one.\n"
                },
                "rolesLdapFilter": {
                    "type": "string",
                    "description": "When specified, adds an additional custom filter to be used when querying for roles. Must start with `(` and end with `)`.\n"
                },
                "useRealmRolesMapping": {
                    "type": "boolean",
                    "description": "When `true`, LDAP role mappings will be mapped to realm roles within Keycloak. Defaults to `true`.\n"
                },
                "userRolesRetrieveStrategy": {
                    "type": "string",
                    "description": "Can be one of `LOAD_ROLES_BY_MEMBER_ATTRIBUTE`, `GET_ROLES_FROM_USER_MEMBEROF_ATTRIBUTE`, or `LOAD_ROLES_BY_MEMBER_ATTRIBUTE_RECURSIVELY`. Defaults to `LOAD_ROLES_BY_MEMBER_ATTRIBUTE`.\n"
                }
            },
            "required": [
                "ldapRolesDn",
                "ldapUserFederationId",
                "membershipLdapAttribute",
                "membershipUserLdapAttribute",
                "name",
                "realmId",
                "roleNameLdapAttribute",
                "roleObjectClasses"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "When specified, LDAP role mappings will be mapped to client role mappings tied to this client ID. Can only be set if `use_realm_roles_mapping` is `false`.\n"
                },
                "ldapRolesDn": {
                    "type": "string",
                    "description": "The LDAP DN where roles can be found.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n",
                    "willReplaceOnChanges": true
                },
                "memberofLdapAttribute": {
                    "type": "string",
                    "description": "Specifies the name of the LDAP attribute on the LDAP user that contains the roles the user has. Defaults to `memberOf`. This is only used when\n"
                },
                "membershipAttributeType": {
                    "type": "string",
                    "description": "Can be one of `DN` or `UID`. Defaults to `DN`.\n"
                },
                "membershipLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute that is used for membership mappings.\n"
                },
                "membershipUserLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute on a user that is used for membership mappings.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Can be one of `READ_ONLY`, `LDAP_ONLY` or `IMPORT`. Defaults to `READ_ONLY`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n",
                    "willReplaceOnChanges": true
                },
                "roleNameLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute that is used in role objects for the name and RDN of the role. Typically `cn`.\n"
                },
                "roleObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings representing the object classes for the role. Must contain at least one.\n"
                },
                "rolesLdapFilter": {
                    "type": "string",
                    "description": "When specified, adds an additional custom filter to be used when querying for roles. Must start with `(` and end with `)`.\n"
                },
                "useRealmRolesMapping": {
                    "type": "boolean",
                    "description": "When `true`, LDAP role mappings will be mapped to realm roles within Keycloak. Defaults to `true`.\n"
                },
                "userRolesRetrieveStrategy": {
                    "type": "string",
                    "description": "Can be one of `LOAD_ROLES_BY_MEMBER_ATTRIBUTE`, `GET_ROLES_FROM_USER_MEMBEROF_ATTRIBUTE`, or `LOAD_ROLES_BY_MEMBER_ATTRIBUTE_RECURSIVELY`. Defaults to `LOAD_ROLES_BY_MEMBER_ATTRIBUTE`.\n"
                }
            },
            "requiredInputs": [
                "ldapRolesDn",
                "ldapUserFederationId",
                "membershipLdapAttribute",
                "membershipUserLdapAttribute",
                "realmId",
                "roleNameLdapAttribute",
                "roleObjectClasses"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RoleMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "When specified, LDAP role mappings will be mapped to client role mappings tied to this client ID. Can only be set if `use_realm_roles_mapping` is `false`.\n"
                    },
                    "ldapRolesDn": {
                        "type": "string",
                        "description": "The LDAP DN where roles can be found.\n"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ID of the LDAP user federation provider to attach this mapper to.\n",
                        "willReplaceOnChanges": true
                    },
                    "memberofLdapAttribute": {
                        "type": "string",
                        "description": "Specifies the name of the LDAP attribute on the LDAP user that contains the roles the user has. Defaults to `memberOf`. This is only used when\n"
                    },
                    "membershipAttributeType": {
                        "type": "string",
                        "description": "Can be one of `DN` or `UID`. Defaults to `DN`.\n"
                    },
                    "membershipLdapAttribute": {
                        "type": "string",
                        "description": "The name of the LDAP attribute that is used for membership mappings.\n"
                    },
                    "membershipUserLdapAttribute": {
                        "type": "string",
                        "description": "The name of the LDAP attribute on a user that is used for membership mappings.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "Can be one of `READ_ONLY`, `LDAP_ONLY` or `IMPORT`. Defaults to `READ_ONLY`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this LDAP mapper will exist in.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleNameLdapAttribute": {
                        "type": "string",
                        "description": "The name of the LDAP attribute that is used in role objects for the name and RDN of the role. Typically `cn`.\n"
                    },
                    "roleObjectClasses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings representing the object classes for the role. Must contain at least one.\n"
                    },
                    "rolesLdapFilter": {
                        "type": "string",
                        "description": "When specified, adds an additional custom filter to be used when querying for roles. Must start with `(` and end with `)`.\n"
                    },
                    "useRealmRolesMapping": {
                        "type": "boolean",
                        "description": "When `true`, LDAP role mappings will be mapped to realm roles within Keycloak. Defaults to `true`.\n"
                    },
                    "userRolesRetrieveStrategy": {
                        "type": "string",
                        "description": "Can be one of `LOAD_ROLES_BY_MEMBER_ATTRIBUTE`, `GET_ROLES_FROM_USER_MEMBEROF_ATTRIBUTE`, or `LOAD_ROLES_BY_MEMBER_ATTRIBUTE_RECURSIVELY`. Defaults to `LOAD_ROLES_BY_MEMBER_ATTRIBUTE`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/userAttributeMapper:UserAttributeMapper": {
            "description": "## # keycloak.ldap.UserAttributeMapper\n\nAllows for creating and managing user attribute mappers for Keycloak users\nfederated via LDAP.\n\nThe LDAP user attribute mapper can be used to map a single LDAP attribute\nto an attribute on the Keycloak user model.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"test\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldap_user_federation\", {\n    name: \"openldap\",\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst ldapUserAttributeMapper = new keycloak.ldap.UserAttributeMapper(\"ldap_user_attribute_mapper\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    name: \"user-attribute-mapper\",\n    userModelAttribute: \"foo\",\n    ldapAttribute: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"test\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldap_user_federation\",\n    name=\"openldap\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nldap_user_attribute_mapper = keycloak.ldap.UserAttributeMapper(\"ldap_user_attribute_mapper\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    name=\"user-attribute-mapper\",\n    user_model_attribute=\"foo\",\n    ldap_attribute=\"bar\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"test\",\n        Enabled = true,\n    });\n\n    var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldap_user_federation\", new()\n    {\n        Name = \"openldap\",\n        RealmId = realm.Id,\n        UsernameLdapAttribute = \"cn\",\n        RdnLdapAttribute = \"cn\",\n        UuidLdapAttribute = \"entryDN\",\n        UserObjectClasses = new[]\n        {\n            \"simpleSecurityObject\",\n            \"organizationalRole\",\n        },\n        ConnectionUrl = \"ldap://openldap\",\n        UsersDn = \"dc=example,dc=org\",\n        BindDn = \"cn=admin,dc=example,dc=org\",\n        BindCredential = \"admin\",\n    });\n\n    var ldapUserAttributeMapper = new Keycloak.Ldap.UserAttributeMapper(\"ldap_user_attribute_mapper\", new()\n    {\n        RealmId = realm.Id,\n        LdapUserFederationId = ldapUserFederation.Id,\n        Name = \"user-attribute-mapper\",\n        UserModelAttribute = \"foo\",\n        LdapAttribute = \"bar\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"test\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldap_user_federation\", \u0026ldap.UserFederationArgs{\n\t\t\tName:                  pulumi.String(\"openldap\"),\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewUserAttributeMapper(ctx, \"ldap_user_attribute_mapper\", \u0026ldap.UserAttributeMapperArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t\tName:                 pulumi.String(\"user-attribute-mapper\"),\n\t\t\tUserModelAttribute:   pulumi.String(\"foo\"),\n\t\t\tLdapAttribute:        pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.ldap.UserFederation;\nimport com.pulumi.keycloak.ldap.UserFederationArgs;\nimport com.pulumi.keycloak.ldap.UserAttributeMapper;\nimport com.pulumi.keycloak.ldap.UserAttributeMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"test\")\n            .enabled(true)\n            .build());\n\n        var ldapUserFederation = new UserFederation(\"ldapUserFederation\", UserFederationArgs.builder()\n            .name(\"openldap\")\n            .realmId(realm.id())\n            .usernameLdapAttribute(\"cn\")\n            .rdnLdapAttribute(\"cn\")\n            .uuidLdapAttribute(\"entryDN\")\n            .userObjectClasses(            \n                \"simpleSecurityObject\",\n                \"organizationalRole\")\n            .connectionUrl(\"ldap://openldap\")\n            .usersDn(\"dc=example,dc=org\")\n            .bindDn(\"cn=admin,dc=example,dc=org\")\n            .bindCredential(\"admin\")\n            .build());\n\n        var ldapUserAttributeMapper = new UserAttributeMapper(\"ldapUserAttributeMapper\", UserAttributeMapperArgs.builder()\n            .realmId(realm.id())\n            .ldapUserFederationId(ldapUserFederation.id())\n            .name(\"user-attribute-mapper\")\n            .userModelAttribute(\"foo\")\n            .ldapAttribute(\"bar\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: test\n      enabled: true\n  ldapUserFederation:\n    type: keycloak:ldap:UserFederation\n    name: ldap_user_federation\n    properties:\n      name: openldap\n      realmId: ${realm.id}\n      usernameLdapAttribute: cn\n      rdnLdapAttribute: cn\n      uuidLdapAttribute: entryDN\n      userObjectClasses:\n        - simpleSecurityObject\n        - organizationalRole\n      connectionUrl: ldap://openldap\n      usersDn: dc=example,dc=org\n      bindDn: cn=admin,dc=example,dc=org\n      bindCredential: admin\n  ldapUserAttributeMapper:\n    type: keycloak:ldap:UserAttributeMapper\n    name: ldap_user_attribute_mapper\n    properties:\n      realmId: ${realm.id}\n      ldapUserFederationId: ${ldapUserFederation.id}\n      name: user-attribute-mapper\n      userModelAttribute: foo\n      ldapAttribute: bar\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm that this LDAP mapper will exist in.\n- `ldap_user_federation_id` - (Required) The ID of the LDAP user federation provider to attach this mapper to.\n- `name` - (Required) Display name of this mapper when displayed in the console.\n- `user_model_attribute` - (Required) Name of the user property or attribute you want to map the LDAP attribute into.\n- `ldap_attribute` - (Required) Name of the mapped attribute on the LDAP object.\n- `read_only` - (Optional) When `true`, this attribute is not saved back to LDAP when the user attribute is updated in Keycloak. Defaults to `false`.\n- `always_read_value_from_ldap` - (Optional) When `true`, the value fetched from LDAP will override the value stored in Keycloak. Defaults to `false`.\n- `is_mandatory_in_ldap` - (Optional) When `true`, this attribute must exist in LDAP. Defaults to `false`.\n\n### Import\n\nLDAP mappers can be imported using the format `{{realm_id}}/{{ldap_user_federation_id}}/{{ldap_mapper_id}}`.\nThe ID of the LDAP user federation provider and the mapper can be found within\nthe Keycloak GUI, and they are typically GUIDs:\n\n```bash\n$ terraform import keycloak_ldap_user_attribute_mapper.ldap_user_attribute_mapper my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860/3d923ece-1a91-4bf7-adaf-3b82f2a12b67\n```\n",
            "properties": {
                "alwaysReadValueFromLdap": {
                    "type": "boolean",
                    "description": "When true, the value fetched from LDAP will override the value stored in Keycloak.\n"
                },
                "attributeDefaultValue": {
                    "type": "string",
                    "description": "Default value to set in LDAP if is_mandatory_in_ldap and the value is empty\n"
                },
                "isBinaryAttribute": {
                    "type": "boolean",
                    "description": "Should be true for binary LDAP attributes\n"
                },
                "isMandatoryInLdap": {
                    "type": "boolean",
                    "description": "When true, this attribute must exist in LDAP.\n"
                },
                "ldapAttribute": {
                    "type": "string",
                    "description": "Name of the mapped attribute on LDAP object.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "When true, this attribute is not saved back to LDAP when the user attribute is updated in Keycloak.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                },
                "userModelAttribute": {
                    "type": "string",
                    "description": "Name of the UserModel property or attribute you want to map the LDAP attribute into.\n"
                }
            },
            "required": [
                "ldapAttribute",
                "ldapUserFederationId",
                "name",
                "realmId",
                "userModelAttribute"
            ],
            "inputProperties": {
                "alwaysReadValueFromLdap": {
                    "type": "boolean",
                    "description": "When true, the value fetched from LDAP will override the value stored in Keycloak.\n"
                },
                "attributeDefaultValue": {
                    "type": "string",
                    "description": "Default value to set in LDAP if is_mandatory_in_ldap and the value is empty\n"
                },
                "isBinaryAttribute": {
                    "type": "boolean",
                    "description": "Should be true for binary LDAP attributes\n"
                },
                "isMandatoryInLdap": {
                    "type": "boolean",
                    "description": "When true, this attribute must exist in LDAP.\n"
                },
                "ldapAttribute": {
                    "type": "string",
                    "description": "Name of the mapped attribute on LDAP object.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "When true, this attribute is not saved back to LDAP when the user attribute is updated in Keycloak.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n",
                    "willReplaceOnChanges": true
                },
                "userModelAttribute": {
                    "type": "string",
                    "description": "Name of the UserModel property or attribute you want to map the LDAP attribute into.\n"
                }
            },
            "requiredInputs": [
                "ldapAttribute",
                "ldapUserFederationId",
                "realmId",
                "userModelAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserAttributeMapper resources.\n",
                "properties": {
                    "alwaysReadValueFromLdap": {
                        "type": "boolean",
                        "description": "When true, the value fetched from LDAP will override the value stored in Keycloak.\n"
                    },
                    "attributeDefaultValue": {
                        "type": "string",
                        "description": "Default value to set in LDAP if is_mandatory_in_ldap and the value is empty\n"
                    },
                    "isBinaryAttribute": {
                        "type": "boolean",
                        "description": "Should be true for binary LDAP attributes\n"
                    },
                    "isMandatoryInLdap": {
                        "type": "boolean",
                        "description": "When true, this attribute must exist in LDAP.\n"
                    },
                    "ldapAttribute": {
                        "type": "string",
                        "description": "Name of the mapped attribute on LDAP object.\n"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ldap user federation provider to attach this mapper to.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the mapper when displayed in the console.\n"
                    },
                    "readOnly": {
                        "type": "boolean",
                        "description": "When true, this attribute is not saved back to LDAP when the user attribute is updated in Keycloak.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm in which the ldap user federation provider exists.\n",
                        "willReplaceOnChanges": true
                    },
                    "userModelAttribute": {
                        "type": "string",
                        "description": "Name of the UserModel property or attribute you want to map the LDAP attribute into.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/userFederation:UserFederation": {
            "description": "## # keycloak.ldap.UserFederation\n\nAllows for creating and managing LDAP user federation providers within Keycloak.\n\nKeycloak can use an LDAP user federation provider to federate users to Keycloak\nfrom a directory system such as LDAP or Active Directory. Federated users\nwill exist within the realm and will be able to log in to clients. Federated\nusers can have their attributes defined using mappers.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"test\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldap_user_federation\", {\n    name: \"openldap\",\n    realmId: realm.id,\n    enabled: true,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n    connectionTimeout: \"5s\",\n    readTimeout: \"10s\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"test\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldap_user_federation\",\n    name=\"openldap\",\n    realm_id=realm.id,\n    enabled=True,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\",\n    connection_timeout=\"5s\",\n    read_timeout=\"10s\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"test\",\n        Enabled = true,\n    });\n\n    var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldap_user_federation\", new()\n    {\n        Name = \"openldap\",\n        RealmId = realm.Id,\n        Enabled = true,\n        UsernameLdapAttribute = \"cn\",\n        RdnLdapAttribute = \"cn\",\n        UuidLdapAttribute = \"entryDN\",\n        UserObjectClasses = new[]\n        {\n            \"simpleSecurityObject\",\n            \"organizationalRole\",\n        },\n        ConnectionUrl = \"ldap://openldap\",\n        UsersDn = \"dc=example,dc=org\",\n        BindDn = \"cn=admin,dc=example,dc=org\",\n        BindCredential = \"admin\",\n        ConnectionTimeout = \"5s\",\n        ReadTimeout = \"10s\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"test\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewUserFederation(ctx, \"ldap_user_federation\", \u0026ldap.UserFederationArgs{\n\t\t\tName:                  pulumi.String(\"openldap\"),\n\t\t\tRealmId:               realm.ID(),\n\t\t\tEnabled:               pulumi.Bool(true),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:     pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:           pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:            pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential:    pulumi.String(\"admin\"),\n\t\t\tConnectionTimeout: pulumi.String(\"5s\"),\n\t\t\tReadTimeout:       pulumi.String(\"10s\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.ldap.UserFederation;\nimport com.pulumi.keycloak.ldap.UserFederationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"test\")\n            .enabled(true)\n            .build());\n\n        var ldapUserFederation = new UserFederation(\"ldapUserFederation\", UserFederationArgs.builder()\n            .name(\"openldap\")\n            .realmId(realm.id())\n            .enabled(true)\n            .usernameLdapAttribute(\"cn\")\n            .rdnLdapAttribute(\"cn\")\n            .uuidLdapAttribute(\"entryDN\")\n            .userObjectClasses(            \n                \"simpleSecurityObject\",\n                \"organizationalRole\")\n            .connectionUrl(\"ldap://openldap\")\n            .usersDn(\"dc=example,dc=org\")\n            .bindDn(\"cn=admin,dc=example,dc=org\")\n            .bindCredential(\"admin\")\n            .connectionTimeout(\"5s\")\n            .readTimeout(\"10s\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: test\n      enabled: true\n  ldapUserFederation:\n    type: keycloak:ldap:UserFederation\n    name: ldap_user_federation\n    properties:\n      name: openldap\n      realmId: ${realm.id}\n      enabled: true\n      usernameLdapAttribute: cn\n      rdnLdapAttribute: cn\n      uuidLdapAttribute: entryDN\n      userObjectClasses:\n        - simpleSecurityObject\n        - organizationalRole\n      connectionUrl: ldap://openldap\n      usersDn: dc=example,dc=org\n      bindDn: cn=admin,dc=example,dc=org\n      bindCredential: admin\n      connectionTimeout: 5s\n      readTimeout: 10s\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm that this provider will provide user federation for.\n- `name` - (Required) Display name of the provider when displayed in the console.\n- `enabled` - (Optional) When `false`, this provider will not be used when performing queries for users. Defaults to `true`.\n- `priority` - (Optional) Priority of this provider when looking up users. Lower values are first. Defaults to `0`.\n- `import_enabled` - (Optional) When `true`, LDAP users will be imported into the Keycloak database. Defaults to `true`.\n- `edit_mode` - (Optional) Can be one of `READ_ONLY`, `WRITABLE`, or `UNSYNCED`. `UNSYNCED` allows user data to be imported but not synced back to LDAP. Defaults to `READ_ONLY`.\n- `sync_registrations` - (Optional) When `true`, newly created users will be synced back to LDAP. Defaults to `false`.\n- `vendor` - (Optional) Can be one of `OTHER`, `EDIRECTORY`, `AD`, `RHDS`, or `TIVOLI`. When this is selected in the GUI, it provides reasonable defaults for other fields. When used with the Keycloak API, this attribute does nothing, but is still required. Defaults to `OPTIONAL`.\n- `username_ldap_attribute` - (Required) Name of the LDAP attribute to use as the Keycloak username.\n- `rdn_ldap_attribute` - (Required) Name of the LDAP attribute to use as the relative distinguished name.\n- `uuid_ldap_attribute` - (Required) Name of the LDAP attribute to use as a unique object identifier for objects in LDAP.\n- `user_object_classes` - (Required) Array of all values of LDAP objectClass attribute for users in LDAP. Must contain at least one.\n- `connection_url` - (Required) Connection URL to the LDAP server.\n- `users_dn` - (Required) Full DN of LDAP tree where your users are.\n- `bind_dn` - (Optional) DN of LDAP admin, which will be used by Keycloak to access LDAP server. This attribute must be set if `bind_credential` is set.\n- `bind_credential` - (Optional) Password of LDAP admin. This attribute must be set if `bind_dn` is set.\n- `custom_user_search_filter` - (Optional) Additional LDAP filter for filtering searched users. Must begin with `(` and end with `)`.\n- `search_scope` - (Optional) Can be one of `ONE_LEVEL` or `SUBTREE`:\n    - `ONE_LEVEL`: Only search for users in the DN specified by `user_dn`.\n    - `SUBTREE`: Search entire LDAP subtree.\n- `validate_password_policy` - (Optional) When `true`, Keycloak will validate passwords using the realm policy before updating it.\n- `use_truststore_spi` - (Optional) Can be one of `ALWAYS`, `ONLY_FOR_LDAPS`, or `NEVER`:\n    - `ALWAYS` - Always use the truststore SPI for LDAP connections.\n    - `NEVER` - Never use the truststore SPI for LDAP connections.\n    - `ONLY_FOR_LDAPS` - Only use the truststore SPI if your LDAP connection uses the ldaps protocol.\n- `connection_timeout` - (Optional) LDAP connection timeout in the format of a [Go duration string](https://golang.org/pkg/time/#Duration.String).\n- `read_timeout` - (Optional) LDAP read timeout in the format of a [Go duration string](https://golang.org/pkg/time/#Duration.String).\n- `pagination` - (Optional) When true, Keycloak assumes the LDAP server supports pagination. Defaults to `true`.\n- `batch_size_for_sync` - (Optional) The number of users to sync within a single transaction. Defaults to `1000`.\n- `full_sync_period` - (Optional) How frequently Keycloak should sync all LDAP users, in seconds. Omit this property to disable periodic full sync.\n- `changed_sync_period` - (Optional) How frequently Keycloak should sync changed LDAP users, in seconds. Omit this property to disable periodic changed users sync.\n- `cache_policy` - (Optional) Can be one of `DEFAULT`, `EVICT_DAILY`, `EVICT_WEEKLY`, `MAX_LIFESPAN`, or `NO_CACHE`. Defaults to `DEFAULT`.\n\n### Import\n\nLDAP user federation providers can be imported using the format `{{realm_id}}/{{ldap_user_federation_id}}`.\nThe ID of the LDAP user federation provider can be found within the Keycloak GUI and is typically a GUID:\n\n```bash\n$ terraform import keycloak_ldap_user_federation.ldap_user_federation my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860\n```\n",
            "properties": {
                "batchSizeForSync": {
                    "type": "integer",
                    "description": "The number of users to sync within a single transaction.\n"
                },
                "bindCredential": {
                    "type": "string",
                    "description": "Password of LDAP admin.\n",
                    "secret": true
                },
                "bindDn": {
                    "type": "string",
                    "description": "DN of LDAP admin, which will be used by Keycloak to access LDAP server.\n"
                },
                "cache": {
                    "$ref": "#/types/keycloak:ldap/UserFederationCache:UserFederationCache",
                    "description": "Settings regarding cache policy for this realm.\n"
                },
                "changedSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync changed LDAP users, in seconds. Omit this property to disable periodic changed users\nsync.\n"
                },
                "connectionTimeout": {
                    "type": "string",
                    "description": "LDAP connection timeout (duration string)\n"
                },
                "connectionUrl": {
                    "type": "string",
                    "description": "Connection URL to the LDAP server.\n"
                },
                "customUserSearchFilter": {
                    "type": "string",
                    "description": "Additional LDAP filter for filtering searched users. Must begin with '(' and end with ')'.\n"
                },
                "deleteDefaultMappers": {
                    "type": "boolean",
                    "description": "When true, the provider will delete the default mappers which are normally created by Keycloak when creating an LDAP\nuser federation provider.\n"
                },
                "editMode": {
                    "type": "string",
                    "description": "READ_ONLY and WRITABLE are self-explanatory. UNSYNCED allows user data to be imported but not synced back to LDAP.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When false, this provider will not be used when performing queries for users.\n"
                },
                "fullSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync all LDAP users, in seconds. Omit this property to disable periodic full sync.\n"
                },
                "importEnabled": {
                    "type": "boolean",
                    "description": "When true, LDAP users will be imported into the Keycloak database.\n"
                },
                "kerberos": {
                    "$ref": "#/types/keycloak:ldap/UserFederationKerberos:UserFederationKerberos",
                    "description": "Settings regarding kerberos authentication for this realm.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the provider when displayed in the console.\n"
                },
                "pagination": {
                    "type": "boolean",
                    "description": "When true, Keycloak assumes the LDAP server supports pagination.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of this provider when looking up users. Lower values are first.\n"
                },
                "rdnLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as the relative distinguished name.\n"
                },
                "readTimeout": {
                    "type": "string",
                    "description": "LDAP read timeout (duration string)\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this provider will provide user federation for.\n"
                },
                "searchScope": {
                    "type": "string",
                    "description": "ONE_LEVEL: only search for users in the DN specified by user_dn. SUBTREE: search entire LDAP subtree.\n"
                },
                "startTls": {
                    "type": "boolean",
                    "description": "When true, Keycloak will encrypt the connection to LDAP using STARTTLS, which will disable connection pooling.\n"
                },
                "syncRegistrations": {
                    "type": "boolean",
                    "description": "When true, newly created users will be synced back to LDAP.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "If enabled, email provided by this provider is not verified even if verification is enabled for the realm.\n"
                },
                "usePasswordModifyExtendedOp": {
                    "type": "boolean",
                    "description": "When `true`, use the LDAPv3 Password Modify Extended Operation (RFC-3062).\n"
                },
                "useTruststoreSpi": {
                    "type": "string"
                },
                "userObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "All values of LDAP objectClass attribute for users in LDAP.\n"
                },
                "usernameLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as the Keycloak username.\n"
                },
                "usersDn": {
                    "type": "string",
                    "description": "Full DN of LDAP tree where your users are.\n"
                },
                "uuidLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as a unique object identifier for objects in LDAP.\n"
                },
                "validatePasswordPolicy": {
                    "type": "boolean",
                    "description": "When true, Keycloak will validate passwords using the realm policy before updating it.\n"
                },
                "vendor": {
                    "type": "string",
                    "description": "LDAP vendor. I am almost certain this field does nothing, but the UI indicates that it is required.\n"
                }
            },
            "required": [
                "connectionUrl",
                "name",
                "rdnLdapAttribute",
                "realmId",
                "userObjectClasses",
                "usernameLdapAttribute",
                "usersDn",
                "uuidLdapAttribute"
            ],
            "inputProperties": {
                "batchSizeForSync": {
                    "type": "integer",
                    "description": "The number of users to sync within a single transaction.\n"
                },
                "bindCredential": {
                    "type": "string",
                    "description": "Password of LDAP admin.\n",
                    "secret": true
                },
                "bindDn": {
                    "type": "string",
                    "description": "DN of LDAP admin, which will be used by Keycloak to access LDAP server.\n"
                },
                "cache": {
                    "$ref": "#/types/keycloak:ldap/UserFederationCache:UserFederationCache",
                    "description": "Settings regarding cache policy for this realm.\n"
                },
                "changedSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync changed LDAP users, in seconds. Omit this property to disable periodic changed users\nsync.\n"
                },
                "connectionTimeout": {
                    "type": "string",
                    "description": "LDAP connection timeout (duration string)\n"
                },
                "connectionUrl": {
                    "type": "string",
                    "description": "Connection URL to the LDAP server.\n"
                },
                "customUserSearchFilter": {
                    "type": "string",
                    "description": "Additional LDAP filter for filtering searched users. Must begin with '(' and end with ')'.\n"
                },
                "deleteDefaultMappers": {
                    "type": "boolean",
                    "description": "When true, the provider will delete the default mappers which are normally created by Keycloak when creating an LDAP\nuser federation provider.\n",
                    "willReplaceOnChanges": true
                },
                "editMode": {
                    "type": "string",
                    "description": "READ_ONLY and WRITABLE are self-explanatory. UNSYNCED allows user data to be imported but not synced back to LDAP.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When false, this provider will not be used when performing queries for users.\n"
                },
                "fullSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync all LDAP users, in seconds. Omit this property to disable periodic full sync.\n"
                },
                "importEnabled": {
                    "type": "boolean",
                    "description": "When true, LDAP users will be imported into the Keycloak database.\n"
                },
                "kerberos": {
                    "$ref": "#/types/keycloak:ldap/UserFederationKerberos:UserFederationKerberos",
                    "description": "Settings regarding kerberos authentication for this realm.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the provider when displayed in the console.\n"
                },
                "pagination": {
                    "type": "boolean",
                    "description": "When true, Keycloak assumes the LDAP server supports pagination.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of this provider when looking up users. Lower values are first.\n"
                },
                "rdnLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as the relative distinguished name.\n"
                },
                "readTimeout": {
                    "type": "string",
                    "description": "LDAP read timeout (duration string)\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this provider will provide user federation for.\n",
                    "willReplaceOnChanges": true
                },
                "searchScope": {
                    "type": "string",
                    "description": "ONE_LEVEL: only search for users in the DN specified by user_dn. SUBTREE: search entire LDAP subtree.\n"
                },
                "startTls": {
                    "type": "boolean",
                    "description": "When true, Keycloak will encrypt the connection to LDAP using STARTTLS, which will disable connection pooling.\n"
                },
                "syncRegistrations": {
                    "type": "boolean",
                    "description": "When true, newly created users will be synced back to LDAP.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "If enabled, email provided by this provider is not verified even if verification is enabled for the realm.\n"
                },
                "usePasswordModifyExtendedOp": {
                    "type": "boolean",
                    "description": "When `true`, use the LDAPv3 Password Modify Extended Operation (RFC-3062).\n"
                },
                "useTruststoreSpi": {
                    "type": "string"
                },
                "userObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "All values of LDAP objectClass attribute for users in LDAP.\n"
                },
                "usernameLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as the Keycloak username.\n"
                },
                "usersDn": {
                    "type": "string",
                    "description": "Full DN of LDAP tree where your users are.\n"
                },
                "uuidLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as a unique object identifier for objects in LDAP.\n"
                },
                "validatePasswordPolicy": {
                    "type": "boolean",
                    "description": "When true, Keycloak will validate passwords using the realm policy before updating it.\n"
                },
                "vendor": {
                    "type": "string",
                    "description": "LDAP vendor. I am almost certain this field does nothing, but the UI indicates that it is required.\n"
                }
            },
            "requiredInputs": [
                "connectionUrl",
                "rdnLdapAttribute",
                "realmId",
                "userObjectClasses",
                "usernameLdapAttribute",
                "usersDn",
                "uuidLdapAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserFederation resources.\n",
                "properties": {
                    "batchSizeForSync": {
                        "type": "integer",
                        "description": "The number of users to sync within a single transaction.\n"
                    },
                    "bindCredential": {
                        "type": "string",
                        "description": "Password of LDAP admin.\n",
                        "secret": true
                    },
                    "bindDn": {
                        "type": "string",
                        "description": "DN of LDAP admin, which will be used by Keycloak to access LDAP server.\n"
                    },
                    "cache": {
                        "$ref": "#/types/keycloak:ldap/UserFederationCache:UserFederationCache",
                        "description": "Settings regarding cache policy for this realm.\n"
                    },
                    "changedSyncPeriod": {
                        "type": "integer",
                        "description": "How frequently Keycloak should sync changed LDAP users, in seconds. Omit this property to disable periodic changed users\nsync.\n"
                    },
                    "connectionTimeout": {
                        "type": "string",
                        "description": "LDAP connection timeout (duration string)\n"
                    },
                    "connectionUrl": {
                        "type": "string",
                        "description": "Connection URL to the LDAP server.\n"
                    },
                    "customUserSearchFilter": {
                        "type": "string",
                        "description": "Additional LDAP filter for filtering searched users. Must begin with '(' and end with ')'.\n"
                    },
                    "deleteDefaultMappers": {
                        "type": "boolean",
                        "description": "When true, the provider will delete the default mappers which are normally created by Keycloak when creating an LDAP\nuser federation provider.\n",
                        "willReplaceOnChanges": true
                    },
                    "editMode": {
                        "type": "string",
                        "description": "READ_ONLY and WRITABLE are self-explanatory. UNSYNCED allows user data to be imported but not synced back to LDAP.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When false, this provider will not be used when performing queries for users.\n"
                    },
                    "fullSyncPeriod": {
                        "type": "integer",
                        "description": "How frequently Keycloak should sync all LDAP users, in seconds. Omit this property to disable periodic full sync.\n"
                    },
                    "importEnabled": {
                        "type": "boolean",
                        "description": "When true, LDAP users will be imported into the Keycloak database.\n"
                    },
                    "kerberos": {
                        "$ref": "#/types/keycloak:ldap/UserFederationKerberos:UserFederationKerberos",
                        "description": "Settings regarding kerberos authentication for this realm.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the provider when displayed in the console.\n"
                    },
                    "pagination": {
                        "type": "boolean",
                        "description": "When true, Keycloak assumes the LDAP server supports pagination.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority of this provider when looking up users. Lower values are first.\n"
                    },
                    "rdnLdapAttribute": {
                        "type": "string",
                        "description": "Name of the LDAP attribute to use as the relative distinguished name.\n"
                    },
                    "readTimeout": {
                        "type": "string",
                        "description": "LDAP read timeout (duration string)\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this provider will provide user federation for.\n",
                        "willReplaceOnChanges": true
                    },
                    "searchScope": {
                        "type": "string",
                        "description": "ONE_LEVEL: only search for users in the DN specified by user_dn. SUBTREE: search entire LDAP subtree.\n"
                    },
                    "startTls": {
                        "type": "boolean",
                        "description": "When true, Keycloak will encrypt the connection to LDAP using STARTTLS, which will disable connection pooling.\n"
                    },
                    "syncRegistrations": {
                        "type": "boolean",
                        "description": "When true, newly created users will be synced back to LDAP.\n"
                    },
                    "trustEmail": {
                        "type": "boolean",
                        "description": "If enabled, email provided by this provider is not verified even if verification is enabled for the realm.\n"
                    },
                    "usePasswordModifyExtendedOp": {
                        "type": "boolean",
                        "description": "When `true`, use the LDAPv3 Password Modify Extended Operation (RFC-3062).\n"
                    },
                    "useTruststoreSpi": {
                        "type": "string"
                    },
                    "userObjectClasses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "All values of LDAP objectClass attribute for users in LDAP.\n"
                    },
                    "usernameLdapAttribute": {
                        "type": "string",
                        "description": "Name of the LDAP attribute to use as the Keycloak username.\n"
                    },
                    "usersDn": {
                        "type": "string",
                        "description": "Full DN of LDAP tree where your users are.\n"
                    },
                    "uuidLdapAttribute": {
                        "type": "string",
                        "description": "Name of the LDAP attribute to use as a unique object identifier for objects in LDAP.\n"
                    },
                    "validatePasswordPolicy": {
                        "type": "boolean",
                        "description": "When true, Keycloak will validate passwords using the realm policy before updating it.\n"
                    },
                    "vendor": {
                        "type": "string",
                        "description": "LDAP vendor. I am almost certain this field does nothing, but the UI indicates that it is required.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:oidc/googleIdentityProvider:GoogleIdentityProvider": {
            "description": "Allows for creating and managing OIDC Identity Providers within Keycloak.\n\nOIDC (OpenID Connect) identity providers allows users to authenticate through a third party system using the OIDC standard.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst google = new keycloak.oidc.GoogleIdentityProvider(\"google\", {\n    realm: realm.id,\n    clientId: googleIdentityProviderClientId,\n    clientSecret: googleIdentityProviderClientSecret,\n    trustEmail: true,\n    hostedDomain: \"example.com\",\n    syncMode: \"IMPORT\",\n    extraConfig: {\n        myCustomConfigKey: \"myValue\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\ngoogle = keycloak.oidc.GoogleIdentityProvider(\"google\",\n    realm=realm.id,\n    client_id=google_identity_provider_client_id,\n    client_secret=google_identity_provider_client_secret,\n    trust_email=True,\n    hosted_domain=\"example.com\",\n    sync_mode=\"IMPORT\",\n    extra_config={\n        \"myCustomConfigKey\": \"myValue\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var google = new Keycloak.Oidc.GoogleIdentityProvider(\"google\", new()\n    {\n        Realm = realm.Id,\n        ClientId = googleIdentityProviderClientId,\n        ClientSecret = googleIdentityProviderClientSecret,\n        TrustEmail = true,\n        HostedDomain = \"example.com\",\n        SyncMode = \"IMPORT\",\n        ExtraConfig = \n        {\n            { \"myCustomConfigKey\", \"myValue\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/oidc\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = oidc.NewGoogleIdentityProvider(ctx, \"google\", \u0026oidc.GoogleIdentityProviderArgs{\n\t\t\tRealm:        realm.ID(),\n\t\t\tClientId:     pulumi.Any(googleIdentityProviderClientId),\n\t\t\tClientSecret: pulumi.Any(googleIdentityProviderClientSecret),\n\t\t\tTrustEmail:   pulumi.Bool(true),\n\t\t\tHostedDomain: pulumi.String(\"example.com\"),\n\t\t\tSyncMode:     pulumi.String(\"IMPORT\"),\n\t\t\tExtraConfig: pulumi.Map{\n\t\t\t\t\"myCustomConfigKey\": pulumi.Any(\"myValue\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.oidc.GoogleIdentityProvider;\nimport com.pulumi.keycloak.oidc.GoogleIdentityProviderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var google = new GoogleIdentityProvider(\"google\", GoogleIdentityProviderArgs.builder()\n            .realm(realm.id())\n            .clientId(googleIdentityProviderClientId)\n            .clientSecret(googleIdentityProviderClientSecret)\n            .trustEmail(true)\n            .hostedDomain(\"example.com\")\n            .syncMode(\"IMPORT\")\n            .extraConfig(Map.of(\"myCustomConfigKey\", \"myValue\"))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  google:\n    type: keycloak:oidc:GoogleIdentityProvider\n    properties:\n      realm: ${realm.id}\n      clientId: ${googleIdentityProviderClientId}\n      clientSecret: ${googleIdentityProviderClientSecret}\n      trustEmail: true\n      hostedDomain: example.com\n      syncMode: IMPORT\n      extraConfig:\n        myCustomConfigKey: myValue\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nGoogle Identity providers can be imported using the format {{realm_id}}/{{idp_alias}}, where idp_alias is the identity provider alias.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:oidc/googleIdentityProvider:GoogleIdentityProvider google_identity_provider my-realm/my-google-idp\n```\n\n",
            "properties": {
                "acceptsPromptNoneForwardFromClient": {
                    "type": "boolean",
                    "description": "When `true`, unauthenticated requests with `prompt=none` will be forwarded to Google instead of returning an error. Defaults to `false`.\n"
                },
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                },
                "alias": {
                    "type": "string",
                    "description": "(Computed) The alias for the Google identity provider.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client or client identifier registered within the identity provider.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use $${vault.ID} format.\n",
                    "secret": true
                },
                "defaultScopes": {
                    "type": "string",
                    "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to `openid profile email`.\n"
                },
                "disableUserInfo": {
                    "type": "boolean",
                    "description": "When `true`, disables the usage of the user info service to obtain additional user information. Defaults to `false`.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "(Computed) Display name for the Google identity provider in the GUI.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `true`, users will be able to log in to this realm using this identity provider. Defaults to `true`.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use when users log in for the first time through this identity provider. Defaults to `first broker login`.\n"
                },
                "guiOrder": {
                    "type": "string",
                    "description": "A number defining the order of this identity provider in the GUI.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "When `true`, this identity provider will be hidden on the login page. Defaults to `false`.\n"
                },
                "hostedDomain": {
                    "type": "string",
                    "description": "Sets the \"hd\" query parameter when logging in with Google. Google will only list accounts for this domain. Keycloak will validate that the returned identity token has a claim for this domain. When `*` is entered, an account from any domain can be used.\n"
                },
                "internalId": {
                    "type": "string",
                    "description": "(Computed) The unique ID that Keycloak assigns to the identity provider upon creation.\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use after users have successfully logged in, which can be used to perform additional user verification (such as OTP checking). Defaults to an empty string, which means no post login flow will be used.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The ID of the identity provider to use. Defaults to `google`, which should be used unless you have extended Keycloak and provided your own implementation.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak.\n"
                },
                "requestRefreshToken": {
                    "type": "boolean",
                    "description": "Sets the \"access_type\" query parameter to \"offline\" when redirecting to google authorization endpoint,to get a refresh token back. This is useful for using Token Exchange to retrieve a Google token to access Google APIs when the user is offline.\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                },
                "syncMode": {
                    "type": "string",
                    "description": "The default sync mode to use for all mappers attached to this identity provider. Can be once of `IMPORT`, `FORCE`, or `LEGACY`.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                },
                "useUserIpParam": {
                    "type": "boolean",
                    "description": "Sets the \"userIp\" query parameter when querying Google's User Info service. This will use the user's IP address. This is useful if Google is throttling Keycloak's access to the User Info service.\n"
                }
            },
            "required": [
                "alias",
                "clientId",
                "clientSecret",
                "displayName",
                "internalId",
                "realm"
            ],
            "inputProperties": {
                "acceptsPromptNoneForwardFromClient": {
                    "type": "boolean",
                    "description": "When `true`, unauthenticated requests with `prompt=none` will be forwarded to Google instead of returning an error. Defaults to `false`.\n"
                },
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n",
                    "willReplaceOnChanges": true
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client or client identifier registered within the identity provider.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use $${vault.ID} format.\n",
                    "secret": true
                },
                "defaultScopes": {
                    "type": "string",
                    "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to `openid profile email`.\n"
                },
                "disableUserInfo": {
                    "type": "boolean",
                    "description": "When `true`, disables the usage of the user info service to obtain additional user information. Defaults to `false`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `true`, users will be able to log in to this realm using this identity provider. Defaults to `true`.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use when users log in for the first time through this identity provider. Defaults to `first broker login`.\n"
                },
                "guiOrder": {
                    "type": "string",
                    "description": "A number defining the order of this identity provider in the GUI.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "When `true`, this identity provider will be hidden on the login page. Defaults to `false`.\n"
                },
                "hostedDomain": {
                    "type": "string",
                    "description": "Sets the \"hd\" query parameter when logging in with Google. Google will only list accounts for this domain. Keycloak will validate that the returned identity token has a claim for this domain. When `*` is entered, an account from any domain can be used.\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use after users have successfully logged in, which can be used to perform additional user verification (such as OTP checking). Defaults to an empty string, which means no post login flow will be used.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The ID of the identity provider to use. Defaults to `google`, which should be used unless you have extended Keycloak and provided your own implementation.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak.\n",
                    "willReplaceOnChanges": true
                },
                "requestRefreshToken": {
                    "type": "boolean",
                    "description": "Sets the \"access_type\" query parameter to \"offline\" when redirecting to google authorization endpoint,to get a refresh token back. This is useful for using Token Exchange to retrieve a Google token to access Google APIs when the user is offline.\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                },
                "syncMode": {
                    "type": "string",
                    "description": "The default sync mode to use for all mappers attached to this identity provider. Can be once of `IMPORT`, `FORCE`, or `LEGACY`.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                },
                "useUserIpParam": {
                    "type": "boolean",
                    "description": "Sets the \"userIp\" query parameter when querying Google's User Info service. This will use the user's IP address. This is useful if Google is throttling Keycloak's access to the User Info service.\n"
                }
            },
            "requiredInputs": [
                "clientId",
                "clientSecret",
                "realm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GoogleIdentityProvider resources.\n",
                "properties": {
                    "acceptsPromptNoneForwardFromClient": {
                        "type": "boolean",
                        "description": "When `true`, unauthenticated requests with `prompt=none` will be forwarded to Google instead of returning an error. Defaults to `false`.\n"
                    },
                    "addReadTokenRoleOnCreate": {
                        "type": "boolean",
                        "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n",
                        "willReplaceOnChanges": true
                    },
                    "alias": {
                        "type": "string",
                        "description": "(Computed) The alias for the Google identity provider.\n"
                    },
                    "authenticateByDefault": {
                        "type": "boolean",
                        "description": "Enable/disable authenticate users by default.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client or client identifier registered within the identity provider.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use $${vault.ID} format.\n",
                        "secret": true
                    },
                    "defaultScopes": {
                        "type": "string",
                        "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to `openid profile email`.\n"
                    },
                    "disableUserInfo": {
                        "type": "boolean",
                        "description": "When `true`, disables the usage of the user info service to obtain additional user information. Defaults to `false`.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "(Computed) Display name for the Google identity provider in the GUI.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `true`, users will be able to log in to this realm using this identity provider. Defaults to `true`.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "firstBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "The authentication flow to use when users log in for the first time through this identity provider. Defaults to `first broker login`.\n"
                    },
                    "guiOrder": {
                        "type": "string",
                        "description": "A number defining the order of this identity provider in the GUI.\n"
                    },
                    "hideOnLoginPage": {
                        "type": "boolean",
                        "description": "When `true`, this identity provider will be hidden on the login page. Defaults to `false`.\n"
                    },
                    "hostedDomain": {
                        "type": "string",
                        "description": "Sets the \"hd\" query parameter when logging in with Google. Google will only list accounts for this domain. Keycloak will validate that the returned identity token has a claim for this domain. When `*` is entered, an account from any domain can be used.\n"
                    },
                    "internalId": {
                        "type": "string",
                        "description": "(Computed) The unique ID that Keycloak assigns to the identity provider upon creation.\n"
                    },
                    "linkOnly": {
                        "type": "boolean",
                        "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                    },
                    "postBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "The authentication flow to use after users have successfully logged in, which can be used to perform additional user verification (such as OTP checking). Defaults to an empty string, which means no post login flow will be used.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The ID of the identity provider to use. Defaults to `google`, which should be used unless you have extended Keycloak and provided your own implementation.\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "The name of the realm. This is unique across Keycloak.\n",
                        "willReplaceOnChanges": true
                    },
                    "requestRefreshToken": {
                        "type": "boolean",
                        "description": "Sets the \"access_type\" query parameter to \"offline\" when redirecting to google authorization endpoint,to get a refresh token back. This is useful for using Token Exchange to retrieve a Google token to access Google APIs when the user is offline.\n"
                    },
                    "storeToken": {
                        "type": "boolean",
                        "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                    },
                    "syncMode": {
                        "type": "string",
                        "description": "The default sync mode to use for all mappers attached to this identity provider. Can be once of `IMPORT`, `FORCE`, or `LEGACY`.\n"
                    },
                    "trustEmail": {
                        "type": "boolean",
                        "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                    },
                    "useUserIpParam": {
                        "type": "boolean",
                        "description": "Sets the \"userIp\" query parameter when querying Google's User Info service. This will use the user's IP address. This is useful if Google is throttling Keycloak's access to the User Info service.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:oidc/identityProvider:IdentityProvider": {
            "description": "Allows for creating and managing OIDC Identity Providers within Keycloak.\n\nOIDC (OpenID Connect) identity providers allows users to authenticate through a third party system using the OIDC standard.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst realmIdentityProvider = new keycloak.oidc.IdentityProvider(\"realm_identity_provider\", {\n    realm: realm.id,\n    alias: \"my-idp\",\n    authorizationUrl: \"https://authorizationurl.com\",\n    clientId: \"clientID\",\n    clientSecret: \"clientSecret\",\n    tokenUrl: \"https://tokenurl.com\",\n    extraConfig: {\n        clientAuthMethod: \"client_secret_post\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrealm_identity_provider = keycloak.oidc.IdentityProvider(\"realm_identity_provider\",\n    realm=realm.id,\n    alias=\"my-idp\",\n    authorization_url=\"https://authorizationurl.com\",\n    client_id=\"clientID\",\n    client_secret=\"clientSecret\",\n    token_url=\"https://tokenurl.com\",\n    extra_config={\n        \"clientAuthMethod\": \"client_secret_post\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var realmIdentityProvider = new Keycloak.Oidc.IdentityProvider(\"realm_identity_provider\", new()\n    {\n        Realm = realm.Id,\n        Alias = \"my-idp\",\n        AuthorizationUrl = \"https://authorizationurl.com\",\n        ClientId = \"clientID\",\n        ClientSecret = \"clientSecret\",\n        TokenUrl = \"https://tokenurl.com\",\n        ExtraConfig = \n        {\n            { \"clientAuthMethod\", \"client_secret_post\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/oidc\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = oidc.NewIdentityProvider(ctx, \"realm_identity_provider\", \u0026oidc.IdentityProviderArgs{\n\t\t\tRealm:            realm.ID(),\n\t\t\tAlias:            pulumi.String(\"my-idp\"),\n\t\t\tAuthorizationUrl: pulumi.String(\"https://authorizationurl.com\"),\n\t\t\tClientId:         pulumi.String(\"clientID\"),\n\t\t\tClientSecret:     pulumi.String(\"clientSecret\"),\n\t\t\tTokenUrl:         pulumi.String(\"https://tokenurl.com\"),\n\t\t\tExtraConfig: pulumi.Map{\n\t\t\t\t\"clientAuthMethod\": pulumi.Any(\"client_secret_post\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.oidc.IdentityProvider;\nimport com.pulumi.keycloak.oidc.IdentityProviderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var realmIdentityProvider = new IdentityProvider(\"realmIdentityProvider\", IdentityProviderArgs.builder()\n            .realm(realm.id())\n            .alias(\"my-idp\")\n            .authorizationUrl(\"https://authorizationurl.com\")\n            .clientId(\"clientID\")\n            .clientSecret(\"clientSecret\")\n            .tokenUrl(\"https://tokenurl.com\")\n            .extraConfig(Map.of(\"clientAuthMethod\", \"client_secret_post\"))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  realmIdentityProvider:\n    type: keycloak:oidc:IdentityProvider\n    name: realm_identity_provider\n    properties:\n      realm: ${realm.id}\n      alias: my-idp\n      authorizationUrl: https://authorizationurl.com\n      clientId: clientID\n      clientSecret: clientSecret\n      tokenUrl: https://tokenurl.com\n      extraConfig:\n        clientAuthMethod: client_secret_post\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nIdentity providers can be imported using the format `{{realm_id}}/{{idp_alias}}`, where `idp_alias` is the identity provider alias.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:oidc/identityProvider:IdentityProvider realm_identity_provider my-realm/my-idp\n```\n\n",
            "properties": {
                "acceptsPromptNoneForwardFromClient": {
                    "type": "boolean",
                    "description": "When `true`, the IDP will accept forwarded authentication requests that contain the `prompt=none` query parameter. Defaults to `false`.\n"
                },
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                },
                "alias": {
                    "type": "string",
                    "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "authorizationUrl": {
                    "type": "string",
                    "description": "The Authorization Url.\n"
                },
                "backchannelSupported": {
                    "type": "boolean",
                    "description": "Does the external IDP support backchannel logout? Defaults to `true`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client or client identifier registered within the identity provider.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use $${vault.ID} format.\n",
                    "secret": true
                },
                "defaultScopes": {
                    "type": "string",
                    "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to `openid`.\n"
                },
                "disableUserInfo": {
                    "type": "boolean",
                    "description": "When `true`, disables the usage of the user info service to obtain additional user information. Defaults to `false`.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "Display name for the identity provider in the GUI.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `true`, users will be able to log in to this realm using this identity provider. Defaults to `true`.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use when users log in for the first time through this identity provider. Defaults to `first broker login`.\n"
                },
                "guiOrder": {
                    "type": "string",
                    "description": "A number defining the order of this identity provider in the GUI.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "When `true`, this provider will be hidden on the login page, and is only accessible when requested explicitly. Defaults to `false`.\n"
                },
                "internalId": {
                    "type": "string",
                    "description": "(Computed) The unique ID that Keycloak assigns to the identity provider upon creation.\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "The issuer identifier for the issuer of the response. If not provided, no validation will be performed.\n"
                },
                "jwksUrl": {
                    "type": "string",
                    "description": "JSON Web Key Set URL.\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                },
                "loginHint": {
                    "type": "string",
                    "description": "Pass login hint to identity provider.\n"
                },
                "logoutUrl": {
                    "type": "string",
                    "description": "The Logout URL is the end session endpoint to use to logout user from external identity provider.\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use after users have successfully logged in, which can be used to perform additional user verification (such as OTP checking). Defaults to an empty string, which means no post login flow will be used.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The ID of the identity provider to use. Defaults to `oidc`, which should be used unless you have extended Keycloak and provided your own implementation.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak.\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                },
                "syncMode": {
                    "type": "string",
                    "description": "The default sync mode to use for all mappers attached to this identity provider. Can be once of `IMPORT`, `FORCE`, or `LEGACY`.\n"
                },
                "tokenUrl": {
                    "type": "string",
                    "description": "The Token URL.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                },
                "uiLocales": {
                    "type": "boolean",
                    "description": "Pass current locale to identity provider. Defaults to `false`.\n"
                },
                "userInfoUrl": {
                    "type": "string",
                    "description": "User Info URL.\n"
                },
                "validateSignature": {
                    "type": "boolean",
                    "description": "Enable/disable signature validation of external IDP signatures. Defaults to `false`.\n"
                }
            },
            "required": [
                "alias",
                "authorizationUrl",
                "clientId",
                "clientSecret",
                "internalId",
                "realm",
                "tokenUrl"
            ],
            "inputProperties": {
                "acceptsPromptNoneForwardFromClient": {
                    "type": "boolean",
                    "description": "When `true`, the IDP will accept forwarded authentication requests that contain the `prompt=none` query parameter. Defaults to `false`.\n"
                },
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n",
                    "willReplaceOnChanges": true
                },
                "alias": {
                    "type": "string",
                    "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\n",
                    "willReplaceOnChanges": true
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "authorizationUrl": {
                    "type": "string",
                    "description": "The Authorization Url.\n"
                },
                "backchannelSupported": {
                    "type": "boolean",
                    "description": "Does the external IDP support backchannel logout? Defaults to `true`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client or client identifier registered within the identity provider.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use $${vault.ID} format.\n",
                    "secret": true
                },
                "defaultScopes": {
                    "type": "string",
                    "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to `openid`.\n"
                },
                "disableUserInfo": {
                    "type": "boolean",
                    "description": "When `true`, disables the usage of the user info service to obtain additional user information. Defaults to `false`.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "Display name for the identity provider in the GUI.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `true`, users will be able to log in to this realm using this identity provider. Defaults to `true`.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use when users log in for the first time through this identity provider. Defaults to `first broker login`.\n"
                },
                "guiOrder": {
                    "type": "string",
                    "description": "A number defining the order of this identity provider in the GUI.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "When `true`, this provider will be hidden on the login page, and is only accessible when requested explicitly. Defaults to `false`.\n"
                },
                "issuer": {
                    "type": "string",
                    "description": "The issuer identifier for the issuer of the response. If not provided, no validation will be performed.\n"
                },
                "jwksUrl": {
                    "type": "string",
                    "description": "JSON Web Key Set URL.\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                },
                "loginHint": {
                    "type": "string",
                    "description": "Pass login hint to identity provider.\n"
                },
                "logoutUrl": {
                    "type": "string",
                    "description": "The Logout URL is the end session endpoint to use to logout user from external identity provider.\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use after users have successfully logged in, which can be used to perform additional user verification (such as OTP checking). Defaults to an empty string, which means no post login flow will be used.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The ID of the identity provider to use. Defaults to `oidc`, which should be used unless you have extended Keycloak and provided your own implementation.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak.\n",
                    "willReplaceOnChanges": true
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                },
                "syncMode": {
                    "type": "string",
                    "description": "The default sync mode to use for all mappers attached to this identity provider. Can be once of `IMPORT`, `FORCE`, or `LEGACY`.\n"
                },
                "tokenUrl": {
                    "type": "string",
                    "description": "The Token URL.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                },
                "uiLocales": {
                    "type": "boolean",
                    "description": "Pass current locale to identity provider. Defaults to `false`.\n"
                },
                "userInfoUrl": {
                    "type": "string",
                    "description": "User Info URL.\n"
                },
                "validateSignature": {
                    "type": "boolean",
                    "description": "Enable/disable signature validation of external IDP signatures. Defaults to `false`.\n"
                }
            },
            "requiredInputs": [
                "alias",
                "authorizationUrl",
                "clientId",
                "clientSecret",
                "realm",
                "tokenUrl"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IdentityProvider resources.\n",
                "properties": {
                    "acceptsPromptNoneForwardFromClient": {
                        "type": "boolean",
                        "description": "When `true`, the IDP will accept forwarded authentication requests that contain the `prompt=none` query parameter. Defaults to `false`.\n"
                    },
                    "addReadTokenRoleOnCreate": {
                        "type": "boolean",
                        "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n",
                        "willReplaceOnChanges": true
                    },
                    "alias": {
                        "type": "string",
                        "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\n",
                        "willReplaceOnChanges": true
                    },
                    "authenticateByDefault": {
                        "type": "boolean",
                        "description": "Enable/disable authenticate users by default.\n"
                    },
                    "authorizationUrl": {
                        "type": "string",
                        "description": "The Authorization Url.\n"
                    },
                    "backchannelSupported": {
                        "type": "boolean",
                        "description": "Does the external IDP support backchannel logout? Defaults to `true`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client or client identifier registered within the identity provider.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use $${vault.ID} format.\n",
                        "secret": true
                    },
                    "defaultScopes": {
                        "type": "string",
                        "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to `openid`.\n"
                    },
                    "disableUserInfo": {
                        "type": "boolean",
                        "description": "When `true`, disables the usage of the user info service to obtain additional user information. Defaults to `false`.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "Display name for the identity provider in the GUI.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `true`, users will be able to log in to this realm using this identity provider. Defaults to `true`.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "firstBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "The authentication flow to use when users log in for the first time through this identity provider. Defaults to `first broker login`.\n"
                    },
                    "guiOrder": {
                        "type": "string",
                        "description": "A number defining the order of this identity provider in the GUI.\n"
                    },
                    "hideOnLoginPage": {
                        "type": "boolean",
                        "description": "When `true`, this provider will be hidden on the login page, and is only accessible when requested explicitly. Defaults to `false`.\n"
                    },
                    "internalId": {
                        "type": "string",
                        "description": "(Computed) The unique ID that Keycloak assigns to the identity provider upon creation.\n"
                    },
                    "issuer": {
                        "type": "string",
                        "description": "The issuer identifier for the issuer of the response. If not provided, no validation will be performed.\n"
                    },
                    "jwksUrl": {
                        "type": "string",
                        "description": "JSON Web Key Set URL.\n"
                    },
                    "linkOnly": {
                        "type": "boolean",
                        "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                    },
                    "loginHint": {
                        "type": "string",
                        "description": "Pass login hint to identity provider.\n"
                    },
                    "logoutUrl": {
                        "type": "string",
                        "description": "The Logout URL is the end session endpoint to use to logout user from external identity provider.\n"
                    },
                    "postBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "The authentication flow to use after users have successfully logged in, which can be used to perform additional user verification (such as OTP checking). Defaults to an empty string, which means no post login flow will be used.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The ID of the identity provider to use. Defaults to `oidc`, which should be used unless you have extended Keycloak and provided your own implementation.\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "The name of the realm. This is unique across Keycloak.\n",
                        "willReplaceOnChanges": true
                    },
                    "storeToken": {
                        "type": "boolean",
                        "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                    },
                    "syncMode": {
                        "type": "string",
                        "description": "The default sync mode to use for all mappers attached to this identity provider. Can be once of `IMPORT`, `FORCE`, or `LEGACY`.\n"
                    },
                    "tokenUrl": {
                        "type": "string",
                        "description": "The Token URL.\n"
                    },
                    "trustEmail": {
                        "type": "boolean",
                        "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                    },
                    "uiLocales": {
                        "type": "boolean",
                        "description": "Pass current locale to identity provider. Defaults to `false`.\n"
                    },
                    "userInfoUrl": {
                        "type": "string",
                        "description": "User Info URL.\n"
                    },
                    "validateSignature": {
                        "type": "boolean",
                        "description": "Enable/disable signature validation of external IDP signatures. Defaults to `false`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/audienceProtocolMapper:AudienceProtocolMapper": {
            "description": "## # keycloak.openid.AudienceProtocolMapper\n\nAllows for creating and managing audience protocol mappers within\nKeycloak. This mapper was added in Keycloak v4.6.0.Final.\n\nAudience protocol mappers allow you add audiences to the `aud` claim\nwithin issued tokens. The audience can be a custom string, or it can be\nmapped to the ID of a pre-existing client.\n\n### Example Usage (Client)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    realmId: realm.id,\n    clientId: \"test-client\",\n    name: \"test client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst audienceMapper = new keycloak.openid.AudienceProtocolMapper(\"audience_mapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    name: \"audience-mapper\",\n    includedCustomAudience: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openid_client\",\n    realm_id=realm.id,\n    client_id=\"test-client\",\n    name=\"test client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\naudience_mapper = keycloak.openid.AudienceProtocolMapper(\"audience_mapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    name=\"audience-mapper\",\n    included_custom_audience=\"foo\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var openidClient = new Keycloak.OpenId.Client(\"openid_client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"test-client\",\n        Name = \"test client\",\n        Enabled = true,\n        AccessType = \"CONFIDENTIAL\",\n        ValidRedirectUris = new[]\n        {\n            \"http://localhost:8080/openid-callback\",\n        },\n    });\n\n    var audienceMapper = new Keycloak.OpenId.AudienceProtocolMapper(\"audience_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = openidClient.Id,\n        Name = \"audience-mapper\",\n        IncludedCustomAudience = \"foo\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openid_client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tName:       pulumi.String(\"test client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewAudienceProtocolMapper(ctx, \"audience_mapper\", \u0026openid.AudienceProtocolMapperArgs{\n\t\t\tRealmId:                realm.ID(),\n\t\t\tClientId:               openidClient.ID(),\n\t\t\tName:                   pulumi.String(\"audience-mapper\"),\n\t\t\tIncludedCustomAudience: pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.openid.AudienceProtocolMapper;\nimport com.pulumi.keycloak.openid.AudienceProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var openidClient = new Client(\"openidClient\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"test-client\")\n            .name(\"test client\")\n            .enabled(true)\n            .accessType(\"CONFIDENTIAL\")\n            .validRedirectUris(\"http://localhost:8080/openid-callback\")\n            .build());\n\n        var audienceMapper = new AudienceProtocolMapper(\"audienceMapper\", AudienceProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(openidClient.id())\n            .name(\"audience-mapper\")\n            .includedCustomAudience(\"foo\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  openidClient:\n    type: keycloak:openid:Client\n    name: openid_client\n    properties:\n      realmId: ${realm.id}\n      clientId: test-client\n      name: test client\n      enabled: true\n      accessType: CONFIDENTIAL\n      validRedirectUris:\n        - http://localhost:8080/openid-callback\n  audienceMapper:\n    type: keycloak:openid:AudienceProtocolMapper\n    name: audience_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${openidClient.id}\n      name: audience-mapper\n      includedCustomAudience: foo\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Usage (Client Scope)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n    name: \"test-client-scope\",\n});\nconst audienceMapper = new keycloak.openid.AudienceProtocolMapper(\"audience_mapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    name: \"audience-mapper\",\n    includedCustomAudience: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"client_scope\",\n    realm_id=realm.id,\n    name=\"test-client-scope\")\naudience_mapper = keycloak.openid.AudienceProtocolMapper(\"audience_mapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    name=\"audience-mapper\",\n    included_custom_audience=\"foo\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var clientScope = new Keycloak.OpenId.ClientScope(\"client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"test-client-scope\",\n    });\n\n    var audienceMapper = new Keycloak.OpenId.AudienceProtocolMapper(\"audience_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientScopeId = clientScope.Id,\n        Name = \"audience-mapper\",\n        IncludedCustomAudience = \"foo\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"test-client-scope\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewAudienceProtocolMapper(ctx, \"audience_mapper\", \u0026openid.AudienceProtocolMapperArgs{\n\t\t\tRealmId:                realm.ID(),\n\t\t\tClientScopeId:          clientScope.ID(),\n\t\t\tName:                   pulumi.String(\"audience-mapper\"),\n\t\t\tIncludedCustomAudience: pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport com.pulumi.keycloak.openid.AudienceProtocolMapper;\nimport com.pulumi.keycloak.openid.AudienceProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var clientScope = new ClientScope(\"clientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"test-client-scope\")\n            .build());\n\n        var audienceMapper = new AudienceProtocolMapper(\"audienceMapper\", AudienceProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientScopeId(clientScope.id())\n            .name(\"audience-mapper\")\n            .includedCustomAudience(\"foo\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  clientScope:\n    type: keycloak:openid:ClientScope\n    name: client_scope\n    properties:\n      realmId: ${realm.id}\n      name: test-client-scope\n  audienceMapper:\n    type: keycloak:openid:AudienceProtocolMapper\n    name: audience_mapper\n    properties:\n      realmId: ${realm.id}\n      clientScopeId: ${clientScope.id}\n      name: audience-mapper\n      includedCustomAudience: foo\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `included_client_audience` - (Required if `included_custom_audience` is not specified) A client ID to include within the token's `aud` claim.\n- `included_custom_audience` - (Required if `included_client_audience` is not specified) A custom audience to include within the token's `aud` claim.\n- `add_to_id_token` - (Optional) Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.\n- `add_to_access_token` - (Optional) Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.\n\n### Import\n\nProtocol mappers can be imported using one of the following formats:\n- Client: `{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}`\n- Client Scope: `{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}`\n\nExample:\n\n```bash\n$ terraform import keycloak_openid_audience_protocol_mapper.audience_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n$ terraform import keycloak_openid_audience_protocol_mapper.audience_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if this claim should be added to the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if this claim should be added to the id token.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "includedClientAudience": {
                    "type": "string",
                    "description": "A client ID to include within the token's `aud` claim. Cannot be used with included_custom_audience\n"
                },
                "includedCustomAudience": {
                    "type": "string",
                    "description": "A custom audience to include within the token's `aud` claim. Cannot be used with included_custom_audience\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if this claim should be added to the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if this claim should be added to the id token.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n",
                    "willReplaceOnChanges": true
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n",
                    "willReplaceOnChanges": true
                },
                "includedClientAudience": {
                    "type": "string",
                    "description": "A client ID to include within the token's `aud` claim. Cannot be used with included_custom_audience\n"
                },
                "includedCustomAudience": {
                    "type": "string",
                    "description": "A custom audience to include within the token's `aud` claim. Cannot be used with included_custom_audience\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AudienceProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if this claim should be added to the access token.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if this claim should be added to the id token.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n",
                        "willReplaceOnChanges": true
                    },
                    "includedClientAudience": {
                        "type": "string",
                        "description": "A client ID to include within the token's `aud` claim. Cannot be used with included_custom_audience\n"
                    },
                    "includedCustomAudience": {
                        "type": "string",
                        "description": "A custom audience to include within the token's `aud` claim. Cannot be used with included_custom_audience\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/audienceResolveProtocolMapper:AudienceResolveProtocolMapper": {
            "description": "Allows for creating the \"Audience Resolve\" OIDC protocol mapper within Keycloak.\n\nThis protocol mapper is useful to avoid manual management of audiences, instead relying on the presence of client roles\nto imply which audiences are appropriate for the token. See the\n[Keycloak docs](https://www.keycloak.org/docs/latest/server_admin/#_audience_resolve) for more details.\n\n## Example Usage\n\n### Client)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    name: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst audienceMapper = new keycloak.openid.AudienceResolveProtocolMapper(\"audience_mapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    name: \"my-audience-resolve-mapper\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openid_client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    name=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\naudience_mapper = keycloak.openid.AudienceResolveProtocolMapper(\"audience_mapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    name=\"my-audience-resolve-mapper\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var openidClient = new Keycloak.OpenId.Client(\"openid_client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"client\",\n        Name = \"client\",\n        Enabled = true,\n        AccessType = \"CONFIDENTIAL\",\n        ValidRedirectUris = new[]\n        {\n            \"http://localhost:8080/openid-callback\",\n        },\n    });\n\n    var audienceMapper = new Keycloak.OpenId.AudienceResolveProtocolMapper(\"audience_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = openidClient.Id,\n        Name = \"my-audience-resolve-mapper\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openid_client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tName:       pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewAudienceResolveProtocolMapper(ctx, \"audience_mapper\", \u0026openid.AudienceResolveProtocolMapperArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: openidClient.ID(),\n\t\t\tName:     pulumi.String(\"my-audience-resolve-mapper\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.openid.AudienceResolveProtocolMapper;\nimport com.pulumi.keycloak.openid.AudienceResolveProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var openidClient = new Client(\"openidClient\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"client\")\n            .name(\"client\")\n            .enabled(true)\n            .accessType(\"CONFIDENTIAL\")\n            .validRedirectUris(\"http://localhost:8080/openid-callback\")\n            .build());\n\n        var audienceMapper = new AudienceResolveProtocolMapper(\"audienceMapper\", AudienceResolveProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(openidClient.id())\n            .name(\"my-audience-resolve-mapper\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  openidClient:\n    type: keycloak:openid:Client\n    name: openid_client\n    properties:\n      realmId: ${realm.id}\n      clientId: client\n      name: client\n      enabled: true\n      accessType: CONFIDENTIAL\n      validRedirectUris:\n        - http://localhost:8080/openid-callback\n  audienceMapper:\n    type: keycloak:openid:AudienceResolveProtocolMapper\n    name: audience_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${openidClient.id}\n      name: my-audience-resolve-mapper\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Client Scope)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n    name: \"test-client-scope\",\n});\nconst audienceMapper = new keycloak.openid.AudienceProtocolMapper(\"audience_mapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"client_scope\",\n    realm_id=realm.id,\n    name=\"test-client-scope\")\naudience_mapper = keycloak.openid.AudienceProtocolMapper(\"audience_mapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var clientScope = new Keycloak.OpenId.ClientScope(\"client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"test-client-scope\",\n    });\n\n    var audienceMapper = new Keycloak.OpenId.AudienceProtocolMapper(\"audience_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientScopeId = clientScope.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"test-client-scope\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewAudienceProtocolMapper(ctx, \"audience_mapper\", \u0026openid.AudienceProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport com.pulumi.keycloak.openid.AudienceProtocolMapper;\nimport com.pulumi.keycloak.openid.AudienceProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var clientScope = new ClientScope(\"clientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"test-client-scope\")\n            .build());\n\n        var audienceMapper = new AudienceProtocolMapper(\"audienceMapper\", AudienceProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientScopeId(clientScope.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  clientScope:\n    type: keycloak:openid:ClientScope\n    name: client_scope\n    properties:\n      realmId: ${realm.id}\n      name: test-client-scope\n  audienceMapper:\n    type: keycloak:openid:AudienceProtocolMapper\n    name: audience_mapper\n    properties:\n      realmId: ${realm.id}\n      clientScopeId: ${clientScope.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nProtocol mappers can be imported using one of the following formats:\n\n- Client: `{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}`\n\n- Client Scope: `{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}`\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:openid/audienceResolveProtocolMapper:AudienceResolveProtocolMapper audience_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n```sh\n$ pulumi import keycloak:openid/audienceResolveProtocolMapper:AudienceResolveProtocolMapper audience_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI. Defaults to \"audience resolve\".\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                    "willReplaceOnChanges": true
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI. Defaults to \"audience resolve\".\n",
                    "willReplaceOnChanges": true
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AudienceResolveProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI. Defaults to \"audience resolve\".\n",
                        "willReplaceOnChanges": true
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "aliases": [
                {
                    "type": "keycloak:openid/audienceResolveProtocolMappter:AudienceResolveProtocolMappter"
                }
            ]
        },
        "keycloak:openid/audienceResolveProtocolMappter:AudienceResolveProtocolMappter": {
            "description": "Allows for creating the \"Audience Resolve\" OIDC protocol mapper within Keycloak.\n\nThis protocol mapper is useful to avoid manual management of audiences, instead relying on the presence of client roles\nto imply which audiences are appropriate for the token. See the\n[Keycloak docs](https://www.keycloak.org/docs/latest/server_admin/#_audience_resolve) for more details.\n\n## Example Usage\n\n### Client)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    name: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst audienceMapper = new keycloak.openid.AudienceResolveProtocolMapper(\"audience_mapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    name: \"my-audience-resolve-mapper\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openid_client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    name=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\naudience_mapper = keycloak.openid.AudienceResolveProtocolMapper(\"audience_mapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    name=\"my-audience-resolve-mapper\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var openidClient = new Keycloak.OpenId.Client(\"openid_client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"client\",\n        Name = \"client\",\n        Enabled = true,\n        AccessType = \"CONFIDENTIAL\",\n        ValidRedirectUris = new[]\n        {\n            \"http://localhost:8080/openid-callback\",\n        },\n    });\n\n    var audienceMapper = new Keycloak.OpenId.AudienceResolveProtocolMapper(\"audience_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = openidClient.Id,\n        Name = \"my-audience-resolve-mapper\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openid_client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tName:       pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewAudienceResolveProtocolMapper(ctx, \"audience_mapper\", \u0026openid.AudienceResolveProtocolMapperArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: openidClient.ID(),\n\t\t\tName:     pulumi.String(\"my-audience-resolve-mapper\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.openid.AudienceResolveProtocolMapper;\nimport com.pulumi.keycloak.openid.AudienceResolveProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var openidClient = new Client(\"openidClient\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"client\")\n            .name(\"client\")\n            .enabled(true)\n            .accessType(\"CONFIDENTIAL\")\n            .validRedirectUris(\"http://localhost:8080/openid-callback\")\n            .build());\n\n        var audienceMapper = new AudienceResolveProtocolMapper(\"audienceMapper\", AudienceResolveProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(openidClient.id())\n            .name(\"my-audience-resolve-mapper\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  openidClient:\n    type: keycloak:openid:Client\n    name: openid_client\n    properties:\n      realmId: ${realm.id}\n      clientId: client\n      name: client\n      enabled: true\n      accessType: CONFIDENTIAL\n      validRedirectUris:\n        - http://localhost:8080/openid-callback\n  audienceMapper:\n    type: keycloak:openid:AudienceResolveProtocolMapper\n    name: audience_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${openidClient.id}\n      name: my-audience-resolve-mapper\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Client Scope)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n    name: \"test-client-scope\",\n});\nconst audienceMapper = new keycloak.openid.AudienceProtocolMapper(\"audience_mapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"client_scope\",\n    realm_id=realm.id,\n    name=\"test-client-scope\")\naudience_mapper = keycloak.openid.AudienceProtocolMapper(\"audience_mapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var clientScope = new Keycloak.OpenId.ClientScope(\"client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"test-client-scope\",\n    });\n\n    var audienceMapper = new Keycloak.OpenId.AudienceProtocolMapper(\"audience_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientScopeId = clientScope.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"test-client-scope\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewAudienceProtocolMapper(ctx, \"audience_mapper\", \u0026openid.AudienceProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport com.pulumi.keycloak.openid.AudienceProtocolMapper;\nimport com.pulumi.keycloak.openid.AudienceProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var clientScope = new ClientScope(\"clientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"test-client-scope\")\n            .build());\n\n        var audienceMapper = new AudienceProtocolMapper(\"audienceMapper\", AudienceProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientScopeId(clientScope.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  clientScope:\n    type: keycloak:openid:ClientScope\n    name: client_scope\n    properties:\n      realmId: ${realm.id}\n      name: test-client-scope\n  audienceMapper:\n    type: keycloak:openid:AudienceProtocolMapper\n    name: audience_mapper\n    properties:\n      realmId: ${realm.id}\n      clientScopeId: ${clientScope.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nProtocol mappers can be imported using one of the following formats:\n\n- Client: `{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}`\n\n- Client Scope: `{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}`\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:openid/audienceResolveProtocolMappter:AudienceResolveProtocolMappter audience_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n```sh\n$ pulumi import keycloak:openid/audienceResolveProtocolMappter:AudienceResolveProtocolMappter audience_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI. Defaults to \"audience resolve\".\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                    "willReplaceOnChanges": true
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI. Defaults to \"audience resolve\".\n",
                    "willReplaceOnChanges": true
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AudienceResolveProtocolMappter resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI. Defaults to \"audience resolve\".\n",
                        "willReplaceOnChanges": true
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            },
            "deprecationMessage": "keycloak.openid/audienceresolveprotocolmappter.AudienceResolveProtocolMappter has been deprecated in favor of keycloak.openid/audienceresolveprotocolmapper.AudienceResolveProtocolMapper"
        },
        "keycloak:openid/client:Client": {
            "description": "## # keycloak.openid.Client\n\nAllows for creating and managing Keycloak clients that use the OpenID Connect protocol.\n\nClients are entities that can use Keycloak for user authentication. Typically,\nclients are applications that redirect users to Keycloak for authentication\nin order to take advantage of Keycloak's user sessions for SSO.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    realmId: realm.id,\n    clientId: \"test-client\",\n    name: \"test client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openid_client\",\n    realm_id=realm.id,\n    client_id=\"test-client\",\n    name=\"test client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var openidClient = new Keycloak.OpenId.Client(\"openid_client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"test-client\",\n        Name = \"test client\",\n        Enabled = true,\n        AccessType = \"CONFIDENTIAL\",\n        ValidRedirectUris = new[]\n        {\n            \"http://localhost:8080/openid-callback\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClient(ctx, \"openid_client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tName:       pulumi.String(\"test client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var openidClient = new Client(\"openidClient\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"test-client\")\n            .name(\"test client\")\n            .enabled(true)\n            .accessType(\"CONFIDENTIAL\")\n            .validRedirectUris(\"http://localhost:8080/openid-callback\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  openidClient:\n    type: keycloak:openid:Client\n    name: openid_client\n    properties:\n      realmId: ${realm.id}\n      clientId: test-client\n      name: test client\n      enabled: true\n      accessType: CONFIDENTIAL\n      validRedirectUris:\n        - http://localhost:8080/openid-callback\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this client is attached to.\n- `client_id` - (Required) The unique ID of this client, referenced in the URI during authentication and in issued tokens.\n- `name` - (Optional) The display name of this client in the GUI.\n- `enabled` - (Optional) When false, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.\n- `description` - (Optional) The description of this client in the GUI.\n- `access_type` - (Required) Specifies the type of client, which can be one of the following:\n    - `CONFIDENTIAL` - Used for server-side clients that require both client ID and secret when authenticating.\n      This client should be used for applications using the Authorization Code or Client Credentials grant flows.\n    - `PUBLIC` - Used for browser-only applications that do not require a client secret, and instead rely only on authorized redirect\n      URIs for security. This client should be used for applications using the Implicit grant flow.\n    - `BEARER-ONLY` - Used for services that never initiate a login. This client will only allow bearer token requests.\n- `client_secret` - (Optional) The secret for clients with an `access_type` of `CONFIDENTIAL` or `BEARER-ONLY`. This value is sensitive and\nshould be treated with the same care as a password. If omitted, Keycloak will generate a GUID for this attribute.\n- `standard_flow_enabled` - (Optional) When `true`, the OAuth2 Authorization Code Grant will be enabled for this client. Defaults to `false`.\n- `implicit_flow_enabled` - (Optional) When `true`, the OAuth2 Implicit Grant will be enabled for this client. Defaults to `false`.\n- `direct_access_grants_enabled` - (Optional) When `true`, the OAuth2 Resource Owner Password Grant will be enabled for this client. Defaults to `false`.\n- `service_accounts_enabled` - (Optional) When `true`, the OAuth2 Client Credentials grant will be enabled for this client. Defaults to `false`.\n- `valid_redirect_uris` - (Optional) A list of valid URIs a browser is permitted to redirect to after a successful login or logout. Simple\nwildcards in the form of an asterisk can be used here. This attribute must be set if either `standard_flow_enabled` or `implicit_flow_enabled`\nis set to `true`.\n- `web_origins` - (Optional) A list of allowed CORS origins. `+` can be used to permit all valid redirect URIs, and `*` can be used to permit all origins.\n- `admin_url` - (Optional) URL to the admin interface of the client.\n- `base_url` - (Optional) Default URL to use when the auth server needs to redirect or link back to the client.\n- `pkce_code_challenge_method` - (Optional) The challenge method to use for Proof Key for Code Exchange. Can be either `plain` or `S256` or set to empty value ``.\n- `full_scope_allowed` - (Optional) - Allow to include all roles mappings in the access token.\n\n### Attributes Reference\n\nIn addition to the arguments listed above, the following computed attributes are exported:\n\n- `service_account_user_id` - When service accounts are enabled for this client, this attribute is the unique ID for the Keycloak user that represents this service account.\n\n\n### Import\n\nClients can be imported using the format `{{realm_id}}/{{client_keycloak_id}}`, where `client_keycloak_id` is the unique ID that Keycloak\nassigns to the client upon creation. This value can be found in the URI when editing this client in the GUI, and is typically a GUID.\n\nExample:\n\n```bash\n$ terraform import keycloak_openid_client.openid_client my-realm/dcbc4c73-e478-4928-ae2e-d5e420223352\n```\n",
            "properties": {
                "accessTokenLifespan": {
                    "type": "string"
                },
                "accessType": {
                    "type": "string"
                },
                "adminUrl": {
                    "type": "string"
                },
                "authenticationFlowBindingOverrides": {
                    "$ref": "#/types/keycloak:openid/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides"
                },
                "authorization": {
                    "$ref": "#/types/keycloak:openid/ClientAuthorization:ClientAuthorization"
                },
                "backchannelLogoutRevokeOfflineSessions": {
                    "type": "boolean"
                },
                "backchannelLogoutSessionRequired": {
                    "type": "boolean"
                },
                "backchannelLogoutUrl": {
                    "type": "string"
                },
                "baseUrl": {
                    "type": "string"
                },
                "clientAuthenticatorType": {
                    "type": "string"
                },
                "clientId": {
                    "type": "string"
                },
                "clientOfflineSessionIdleTimeout": {
                    "type": "string"
                },
                "clientOfflineSessionMaxLifespan": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string",
                    "secret": true
                },
                "clientSessionIdleTimeout": {
                    "type": "string"
                },
                "clientSessionMaxLifespan": {
                    "type": "string"
                },
                "consentRequired": {
                    "type": "boolean"
                },
                "consentScreenText": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "directAccessGrantsEnabled": {
                    "type": "boolean"
                },
                "displayOnConsentScreen": {
                    "type": "boolean"
                },
                "enabled": {
                    "type": "boolean"
                },
                "excludeSessionStateFromAuthResponse": {
                    "type": "boolean"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "frontchannelLogoutEnabled": {
                    "type": "boolean"
                },
                "frontchannelLogoutUrl": {
                    "type": "string"
                },
                "fullScopeAllowed": {
                    "type": "boolean"
                },
                "implicitFlowEnabled": {
                    "type": "boolean"
                },
                "import": {
                    "type": "boolean"
                },
                "loginTheme": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "oauth2DeviceAuthorizationGrantEnabled": {
                    "type": "boolean"
                },
                "oauth2DeviceCodeLifespan": {
                    "type": "string"
                },
                "oauth2DevicePollingInterval": {
                    "type": "string"
                },
                "pkceCodeChallengeMethod": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "rootUrl": {
                    "type": "string"
                },
                "serviceAccountUserId": {
                    "type": "string"
                },
                "serviceAccountsEnabled": {
                    "type": "boolean"
                },
                "standardFlowEnabled": {
                    "type": "boolean"
                },
                "useRefreshTokens": {
                    "type": "boolean"
                },
                "useRefreshTokensClientCredentials": {
                    "type": "boolean"
                },
                "validPostLogoutRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "validRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "webOrigins": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "accessTokenLifespan",
                "accessType",
                "adminUrl",
                "baseUrl",
                "clientId",
                "clientOfflineSessionIdleTimeout",
                "clientOfflineSessionMaxLifespan",
                "clientSecret",
                "clientSessionIdleTimeout",
                "clientSessionMaxLifespan",
                "consentRequired",
                "consentScreenText",
                "description",
                "directAccessGrantsEnabled",
                "displayOnConsentScreen",
                "excludeSessionStateFromAuthResponse",
                "frontchannelLogoutEnabled",
                "implicitFlowEnabled",
                "name",
                "realmId",
                "resourceServerId",
                "rootUrl",
                "serviceAccountUserId",
                "serviceAccountsEnabled",
                "standardFlowEnabled",
                "validPostLogoutRedirectUris",
                "validRedirectUris",
                "webOrigins"
            ],
            "inputProperties": {
                "accessTokenLifespan": {
                    "type": "string"
                },
                "accessType": {
                    "type": "string"
                },
                "adminUrl": {
                    "type": "string"
                },
                "authenticationFlowBindingOverrides": {
                    "$ref": "#/types/keycloak:openid/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides"
                },
                "authorization": {
                    "$ref": "#/types/keycloak:openid/ClientAuthorization:ClientAuthorization"
                },
                "backchannelLogoutRevokeOfflineSessions": {
                    "type": "boolean"
                },
                "backchannelLogoutSessionRequired": {
                    "type": "boolean"
                },
                "backchannelLogoutUrl": {
                    "type": "string"
                },
                "baseUrl": {
                    "type": "string"
                },
                "clientAuthenticatorType": {
                    "type": "string"
                },
                "clientId": {
                    "type": "string"
                },
                "clientOfflineSessionIdleTimeout": {
                    "type": "string"
                },
                "clientOfflineSessionMaxLifespan": {
                    "type": "string"
                },
                "clientSecret": {
                    "type": "string",
                    "secret": true
                },
                "clientSessionIdleTimeout": {
                    "type": "string"
                },
                "clientSessionMaxLifespan": {
                    "type": "string"
                },
                "consentRequired": {
                    "type": "boolean"
                },
                "consentScreenText": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "directAccessGrantsEnabled": {
                    "type": "boolean"
                },
                "displayOnConsentScreen": {
                    "type": "boolean"
                },
                "enabled": {
                    "type": "boolean"
                },
                "excludeSessionStateFromAuthResponse": {
                    "type": "boolean"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "frontchannelLogoutEnabled": {
                    "type": "boolean"
                },
                "frontchannelLogoutUrl": {
                    "type": "string"
                },
                "fullScopeAllowed": {
                    "type": "boolean"
                },
                "implicitFlowEnabled": {
                    "type": "boolean"
                },
                "import": {
                    "type": "boolean",
                    "willReplaceOnChanges": true
                },
                "loginTheme": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "oauth2DeviceAuthorizationGrantEnabled": {
                    "type": "boolean"
                },
                "oauth2DeviceCodeLifespan": {
                    "type": "string"
                },
                "oauth2DevicePollingInterval": {
                    "type": "string"
                },
                "pkceCodeChallengeMethod": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "rootUrl": {
                    "type": "string"
                },
                "serviceAccountsEnabled": {
                    "type": "boolean"
                },
                "standardFlowEnabled": {
                    "type": "boolean"
                },
                "useRefreshTokens": {
                    "type": "boolean"
                },
                "useRefreshTokensClientCredentials": {
                    "type": "boolean"
                },
                "validPostLogoutRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "validRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "webOrigins": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "requiredInputs": [
                "accessType",
                "clientId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Client resources.\n",
                "properties": {
                    "accessTokenLifespan": {
                        "type": "string"
                    },
                    "accessType": {
                        "type": "string"
                    },
                    "adminUrl": {
                        "type": "string"
                    },
                    "authenticationFlowBindingOverrides": {
                        "$ref": "#/types/keycloak:openid/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides"
                    },
                    "authorization": {
                        "$ref": "#/types/keycloak:openid/ClientAuthorization:ClientAuthorization"
                    },
                    "backchannelLogoutRevokeOfflineSessions": {
                        "type": "boolean"
                    },
                    "backchannelLogoutSessionRequired": {
                        "type": "boolean"
                    },
                    "backchannelLogoutUrl": {
                        "type": "string"
                    },
                    "baseUrl": {
                        "type": "string"
                    },
                    "clientAuthenticatorType": {
                        "type": "string"
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "clientOfflineSessionIdleTimeout": {
                        "type": "string"
                    },
                    "clientOfflineSessionMaxLifespan": {
                        "type": "string"
                    },
                    "clientSecret": {
                        "type": "string",
                        "secret": true
                    },
                    "clientSessionIdleTimeout": {
                        "type": "string"
                    },
                    "clientSessionMaxLifespan": {
                        "type": "string"
                    },
                    "consentRequired": {
                        "type": "boolean"
                    },
                    "consentScreenText": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "directAccessGrantsEnabled": {
                        "type": "boolean"
                    },
                    "displayOnConsentScreen": {
                        "type": "boolean"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "excludeSessionStateFromAuthResponse": {
                        "type": "boolean"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "frontchannelLogoutEnabled": {
                        "type": "boolean"
                    },
                    "frontchannelLogoutUrl": {
                        "type": "string"
                    },
                    "fullScopeAllowed": {
                        "type": "boolean"
                    },
                    "implicitFlowEnabled": {
                        "type": "boolean"
                    },
                    "import": {
                        "type": "boolean",
                        "willReplaceOnChanges": true
                    },
                    "loginTheme": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "oauth2DeviceAuthorizationGrantEnabled": {
                        "type": "boolean"
                    },
                    "oauth2DeviceCodeLifespan": {
                        "type": "string"
                    },
                    "oauth2DevicePollingInterval": {
                        "type": "string"
                    },
                    "pkceCodeChallengeMethod": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "rootUrl": {
                        "type": "string"
                    },
                    "serviceAccountUserId": {
                        "type": "string"
                    },
                    "serviceAccountsEnabled": {
                        "type": "boolean"
                    },
                    "standardFlowEnabled": {
                        "type": "boolean"
                    },
                    "useRefreshTokens": {
                        "type": "boolean"
                    },
                    "useRefreshTokensClientCredentials": {
                        "type": "boolean"
                    },
                    "validPostLogoutRedirectUris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "validRedirectUris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "webOrigins": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientAggregatePolicy:ClientAggregatePolicy": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "required": [
                "decisionStrategy",
                "name",
                "policies",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "decisionStrategy",
                "policies",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientAggregatePolicy resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientAuthorizationPermission:ClientAuthorizationPermission": {
            "description": "Allows you to manage openid Client Authorization Permissions.\n\n## Import\n\nClient authorization permissions can be imported using the format: `{{realmId}}/{{resourceServerId}}/{{permissionId}}`.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:openid/clientAuthorizationPermission:ClientAuthorizationPermission test my-realm/3bd4a686-1062-4b59-97b8-e4e3f10b99da/63b3cde8-987d-4cd9-9306-1955579281d9\n```\n\n",
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "resourceType": {
                    "type": "string"
                },
                "resources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "resourceServerId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "resourceType": {
                    "type": "string"
                },
                "resources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "type": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientAuthorizationPermission resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "resourceServerId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "resourceType": {
                        "type": "string"
                    },
                    "resources": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientAuthorizationResource:ClientAuthorizationResource": {
            "properties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "displayName": {
                    "type": "string"
                },
                "iconUri": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "ownerManagedAccess": {
                    "type": "boolean"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "type": {
                    "type": "string"
                },
                "uris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "displayName": {
                    "type": "string"
                },
                "iconUri": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "ownerManagedAccess": {
                    "type": "boolean"
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "resourceServerId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "type": {
                    "type": "string"
                },
                "uris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "requiredInputs": [
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientAuthorizationResource resources.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "displayName": {
                        "type": "string"
                    },
                    "iconUri": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "ownerManagedAccess": {
                        "type": "boolean"
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "resourceServerId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "type": {
                        "type": "string"
                    },
                    "uris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientAuthorizationScope:ClientAuthorizationScope": {
            "properties": {
                "displayName": {
                    "type": "string"
                },
                "iconUri": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "displayName": {
                    "type": "string"
                },
                "iconUri": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "resourceServerId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientAuthorizationScope resources.\n",
                "properties": {
                    "displayName": {
                        "type": "string"
                    },
                    "iconUri": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "resourceServerId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientDefaultScopes:ClientDefaultScopes": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"test-client\",\n    accessType: \"CONFIDENTIAL\",\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n    name: \"test-client-scope\",\n});\nconst clientDefaultScopes = new keycloak.openid.ClientDefaultScopes(\"client_default_scopes\", {\n    realmId: realm.id,\n    clientId: client.id,\n    defaultScopes: [\n        \"profile\",\n        \"email\",\n        \"roles\",\n        \"web-origins\",\n        clientScope.name,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"test-client\",\n    access_type=\"CONFIDENTIAL\")\nclient_scope = keycloak.openid.ClientScope(\"client_scope\",\n    realm_id=realm.id,\n    name=\"test-client-scope\")\nclient_default_scopes = keycloak.openid.ClientDefaultScopes(\"client_default_scopes\",\n    realm_id=realm.id,\n    client_id=client.id,\n    default_scopes=[\n        \"profile\",\n        \"email\",\n        \"roles\",\n        \"web-origins\",\n        client_scope.name,\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var client = new Keycloak.OpenId.Client(\"client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"test-client\",\n        AccessType = \"CONFIDENTIAL\",\n    });\n\n    var clientScope = new Keycloak.OpenId.ClientScope(\"client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"test-client-scope\",\n    });\n\n    var clientDefaultScopes = new Keycloak.OpenId.ClientDefaultScopes(\"client_default_scopes\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = client.Id,\n        DefaultScopes = new[]\n        {\n            \"profile\",\n            \"email\",\n            \"roles\",\n            \"web-origins\",\n            clientScope.Name,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"test-client-scope\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientDefaultScopes(ctx, \"client_default_scopes\", \u0026openid.ClientDefaultScopesArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: client.ID(),\n\t\t\tDefaultScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"profile\"),\n\t\t\t\tpulumi.String(\"email\"),\n\t\t\t\tpulumi.String(\"roles\"),\n\t\t\t\tpulumi.String(\"web-origins\"),\n\t\t\t\tclientScope.Name,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport com.pulumi.keycloak.openid.ClientDefaultScopes;\nimport com.pulumi.keycloak.openid.ClientDefaultScopesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var client = new Client(\"client\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"test-client\")\n            .accessType(\"CONFIDENTIAL\")\n            .build());\n\n        var clientScope = new ClientScope(\"clientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"test-client-scope\")\n            .build());\n\n        var clientDefaultScopes = new ClientDefaultScopes(\"clientDefaultScopes\", ClientDefaultScopesArgs.builder()\n            .realmId(realm.id())\n            .clientId(client.id())\n            .defaultScopes(            \n                \"profile\",\n                \"email\",\n                \"roles\",\n                \"web-origins\",\n                clientScope.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  client:\n    type: keycloak:openid:Client\n    properties:\n      realmId: ${realm.id}\n      clientId: test-client\n      accessType: CONFIDENTIAL\n  clientScope:\n    type: keycloak:openid:ClientScope\n    name: client_scope\n    properties:\n      realmId: ${realm.id}\n      name: test-client-scope\n  clientDefaultScopes:\n    type: keycloak:openid:ClientDefaultScopes\n    name: client_default_scopes\n    properties:\n      realmId: ${realm.id}\n      clientId: ${client.id}\n      defaultScopes:\n        - profile\n        - email\n        - roles\n        - web-origins\n        - ${clientScope.name}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this client and scopes exists in.\n- `client_id` - (Required) The ID of the client to attach default scopes to. Note that this is the unique ID of the client generated by Keycloak.\n- `default_scopes` - (Required) An array of client scope names to attach to this client.\n\n### Import\n\nThis resource does not support import. Instead of importing, feel free to create this resource\nas if it did not already exist on the server.\n",
            "properties": {
                "clientId": {
                    "type": "string"
                },
                "defaultScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "clientId",
                "defaultScopes",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "defaultScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clientId",
                "defaultScopes",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientDefaultScopes resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "defaultScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientGroupPolicy:ClientGroupPolicy": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:openid/ClientGroupPolicyGroup:ClientGroupPolicyGroup"
                    }
                },
                "groupsClaim": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "required": [
                "decisionStrategy",
                "groups",
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:openid/ClientGroupPolicyGroup:ClientGroupPolicyGroup"
                    }
                },
                "groupsClaim": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "decisionStrategy",
                "groups",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientGroupPolicy resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "groups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:openid/ClientGroupPolicyGroup:ClientGroupPolicyGroup"
                        }
                    },
                    "groupsClaim": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientJsPolicy:ClientJsPolicy": {
            "properties": {
                "code": {
                    "type": "string"
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "code",
                "decisionStrategy",
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "code": {
                    "type": "string"
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "code",
                "decisionStrategy",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientJsPolicy resources.\n",
                "properties": {
                    "code": {
                        "type": "string"
                    },
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientOptionalScopes:ClientOptionalScopes": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"test-client\",\n    accessType: \"CONFIDENTIAL\",\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n    name: \"test-client-scope\",\n});\nconst clientOptionalScopes = new keycloak.openid.ClientOptionalScopes(\"client_optional_scopes\", {\n    realmId: realm.id,\n    clientId: client.id,\n    optionalScopes: [\n        \"address\",\n        \"phone\",\n        \"offline_access\",\n        clientScope.name,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"test-client\",\n    access_type=\"CONFIDENTIAL\")\nclient_scope = keycloak.openid.ClientScope(\"client_scope\",\n    realm_id=realm.id,\n    name=\"test-client-scope\")\nclient_optional_scopes = keycloak.openid.ClientOptionalScopes(\"client_optional_scopes\",\n    realm_id=realm.id,\n    client_id=client.id,\n    optional_scopes=[\n        \"address\",\n        \"phone\",\n        \"offline_access\",\n        client_scope.name,\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var client = new Keycloak.OpenId.Client(\"client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"test-client\",\n        AccessType = \"CONFIDENTIAL\",\n    });\n\n    var clientScope = new Keycloak.OpenId.ClientScope(\"client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"test-client-scope\",\n    });\n\n    var clientOptionalScopes = new Keycloak.OpenId.ClientOptionalScopes(\"client_optional_scopes\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = client.Id,\n        OptionalScopes = new[]\n        {\n            \"address\",\n            \"phone\",\n            \"offline_access\",\n            clientScope.Name,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"test-client-scope\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientOptionalScopes(ctx, \"client_optional_scopes\", \u0026openid.ClientOptionalScopesArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: client.ID(),\n\t\t\tOptionalScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"address\"),\n\t\t\t\tpulumi.String(\"phone\"),\n\t\t\t\tpulumi.String(\"offline_access\"),\n\t\t\t\tclientScope.Name,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport com.pulumi.keycloak.openid.ClientOptionalScopes;\nimport com.pulumi.keycloak.openid.ClientOptionalScopesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var client = new Client(\"client\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"test-client\")\n            .accessType(\"CONFIDENTIAL\")\n            .build());\n\n        var clientScope = new ClientScope(\"clientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"test-client-scope\")\n            .build());\n\n        var clientOptionalScopes = new ClientOptionalScopes(\"clientOptionalScopes\", ClientOptionalScopesArgs.builder()\n            .realmId(realm.id())\n            .clientId(client.id())\n            .optionalScopes(            \n                \"address\",\n                \"phone\",\n                \"offline_access\",\n                clientScope.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  client:\n    type: keycloak:openid:Client\n    properties:\n      realmId: ${realm.id}\n      clientId: test-client\n      accessType: CONFIDENTIAL\n  clientScope:\n    type: keycloak:openid:ClientScope\n    name: client_scope\n    properties:\n      realmId: ${realm.id}\n      name: test-client-scope\n  clientOptionalScopes:\n    type: keycloak:openid:ClientOptionalScopes\n    name: client_optional_scopes\n    properties:\n      realmId: ${realm.id}\n      clientId: ${client.id}\n      optionalScopes:\n        - address\n        - phone\n        - offline_access\n        - ${clientScope.name}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this client and scopes exists in.\n- `client_id` - (Required) The ID of the client to attach optional scopes to. Note that this is the unique ID of the client generated by Keycloak.\n- `optional_scopes` - (Required) An array of client scope names to attach to this client as optional scopes.\n\n### Import\n\nThis resource does not support import. Instead of importing, feel free to create this resource\nas if it did not already exist on the server.\n",
            "properties": {
                "clientId": {
                    "type": "string"
                },
                "optionalScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "clientId",
                "optionalScopes",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "optionalScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clientId",
                "optionalScopes",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientOptionalScopes resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "optionalScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientPermissions:ClientPermissions": {
            "description": "Allows you to manage all openid client Scope Based Permissions.\n\nThis is part of a preview keycloak feature. You need to enable this feature to be able to use this resource. More\ninformation about enabling the preview feature can be found\nhere: https://www.keycloak.org/docs/latest/securing_apps/index.html#_token-exchange\n\nWhen enabling Openid Client Permissions, Keycloak does several things automatically:\n\n1. Enable Authorization on build-in realm-management client\n1. Create scopes \"view\", \"manage\", \"configure\", \"map-roles\", \"map-roles-client-scope\", \"map-roles-composite\", \"\n   token-exchange\"\n1. Create a resource representing the openid client\n1. Create all scope based permission for the scopes and openid client resource\n\nIf the realm-management Authorization is not enable, you have to ceate a dependency (`depends_on`) with the policy and\nthe openid client.\n",
            "properties": {
                "authorizationResourceServerId": {
                    "type": "string",
                    "description": "Resource server id representing the realm management client on which this permission is managed\n"
                },
                "clientId": {
                    "type": "string"
                },
                "configureScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsConfigureScope:ClientPermissionsConfigureScope"
                },
                "enabled": {
                    "type": "boolean"
                },
                "manageScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsManageScope:ClientPermissionsManageScope"
                },
                "mapRolesClientScopeScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsMapRolesClientScopeScope:ClientPermissionsMapRolesClientScopeScope"
                },
                "mapRolesCompositeScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsMapRolesCompositeScope:ClientPermissionsMapRolesCompositeScope"
                },
                "mapRolesScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsMapRolesScope:ClientPermissionsMapRolesScope"
                },
                "realmId": {
                    "type": "string"
                },
                "tokenExchangeScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsTokenExchangeScope:ClientPermissionsTokenExchangeScope"
                },
                "viewScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsViewScope:ClientPermissionsViewScope"
                }
            },
            "required": [
                "authorizationResourceServerId",
                "clientId",
                "enabled",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "configureScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsConfigureScope:ClientPermissionsConfigureScope"
                },
                "manageScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsManageScope:ClientPermissionsManageScope"
                },
                "mapRolesClientScopeScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsMapRolesClientScopeScope:ClientPermissionsMapRolesClientScopeScope"
                },
                "mapRolesCompositeScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsMapRolesCompositeScope:ClientPermissionsMapRolesCompositeScope"
                },
                "mapRolesScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsMapRolesScope:ClientPermissionsMapRolesScope"
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "tokenExchangeScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsTokenExchangeScope:ClientPermissionsTokenExchangeScope"
                },
                "viewScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsViewScope:ClientPermissionsViewScope"
                }
            },
            "requiredInputs": [
                "clientId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientPermissions resources.\n",
                "properties": {
                    "authorizationResourceServerId": {
                        "type": "string",
                        "description": "Resource server id representing the realm management client on which this permission is managed\n"
                    },
                    "clientId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "configureScope": {
                        "$ref": "#/types/keycloak:openid/ClientPermissionsConfigureScope:ClientPermissionsConfigureScope"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "manageScope": {
                        "$ref": "#/types/keycloak:openid/ClientPermissionsManageScope:ClientPermissionsManageScope"
                    },
                    "mapRolesClientScopeScope": {
                        "$ref": "#/types/keycloak:openid/ClientPermissionsMapRolesClientScopeScope:ClientPermissionsMapRolesClientScopeScope"
                    },
                    "mapRolesCompositeScope": {
                        "$ref": "#/types/keycloak:openid/ClientPermissionsMapRolesCompositeScope:ClientPermissionsMapRolesCompositeScope"
                    },
                    "mapRolesScope": {
                        "$ref": "#/types/keycloak:openid/ClientPermissionsMapRolesScope:ClientPermissionsMapRolesScope"
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "tokenExchangeScope": {
                        "$ref": "#/types/keycloak:openid/ClientPermissionsTokenExchangeScope:ClientPermissionsTokenExchangeScope"
                    },
                    "viewScope": {
                        "$ref": "#/types/keycloak:openid/ClientPermissionsViewScope:ClientPermissionsViewScope"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientPolicy:ClientPolicy": {
            "description": "This resource can be used to create client policy.\n\n## Example Usage\n\nIn this example, we'll create a new OpenID client, then enabled permissions for the client. A client without permissions disabled cannot be assigned by a client policy. We'll use the `keycloak.openid.ClientPolicy` resource to create a new client policy, which could be applied to many clients, for a realm and a resource_server_id.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    clientId: \"openid_client\",\n    name: \"openid_client\",\n    realmId: realm.id,\n    accessType: \"CONFIDENTIAL\",\n    serviceAccountsEnabled: true,\n});\nconst myPermission = new keycloak.openid.ClientPermissions(\"my_permission\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n});\nconst realmManagement = keycloak.openid.getClient({\n    realmId: \"my-realm\",\n    clientId: \"realm-management\",\n});\nconst tokenExchange = new keycloak.openid.ClientPolicy(\"token_exchange\", {\n    resourceServerId: realmManagement.then(realmManagement =\u003e realmManagement.id),\n    realmId: realm.id,\n    name: \"my-policy\",\n    logic: \"POSITIVE\",\n    decisionStrategy: \"UNANIMOUS\",\n    clients: [openidClient.id],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openid_client\",\n    client_id=\"openid_client\",\n    name=\"openid_client\",\n    realm_id=realm.id,\n    access_type=\"CONFIDENTIAL\",\n    service_accounts_enabled=True)\nmy_permission = keycloak.openid.ClientPermissions(\"my_permission\",\n    realm_id=realm.id,\n    client_id=openid_client.id)\nrealm_management = keycloak.openid.get_client(realm_id=\"my-realm\",\n    client_id=\"realm-management\")\ntoken_exchange = keycloak.openid.ClientPolicy(\"token_exchange\",\n    resource_server_id=realm_management.id,\n    realm_id=realm.id,\n    name=\"my-policy\",\n    logic=\"POSITIVE\",\n    decision_strategy=\"UNANIMOUS\",\n    clients=[openid_client.id])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var openidClient = new Keycloak.OpenId.Client(\"openid_client\", new()\n    {\n        ClientId = \"openid_client\",\n        Name = \"openid_client\",\n        RealmId = realm.Id,\n        AccessType = \"CONFIDENTIAL\",\n        ServiceAccountsEnabled = true,\n    });\n\n    var myPermission = new Keycloak.OpenId.ClientPermissions(\"my_permission\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = openidClient.Id,\n    });\n\n    var realmManagement = Keycloak.OpenId.GetClient.Invoke(new()\n    {\n        RealmId = \"my-realm\",\n        ClientId = \"realm-management\",\n    });\n\n    var tokenExchange = new Keycloak.OpenId.ClientPolicy(\"token_exchange\", new()\n    {\n        ResourceServerId = realmManagement.Apply(getClientResult =\u003e getClientResult.Id),\n        RealmId = realm.Id,\n        Name = \"my-policy\",\n        Logic = \"POSITIVE\",\n        DecisionStrategy = \"UNANIMOUS\",\n        Clients = new[]\n        {\n            openidClient.Id,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openid_client\", \u0026openid.ClientArgs{\n\t\t\tClientId:               pulumi.String(\"openid_client\"),\n\t\t\tName:                   pulumi.String(\"openid_client\"),\n\t\t\tRealmId:                realm.ID(),\n\t\t\tAccessType:             pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tServiceAccountsEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientPermissions(ctx, \"my_permission\", \u0026openid.ClientPermissionsArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: openidClient.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmManagement, err := openid.LookupClient(ctx, \u0026openid.LookupClientArgs{\n\t\t\tRealmId:  \"my-realm\",\n\t\t\tClientId: \"realm-management\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientPolicy(ctx, \"token_exchange\", \u0026openid.ClientPolicyArgs{\n\t\t\tResourceServerId: pulumi.String(realmManagement.Id),\n\t\t\tRealmId:          realm.ID(),\n\t\t\tName:             pulumi.String(\"my-policy\"),\n\t\t\tLogic:            pulumi.String(\"POSITIVE\"),\n\t\t\tDecisionStrategy: pulumi.String(\"UNANIMOUS\"),\n\t\t\tClients: pulumi.StringArray{\n\t\t\t\topenidClient.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.openid.ClientPermissions;\nimport com.pulumi.keycloak.openid.ClientPermissionsArgs;\nimport com.pulumi.keycloak.openid.OpenidFunctions;\nimport com.pulumi.keycloak.openid.inputs.GetClientArgs;\nimport com.pulumi.keycloak.openid.ClientPolicy;\nimport com.pulumi.keycloak.openid.ClientPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var openidClient = new Client(\"openidClient\", ClientArgs.builder()\n            .clientId(\"openid_client\")\n            .name(\"openid_client\")\n            .realmId(realm.id())\n            .accessType(\"CONFIDENTIAL\")\n            .serviceAccountsEnabled(true)\n            .build());\n\n        var myPermission = new ClientPermissions(\"myPermission\", ClientPermissionsArgs.builder()\n            .realmId(realm.id())\n            .clientId(openidClient.id())\n            .build());\n\n        final var realmManagement = OpenidFunctions.getClient(GetClientArgs.builder()\n            .realmId(\"my-realm\")\n            .clientId(\"realm-management\")\n            .build());\n\n        var tokenExchange = new ClientPolicy(\"tokenExchange\", ClientPolicyArgs.builder()\n            .resourceServerId(realmManagement.applyValue(getClientResult -\u003e getClientResult.id()))\n            .realmId(realm.id())\n            .name(\"my-policy\")\n            .logic(\"POSITIVE\")\n            .decisionStrategy(\"UNANIMOUS\")\n            .clients(openidClient.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  openidClient:\n    type: keycloak:openid:Client\n    name: openid_client\n    properties:\n      clientId: openid_client\n      name: openid_client\n      realmId: ${realm.id}\n      accessType: CONFIDENTIAL\n      serviceAccountsEnabled: true\n  myPermission:\n    type: keycloak:openid:ClientPermissions\n    name: my_permission\n    properties:\n      realmId: ${realm.id}\n      clientId: ${openidClient.id}\n  tokenExchange:\n    type: keycloak:openid:ClientPolicy\n    name: token_exchange\n    properties:\n      resourceServerId: ${realmManagement.id}\n      realmId: ${realm.id}\n      name: my-policy\n      logic: POSITIVE\n      decisionStrategy: UNANIMOUS\n      clients:\n        - ${openidClient.id}\nvariables:\n  realmManagement:\n    fn::invoke:\n      Function: keycloak:openid:getClient\n      Arguments:\n        realmId: my-realm\n        clientId: realm-management\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "clients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The clients allowed by this client policy.\n"
                },
                "decisionStrategy": {
                    "type": "string",
                    "description": "(Computed) Dictates how the policies associated with a given permission are evaluated and how a final decision is obtained. Could be one of `AFFIRMATIVE`, `CONSENSUS`, or `UNANIMOUS`. Applies to permissions.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client policy.\n"
                },
                "logic": {
                    "type": "string",
                    "description": "(Computed) Dictates how the policy decision should be made. Can be either `POSITIVE` or `NEGATIVE`. Applies to policies.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of this client policy.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client policy exists within.\n"
                },
                "resourceServerId": {
                    "type": "string",
                    "description": "The ID of the resource server this client policy is attached to.\n"
                }
            },
            "required": [
                "clients",
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "clients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The clients allowed by this client policy.\n"
                },
                "decisionStrategy": {
                    "type": "string",
                    "description": "(Computed) Dictates how the policies associated with a given permission are evaluated and how a final decision is obtained. Could be one of `AFFIRMATIVE`, `CONSENSUS`, or `UNANIMOUS`. Applies to permissions.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client policy.\n"
                },
                "logic": {
                    "type": "string",
                    "description": "(Computed) Dictates how the policy decision should be made. Can be either `POSITIVE` or `NEGATIVE`. Applies to policies.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of this client policy.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client policy exists within.\n"
                },
                "resourceServerId": {
                    "type": "string",
                    "description": "The ID of the resource server this client policy is attached to.\n"
                }
            },
            "requiredInputs": [
                "clients",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientPolicy resources.\n",
                "properties": {
                    "clients": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The clients allowed by this client policy.\n"
                    },
                    "decisionStrategy": {
                        "type": "string",
                        "description": "(Computed) Dictates how the policies associated with a given permission are evaluated and how a final decision is obtained. Could be one of `AFFIRMATIVE`, `CONSENSUS`, or `UNANIMOUS`. Applies to permissions.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of this client policy.\n"
                    },
                    "logic": {
                        "type": "string",
                        "description": "(Computed) Dictates how the policy decision should be made. Can be either `POSITIVE` or `NEGATIVE`. Applies to policies.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of this client policy.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this client policy exists within.\n"
                    },
                    "resourceServerId": {
                        "type": "string",
                        "description": "The ID of the resource server this client policy is attached to.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientRolePolicy:ClientRolePolicy": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:openid/ClientRolePolicyRole:ClientRolePolicyRole"
                    }
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId",
                "resourceServerId",
                "roles",
                "type"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:openid/ClientRolePolicyRole:ClientRolePolicyRole"
                    }
                },
                "type": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "resourceServerId",
                "roles",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientRolePolicy resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:openid/ClientRolePolicyRole:ClientRolePolicyRole"
                        }
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientScope:ClientScope": {
            "description": "## # keycloak.openid.ClientScope\n\nAllows for creating and managing Keycloak client scopes that can be attached to\nclients that use the OpenID Connect protocol.\n\nClient Scopes can be used to share common protocol and role mappings between multiple\nclients within a realm. They can also be used by clients to conditionally request\nclaims or roles for a user based on the OAuth 2.0 `scope` parameter.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClientScope = new keycloak.openid.ClientScope(\"openid_client_scope\", {\n    realmId: realm.id,\n    name: \"groups\",\n    description: \"When requested, this scope will map a user's group memberships to a claim\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client_scope = keycloak.openid.ClientScope(\"openid_client_scope\",\n    realm_id=realm.id,\n    name=\"groups\",\n    description=\"When requested, this scope will map a user's group memberships to a claim\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var openidClientScope = new Keycloak.OpenId.ClientScope(\"openid_client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"groups\",\n        Description = \"When requested, this scope will map a user's group memberships to a claim\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientScope(ctx, \"openid_client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tName:        pulumi.String(\"groups\"),\n\t\t\tDescription: pulumi.String(\"When requested, this scope will map a user's group memberships to a claim\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var openidClientScope = new ClientScope(\"openidClientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"groups\")\n            .description(\"When requested, this scope will map a user's group memberships to a claim\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  openidClientScope:\n    type: keycloak:openid:ClientScope\n    name: openid_client_scope\n    properties:\n      realmId: ${realm.id}\n      name: groups\n      description: When requested, this scope will map a user's group memberships to a claim\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this client scope belongs to.\n- `name` - (Required) The display name of this client scope in the GUI.\n- `description` - (Optional) The description of this client scope in the GUI.\n- `consent_screen_text` - (Optional) When set, a consent screen will be displayed to users\nauthenticating to clients with this scope attached. The consent screen will display the string\nvalue of this attribute.\n\n### Import\n\nClient scopes can be imported using the format `{{realm_id}}/{{client_scope_id}}`, where `client_scope_id` is the unique ID that Keycloak\nassigns to the client scope upon creation. This value can be found in the URI when editing this client scope in the GUI, and is typically a GUID.\n\nExample:\n\n```bash\n$ terraform import keycloak_openid_client_scope.openid_client_scope my-realm/8e8f7fe1-df9b-40ed-bed3-4597aa0dac52\n```\n",
            "properties": {
                "consentScreenText": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "guiOrder": {
                    "type": "integer"
                },
                "includeInTokenScope": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "consentScreenText": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "guiOrder": {
                    "type": "integer"
                },
                "includeInTokenScope": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientScope resources.\n",
                "properties": {
                    "consentScreenText": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "guiOrder": {
                        "type": "integer"
                    },
                    "includeInTokenScope": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientServiceAccountRealmRole:ClientServiceAccountRealmRole": {
            "description": "Allows for assigning realm roles to the service account of an openid client.\nYou need to set `service_accounts_enabled` to `true` for the openid client that should be assigned the role.\n\nIf you'd like to attach client roles to a service account, please use the `keycloak.openid.ClientServiceAccountRole`\nresource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst realmRole = new keycloak.Role(\"realm_role\", {\n    realmId: realm.id,\n    name: \"my-realm-role\",\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    name: \"client\",\n    serviceAccountsEnabled: true,\n});\nconst clientServiceAccountRole = new keycloak.openid.ClientServiceAccountRealmRole(\"client_service_account_role\", {\n    realmId: realm.id,\n    serviceAccountUserId: client.serviceAccountUserId,\n    role: realmRole.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrealm_role = keycloak.Role(\"realm_role\",\n    realm_id=realm.id,\n    name=\"my-realm-role\")\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    name=\"client\",\n    service_accounts_enabled=True)\nclient_service_account_role = keycloak.openid.ClientServiceAccountRealmRole(\"client_service_account_role\",\n    realm_id=realm.id,\n    service_account_user_id=client.service_account_user_id,\n    role=realm_role.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var realmRole = new Keycloak.Role(\"realm_role\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-realm-role\",\n    });\n\n    var client = new Keycloak.OpenId.Client(\"client\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"client\",\n        ServiceAccountsEnabled = true,\n    });\n\n    var clientServiceAccountRole = new Keycloak.OpenId.ClientServiceAccountRealmRole(\"client_service_account_role\", new()\n    {\n        RealmId = realm.Id,\n        ServiceAccountUserId = client.ServiceAccountUserId,\n        Role = realmRole.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmRole, err := keycloak.NewRole(ctx, \"realm_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"my-realm-role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:                realm.ID(),\n\t\t\tName:                   pulumi.String(\"client\"),\n\t\t\tServiceAccountsEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientServiceAccountRealmRole(ctx, \"client_service_account_role\", \u0026openid.ClientServiceAccountRealmRoleArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tServiceAccountUserId: client.ServiceAccountUserId,\n\t\t\tRole:                 realmRole.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.openid.ClientServiceAccountRealmRole;\nimport com.pulumi.keycloak.openid.ClientServiceAccountRealmRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var realmRole = new Role(\"realmRole\", RoleArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-realm-role\")\n            .build());\n\n        var client = new Client(\"client\", ClientArgs.builder()\n            .realmId(realm.id())\n            .name(\"client\")\n            .serviceAccountsEnabled(true)\n            .build());\n\n        var clientServiceAccountRole = new ClientServiceAccountRealmRole(\"clientServiceAccountRole\", ClientServiceAccountRealmRoleArgs.builder()\n            .realmId(realm.id())\n            .serviceAccountUserId(client.serviceAccountUserId())\n            .role(realmRole.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  realmRole:\n    type: keycloak:Role\n    name: realm_role\n    properties:\n      realmId: ${realm.id}\n      name: my-realm-role\n  client:\n    type: keycloak:openid:Client\n    properties:\n      realmId: ${realm.id}\n      name: client\n      serviceAccountsEnabled: true\n  clientServiceAccountRole:\n    type: keycloak:openid:ClientServiceAccountRealmRole\n    name: client_service_account_role\n    properties:\n      realmId: ${realm.id}\n      serviceAccountUserId: ${client.serviceAccountUserId}\n      role: ${realmRole.name}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nThis resource can be imported using the format `{{realmId}}/{{serviceAccountUserId}}/{{roleId}}`.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:openid/clientServiceAccountRealmRole:ClientServiceAccountRealmRole client_service_account_role my-realm/489ba513-1ceb-49ba-ae0b-1ab1f5099ebf/c7230ab7-8e4e-4135-995d-e81b50696ad8\n```\n\n",
            "properties": {
                "realmId": {
                    "type": "string",
                    "description": "The realm that the client and role belong to.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role that is assigned.\n"
                },
                "serviceAccountUserId": {
                    "type": "string",
                    "description": "The id of the service account that is assigned the role (the service account of the client that \"consumes\" the role).\n"
                }
            },
            "required": [
                "realmId",
                "role",
                "serviceAccountUserId"
            ],
            "inputProperties": {
                "realmId": {
                    "type": "string",
                    "description": "The realm that the client and role belong to.\n",
                    "willReplaceOnChanges": true
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role that is assigned.\n",
                    "willReplaceOnChanges": true
                },
                "serviceAccountUserId": {
                    "type": "string",
                    "description": "The id of the service account that is assigned the role (the service account of the client that \"consumes\" the role).\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "realmId",
                "role",
                "serviceAccountUserId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientServiceAccountRealmRole resources.\n",
                "properties": {
                    "realmId": {
                        "type": "string",
                        "description": "The realm that the client and role belong to.\n",
                        "willReplaceOnChanges": true
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the role that is assigned.\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceAccountUserId": {
                        "type": "string",
                        "description": "The id of the service account that is assigned the role (the service account of the client that \"consumes\" the role).\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientServiceAccountRole:ClientServiceAccountRole": {
            "description": "Allows for assigning client roles to the service account of an openid client.\nYou need to set `service_accounts_enabled` to `true` for the openid client that should be assigned the role.\n\nIf you'd like to attach realm roles to a service account, please use the `keycloak.openid.ClientServiceAccountRealmRole`\nresource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\n// client1 provides a role to other clients\nconst client1 = new keycloak.openid.Client(\"client1\", {\n    realmId: realm.id,\n    name: \"client1\",\n});\nconst client1Role = new keycloak.Role(\"client1_role\", {\n    realmId: realm.id,\n    clientId: client1.id,\n    name: \"my-client1-role\",\n    description: \"A role that client1 provides\",\n});\n// client2 is assigned the role of client1\nconst client2 = new keycloak.openid.Client(\"client2\", {\n    realmId: realm.id,\n    name: \"client2\",\n    serviceAccountsEnabled: true,\n});\nconst client2ServiceAccountRole = new keycloak.openid.ClientServiceAccountRole(\"client2_service_account_role\", {\n    realmId: realm.id,\n    serviceAccountUserId: client2.serviceAccountUserId,\n    clientId: client1.id,\n    role: client1Role.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\n# client1 provides a role to other clients\nclient1 = keycloak.openid.Client(\"client1\",\n    realm_id=realm.id,\n    name=\"client1\")\nclient1_role = keycloak.Role(\"client1_role\",\n    realm_id=realm.id,\n    client_id=client1.id,\n    name=\"my-client1-role\",\n    description=\"A role that client1 provides\")\n# client2 is assigned the role of client1\nclient2 = keycloak.openid.Client(\"client2\",\n    realm_id=realm.id,\n    name=\"client2\",\n    service_accounts_enabled=True)\nclient2_service_account_role = keycloak.openid.ClientServiceAccountRole(\"client2_service_account_role\",\n    realm_id=realm.id,\n    service_account_user_id=client2.service_account_user_id,\n    client_id=client1.id,\n    role=client1_role.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    // client1 provides a role to other clients\n    var client1 = new Keycloak.OpenId.Client(\"client1\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"client1\",\n    });\n\n    var client1Role = new Keycloak.Role(\"client1_role\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = client1.Id,\n        Name = \"my-client1-role\",\n        Description = \"A role that client1 provides\",\n    });\n\n    // client2 is assigned the role of client1\n    var client2 = new Keycloak.OpenId.Client(\"client2\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"client2\",\n        ServiceAccountsEnabled = true,\n    });\n\n    var client2ServiceAccountRole = new Keycloak.OpenId.ClientServiceAccountRole(\"client2_service_account_role\", new()\n    {\n        RealmId = realm.Id,\n        ServiceAccountUserId = client2.ServiceAccountUserId,\n        ClientId = client1.Id,\n        Role = client1Role.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// client1 provides a role to other clients\n\t\tclient1, err := openid.NewClient(ctx, \"client1\", \u0026openid.ClientArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"client1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient1Role, err := keycloak.NewRole(ctx, \"client1_role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    client1.ID(),\n\t\t\tName:        pulumi.String(\"my-client1-role\"),\n\t\t\tDescription: pulumi.String(\"A role that client1 provides\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// client2 is assigned the role of client1\n\t\tclient2, err := openid.NewClient(ctx, \"client2\", \u0026openid.ClientArgs{\n\t\t\tRealmId:                realm.ID(),\n\t\t\tName:                   pulumi.String(\"client2\"),\n\t\t\tServiceAccountsEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientServiceAccountRole(ctx, \"client2_service_account_role\", \u0026openid.ClientServiceAccountRoleArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tServiceAccountUserId: client2.ServiceAccountUserId,\n\t\t\tClientId:             client1.ID(),\n\t\t\tRole:                 client1Role.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport com.pulumi.keycloak.openid.ClientServiceAccountRole;\nimport com.pulumi.keycloak.openid.ClientServiceAccountRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        // client1 provides a role to other clients\n        var client1 = new Client(\"client1\", ClientArgs.builder()\n            .realmId(realm.id())\n            .name(\"client1\")\n            .build());\n\n        var client1Role = new Role(\"client1Role\", RoleArgs.builder()\n            .realmId(realm.id())\n            .clientId(client1.id())\n            .name(\"my-client1-role\")\n            .description(\"A role that client1 provides\")\n            .build());\n\n        // client2 is assigned the role of client1\n        var client2 = new Client(\"client2\", ClientArgs.builder()\n            .realmId(realm.id())\n            .name(\"client2\")\n            .serviceAccountsEnabled(true)\n            .build());\n\n        var client2ServiceAccountRole = new ClientServiceAccountRole(\"client2ServiceAccountRole\", ClientServiceAccountRoleArgs.builder()\n            .realmId(realm.id())\n            .serviceAccountUserId(client2.serviceAccountUserId())\n            .clientId(client1.id())\n            .role(client1Role.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  # client1 provides a role to other clients\n  client1:\n    type: keycloak:openid:Client\n    properties:\n      realmId: ${realm.id}\n      name: client1\n  client1Role:\n    type: keycloak:Role\n    name: client1_role\n    properties:\n      realmId: ${realm.id}\n      clientId: ${client1.id}\n      name: my-client1-role\n      description: A role that client1 provides\n  # client2 is assigned the role of client1\n  client2:\n    type: keycloak:openid:Client\n    properties:\n      realmId: ${realm.id}\n      name: client2\n      serviceAccountsEnabled: true\n  client2ServiceAccountRole:\n    type: keycloak:openid:ClientServiceAccountRole\n    name: client2_service_account_role\n    properties:\n      realmId: ${realm.id}\n      serviceAccountUserId: ${client2.serviceAccountUserId}\n      clientId: ${client1.id}\n      role: ${client1Role.name}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nThis resource can be imported using the format `{{realmId}}/{{serviceAccountUserId}}/{{clientId}}/{{roleId}}`.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:openid/clientServiceAccountRole:ClientServiceAccountRole client2_service_account_role my-realm/489ba513-1ceb-49ba-ae0b-1ab1f5099ebf/baf01820-0f8b-4494-9be2-fb3bc8a397a4/c7230ab7-8e4e-4135-995d-e81b50696ad8\n```\n\n",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The id of the client that provides the role.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the clients and roles belong to.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role that is assigned.\n"
                },
                "serviceAccountUserId": {
                    "type": "string",
                    "description": "The id of the service account that is assigned the role (the service account of the client that \"consumes\" the role).\n"
                }
            },
            "required": [
                "clientId",
                "realmId",
                "role",
                "serviceAccountUserId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The id of the client that provides the role.\n",
                    "willReplaceOnChanges": true
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the clients and roles belong to.\n",
                    "willReplaceOnChanges": true
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role that is assigned.\n",
                    "willReplaceOnChanges": true
                },
                "serviceAccountUserId": {
                    "type": "string",
                    "description": "The id of the service account that is assigned the role (the service account of the client that \"consumes\" the role).\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clientId",
                "realmId",
                "role",
                "serviceAccountUserId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientServiceAccountRole resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The id of the client that provides the role.\n",
                        "willReplaceOnChanges": true
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm the clients and roles belong to.\n",
                        "willReplaceOnChanges": true
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the role that is assigned.\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceAccountUserId": {
                        "type": "string",
                        "description": "The id of the service account that is assigned the role (the service account of the client that \"consumes\" the role).\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientTimePolicy:ClientTimePolicy": {
            "properties": {
                "dayMonth": {
                    "type": "string"
                },
                "dayMonthEnd": {
                    "type": "string"
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "hour": {
                    "type": "string"
                },
                "hourEnd": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "minute": {
                    "type": "string"
                },
                "minuteEnd": {
                    "type": "string"
                },
                "month": {
                    "type": "string"
                },
                "monthEnd": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "notBefore": {
                    "type": "string"
                },
                "notOnOrAfter": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "year": {
                    "type": "string"
                },
                "yearEnd": {
                    "type": "string"
                }
            },
            "required": [
                "decisionStrategy",
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "dayMonth": {
                    "type": "string"
                },
                "dayMonthEnd": {
                    "type": "string"
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "hour": {
                    "type": "string"
                },
                "hourEnd": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "minute": {
                    "type": "string"
                },
                "minuteEnd": {
                    "type": "string"
                },
                "month": {
                    "type": "string"
                },
                "monthEnd": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "notBefore": {
                    "type": "string"
                },
                "notOnOrAfter": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "year": {
                    "type": "string"
                },
                "yearEnd": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "decisionStrategy",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientTimePolicy resources.\n",
                "properties": {
                    "dayMonth": {
                        "type": "string"
                    },
                    "dayMonthEnd": {
                        "type": "string"
                    },
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "hour": {
                        "type": "string"
                    },
                    "hourEnd": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "minute": {
                        "type": "string"
                    },
                    "minuteEnd": {
                        "type": "string"
                    },
                    "month": {
                        "type": "string"
                    },
                    "monthEnd": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "notBefore": {
                        "type": "string"
                    },
                    "notOnOrAfter": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "year": {
                        "type": "string"
                    },
                    "yearEnd": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientUserPolicy:ClientUserPolicy": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "decisionStrategy",
                "name",
                "realmId",
                "resourceServerId",
                "users"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "requiredInputs": [
                "decisionStrategy",
                "realmId",
                "resourceServerId",
                "users"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientUserPolicy resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "users": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/fullNameProtocolMapper:FullNameProtocolMapper": {
            "description": "## # keycloak.openid.FullNameProtocolMapper\n\nAllows for creating and managing full name protocol mappers within\nKeycloak.\n\nFull name protocol mappers allow you to map a user's first and last name\nto the OpenID Connect `name` claim in a token. Protocol mappers can be defined\nfor a single client, or they can be defined for a client scope which can\nbe shared between multiple different clients.\n\n### Example Usage (Client)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    realmId: realm.id,\n    clientId: \"test-client\",\n    name: \"test client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst fullNameMapper = new keycloak.openid.FullNameProtocolMapper(\"full_name_mapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    name: \"full-name-mapper\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openid_client\",\n    realm_id=realm.id,\n    client_id=\"test-client\",\n    name=\"test client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nfull_name_mapper = keycloak.openid.FullNameProtocolMapper(\"full_name_mapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    name=\"full-name-mapper\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var openidClient = new Keycloak.OpenId.Client(\"openid_client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"test-client\",\n        Name = \"test client\",\n        Enabled = true,\n        AccessType = \"CONFIDENTIAL\",\n        ValidRedirectUris = new[]\n        {\n            \"http://localhost:8080/openid-callback\",\n        },\n    });\n\n    var fullNameMapper = new Keycloak.OpenId.FullNameProtocolMapper(\"full_name_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = openidClient.Id,\n        Name = \"full-name-mapper\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openid_client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tName:       pulumi.String(\"test client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewFullNameProtocolMapper(ctx, \"full_name_mapper\", \u0026openid.FullNameProtocolMapperArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: openidClient.ID(),\n\t\t\tName:     pulumi.String(\"full-name-mapper\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.openid.FullNameProtocolMapper;\nimport com.pulumi.keycloak.openid.FullNameProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var openidClient = new Client(\"openidClient\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"test-client\")\n            .name(\"test client\")\n            .enabled(true)\n            .accessType(\"CONFIDENTIAL\")\n            .validRedirectUris(\"http://localhost:8080/openid-callback\")\n            .build());\n\n        var fullNameMapper = new FullNameProtocolMapper(\"fullNameMapper\", FullNameProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(openidClient.id())\n            .name(\"full-name-mapper\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  openidClient:\n    type: keycloak:openid:Client\n    name: openid_client\n    properties:\n      realmId: ${realm.id}\n      clientId: test-client\n      name: test client\n      enabled: true\n      accessType: CONFIDENTIAL\n      validRedirectUris:\n        - http://localhost:8080/openid-callback\n  fullNameMapper:\n    type: keycloak:openid:FullNameProtocolMapper\n    name: full_name_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${openidClient.id}\n      name: full-name-mapper\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Usage (Client Scope)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n    name: \"test-client-scope\",\n});\nconst fullNameMapper = new keycloak.openid.FullNameProtocolMapper(\"full_name_mapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    name: \"full-name-mapper\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"client_scope\",\n    realm_id=realm.id,\n    name=\"test-client-scope\")\nfull_name_mapper = keycloak.openid.FullNameProtocolMapper(\"full_name_mapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    name=\"full-name-mapper\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var clientScope = new Keycloak.OpenId.ClientScope(\"client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"test-client-scope\",\n    });\n\n    var fullNameMapper = new Keycloak.OpenId.FullNameProtocolMapper(\"full_name_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientScopeId = clientScope.Id,\n        Name = \"full-name-mapper\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"test-client-scope\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewFullNameProtocolMapper(ctx, \"full_name_mapper\", \u0026openid.FullNameProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tName:          pulumi.String(\"full-name-mapper\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport com.pulumi.keycloak.openid.FullNameProtocolMapper;\nimport com.pulumi.keycloak.openid.FullNameProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var clientScope = new ClientScope(\"clientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"test-client-scope\")\n            .build());\n\n        var fullNameMapper = new FullNameProtocolMapper(\"fullNameMapper\", FullNameProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientScopeId(clientScope.id())\n            .name(\"full-name-mapper\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  clientScope:\n    type: keycloak:openid:ClientScope\n    name: client_scope\n    properties:\n      realmId: ${realm.id}\n      name: test-client-scope\n  fullNameMapper:\n    type: keycloak:openid:FullNameProtocolMapper\n    name: full_name_mapper\n    properties:\n      realmId: ${realm.id}\n      clientScopeId: ${clientScope.id}\n      name: full-name-mapper\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `add_to_id_token` - (Optional) Indicates if the user's full name should be added as a claim to the id token. Defaults to `true`.\n- `add_to_access_token` - (Optional) Indicates if the user's full name should be added as a claim to the access token. Defaults to `true`.\n- `add_to_userinfo` - (Optional) Indicates if the user's full name should be added as a claim to the UserInfo response body. Defaults to `true`.\n\n### Import\n\nProtocol mappers can be imported using one of the following formats:\n- Client: `{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}`\n- Client Scope: `{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}`\n\nExample:\n\n```bash\n$ terraform import keycloak_openid_full_name_protocol_mapper.full_name_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n$ terraform import keycloak_openid_full_name_protocol_mapper.full_name_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean"
                },
                "addToIdToken": {
                    "type": "boolean"
                },
                "addToUserinfo": {
                    "type": "boolean"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean"
                },
                "addToIdToken": {
                    "type": "boolean"
                },
                "addToUserinfo": {
                    "type": "boolean"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n",
                    "willReplaceOnChanges": true
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n",
                    "willReplaceOnChanges": true
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FullNameProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean"
                    },
                    "addToIdToken": {
                        "type": "boolean"
                    },
                    "addToUserinfo": {
                        "type": "boolean"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n",
                        "willReplaceOnChanges": true
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/groupMembershipProtocolMapper:GroupMembershipProtocolMapper": {
            "description": "## # keycloak.openid.GroupMembershipProtocolMapper\n\nAllows for creating and managing group membership protocol mappers within\nKeycloak.\n\nGroup membership protocol mappers allow you to map a user's group memberships\nto a claim in a token. Protocol mappers can be defined for a single client,\nor they can be defined for a client scope which can be shared between multiple\ndifferent clients.\n\n### Example Usage (Client)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    realmId: realm.id,\n    clientId: \"test-client\",\n    name: \"test client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst groupMembershipMapper = new keycloak.openid.GroupMembershipProtocolMapper(\"group_membership_mapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    name: \"group-membership-mapper\",\n    claimName: \"groups\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openid_client\",\n    realm_id=realm.id,\n    client_id=\"test-client\",\n    name=\"test client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\ngroup_membership_mapper = keycloak.openid.GroupMembershipProtocolMapper(\"group_membership_mapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    name=\"group-membership-mapper\",\n    claim_name=\"groups\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var openidClient = new Keycloak.OpenId.Client(\"openid_client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"test-client\",\n        Name = \"test client\",\n        Enabled = true,\n        AccessType = \"CONFIDENTIAL\",\n        ValidRedirectUris = new[]\n        {\n            \"http://localhost:8080/openid-callback\",\n        },\n    });\n\n    var groupMembershipMapper = new Keycloak.OpenId.GroupMembershipProtocolMapper(\"group_membership_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = openidClient.Id,\n        Name = \"group-membership-mapper\",\n        ClaimName = \"groups\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openid_client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tName:       pulumi.String(\"test client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewGroupMembershipProtocolMapper(ctx, \"group_membership_mapper\", \u0026openid.GroupMembershipProtocolMapperArgs{\n\t\t\tRealmId:   realm.ID(),\n\t\t\tClientId:  openidClient.ID(),\n\t\t\tName:      pulumi.String(\"group-membership-mapper\"),\n\t\t\tClaimName: pulumi.String(\"groups\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.openid.GroupMembershipProtocolMapper;\nimport com.pulumi.keycloak.openid.GroupMembershipProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var openidClient = new Client(\"openidClient\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"test-client\")\n            .name(\"test client\")\n            .enabled(true)\n            .accessType(\"CONFIDENTIAL\")\n            .validRedirectUris(\"http://localhost:8080/openid-callback\")\n            .build());\n\n        var groupMembershipMapper = new GroupMembershipProtocolMapper(\"groupMembershipMapper\", GroupMembershipProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(openidClient.id())\n            .name(\"group-membership-mapper\")\n            .claimName(\"groups\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  openidClient:\n    type: keycloak:openid:Client\n    name: openid_client\n    properties:\n      realmId: ${realm.id}\n      clientId: test-client\n      name: test client\n      enabled: true\n      accessType: CONFIDENTIAL\n      validRedirectUris:\n        - http://localhost:8080/openid-callback\n  groupMembershipMapper:\n    type: keycloak:openid:GroupMembershipProtocolMapper\n    name: group_membership_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${openidClient.id}\n      name: group-membership-mapper\n      claimName: groups\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Usage (Client Scope)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n    name: \"test-client-scope\",\n});\nconst groupMembershipMapper = new keycloak.openid.GroupMembershipProtocolMapper(\"group_membership_mapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    name: \"group-membership-mapper\",\n    claimName: \"groups\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"client_scope\",\n    realm_id=realm.id,\n    name=\"test-client-scope\")\ngroup_membership_mapper = keycloak.openid.GroupMembershipProtocolMapper(\"group_membership_mapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    name=\"group-membership-mapper\",\n    claim_name=\"groups\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var clientScope = new Keycloak.OpenId.ClientScope(\"client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"test-client-scope\",\n    });\n\n    var groupMembershipMapper = new Keycloak.OpenId.GroupMembershipProtocolMapper(\"group_membership_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientScopeId = clientScope.Id,\n        Name = \"group-membership-mapper\",\n        ClaimName = \"groups\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"test-client-scope\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewGroupMembershipProtocolMapper(ctx, \"group_membership_mapper\", \u0026openid.GroupMembershipProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tName:          pulumi.String(\"group-membership-mapper\"),\n\t\t\tClaimName:     pulumi.String(\"groups\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport com.pulumi.keycloak.openid.GroupMembershipProtocolMapper;\nimport com.pulumi.keycloak.openid.GroupMembershipProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var clientScope = new ClientScope(\"clientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"test-client-scope\")\n            .build());\n\n        var groupMembershipMapper = new GroupMembershipProtocolMapper(\"groupMembershipMapper\", GroupMembershipProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientScopeId(clientScope.id())\n            .name(\"group-membership-mapper\")\n            .claimName(\"groups\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  clientScope:\n    type: keycloak:openid:ClientScope\n    name: client_scope\n    properties:\n      realmId: ${realm.id}\n      name: test-client-scope\n  groupMembershipMapper:\n    type: keycloak:openid:GroupMembershipProtocolMapper\n    name: group_membership_mapper\n    properties:\n      realmId: ${realm.id}\n      clientScopeId: ${clientScope.id}\n      name: group-membership-mapper\n      claimName: groups\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `claim_name` - (Required) The name of the claim to insert into a token.\n- `full_path` - (Optional) Indicates whether the full path of the group including its parents will be used. Defaults to `true`.\n- `add_to_id_token` - (Optional) Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n- `add_to_access_token` - (Optional) Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n- `add_to_userinfo` - (Optional) Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n\n### Import\n\nProtocol mappers can be imported using one of the following formats:\n- Client: `{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}`\n- Client Scope: `{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}`\n\nExample:\n\n```bash\n$ terraform import keycloak_openid_group_membership_protocol_mapper.group_membership_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n$ terraform import keycloak_openid_group_membership_protocol_mapper.group_membership_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean"
                },
                "addToIdToken": {
                    "type": "boolean"
                },
                "addToUserinfo": {
                    "type": "boolean"
                },
                "claimName": {
                    "type": "string"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "fullPath": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean"
                },
                "addToIdToken": {
                    "type": "boolean"
                },
                "addToUserinfo": {
                    "type": "boolean"
                },
                "claimName": {
                    "type": "string"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n",
                    "willReplaceOnChanges": true
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n",
                    "willReplaceOnChanges": true
                },
                "fullPath": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n",
                    "willReplaceOnChanges": true
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupMembershipProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean"
                    },
                    "addToIdToken": {
                        "type": "boolean"
                    },
                    "addToUserinfo": {
                        "type": "boolean"
                    },
                    "claimName": {
                        "type": "string"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n",
                        "willReplaceOnChanges": true
                    },
                    "fullPath": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n",
                        "willReplaceOnChanges": true
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/hardcodedClaimProtocolMapper:HardcodedClaimProtocolMapper": {
            "description": "## # keycloak.openid.HardcodedClaimProtocolMapper\n\nAllows for creating and managing hardcoded claim protocol mappers within\nKeycloak.\n\nHardcoded claim protocol mappers allow you to define a claim with a hardcoded\nvalue. Protocol mappers can be defined for a single client, or they can\nbe defined for a client scope which can be shared between multiple different\nclients.\n\n### Example Usage (Client)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    realmId: realm.id,\n    clientId: \"test-client\",\n    name: \"test client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst hardcodedClaimMapper = new keycloak.openid.HardcodedClaimProtocolMapper(\"hardcoded_claim_mapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    name: \"hardcoded-claim-mapper\",\n    claimName: \"foo\",\n    claimValue: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openid_client\",\n    realm_id=realm.id,\n    client_id=\"test-client\",\n    name=\"test client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nhardcoded_claim_mapper = keycloak.openid.HardcodedClaimProtocolMapper(\"hardcoded_claim_mapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    name=\"hardcoded-claim-mapper\",\n    claim_name=\"foo\",\n    claim_value=\"bar\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var openidClient = new Keycloak.OpenId.Client(\"openid_client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"test-client\",\n        Name = \"test client\",\n        Enabled = true,\n        AccessType = \"CONFIDENTIAL\",\n        ValidRedirectUris = new[]\n        {\n            \"http://localhost:8080/openid-callback\",\n        },\n    });\n\n    var hardcodedClaimMapper = new Keycloak.OpenId.HardcodedClaimProtocolMapper(\"hardcoded_claim_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = openidClient.Id,\n        Name = \"hardcoded-claim-mapper\",\n        ClaimName = \"foo\",\n        ClaimValue = \"bar\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openid_client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tName:       pulumi.String(\"test client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewHardcodedClaimProtocolMapper(ctx, \"hardcoded_claim_mapper\", \u0026openid.HardcodedClaimProtocolMapperArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   openidClient.ID(),\n\t\t\tName:       pulumi.String(\"hardcoded-claim-mapper\"),\n\t\t\tClaimName:  pulumi.String(\"foo\"),\n\t\t\tClaimValue: pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.openid.HardcodedClaimProtocolMapper;\nimport com.pulumi.keycloak.openid.HardcodedClaimProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var openidClient = new Client(\"openidClient\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"test-client\")\n            .name(\"test client\")\n            .enabled(true)\n            .accessType(\"CONFIDENTIAL\")\n            .validRedirectUris(\"http://localhost:8080/openid-callback\")\n            .build());\n\n        var hardcodedClaimMapper = new HardcodedClaimProtocolMapper(\"hardcodedClaimMapper\", HardcodedClaimProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(openidClient.id())\n            .name(\"hardcoded-claim-mapper\")\n            .claimName(\"foo\")\n            .claimValue(\"bar\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  openidClient:\n    type: keycloak:openid:Client\n    name: openid_client\n    properties:\n      realmId: ${realm.id}\n      clientId: test-client\n      name: test client\n      enabled: true\n      accessType: CONFIDENTIAL\n      validRedirectUris:\n        - http://localhost:8080/openid-callback\n  hardcodedClaimMapper:\n    type: keycloak:openid:HardcodedClaimProtocolMapper\n    name: hardcoded_claim_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${openidClient.id}\n      name: hardcoded-claim-mapper\n      claimName: foo\n      claimValue: bar\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Usage (Client Scope)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n    name: \"test-client-scope\",\n});\nconst hardcodedClaimMapper = new keycloak.openid.HardcodedClaimProtocolMapper(\"hardcoded_claim_mapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    name: \"hardcoded-claim-mapper\",\n    claimName: \"foo\",\n    claimValue: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"client_scope\",\n    realm_id=realm.id,\n    name=\"test-client-scope\")\nhardcoded_claim_mapper = keycloak.openid.HardcodedClaimProtocolMapper(\"hardcoded_claim_mapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    name=\"hardcoded-claim-mapper\",\n    claim_name=\"foo\",\n    claim_value=\"bar\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var clientScope = new Keycloak.OpenId.ClientScope(\"client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"test-client-scope\",\n    });\n\n    var hardcodedClaimMapper = new Keycloak.OpenId.HardcodedClaimProtocolMapper(\"hardcoded_claim_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientScopeId = clientScope.Id,\n        Name = \"hardcoded-claim-mapper\",\n        ClaimName = \"foo\",\n        ClaimValue = \"bar\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"test-client-scope\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewHardcodedClaimProtocolMapper(ctx, \"hardcoded_claim_mapper\", \u0026openid.HardcodedClaimProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tName:          pulumi.String(\"hardcoded-claim-mapper\"),\n\t\t\tClaimName:     pulumi.String(\"foo\"),\n\t\t\tClaimValue:    pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport com.pulumi.keycloak.openid.HardcodedClaimProtocolMapper;\nimport com.pulumi.keycloak.openid.HardcodedClaimProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var clientScope = new ClientScope(\"clientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"test-client-scope\")\n            .build());\n\n        var hardcodedClaimMapper = new HardcodedClaimProtocolMapper(\"hardcodedClaimMapper\", HardcodedClaimProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientScopeId(clientScope.id())\n            .name(\"hardcoded-claim-mapper\")\n            .claimName(\"foo\")\n            .claimValue(\"bar\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  clientScope:\n    type: keycloak:openid:ClientScope\n    name: client_scope\n    properties:\n      realmId: ${realm.id}\n      name: test-client-scope\n  hardcodedClaimMapper:\n    type: keycloak:openid:HardcodedClaimProtocolMapper\n    name: hardcoded_claim_mapper\n    properties:\n      realmId: ${realm.id}\n      clientScopeId: ${clientScope.id}\n      name: hardcoded-claim-mapper\n      claimName: foo\n      claimValue: bar\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `claim_name` - (Required) The name of the claim to insert into a token.\n- `claim_value` - (Required) The hardcoded value of the claim.\n- `claim_value_type` - (Optional) The claim type used when serializing JSON tokens. Can be one of `String`, `long`, `int`, or `boolean`. Defaults to `String`.\n- `add_to_id_token` - (Optional) Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n- `add_to_access_token` - (Optional) Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n- `add_to_userinfo` - (Optional) Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n\n### Import\n\nProtocol mappers can be imported using one of the following formats:\n- Client: `{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}`\n- Client Scope: `{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}`\n\nExample:\n\n```bash\n$ terraform import keycloak_openid_hardcoded_claim_protocol_mapper.hardcoded_claim_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n$ terraform import keycloak_openid_hardcoded_claim_protocol_mapper.hardcoded_claim_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the id token.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValue": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                }
            },
            "required": [
                "claimName",
                "claimValue",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the id token.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValue": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n",
                    "willReplaceOnChanges": true
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "claimName",
                "claimValue",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedClaimProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be a claim in the access token.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be a claim in the id token.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                    },
                    "claimName": {
                        "type": "string"
                    },
                    "claimValue": {
                        "type": "string"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "Claim type used when serializing tokens.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/hardcodedRoleProtocolMapper:HardcodedRoleProtocolMapper": {
            "description": "## # keycloak.openid.HardcodedRoleProtocolMapper\n\nAllows for creating and managing hardcoded role protocol mappers within\nKeycloak.\n\nHardcoded role protocol mappers allow you to specify a single role to\nalways map to an access token for a client. Protocol mappers can be\ndefined for a single client, or they can be defined for a client scope\nwhich can be shared between multiple different clients.\n\n### Example Usage (Client)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst role = new keycloak.Role(\"role\", {\n    realmId: realm.id,\n    name: \"my-role\",\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    realmId: realm.id,\n    clientId: \"test-client\",\n    name: \"test client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst hardcodedRoleMapper = new keycloak.openid.HardcodedRoleProtocolMapper(\"hardcoded_role_mapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    name: \"hardcoded-role-mapper\",\n    roleId: role.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrole = keycloak.Role(\"role\",\n    realm_id=realm.id,\n    name=\"my-role\")\nopenid_client = keycloak.openid.Client(\"openid_client\",\n    realm_id=realm.id,\n    client_id=\"test-client\",\n    name=\"test client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nhardcoded_role_mapper = keycloak.openid.HardcodedRoleProtocolMapper(\"hardcoded_role_mapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    name=\"hardcoded-role-mapper\",\n    role_id=role.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var role = new Keycloak.Role(\"role\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-role\",\n    });\n\n    var openidClient = new Keycloak.OpenId.Client(\"openid_client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"test-client\",\n        Name = \"test client\",\n        Enabled = true,\n        AccessType = \"CONFIDENTIAL\",\n        ValidRedirectUris = new[]\n        {\n            \"http://localhost:8080/openid-callback\",\n        },\n    });\n\n    var hardcodedRoleMapper = new Keycloak.OpenId.HardcodedRoleProtocolMapper(\"hardcoded_role_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = openidClient.Id,\n        Name = \"hardcoded-role-mapper\",\n        RoleId = role.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trole, err := keycloak.NewRole(ctx, \"role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"my-role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openid_client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tName:       pulumi.String(\"test client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewHardcodedRoleProtocolMapper(ctx, \"hardcoded_role_mapper\", \u0026openid.HardcodedRoleProtocolMapperArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: openidClient.ID(),\n\t\t\tName:     pulumi.String(\"hardcoded-role-mapper\"),\n\t\t\tRoleId:   role.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.openid.HardcodedRoleProtocolMapper;\nimport com.pulumi.keycloak.openid.HardcodedRoleProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var role = new Role(\"role\", RoleArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-role\")\n            .build());\n\n        var openidClient = new Client(\"openidClient\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"test-client\")\n            .name(\"test client\")\n            .enabled(true)\n            .accessType(\"CONFIDENTIAL\")\n            .validRedirectUris(\"http://localhost:8080/openid-callback\")\n            .build());\n\n        var hardcodedRoleMapper = new HardcodedRoleProtocolMapper(\"hardcodedRoleMapper\", HardcodedRoleProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(openidClient.id())\n            .name(\"hardcoded-role-mapper\")\n            .roleId(role.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  role:\n    type: keycloak:Role\n    properties:\n      realmId: ${realm.id}\n      name: my-role\n  openidClient:\n    type: keycloak:openid:Client\n    name: openid_client\n    properties:\n      realmId: ${realm.id}\n      clientId: test-client\n      name: test client\n      enabled: true\n      accessType: CONFIDENTIAL\n      validRedirectUris:\n        - http://localhost:8080/openid-callback\n  hardcodedRoleMapper:\n    type: keycloak:openid:HardcodedRoleProtocolMapper\n    name: hardcoded_role_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${openidClient.id}\n      name: hardcoded-role-mapper\n      roleId: ${role.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Usage (Client Scope)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst role = new keycloak.Role(\"role\", {\n    realmId: realm.id,\n    name: \"my-role\",\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n    name: \"test-client-scope\",\n});\nconst hardcodedRoleMapper = new keycloak.openid.HardcodedRoleProtocolMapper(\"hardcoded_role_mapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    name: \"hardcoded-role-mapper\",\n    roleId: role.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrole = keycloak.Role(\"role\",\n    realm_id=realm.id,\n    name=\"my-role\")\nclient_scope = keycloak.openid.ClientScope(\"client_scope\",\n    realm_id=realm.id,\n    name=\"test-client-scope\")\nhardcoded_role_mapper = keycloak.openid.HardcodedRoleProtocolMapper(\"hardcoded_role_mapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    name=\"hardcoded-role-mapper\",\n    role_id=role.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var role = new Keycloak.Role(\"role\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"my-role\",\n    });\n\n    var clientScope = new Keycloak.OpenId.ClientScope(\"client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"test-client-scope\",\n    });\n\n    var hardcodedRoleMapper = new Keycloak.OpenId.HardcodedRoleProtocolMapper(\"hardcoded_role_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientScopeId = clientScope.Id,\n        Name = \"hardcoded-role-mapper\",\n        RoleId = role.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trole, err := keycloak.NewRole(ctx, \"role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"my-role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"test-client-scope\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewHardcodedRoleProtocolMapper(ctx, \"hardcoded_role_mapper\", \u0026openid.HardcodedRoleProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tName:          pulumi.String(\"hardcoded-role-mapper\"),\n\t\t\tRoleId:        role.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport com.pulumi.keycloak.openid.HardcodedRoleProtocolMapper;\nimport com.pulumi.keycloak.openid.HardcodedRoleProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var role = new Role(\"role\", RoleArgs.builder()\n            .realmId(realm.id())\n            .name(\"my-role\")\n            .build());\n\n        var clientScope = new ClientScope(\"clientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"test-client-scope\")\n            .build());\n\n        var hardcodedRoleMapper = new HardcodedRoleProtocolMapper(\"hardcodedRoleMapper\", HardcodedRoleProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientScopeId(clientScope.id())\n            .name(\"hardcoded-role-mapper\")\n            .roleId(role.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  role:\n    type: keycloak:Role\n    properties:\n      realmId: ${realm.id}\n      name: my-role\n  clientScope:\n    type: keycloak:openid:ClientScope\n    name: client_scope\n    properties:\n      realmId: ${realm.id}\n      name: test-client-scope\n  hardcodedRoleMapper:\n    type: keycloak:openid:HardcodedRoleProtocolMapper\n    name: hardcoded_role_mapper\n    properties:\n      realmId: ${realm.id}\n      clientScopeId: ${clientScope.id}\n      name: hardcoded-role-mapper\n      roleId: ${role.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the\n  GUI.\n- `role_id` - (Required) The ID of the role to map to an access token.\n\n### Import\n\nProtocol mappers can be imported using one of the following formats:\n- Client: `{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}`\n- Client Scope: `{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}`\n\nExample:\n\n```bash\n$ terraform import keycloak_openid_hardcoded_role_protocol_mapper.hardcoded_role_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n$ terraform import keycloak_openid_hardcoded_role_protocol_mapper.hardcoded_role_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                },
                "roleId": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId",
                "roleId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n",
                    "willReplaceOnChanges": true
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n",
                    "willReplaceOnChanges": true
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n",
                    "willReplaceOnChanges": true
                },
                "roleId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "roleId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedRoleProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n",
                        "willReplaceOnChanges": true
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/scriptProtocolMapper:ScriptProtocolMapper": {
            "description": "Allows for creating and managing script protocol mappers within Keycloak.\n\nScript protocol mappers evaluate a JavaScript function to produce a token claim based on context information.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n\u003e Support for this protocol mapper was removed in Keycloak 18.\n\n## Example Usage\n\n### Client)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    name: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst scriptMapper = new keycloak.openid.ScriptProtocolMapper(\"script_mapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    name: \"script-mapper\",\n    claimName: \"foo\",\n    script: \"exports = 'foo';\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openid_client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    name=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nscript_mapper = keycloak.openid.ScriptProtocolMapper(\"script_mapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    name=\"script-mapper\",\n    claim_name=\"foo\",\n    script=\"exports = 'foo';\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var openidClient = new Keycloak.OpenId.Client(\"openid_client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"client\",\n        Name = \"client\",\n        Enabled = true,\n        AccessType = \"CONFIDENTIAL\",\n        ValidRedirectUris = new[]\n        {\n            \"http://localhost:8080/openid-callback\",\n        },\n    });\n\n    var scriptMapper = new Keycloak.OpenId.ScriptProtocolMapper(\"script_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = openidClient.Id,\n        Name = \"script-mapper\",\n        ClaimName = \"foo\",\n        Script = \"exports = 'foo';\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openid_client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tName:       pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewScriptProtocolMapper(ctx, \"script_mapper\", \u0026openid.ScriptProtocolMapperArgs{\n\t\t\tRealmId:   realm.ID(),\n\t\t\tClientId:  openidClient.ID(),\n\t\t\tName:      pulumi.String(\"script-mapper\"),\n\t\t\tClaimName: pulumi.String(\"foo\"),\n\t\t\tScript:    pulumi.String(\"exports = 'foo';\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.openid.ScriptProtocolMapper;\nimport com.pulumi.keycloak.openid.ScriptProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var openidClient = new Client(\"openidClient\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"client\")\n            .name(\"client\")\n            .enabled(true)\n            .accessType(\"CONFIDENTIAL\")\n            .validRedirectUris(\"http://localhost:8080/openid-callback\")\n            .build());\n\n        var scriptMapper = new ScriptProtocolMapper(\"scriptMapper\", ScriptProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(openidClient.id())\n            .name(\"script-mapper\")\n            .claimName(\"foo\")\n            .script(\"exports = 'foo';\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  openidClient:\n    type: keycloak:openid:Client\n    name: openid_client\n    properties:\n      realmId: ${realm.id}\n      clientId: client\n      name: client\n      enabled: true\n      accessType: CONFIDENTIAL\n      validRedirectUris:\n        - http://localhost:8080/openid-callback\n  scriptMapper:\n    type: keycloak:openid:ScriptProtocolMapper\n    name: script_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${openidClient.id}\n      name: script-mapper\n      claimName: foo\n      script: exports = 'foo';\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Client Scope)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n    name: \"client-scope\",\n});\nconst scriptMapper = new keycloak.openid.ScriptProtocolMapper(\"script_mapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    name: \"script-mapper\",\n    claimName: \"foo\",\n    script: \"exports = 'foo';\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"client_scope\",\n    realm_id=realm.id,\n    name=\"client-scope\")\nscript_mapper = keycloak.openid.ScriptProtocolMapper(\"script_mapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    name=\"script-mapper\",\n    claim_name=\"foo\",\n    script=\"exports = 'foo';\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var clientScope = new Keycloak.OpenId.ClientScope(\"client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"client-scope\",\n    });\n\n    var scriptMapper = new Keycloak.OpenId.ScriptProtocolMapper(\"script_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientScopeId = clientScope.Id,\n        Name = \"script-mapper\",\n        ClaimName = \"foo\",\n        Script = \"exports = 'foo';\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"client-scope\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewScriptProtocolMapper(ctx, \"script_mapper\", \u0026openid.ScriptProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tName:          pulumi.String(\"script-mapper\"),\n\t\t\tClaimName:     pulumi.String(\"foo\"),\n\t\t\tScript:        pulumi.String(\"exports = 'foo';\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport com.pulumi.keycloak.openid.ScriptProtocolMapper;\nimport com.pulumi.keycloak.openid.ScriptProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var clientScope = new ClientScope(\"clientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"client-scope\")\n            .build());\n\n        var scriptMapper = new ScriptProtocolMapper(\"scriptMapper\", ScriptProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientScopeId(clientScope.id())\n            .name(\"script-mapper\")\n            .claimName(\"foo\")\n            .script(\"exports = 'foo';\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  clientScope:\n    type: keycloak:openid:ClientScope\n    name: client_scope\n    properties:\n      realmId: ${realm.id}\n      name: client-scope\n  scriptMapper:\n    type: keycloak:openid:ScriptProtocolMapper\n    name: script_mapper\n    properties:\n      realmId: ${realm.id}\n      clientScopeId: ${clientScope.id}\n      name: script-mapper\n      claimName: foo\n      script: exports = 'foo';\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nProtocol mappers can be imported using one of the following formats:\n\n- Client: `{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}`\n\n- Client Scope: `{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}`\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:openid/scriptProtocolMapper:ScriptProtocolMapper script_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n```sh\n$ pulumi import keycloak:openid/scriptProtocolMapper:ScriptProtocolMapper script_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "script": {
                    "type": "string",
                    "description": "JavaScript code to compute the claim value.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId",
                "script"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                    "willReplaceOnChanges": true
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                    "willReplaceOnChanges": true
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n",
                    "willReplaceOnChanges": true
                },
                "script": {
                    "type": "string",
                    "description": "JavaScript code to compute the claim value.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId",
                "script"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ScriptProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "The name of the claim to insert into a token.\n"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                        "willReplaceOnChanges": true
                    },
                    "multivalued": {
                        "type": "boolean",
                        "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n",
                        "willReplaceOnChanges": true
                    },
                    "script": {
                        "type": "string",
                        "description": "JavaScript code to compute the claim value.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userAttributeProtocolMapper:UserAttributeProtocolMapper": {
            "description": "## # keycloak.openid.UserAttributeProtocolMapper\n\nAllows for creating and managing user attribute protocol mappers within\nKeycloak.\n\nUser attribute protocol mappers allow you to map custom attributes defined\nfor a user within Keycloak to a claim in a token. Protocol mappers can be\ndefined for a single client, or they can be defined for a client scope which\ncan be shared between multiple different clients.\n\n### Example Usage (Client)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    realmId: realm.id,\n    clientId: \"test-client\",\n    name: \"test client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userAttributeMapper = new keycloak.openid.UserAttributeProtocolMapper(\"user_attribute_mapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    name: \"test-mapper\",\n    userAttribute: \"foo\",\n    claimName: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openid_client\",\n    realm_id=realm.id,\n    client_id=\"test-client\",\n    name=\"test client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_attribute_mapper = keycloak.openid.UserAttributeProtocolMapper(\"user_attribute_mapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    name=\"test-mapper\",\n    user_attribute=\"foo\",\n    claim_name=\"bar\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var openidClient = new Keycloak.OpenId.Client(\"openid_client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"test-client\",\n        Name = \"test client\",\n        Enabled = true,\n        AccessType = \"CONFIDENTIAL\",\n        ValidRedirectUris = new[]\n        {\n            \"http://localhost:8080/openid-callback\",\n        },\n    });\n\n    var userAttributeMapper = new Keycloak.OpenId.UserAttributeProtocolMapper(\"user_attribute_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = openidClient.Id,\n        Name = \"test-mapper\",\n        UserAttribute = \"foo\",\n        ClaimName = \"bar\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openid_client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tName:       pulumi.String(\"test client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserAttributeProtocolMapper(ctx, \"user_attribute_mapper\", \u0026openid.UserAttributeProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientId:      openidClient.ID(),\n\t\t\tName:          pulumi.String(\"test-mapper\"),\n\t\t\tUserAttribute: pulumi.String(\"foo\"),\n\t\t\tClaimName:     pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.openid.UserAttributeProtocolMapper;\nimport com.pulumi.keycloak.openid.UserAttributeProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var openidClient = new Client(\"openidClient\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"test-client\")\n            .name(\"test client\")\n            .enabled(true)\n            .accessType(\"CONFIDENTIAL\")\n            .validRedirectUris(\"http://localhost:8080/openid-callback\")\n            .build());\n\n        var userAttributeMapper = new UserAttributeProtocolMapper(\"userAttributeMapper\", UserAttributeProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(openidClient.id())\n            .name(\"test-mapper\")\n            .userAttribute(\"foo\")\n            .claimName(\"bar\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  openidClient:\n    type: keycloak:openid:Client\n    name: openid_client\n    properties:\n      realmId: ${realm.id}\n      clientId: test-client\n      name: test client\n      enabled: true\n      accessType: CONFIDENTIAL\n      validRedirectUris:\n        - http://localhost:8080/openid-callback\n  userAttributeMapper:\n    type: keycloak:openid:UserAttributeProtocolMapper\n    name: user_attribute_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${openidClient.id}\n      name: test-mapper\n      userAttribute: foo\n      claimName: bar\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Usage (Client Scope)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n    name: \"test-client-scope\",\n});\nconst userAttributeMapper = new keycloak.openid.UserAttributeProtocolMapper(\"user_attribute_mapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    name: \"test-mapper\",\n    userAttribute: \"foo\",\n    claimName: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"client_scope\",\n    realm_id=realm.id,\n    name=\"test-client-scope\")\nuser_attribute_mapper = keycloak.openid.UserAttributeProtocolMapper(\"user_attribute_mapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    name=\"test-mapper\",\n    user_attribute=\"foo\",\n    claim_name=\"bar\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var clientScope = new Keycloak.OpenId.ClientScope(\"client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"test-client-scope\",\n    });\n\n    var userAttributeMapper = new Keycloak.OpenId.UserAttributeProtocolMapper(\"user_attribute_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientScopeId = clientScope.Id,\n        Name = \"test-mapper\",\n        UserAttribute = \"foo\",\n        ClaimName = \"bar\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"test-client-scope\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserAttributeProtocolMapper(ctx, \"user_attribute_mapper\", \u0026openid.UserAttributeProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tName:          pulumi.String(\"test-mapper\"),\n\t\t\tUserAttribute: pulumi.String(\"foo\"),\n\t\t\tClaimName:     pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport com.pulumi.keycloak.openid.UserAttributeProtocolMapper;\nimport com.pulumi.keycloak.openid.UserAttributeProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var clientScope = new ClientScope(\"clientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"test-client-scope\")\n            .build());\n\n        var userAttributeMapper = new UserAttributeProtocolMapper(\"userAttributeMapper\", UserAttributeProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientScopeId(clientScope.id())\n            .name(\"test-mapper\")\n            .userAttribute(\"foo\")\n            .claimName(\"bar\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  clientScope:\n    type: keycloak:openid:ClientScope\n    name: client_scope\n    properties:\n      realmId: ${realm.id}\n      name: test-client-scope\n  userAttributeMapper:\n    type: keycloak:openid:UserAttributeProtocolMapper\n    name: user_attribute_mapper\n    properties:\n      realmId: ${realm.id}\n      clientScopeId: ${clientScope.id}\n      name: test-mapper\n      userAttribute: foo\n      claimName: bar\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `user_attribute` - (Required) The custom user attribute to map a claim for.\n- `claim_name` - (Required) The name of the claim to insert into a token.\n- `claim_value_type` - (Optional) The claim type used when serializing JSON tokens. Can be one of `String`, `long`, `int`, or `boolean`. Defaults to `String`.\n- `multivalued` - (Optional) Indicates whether this attribute is a single value or an array of values. Defaults to `false`.\n- `add_to_id_token` - (Optional) Indicates if the attribute should be added as a claim to the id token. Defaults to `true`.\n- `add_to_access_token` - (Optional) Indicates if the attribute should be added as a claim to the access token. Defaults to `true`.\n- `add_to_userinfo` - (Optional) Indicates if the attribute should be added as a claim to the UserInfo response body. Defaults to `true`.\n\n### Import\n\nProtocol mappers can be imported using one of the following formats:\n- Client: `{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}`\n- Client Scope: `{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}`\n\nExample:\n\n```bash\n$ terraform import keycloak_openid_user_attribute_protocol_mapper.user_attribute_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n$ terraform import keycloak_openid_user_attribute_protocol_mapper.user_attribute_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the id token.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                },
                "aggregateAttributes": {
                    "type": "boolean",
                    "description": "Indicates if attribute values should be aggregated within the group attributes\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates whether this attribute is a single value or an array of values.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                },
                "userAttribute": {
                    "type": "string"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId",
                "userAttribute"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the id token.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                },
                "aggregateAttributes": {
                    "type": "boolean",
                    "description": "Indicates if attribute values should be aggregated within the group attributes\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n",
                    "willReplaceOnChanges": true
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n",
                    "willReplaceOnChanges": true
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates whether this attribute is a single value or an array of values.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n",
                    "willReplaceOnChanges": true
                },
                "userAttribute": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId",
                "userAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserAttributeProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be a claim in the access token.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be a claim in the id token.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                    },
                    "aggregateAttributes": {
                        "type": "boolean",
                        "description": "Indicates if attribute values should be aggregated within the group attributes\n"
                    },
                    "claimName": {
                        "type": "string"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "Claim type used when serializing tokens.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n",
                        "willReplaceOnChanges": true
                    },
                    "multivalued": {
                        "type": "boolean",
                        "description": "Indicates whether this attribute is a single value or an array of values.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n",
                        "willReplaceOnChanges": true
                    },
                    "userAttribute": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userClientRoleProtocolMapper:UserClientRoleProtocolMapper": {
            "description": "Allows for creating and managing user client role protocol mappers within Keycloak.\n\nUser client role protocol mappers allow you to define a claim containing the list of a client roles.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n## Example Usage\n\n### Client)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    name: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userClientRoleMapper = new keycloak.openid.UserClientRoleProtocolMapper(\"user_client_role_mapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    name: \"user-client-role-mapper\",\n    claimName: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openid_client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    name=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_client_role_mapper = keycloak.openid.UserClientRoleProtocolMapper(\"user_client_role_mapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    name=\"user-client-role-mapper\",\n    claim_name=\"foo\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var openidClient = new Keycloak.OpenId.Client(\"openid_client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"client\",\n        Name = \"client\",\n        Enabled = true,\n        AccessType = \"CONFIDENTIAL\",\n        ValidRedirectUris = new[]\n        {\n            \"http://localhost:8080/openid-callback\",\n        },\n    });\n\n    var userClientRoleMapper = new Keycloak.OpenId.UserClientRoleProtocolMapper(\"user_client_role_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = openidClient.Id,\n        Name = \"user-client-role-mapper\",\n        ClaimName = \"foo\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openid_client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tName:       pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserClientRoleProtocolMapper(ctx, \"user_client_role_mapper\", \u0026openid.UserClientRoleProtocolMapperArgs{\n\t\t\tRealmId:   realm.ID(),\n\t\t\tClientId:  openidClient.ID(),\n\t\t\tName:      pulumi.String(\"user-client-role-mapper\"),\n\t\t\tClaimName: pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.openid.UserClientRoleProtocolMapper;\nimport com.pulumi.keycloak.openid.UserClientRoleProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var openidClient = new Client(\"openidClient\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"client\")\n            .name(\"client\")\n            .enabled(true)\n            .accessType(\"CONFIDENTIAL\")\n            .validRedirectUris(\"http://localhost:8080/openid-callback\")\n            .build());\n\n        var userClientRoleMapper = new UserClientRoleProtocolMapper(\"userClientRoleMapper\", UserClientRoleProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(openidClient.id())\n            .name(\"user-client-role-mapper\")\n            .claimName(\"foo\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  openidClient:\n    type: keycloak:openid:Client\n    name: openid_client\n    properties:\n      realmId: ${realm.id}\n      clientId: client\n      name: client\n      enabled: true\n      accessType: CONFIDENTIAL\n      validRedirectUris:\n        - http://localhost:8080/openid-callback\n  userClientRoleMapper:\n    type: keycloak:openid:UserClientRoleProtocolMapper\n    name: user_client_role_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${openidClient.id}\n      name: user-client-role-mapper\n      claimName: foo\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Client Scope)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n    name: \"client-scope\",\n});\nconst userClientRoleMapper = new keycloak.openid.UserClientRoleProtocolMapper(\"user_client_role_mapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    name: \"user-client-role-mapper\",\n    claimName: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"client_scope\",\n    realm_id=realm.id,\n    name=\"client-scope\")\nuser_client_role_mapper = keycloak.openid.UserClientRoleProtocolMapper(\"user_client_role_mapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    name=\"user-client-role-mapper\",\n    claim_name=\"foo\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var clientScope = new Keycloak.OpenId.ClientScope(\"client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"client-scope\",\n    });\n\n    var userClientRoleMapper = new Keycloak.OpenId.UserClientRoleProtocolMapper(\"user_client_role_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientScopeId = clientScope.Id,\n        Name = \"user-client-role-mapper\",\n        ClaimName = \"foo\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"client-scope\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserClientRoleProtocolMapper(ctx, \"user_client_role_mapper\", \u0026openid.UserClientRoleProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tName:          pulumi.String(\"user-client-role-mapper\"),\n\t\t\tClaimName:     pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport com.pulumi.keycloak.openid.UserClientRoleProtocolMapper;\nimport com.pulumi.keycloak.openid.UserClientRoleProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var clientScope = new ClientScope(\"clientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"client-scope\")\n            .build());\n\n        var userClientRoleMapper = new UserClientRoleProtocolMapper(\"userClientRoleMapper\", UserClientRoleProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientScopeId(clientScope.id())\n            .name(\"user-client-role-mapper\")\n            .claimName(\"foo\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  clientScope:\n    type: keycloak:openid:ClientScope\n    name: client_scope\n    properties:\n      realmId: ${realm.id}\n      name: client-scope\n  userClientRoleMapper:\n    type: keycloak:openid:UserClientRoleProtocolMapper\n    name: user_client_role_mapper\n    properties:\n      realmId: ${realm.id}\n      clientScopeId: ${clientScope.id}\n      name: user-client-role-mapper\n      claimName: foo\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nProtocol mappers can be imported using one of the following formats:\n\n- Client: `{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}`\n\n- Client Scope: `{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}`\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:openid/userClientRoleProtocolMapper:UserClientRoleProtocolMapper user_client_role_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n```sh\n$ pulumi import keycloak:openid/userClientRoleProtocolMapper:UserClientRoleProtocolMapper user_client_role_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientIdForRoleMappings": {
                    "type": "string",
                    "description": "The Client ID for role mappings. Just client roles of this client will be added to the token. If this is unset, client roles of all clients will be added to the token.\n"
                },
                "clientRolePrefix": {
                    "type": "string",
                    "description": "A prefix for each Client Role.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                    "willReplaceOnChanges": true
                },
                "clientIdForRoleMappings": {
                    "type": "string",
                    "description": "The Client ID for role mappings. Just client roles of this client will be added to the token. If this is unset, client roles of all clients will be added to the token.\n"
                },
                "clientRolePrefix": {
                    "type": "string",
                    "description": "A prefix for each Client Role.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                    "willReplaceOnChanges": true
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserClientRoleProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "The name of the claim to insert into a token.\n"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientIdForRoleMappings": {
                        "type": "string",
                        "description": "The Client ID for role mappings. Just client roles of this client will be added to the token. If this is unset, client roles of all clients will be added to the token.\n"
                    },
                    "clientRolePrefix": {
                        "type": "string",
                        "description": "A prefix for each Client Role.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                        "willReplaceOnChanges": true
                    },
                    "multivalued": {
                        "type": "boolean",
                        "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userPropertyProtocolMapper:UserPropertyProtocolMapper": {
            "description": "## # keycloak.openid.UserPropertyProtocolMapper\n\nAllows for creating and managing user property protocol mappers within\nKeycloak.\n\nUser property protocol mappers allow you to map built in properties defined\non the Keycloak user interface to a claim in a token. Protocol mappers can be\ndefined for a single client, or they can be defined for a client scope which\ncan be shared between multiple different clients.\n\n### Example Usage (Client)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    realmId: realm.id,\n    clientId: \"test-client\",\n    name: \"test client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userPropertyMapper = new keycloak.openid.UserPropertyProtocolMapper(\"user_property_mapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    name: \"test-mapper\",\n    userProperty: \"email\",\n    claimName: \"email\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openid_client\",\n    realm_id=realm.id,\n    client_id=\"test-client\",\n    name=\"test client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_property_mapper = keycloak.openid.UserPropertyProtocolMapper(\"user_property_mapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    name=\"test-mapper\",\n    user_property=\"email\",\n    claim_name=\"email\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var openidClient = new Keycloak.OpenId.Client(\"openid_client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"test-client\",\n        Name = \"test client\",\n        Enabled = true,\n        AccessType = \"CONFIDENTIAL\",\n        ValidRedirectUris = new[]\n        {\n            \"http://localhost:8080/openid-callback\",\n        },\n    });\n\n    var userPropertyMapper = new Keycloak.OpenId.UserPropertyProtocolMapper(\"user_property_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = openidClient.Id,\n        Name = \"test-mapper\",\n        UserProperty = \"email\",\n        ClaimName = \"email\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openid_client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tName:       pulumi.String(\"test client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserPropertyProtocolMapper(ctx, \"user_property_mapper\", \u0026openid.UserPropertyProtocolMapperArgs{\n\t\t\tRealmId:      realm.ID(),\n\t\t\tClientId:     openidClient.ID(),\n\t\t\tName:         pulumi.String(\"test-mapper\"),\n\t\t\tUserProperty: pulumi.String(\"email\"),\n\t\t\tClaimName:    pulumi.String(\"email\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.openid.UserPropertyProtocolMapper;\nimport com.pulumi.keycloak.openid.UserPropertyProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var openidClient = new Client(\"openidClient\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"test-client\")\n            .name(\"test client\")\n            .enabled(true)\n            .accessType(\"CONFIDENTIAL\")\n            .validRedirectUris(\"http://localhost:8080/openid-callback\")\n            .build());\n\n        var userPropertyMapper = new UserPropertyProtocolMapper(\"userPropertyMapper\", UserPropertyProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(openidClient.id())\n            .name(\"test-mapper\")\n            .userProperty(\"email\")\n            .claimName(\"email\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  openidClient:\n    type: keycloak:openid:Client\n    name: openid_client\n    properties:\n      realmId: ${realm.id}\n      clientId: test-client\n      name: test client\n      enabled: true\n      accessType: CONFIDENTIAL\n      validRedirectUris:\n        - http://localhost:8080/openid-callback\n  userPropertyMapper:\n    type: keycloak:openid:UserPropertyProtocolMapper\n    name: user_property_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${openidClient.id}\n      name: test-mapper\n      userProperty: email\n      claimName: email\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Usage (Client Scope)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n    name: \"test-client-scope\",\n});\nconst userPropertyMapper = new keycloak.openid.UserPropertyProtocolMapper(\"user_property_mapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    name: \"test-mapper\",\n    userProperty: \"email\",\n    claimName: \"email\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"client_scope\",\n    realm_id=realm.id,\n    name=\"test-client-scope\")\nuser_property_mapper = keycloak.openid.UserPropertyProtocolMapper(\"user_property_mapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    name=\"test-mapper\",\n    user_property=\"email\",\n    claim_name=\"email\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var clientScope = new Keycloak.OpenId.ClientScope(\"client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"test-client-scope\",\n    });\n\n    var userPropertyMapper = new Keycloak.OpenId.UserPropertyProtocolMapper(\"user_property_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientScopeId = clientScope.Id,\n        Name = \"test-mapper\",\n        UserProperty = \"email\",\n        ClaimName = \"email\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"test-client-scope\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserPropertyProtocolMapper(ctx, \"user_property_mapper\", \u0026openid.UserPropertyProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tName:          pulumi.String(\"test-mapper\"),\n\t\t\tUserProperty:  pulumi.String(\"email\"),\n\t\t\tClaimName:     pulumi.String(\"email\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport com.pulumi.keycloak.openid.UserPropertyProtocolMapper;\nimport com.pulumi.keycloak.openid.UserPropertyProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var clientScope = new ClientScope(\"clientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"test-client-scope\")\n            .build());\n\n        var userPropertyMapper = new UserPropertyProtocolMapper(\"userPropertyMapper\", UserPropertyProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientScopeId(clientScope.id())\n            .name(\"test-mapper\")\n            .userProperty(\"email\")\n            .claimName(\"email\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  clientScope:\n    type: keycloak:openid:ClientScope\n    name: client_scope\n    properties:\n      realmId: ${realm.id}\n      name: test-client-scope\n  userPropertyMapper:\n    type: keycloak:openid:UserPropertyProtocolMapper\n    name: user_property_mapper\n    properties:\n      realmId: ${realm.id}\n      clientScopeId: ${clientScope.id}\n      name: test-mapper\n      userProperty: email\n      claimName: email\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `user_property` - (Required) The built in user property (such as email) to map a claim for.\n- `claim_name` - (Required) The name of the claim to insert into a token.\n- `claim_value_type` - (Optional) The claim type used when serializing JSON tokens. Can be one of `String`, `long`, `int`, or `boolean`. Defaults to `String`.\n- `add_to_id_token` - (Optional) Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n- `add_to_access_token` - (Optional) Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n- `add_to_userinfo` - (Optional) Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n\n### Import\n\nProtocol mappers can be imported using one of the following formats:\n- Client: `{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}`\n- Client Scope: `{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}`\n\nExample:\n\n```bash\n$ terraform import keycloak_openid_user_property_protocol_mapper.user_property_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n$ terraform import keycloak_openid_user_property_protocol_mapper.user_property_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be a claim in the id token.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should appear in the userinfo response body.\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                },
                "userProperty": {
                    "type": "string"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId",
                "userProperty"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be a claim in the id token.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should appear in the userinfo response body.\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n",
                    "willReplaceOnChanges": true
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n",
                    "willReplaceOnChanges": true
                },
                "userProperty": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId",
                "userProperty"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserPropertyProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be a claim in the access token.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be a claim in the id token.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the property should appear in the userinfo response body.\n"
                    },
                    "claimName": {
                        "type": "string"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "Claim type used when serializing tokens.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n",
                        "willReplaceOnChanges": true
                    },
                    "userProperty": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userRealmRoleProtocolMapper:UserRealmRoleProtocolMapper": {
            "description": "## # keycloak.openid.UserRealmRoleProtocolMapper\n\nAllows for creating and managing user realm role protocol mappers within\nKeycloak.\n\nUser realm role protocol mappers allow you to define a claim containing the list of the realm roles.\nProtocol mappers can be defined for a single client, or they can\nbe defined for a client scope which can be shared between multiple different\nclients.\n\n### Example Usage (Client)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    realmId: realm.id,\n    clientId: \"test-client\",\n    name: \"test client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userRealmRoleMapper = new keycloak.openid.UserRealmRoleProtocolMapper(\"user_realm_role_mapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    name: \"user-realm-role-mapper\",\n    claimName: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openid_client\",\n    realm_id=realm.id,\n    client_id=\"test-client\",\n    name=\"test client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_realm_role_mapper = keycloak.openid.UserRealmRoleProtocolMapper(\"user_realm_role_mapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    name=\"user-realm-role-mapper\",\n    claim_name=\"foo\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var openidClient = new Keycloak.OpenId.Client(\"openid_client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"test-client\",\n        Name = \"test client\",\n        Enabled = true,\n        AccessType = \"CONFIDENTIAL\",\n        ValidRedirectUris = new[]\n        {\n            \"http://localhost:8080/openid-callback\",\n        },\n    });\n\n    var userRealmRoleMapper = new Keycloak.OpenId.UserRealmRoleProtocolMapper(\"user_realm_role_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = openidClient.Id,\n        Name = \"user-realm-role-mapper\",\n        ClaimName = \"foo\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openid_client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tName:       pulumi.String(\"test client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserRealmRoleProtocolMapper(ctx, \"user_realm_role_mapper\", \u0026openid.UserRealmRoleProtocolMapperArgs{\n\t\t\tRealmId:   realm.ID(),\n\t\t\tClientId:  openidClient.ID(),\n\t\t\tName:      pulumi.String(\"user-realm-role-mapper\"),\n\t\t\tClaimName: pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.openid.UserRealmRoleProtocolMapper;\nimport com.pulumi.keycloak.openid.UserRealmRoleProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var openidClient = new Client(\"openidClient\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"test-client\")\n            .name(\"test client\")\n            .enabled(true)\n            .accessType(\"CONFIDENTIAL\")\n            .validRedirectUris(\"http://localhost:8080/openid-callback\")\n            .build());\n\n        var userRealmRoleMapper = new UserRealmRoleProtocolMapper(\"userRealmRoleMapper\", UserRealmRoleProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(openidClient.id())\n            .name(\"user-realm-role-mapper\")\n            .claimName(\"foo\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  openidClient:\n    type: keycloak:openid:Client\n    name: openid_client\n    properties:\n      realmId: ${realm.id}\n      clientId: test-client\n      name: test client\n      enabled: true\n      accessType: CONFIDENTIAL\n      validRedirectUris:\n        - http://localhost:8080/openid-callback\n  userRealmRoleMapper:\n    type: keycloak:openid:UserRealmRoleProtocolMapper\n    name: user_realm_role_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${openidClient.id}\n      name: user-realm-role-mapper\n      claimName: foo\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Usage (Client Scope)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n    name: \"test-client-scope\",\n});\nconst userRealmRoleMapper = new keycloak.openid.UserRealmRoleProtocolMapper(\"user_realm_role_mapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    name: \"user-realm-role-mapper\",\n    claimName: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"client_scope\",\n    realm_id=realm.id,\n    name=\"test-client-scope\")\nuser_realm_role_mapper = keycloak.openid.UserRealmRoleProtocolMapper(\"user_realm_role_mapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    name=\"user-realm-role-mapper\",\n    claim_name=\"foo\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var clientScope = new Keycloak.OpenId.ClientScope(\"client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"test-client-scope\",\n    });\n\n    var userRealmRoleMapper = new Keycloak.OpenId.UserRealmRoleProtocolMapper(\"user_realm_role_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientScopeId = clientScope.Id,\n        Name = \"user-realm-role-mapper\",\n        ClaimName = \"foo\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"test-client-scope\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserRealmRoleProtocolMapper(ctx, \"user_realm_role_mapper\", \u0026openid.UserRealmRoleProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tName:          pulumi.String(\"user-realm-role-mapper\"),\n\t\t\tClaimName:     pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport com.pulumi.keycloak.openid.UserRealmRoleProtocolMapper;\nimport com.pulumi.keycloak.openid.UserRealmRoleProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var clientScope = new ClientScope(\"clientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"test-client-scope\")\n            .build());\n\n        var userRealmRoleMapper = new UserRealmRoleProtocolMapper(\"userRealmRoleMapper\", UserRealmRoleProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientScopeId(clientScope.id())\n            .name(\"user-realm-role-mapper\")\n            .claimName(\"foo\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  clientScope:\n    type: keycloak:openid:ClientScope\n    name: client_scope\n    properties:\n      realmId: ${realm.id}\n      name: test-client-scope\n  userRealmRoleMapper:\n    type: keycloak:openid:UserRealmRoleProtocolMapper\n    name: user_realm_role_mapper\n    properties:\n      realmId: ${realm.id}\n      clientScopeId: ${clientScope.id}\n      name: user-realm-role-mapper\n      claimName: foo\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `claim_name` - (Required) The name of the claim to insert into a token.\n- `claim_value_type` - (Optional) The claim type used when serializing JSON tokens. Can be one of `String`, `long`, `int`, or `boolean`. Defaults to `String`.\n- `multivalued` - (Optional) Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `true`.\n- `realm_role_prefix` - (Optional) A prefix for each Realm Role.\n- `add_to_id_token` - (Optional) Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n- `add_to_access_token` - (Optional) Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n- `add_to_userinfo` - (Optional) Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n\n### Import\n\nProtocol mappers can be imported using one of the following formats:\n- Client: `{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}`\n- Client Scope: `{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}`\n\nExample:\n\n```bash\n$ terraform import keycloak_openid_user_realm_role_protocol_mapper.user_realm_role_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n$ terraform import keycloak_openid_user_realm_role_protocol_mapper.user_realm_role_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the id token.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates whether this attribute is a single value or an array of values.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n"
                },
                "realmRolePrefix": {
                    "type": "string",
                    "description": "Prefix that will be added to each realm role.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the access token.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be a claim in the id token.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                },
                "claimName": {
                    "type": "string"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "Claim type used when serializing tokens.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n",
                    "willReplaceOnChanges": true
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n",
                    "willReplaceOnChanges": true
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates whether this attribute is a single value or an array of values.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A human-friendly name that will appear in the Keycloak console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm id where the associated client or client scope exists.\n",
                    "willReplaceOnChanges": true
                },
                "realmRolePrefix": {
                    "type": "string",
                    "description": "Prefix that will be added to each realm role.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserRealmRoleProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be a claim in the access token.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be a claim in the id token.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should appear in the userinfo response body.\n"
                    },
                    "claimName": {
                        "type": "string"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "Claim type used when serializing tokens.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The mapper's associated client. Cannot be used at the same time as client_scope_id.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n",
                        "willReplaceOnChanges": true
                    },
                    "multivalued": {
                        "type": "boolean",
                        "description": "Indicates whether this attribute is a single value or an array of values.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A human-friendly name that will appear in the Keycloak console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id where the associated client or client scope exists.\n",
                        "willReplaceOnChanges": true
                    },
                    "realmRolePrefix": {
                        "type": "string",
                        "description": "Prefix that will be added to each realm role.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userSessionNoteProtocolMapper:UserSessionNoteProtocolMapper": {
            "description": "Allows for creating and managing user session note protocol mappers within Keycloak.\n\nUser session note protocol mappers map a custom user session note to a token claim.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n## Example Usage\n\n### Client)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openid_client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    name: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userSessionNoteMapper = new keycloak.openid.UserSessionNoteProtocolMapper(\"user_session_note_mapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    name: \"user-session-note-mapper\",\n    claimName: \"foo\",\n    claimValueType: \"String\",\n    sessionNote: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openid_client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    name=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_session_note_mapper = keycloak.openid.UserSessionNoteProtocolMapper(\"user_session_note_mapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    name=\"user-session-note-mapper\",\n    claim_name=\"foo\",\n    claim_value_type=\"String\",\n    session_note=\"bar\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var openidClient = new Keycloak.OpenId.Client(\"openid_client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"client\",\n        Name = \"client\",\n        Enabled = true,\n        AccessType = \"CONFIDENTIAL\",\n        ValidRedirectUris = new[]\n        {\n            \"http://localhost:8080/openid-callback\",\n        },\n    });\n\n    var userSessionNoteMapper = new Keycloak.OpenId.UserSessionNoteProtocolMapper(\"user_session_note_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = openidClient.Id,\n        Name = \"user-session-note-mapper\",\n        ClaimName = \"foo\",\n        ClaimValueType = \"String\",\n        SessionNote = \"bar\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openid_client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tName:       pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserSessionNoteProtocolMapper(ctx, \"user_session_note_mapper\", \u0026openid.UserSessionNoteProtocolMapperArgs{\n\t\t\tRealmId:        realm.ID(),\n\t\t\tClientId:       openidClient.ID(),\n\t\t\tName:           pulumi.String(\"user-session-note-mapper\"),\n\t\t\tClaimName:      pulumi.String(\"foo\"),\n\t\t\tClaimValueType: pulumi.String(\"String\"),\n\t\t\tSessionNote:    pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.openid.UserSessionNoteProtocolMapper;\nimport com.pulumi.keycloak.openid.UserSessionNoteProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var openidClient = new Client(\"openidClient\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"client\")\n            .name(\"client\")\n            .enabled(true)\n            .accessType(\"CONFIDENTIAL\")\n            .validRedirectUris(\"http://localhost:8080/openid-callback\")\n            .build());\n\n        var userSessionNoteMapper = new UserSessionNoteProtocolMapper(\"userSessionNoteMapper\", UserSessionNoteProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(openidClient.id())\n            .name(\"user-session-note-mapper\")\n            .claimName(\"foo\")\n            .claimValueType(\"String\")\n            .sessionNote(\"bar\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  openidClient:\n    type: keycloak:openid:Client\n    name: openid_client\n    properties:\n      realmId: ${realm.id}\n      clientId: client\n      name: client\n      enabled: true\n      accessType: CONFIDENTIAL\n      validRedirectUris:\n        - http://localhost:8080/openid-callback\n  userSessionNoteMapper:\n    type: keycloak:openid:UserSessionNoteProtocolMapper\n    name: user_session_note_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${openidClient.id}\n      name: user-session-note-mapper\n      claimName: foo\n      claimValueType: String\n      sessionNote: bar\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Client Scope)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"client_scope\", {\n    realmId: realm.id,\n    name: \"client-scope\",\n});\nconst userSessionNoteMapper = new keycloak.openid.UserSessionNoteProtocolMapper(\"user_session_note_mapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    name: \"user-session-note-mapper\",\n    claimName: \"foo\",\n    claimValueType: \"String\",\n    sessionNote: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"client_scope\",\n    realm_id=realm.id,\n    name=\"client-scope\")\nuser_session_note_mapper = keycloak.openid.UserSessionNoteProtocolMapper(\"user_session_note_mapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    name=\"user-session-note-mapper\",\n    claim_name=\"foo\",\n    claim_value_type=\"String\",\n    session_note=\"bar\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var clientScope = new Keycloak.OpenId.ClientScope(\"client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"client-scope\",\n    });\n\n    var userSessionNoteMapper = new Keycloak.OpenId.UserSessionNoteProtocolMapper(\"user_session_note_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientScopeId = clientScope.Id,\n        Name = \"user-session-note-mapper\",\n        ClaimName = \"foo\",\n        ClaimValueType = \"String\",\n        SessionNote = \"bar\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"client_scope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"client-scope\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserSessionNoteProtocolMapper(ctx, \"user_session_note_mapper\", \u0026openid.UserSessionNoteProtocolMapperArgs{\n\t\t\tRealmId:        realm.ID(),\n\t\t\tClientScopeId:  clientScope.ID(),\n\t\t\tName:           pulumi.String(\"user-session-note-mapper\"),\n\t\t\tClaimName:      pulumi.String(\"foo\"),\n\t\t\tClaimValueType: pulumi.String(\"String\"),\n\t\t\tSessionNote:    pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.ClientScope;\nimport com.pulumi.keycloak.openid.ClientScopeArgs;\nimport com.pulumi.keycloak.openid.UserSessionNoteProtocolMapper;\nimport com.pulumi.keycloak.openid.UserSessionNoteProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var clientScope = new ClientScope(\"clientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"client-scope\")\n            .build());\n\n        var userSessionNoteMapper = new UserSessionNoteProtocolMapper(\"userSessionNoteMapper\", UserSessionNoteProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientScopeId(clientScope.id())\n            .name(\"user-session-note-mapper\")\n            .claimName(\"foo\")\n            .claimValueType(\"String\")\n            .sessionNote(\"bar\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  clientScope:\n    type: keycloak:openid:ClientScope\n    name: client_scope\n    properties:\n      realmId: ${realm.id}\n      name: client-scope\n  userSessionNoteMapper:\n    type: keycloak:openid:UserSessionNoteProtocolMapper\n    name: user_session_note_mapper\n    properties:\n      realmId: ${realm.id}\n      clientScopeId: ${clientScope.id}\n      name: user-session-note-mapper\n      claimName: foo\n      claimValueType: String\n      sessionNote: bar\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nProtocol mappers can be imported using one of the following formats:\n\n- Client: `{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}`\n\n- Client Scope: `{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}`\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:openid/userSessionNoteProtocolMapper:UserSessionNoteProtocolMapper user_session_note_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n```sh\n$ pulumi import keycloak:openid/userSessionNoteProtocolMapper:UserSessionNoteProtocolMapper user_session_note_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "sessionNote": {
                    "type": "string",
                    "description": "String value being the name of stored user session note within the UserSessionModel.note map.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                    "willReplaceOnChanges": true
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n",
                    "willReplaceOnChanges": true
                },
                "sessionNote": {
                    "type": "string",
                    "description": "String value being the name of stored user session note within the UserSessionModel.note map.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserSessionNoteProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "The name of the claim to insert into a token.\n"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n",
                        "willReplaceOnChanges": true
                    },
                    "sessionNote": {
                        "type": "string",
                        "description": "String value being the name of stored user session note within the UserSessionModel.note map.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/client:Client": {
            "description": "## # keycloak.saml.Client\n\nAllows for creating and managing Keycloak clients that use the SAML protocol.\n\nClients are entities that can use Keycloak for user authentication. Typically,\nclients are applications that redirect users to Keycloak for authentication\nin order to take advantage of Keycloak's user sessions for SSO.\n\n### Import\n\nClients can be imported using the format `{{realm_id}}/{{client_keycloak_id}}`, where `client_keycloak_id` is the unique ID that Keycloak\nassigns to the client upon creation. This value can be found in the URI when editing this client in the GUI, and is typically a GUID.\n\nExample:\n\n```bash\n$ terraform import keycloak_saml_client.saml_client my-realm/dcbc4c73-e478-4928-ae2e-d5e420223352\n```\n",
            "properties": {
                "assertionConsumerPostUrl": {
                    "type": "string"
                },
                "assertionConsumerRedirectUrl": {
                    "type": "string"
                },
                "authenticationFlowBindingOverrides": {
                    "$ref": "#/types/keycloak:saml/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides"
                },
                "baseUrl": {
                    "type": "string"
                },
                "canonicalizationMethod": {
                    "type": "string"
                },
                "clientId": {
                    "type": "string"
                },
                "clientSignatureRequired": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string"
                },
                "enabled": {
                    "type": "boolean"
                },
                "encryptAssertions": {
                    "type": "boolean"
                },
                "encryptionCertificate": {
                    "type": "string"
                },
                "encryptionCertificateSha1": {
                    "type": "string"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "forceNameIdFormat": {
                    "type": "boolean"
                },
                "forcePostBinding": {
                    "type": "boolean"
                },
                "frontChannelLogout": {
                    "type": "boolean"
                },
                "fullScopeAllowed": {
                    "type": "boolean"
                },
                "idpInitiatedSsoRelayState": {
                    "type": "string"
                },
                "idpInitiatedSsoUrlName": {
                    "type": "string"
                },
                "includeAuthnStatement": {
                    "type": "boolean"
                },
                "loginTheme": {
                    "type": "string"
                },
                "logoutServicePostBindingUrl": {
                    "type": "string"
                },
                "logoutServiceRedirectBindingUrl": {
                    "type": "string"
                },
                "masterSamlProcessingUrl": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "nameIdFormat": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "rootUrl": {
                    "type": "string"
                },
                "signAssertions": {
                    "type": "boolean"
                },
                "signDocuments": {
                    "type": "boolean"
                },
                "signatureAlgorithm": {
                    "type": "string"
                },
                "signatureKeyName": {
                    "type": "string"
                },
                "signingCertificate": {
                    "type": "string"
                },
                "signingCertificateSha1": {
                    "type": "string"
                },
                "signingPrivateKey": {
                    "type": "string"
                },
                "signingPrivateKeySha1": {
                    "type": "string"
                },
                "validRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "clientId",
                "encryptionCertificate",
                "encryptionCertificateSha1",
                "name",
                "nameIdFormat",
                "realmId",
                "signingCertificate",
                "signingCertificateSha1",
                "signingPrivateKey",
                "signingPrivateKeySha1"
            ],
            "inputProperties": {
                "assertionConsumerPostUrl": {
                    "type": "string"
                },
                "assertionConsumerRedirectUrl": {
                    "type": "string"
                },
                "authenticationFlowBindingOverrides": {
                    "$ref": "#/types/keycloak:saml/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides"
                },
                "baseUrl": {
                    "type": "string"
                },
                "canonicalizationMethod": {
                    "type": "string"
                },
                "clientId": {
                    "type": "string"
                },
                "clientSignatureRequired": {
                    "type": "boolean"
                },
                "description": {
                    "type": "string"
                },
                "enabled": {
                    "type": "boolean"
                },
                "encryptAssertions": {
                    "type": "boolean"
                },
                "encryptionCertificate": {
                    "type": "string"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "forceNameIdFormat": {
                    "type": "boolean"
                },
                "forcePostBinding": {
                    "type": "boolean"
                },
                "frontChannelLogout": {
                    "type": "boolean"
                },
                "fullScopeAllowed": {
                    "type": "boolean"
                },
                "idpInitiatedSsoRelayState": {
                    "type": "string"
                },
                "idpInitiatedSsoUrlName": {
                    "type": "string"
                },
                "includeAuthnStatement": {
                    "type": "boolean"
                },
                "loginTheme": {
                    "type": "string"
                },
                "logoutServicePostBindingUrl": {
                    "type": "string"
                },
                "logoutServiceRedirectBindingUrl": {
                    "type": "string"
                },
                "masterSamlProcessingUrl": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "nameIdFormat": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "rootUrl": {
                    "type": "string"
                },
                "signAssertions": {
                    "type": "boolean"
                },
                "signDocuments": {
                    "type": "boolean"
                },
                "signatureAlgorithm": {
                    "type": "string"
                },
                "signatureKeyName": {
                    "type": "string"
                },
                "signingCertificate": {
                    "type": "string"
                },
                "signingPrivateKey": {
                    "type": "string"
                },
                "validRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "requiredInputs": [
                "clientId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Client resources.\n",
                "properties": {
                    "assertionConsumerPostUrl": {
                        "type": "string"
                    },
                    "assertionConsumerRedirectUrl": {
                        "type": "string"
                    },
                    "authenticationFlowBindingOverrides": {
                        "$ref": "#/types/keycloak:saml/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides"
                    },
                    "baseUrl": {
                        "type": "string"
                    },
                    "canonicalizationMethod": {
                        "type": "string"
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "clientSignatureRequired": {
                        "type": "boolean"
                    },
                    "description": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "encryptAssertions": {
                        "type": "boolean"
                    },
                    "encryptionCertificate": {
                        "type": "string"
                    },
                    "encryptionCertificateSha1": {
                        "type": "string"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "forceNameIdFormat": {
                        "type": "boolean"
                    },
                    "forcePostBinding": {
                        "type": "boolean"
                    },
                    "frontChannelLogout": {
                        "type": "boolean"
                    },
                    "fullScopeAllowed": {
                        "type": "boolean"
                    },
                    "idpInitiatedSsoRelayState": {
                        "type": "string"
                    },
                    "idpInitiatedSsoUrlName": {
                        "type": "string"
                    },
                    "includeAuthnStatement": {
                        "type": "boolean"
                    },
                    "loginTheme": {
                        "type": "string"
                    },
                    "logoutServicePostBindingUrl": {
                        "type": "string"
                    },
                    "logoutServiceRedirectBindingUrl": {
                        "type": "string"
                    },
                    "masterSamlProcessingUrl": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nameIdFormat": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "rootUrl": {
                        "type": "string"
                    },
                    "signAssertions": {
                        "type": "boolean"
                    },
                    "signDocuments": {
                        "type": "boolean"
                    },
                    "signatureAlgorithm": {
                        "type": "string"
                    },
                    "signatureKeyName": {
                        "type": "string"
                    },
                    "signingCertificate": {
                        "type": "string"
                    },
                    "signingCertificateSha1": {
                        "type": "string"
                    },
                    "signingPrivateKey": {
                        "type": "string"
                    },
                    "signingPrivateKeySha1": {
                        "type": "string"
                    },
                    "validRedirectUris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/clientDefaultScope:ClientDefaultScope": {
            "description": "## Example Usage\n\n",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client to attach default scopes to. Note that this is the unique ID of the client generated by Keycloak.\n"
                },
                "defaultScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of client scope names to attach to this client.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client and scopes exists in.\n"
                }
            },
            "required": [
                "clientId",
                "defaultScopes",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client to attach default scopes to. Note that this is the unique ID of the client generated by Keycloak.\n",
                    "willReplaceOnChanges": true
                },
                "defaultScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of client scope names to attach to this client.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client and scopes exists in.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clientId",
                "defaultScopes",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientDefaultScope resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The ID of the client to attach default scopes to. Note that this is the unique ID of the client generated by Keycloak.\n",
                        "willReplaceOnChanges": true
                    },
                    "defaultScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of client scope names to attach to this client.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this client and scopes exists in.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/clientScope:ClientScope": {
            "description": "Allows for creating and managing Keycloak client scopes that can be attached to clients that use the SAML protocol.\n\nClient Scopes can be used to share common protocol and role mappings between multiple clients within a realm.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClientScope = new keycloak.saml.ClientScope(\"saml_client_scope\", {\n    realmId: realm.id,\n    name: \"groups\",\n    description: \"This scope will map a user's group memberships to SAML assertion\",\n    guiOrder: 1,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client_scope = keycloak.saml.ClientScope(\"saml_client_scope\",\n    realm_id=realm.id,\n    name=\"groups\",\n    description=\"This scope will map a user's group memberships to SAML assertion\",\n    gui_order=1)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var samlClientScope = new Keycloak.Saml.ClientScope(\"saml_client_scope\", new()\n    {\n        RealmId = realm.Id,\n        Name = \"groups\",\n        Description = \"This scope will map a user's group memberships to SAML assertion\",\n        GuiOrder = 1,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = saml.NewClientScope(ctx, \"saml_client_scope\", \u0026saml.ClientScopeArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tName:        pulumi.String(\"groups\"),\n\t\t\tDescription: pulumi.String(\"This scope will map a user's group memberships to SAML assertion\"),\n\t\t\tGuiOrder:    pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.saml.ClientScope;\nimport com.pulumi.keycloak.saml.ClientScopeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var samlClientScope = new ClientScope(\"samlClientScope\", ClientScopeArgs.builder()\n            .realmId(realm.id())\n            .name(\"groups\")\n            .description(\"This scope will map a user's group memberships to SAML assertion\")\n            .guiOrder(1)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  samlClientScope:\n    type: keycloak:saml:ClientScope\n    name: saml_client_scope\n    properties:\n      realmId: ${realm.id}\n      name: groups\n      description: This scope will map a user's group memberships to SAML assertion\n      guiOrder: 1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nClient scopes can be imported using the format `{{realm_id}}/{{client_scope_id}}`, where `client_scope_id` is the unique ID that Keycloak\n\nassigns to the client scope upon creation. This value can be found in the URI when editing this client scope in the GUI, and is typically a GUID.\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:saml/clientScope:ClientScope saml_client_scope my-realm/e8a5d115-6985-4de3-a0f5-732e1be4525e\n```\n\n",
            "properties": {
                "consentScreenText": {
                    "type": "string",
                    "description": "When set, a consent screen will be displayed to users authenticating to clients with this scope attached. The consent screen will display the string value of this attribute.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client scope in the GUI.\n"
                },
                "guiOrder": {
                    "type": "integer",
                    "description": "Specify order of the client scope in GUI (such as in Consent page) as integer.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this client scope in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client scope belongs to.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "consentScreenText": {
                    "type": "string",
                    "description": "When set, a consent screen will be displayed to users authenticating to clients with this scope attached. The consent screen will display the string value of this attribute.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client scope in the GUI.\n"
                },
                "guiOrder": {
                    "type": "integer",
                    "description": "Specify order of the client scope in GUI (such as in Consent page) as integer.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this client scope in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client scope belongs to.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientScope resources.\n",
                "properties": {
                    "consentScreenText": {
                        "type": "string",
                        "description": "When set, a consent screen will be displayed to users authenticating to clients with this scope attached. The consent screen will display the string value of this attribute.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of this client scope in the GUI.\n"
                    },
                    "guiOrder": {
                        "type": "integer",
                        "description": "Specify order of the client scope in GUI (such as in Consent page) as integer.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this client scope in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this client scope belongs to.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/identityProvider:IdentityProvider": {
            "description": "## # keycloak.saml.IdentityProvider\n\nAllows to create and manage SAML Identity Providers within Keycloak.\n\nSAML (Security Assertion Markup Language) identity providers allows to authenticate through a third-party system, using SAML standard.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realmIdentityProvider = new keycloak.saml.IdentityProvider(\"realm_identity_provider\", {\n    realm: \"my-realm\",\n    alias: \"my-idp\",\n    singleSignOnServiceUrl: \"https://domain.com/adfs/ls/\",\n    singleLogoutServiceUrl: \"https://domain.com/adfs/ls/?wa=wsignout1.0\",\n    backchannelSupported: true,\n    postBindingResponse: true,\n    postBindingLogout: true,\n    postBindingAuthnRequest: true,\n    storeToken: false,\n    trustEmail: true,\n    forceAuthn: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm_identity_provider = keycloak.saml.IdentityProvider(\"realm_identity_provider\",\n    realm=\"my-realm\",\n    alias=\"my-idp\",\n    single_sign_on_service_url=\"https://domain.com/adfs/ls/\",\n    single_logout_service_url=\"https://domain.com/adfs/ls/?wa=wsignout1.0\",\n    backchannel_supported=True,\n    post_binding_response=True,\n    post_binding_logout=True,\n    post_binding_authn_request=True,\n    store_token=False,\n    trust_email=True,\n    force_authn=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realmIdentityProvider = new Keycloak.Saml.IdentityProvider(\"realm_identity_provider\", new()\n    {\n        Realm = \"my-realm\",\n        Alias = \"my-idp\",\n        SingleSignOnServiceUrl = \"https://domain.com/adfs/ls/\",\n        SingleLogoutServiceUrl = \"https://domain.com/adfs/ls/?wa=wsignout1.0\",\n        BackchannelSupported = true,\n        PostBindingResponse = true,\n        PostBindingLogout = true,\n        PostBindingAuthnRequest = true,\n        StoreToken = false,\n        TrustEmail = true,\n        ForceAuthn = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := saml.NewIdentityProvider(ctx, \"realm_identity_provider\", \u0026saml.IdentityProviderArgs{\n\t\t\tRealm:                   pulumi.String(\"my-realm\"),\n\t\t\tAlias:                   pulumi.String(\"my-idp\"),\n\t\t\tSingleSignOnServiceUrl:  pulumi.String(\"https://domain.com/adfs/ls/\"),\n\t\t\tSingleLogoutServiceUrl:  pulumi.String(\"https://domain.com/adfs/ls/?wa=wsignout1.0\"),\n\t\t\tBackchannelSupported:    pulumi.Bool(true),\n\t\t\tPostBindingResponse:     pulumi.Bool(true),\n\t\t\tPostBindingLogout:       pulumi.Bool(true),\n\t\t\tPostBindingAuthnRequest: pulumi.Bool(true),\n\t\t\tStoreToken:              pulumi.Bool(false),\n\t\t\tTrustEmail:              pulumi.Bool(true),\n\t\t\tForceAuthn:              pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.saml.IdentityProvider;\nimport com.pulumi.keycloak.saml.IdentityProviderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realmIdentityProvider = new IdentityProvider(\"realmIdentityProvider\", IdentityProviderArgs.builder()\n            .realm(\"my-realm\")\n            .alias(\"my-idp\")\n            .singleSignOnServiceUrl(\"https://domain.com/adfs/ls/\")\n            .singleLogoutServiceUrl(\"https://domain.com/adfs/ls/?wa=wsignout1.0\")\n            .backchannelSupported(true)\n            .postBindingResponse(true)\n            .postBindingLogout(true)\n            .postBindingAuthnRequest(true)\n            .storeToken(false)\n            .trustEmail(true)\n            .forceAuthn(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realmIdentityProvider:\n    type: keycloak:saml:IdentityProvider\n    name: realm_identity_provider\n    properties:\n      realm: my-realm\n      alias: my-idp\n      singleSignOnServiceUrl: https://domain.com/adfs/ls/\n      singleLogoutServiceUrl: https://domain.com/adfs/ls/?wa=wsignout1.0\n      backchannelSupported: true\n      postBindingResponse: true\n      postBindingLogout: true\n      postBindingAuthnRequest: true\n      storeToken: false\n      trustEmail: true\n      forceAuthn: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm` - (Required) The name of the realm. This is unique across Keycloak.\n- `alias` - (Optional) The uniq name of identity provider.\n- `enabled` - (Optional) When false, users and clients will not be able to access this realm. Defaults to `true`.\n- `display_name` - (Optional) The display name for the realm that is shown when logging in to the admin console.\n- `store_token` - (Optional) Enable/disable if tokens must be stored after authenticating users. Defaults to `true`.\n- `add_read_token_role_on_create` - (Optional) Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role. Defaults to `false`.\n- `trust_email` - (Optional) If enabled then email provided by this provider is not verified even if verification is enabled for the realm. Defaults to `false`.\n- `link_only` - (Optional) If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't want to allow login from the provider, but want to integrate with a provider. Defaults to `false`.\n- `hide_on_login_page` - (Optional) If hidden, then login with this provider is possible only if requested explicitly, e.g. using the 'kc_idp_hint' parameter.\n- `first_broker_login_flow_alias` - (Optional) Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that there is not yet existing Keycloak account linked with the authenticated identity provider account. Defaults to `first broker login`.\n- `post_broker_login_flow_alias` - (Optional) Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it. Defaults to empty.\n- `authenticate_by_default` - (Optional) Authenticate users by default. Defaults to `false`.\n\n#### SAML Configuration\n\n- `single_sign_on_service_url` - (Optional) The Url that must be used to send authentication requests (SAML AuthnRequest).\n- `single_logout_service_url` - (Optional) The Url that must be used to send logout requests.\n- `backchannel_supported` - (Optional) Does the external IDP support back-channel logout ?.\n- `name_id_policy_format` - (Optional) Specifies the URI reference corresponding to a name identifier format. Defaults to empty.\n- `post_binding_response` - (Optional) Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used..\n- `post_binding_authn_request` - (Optional) Indicates whether the AuthnRequest must be sent using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\n- `post_binding_logout` - (Optional) Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\n- `want_assertions_signed` - (Optional) Indicates whether this service provider expects a signed Assertion.\n- `want_assertions_encrypted` - (Optional) Indicates whether this service provider expects an encrypted Assertion.\n- `force_authn` - (Optional) Indicates whether the identity provider must authenticate the presenter directly rather than rely on a previous security context.\n- `validate_signature` - (Optional) Enable/disable signature validation of SAML responses.\n- `signing_certificate` - (Optional) Signing Certificate.\n- `signature_algorithm` - (Optional) Signing Algorithm. Defaults to empty.\n- `xml_sign_key_info_key_name_transformer` - (Optional) Sign Key Transformer. Defaults to empty.\n\n### Import\n\nIdentity providers can be imported using the format `{{realm_id}}/{{idp_alias}}`, where `idp_alias` is the identity provider alias.\n\nExample:\n\n```bash\n$ terraform import keycloak_saml_identity_provider.realm_identity_provider my-realm/my-idp\n```\n",
            "properties": {
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.\n"
                },
                "alias": {
                    "type": "string",
                    "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "authnContextClassRefs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "AuthnContext ClassRefs\n"
                },
                "authnContextComparisonType": {
                    "type": "string",
                    "description": "AuthnContext Comparison\n"
                },
                "authnContextDeclRefs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "AuthnContext DeclRefs\n"
                },
                "backchannelSupported": {
                    "type": "boolean",
                    "description": "Does the external IDP support backchannel logout?\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "Friendly name for Identity Providers.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable/disable this identity provider.\n"
                },
                "entityId": {
                    "type": "string",
                    "description": "The Entity ID that will be used to uniquely identify this SAML Service Provider.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means\nthat there is not yet existing Keycloak account linked with the authenticated identity provider account.\n"
                },
                "forceAuthn": {
                    "type": "boolean",
                    "description": "Require Force Authn.\n"
                },
                "guiOrder": {
                    "type": "string",
                    "description": "GUI Order\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "Hide On Login Page.\n"
                },
                "internalId": {
                    "type": "string",
                    "description": "Internal Identity Provider Id\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't\nwant to allow login from the provider, but want to integrate with a provider\n"
                },
                "loginHint": {
                    "type": "string",
                    "description": "Login Hint.\n"
                },
                "nameIdPolicyFormat": {
                    "type": "string",
                    "description": "Name ID Policy Format.\n"
                },
                "postBindingAuthnRequest": {
                    "type": "boolean",
                    "description": "Post Binding Authn Request.\n"
                },
                "postBindingLogout": {
                    "type": "boolean",
                    "description": "Post Binding Logout.\n"
                },
                "postBindingResponse": {
                    "type": "boolean",
                    "description": "Post Binding Response.\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want\nadditional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if\nyou don't want any additional authenticators to be triggered after login with this identity provider. Also note, that\nauthenticator implementations must assume that user is already set in ClientSession as identity provider already set it.\n"
                },
                "principalAttribute": {
                    "type": "string",
                    "description": "Principal Attribute\n"
                },
                "principalType": {
                    "type": "string",
                    "description": "Principal Type\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "provider id, is always saml, unless you have a custom implementation\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "description": "Signing Algorithm.\n"
                },
                "signingCertificate": {
                    "type": "string",
                    "description": "Signing Certificate.\n"
                },
                "singleLogoutServiceUrl": {
                    "type": "string",
                    "description": "Logout URL.\n"
                },
                "singleSignOnServiceUrl": {
                    "type": "string",
                    "description": "SSO Logout URL.\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "Enable/disable if tokens must be stored after authenticating users.\n"
                },
                "syncMode": {
                    "type": "string",
                    "description": "Sync Mode\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "If enabled then email provided by this provider is not verified even if verification is enabled for the realm.\n"
                },
                "validateSignature": {
                    "type": "boolean",
                    "description": "Enable/disable signature validation of SAML responses.\n"
                },
                "wantAssertionsEncrypted": {
                    "type": "boolean",
                    "description": "Want Assertions Encrypted.\n"
                },
                "wantAssertionsSigned": {
                    "type": "boolean",
                    "description": "Want Assertions Signed.\n"
                },
                "xmlSignKeyInfoKeyNameTransformer": {
                    "type": "string",
                    "description": "Sign Key Transformer.\n"
                }
            },
            "required": [
                "alias",
                "entityId",
                "internalId",
                "realm",
                "singleSignOnServiceUrl"
            ],
            "inputProperties": {
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.\n",
                    "willReplaceOnChanges": true
                },
                "alias": {
                    "type": "string",
                    "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\n",
                    "willReplaceOnChanges": true
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "authnContextClassRefs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "AuthnContext ClassRefs\n"
                },
                "authnContextComparisonType": {
                    "type": "string",
                    "description": "AuthnContext Comparison\n"
                },
                "authnContextDeclRefs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "AuthnContext DeclRefs\n"
                },
                "backchannelSupported": {
                    "type": "boolean",
                    "description": "Does the external IDP support backchannel logout?\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "Friendly name for Identity Providers.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable/disable this identity provider.\n"
                },
                "entityId": {
                    "type": "string",
                    "description": "The Entity ID that will be used to uniquely identify this SAML Service Provider.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means\nthat there is not yet existing Keycloak account linked with the authenticated identity provider account.\n"
                },
                "forceAuthn": {
                    "type": "boolean",
                    "description": "Require Force Authn.\n"
                },
                "guiOrder": {
                    "type": "string",
                    "description": "GUI Order\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "Hide On Login Page.\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't\nwant to allow login from the provider, but want to integrate with a provider\n"
                },
                "loginHint": {
                    "type": "string",
                    "description": "Login Hint.\n"
                },
                "nameIdPolicyFormat": {
                    "type": "string",
                    "description": "Name ID Policy Format.\n"
                },
                "postBindingAuthnRequest": {
                    "type": "boolean",
                    "description": "Post Binding Authn Request.\n"
                },
                "postBindingLogout": {
                    "type": "boolean",
                    "description": "Post Binding Logout.\n"
                },
                "postBindingResponse": {
                    "type": "boolean",
                    "description": "Post Binding Response.\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want\nadditional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if\nyou don't want any additional authenticators to be triggered after login with this identity provider. Also note, that\nauthenticator implementations must assume that user is already set in ClientSession as identity provider already set it.\n"
                },
                "principalAttribute": {
                    "type": "string",
                    "description": "Principal Attribute\n"
                },
                "principalType": {
                    "type": "string",
                    "description": "Principal Type\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "provider id, is always saml, unless you have a custom implementation\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n",
                    "willReplaceOnChanges": true
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "description": "Signing Algorithm.\n"
                },
                "signingCertificate": {
                    "type": "string",
                    "description": "Signing Certificate.\n"
                },
                "singleLogoutServiceUrl": {
                    "type": "string",
                    "description": "Logout URL.\n"
                },
                "singleSignOnServiceUrl": {
                    "type": "string",
                    "description": "SSO Logout URL.\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "Enable/disable if tokens must be stored after authenticating users.\n"
                },
                "syncMode": {
                    "type": "string",
                    "description": "Sync Mode\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "If enabled then email provided by this provider is not verified even if verification is enabled for the realm.\n"
                },
                "validateSignature": {
                    "type": "boolean",
                    "description": "Enable/disable signature validation of SAML responses.\n"
                },
                "wantAssertionsEncrypted": {
                    "type": "boolean",
                    "description": "Want Assertions Encrypted.\n"
                },
                "wantAssertionsSigned": {
                    "type": "boolean",
                    "description": "Want Assertions Signed.\n"
                },
                "xmlSignKeyInfoKeyNameTransformer": {
                    "type": "string",
                    "description": "Sign Key Transformer.\n"
                }
            },
            "requiredInputs": [
                "alias",
                "entityId",
                "realm",
                "singleSignOnServiceUrl"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IdentityProvider resources.\n",
                "properties": {
                    "addReadTokenRoleOnCreate": {
                        "type": "boolean",
                        "description": "Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.\n",
                        "willReplaceOnChanges": true
                    },
                    "alias": {
                        "type": "string",
                        "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\n",
                        "willReplaceOnChanges": true
                    },
                    "authenticateByDefault": {
                        "type": "boolean",
                        "description": "Enable/disable authenticate users by default.\n"
                    },
                    "authnContextClassRefs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "AuthnContext ClassRefs\n"
                    },
                    "authnContextComparisonType": {
                        "type": "string",
                        "description": "AuthnContext Comparison\n"
                    },
                    "authnContextDeclRefs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "AuthnContext DeclRefs\n"
                    },
                    "backchannelSupported": {
                        "type": "boolean",
                        "description": "Does the external IDP support backchannel logout?\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "Friendly name for Identity Providers.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable/disable this identity provider.\n"
                    },
                    "entityId": {
                        "type": "string",
                        "description": "The Entity ID that will be used to uniquely identify this SAML Service Provider.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "firstBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means\nthat there is not yet existing Keycloak account linked with the authenticated identity provider account.\n"
                    },
                    "forceAuthn": {
                        "type": "boolean",
                        "description": "Require Force Authn.\n"
                    },
                    "guiOrder": {
                        "type": "string",
                        "description": "GUI Order\n"
                    },
                    "hideOnLoginPage": {
                        "type": "boolean",
                        "description": "Hide On Login Page.\n"
                    },
                    "internalId": {
                        "type": "string",
                        "description": "Internal Identity Provider Id\n"
                    },
                    "linkOnly": {
                        "type": "boolean",
                        "description": "If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't\nwant to allow login from the provider, but want to integrate with a provider\n"
                    },
                    "loginHint": {
                        "type": "string",
                        "description": "Login Hint.\n"
                    },
                    "nameIdPolicyFormat": {
                        "type": "string",
                        "description": "Name ID Policy Format.\n"
                    },
                    "postBindingAuthnRequest": {
                        "type": "boolean",
                        "description": "Post Binding Authn Request.\n"
                    },
                    "postBindingLogout": {
                        "type": "boolean",
                        "description": "Post Binding Logout.\n"
                    },
                    "postBindingResponse": {
                        "type": "boolean",
                        "description": "Post Binding Response.\n"
                    },
                    "postBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want\nadditional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if\nyou don't want any additional authenticators to be triggered after login with this identity provider. Also note, that\nauthenticator implementations must assume that user is already set in ClientSession as identity provider already set it.\n"
                    },
                    "principalAttribute": {
                        "type": "string",
                        "description": "Principal Attribute\n"
                    },
                    "principalType": {
                        "type": "string",
                        "description": "Principal Type\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "provider id, is always saml, unless you have a custom implementation\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "Realm Name\n",
                        "willReplaceOnChanges": true
                    },
                    "signatureAlgorithm": {
                        "type": "string",
                        "description": "Signing Algorithm.\n"
                    },
                    "signingCertificate": {
                        "type": "string",
                        "description": "Signing Certificate.\n"
                    },
                    "singleLogoutServiceUrl": {
                        "type": "string",
                        "description": "Logout URL.\n"
                    },
                    "singleSignOnServiceUrl": {
                        "type": "string",
                        "description": "SSO Logout URL.\n"
                    },
                    "storeToken": {
                        "type": "boolean",
                        "description": "Enable/disable if tokens must be stored after authenticating users.\n"
                    },
                    "syncMode": {
                        "type": "string",
                        "description": "Sync Mode\n"
                    },
                    "trustEmail": {
                        "type": "boolean",
                        "description": "If enabled then email provided by this provider is not verified even if verification is enabled for the realm.\n"
                    },
                    "validateSignature": {
                        "type": "boolean",
                        "description": "Enable/disable signature validation of SAML responses.\n"
                    },
                    "wantAssertionsEncrypted": {
                        "type": "boolean",
                        "description": "Want Assertions Encrypted.\n"
                    },
                    "wantAssertionsSigned": {
                        "type": "boolean",
                        "description": "Want Assertions Signed.\n"
                    },
                    "xmlSignKeyInfoKeyNameTransformer": {
                        "type": "string",
                        "description": "Sign Key Transformer.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/scriptProtocolMapper:ScriptProtocolMapper": {
            "description": "Allows for creating and managing script protocol mappers for SAML clients within Keycloak.\n\nScript protocol mappers evaluate a JavaScript function to produce an attribute value based on context information.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClient = new keycloak.saml.Client(\"saml_client\", {\n    realmId: realm.id,\n    clientId: \"saml-client\",\n    name: \"saml-client\",\n});\nconst samlScriptMapper = new keycloak.saml.ScriptProtocolMapper(\"saml_script_mapper\", {\n    realmId: realm.id,\n    clientId: samlClient.id,\n    name: \"script-mapper\",\n    script: \"exports = 'foo';\",\n    samlAttributeName: \"displayName\",\n    samlAttributeNameFormat: \"Unspecified\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client = keycloak.saml.Client(\"saml_client\",\n    realm_id=realm.id,\n    client_id=\"saml-client\",\n    name=\"saml-client\")\nsaml_script_mapper = keycloak.saml.ScriptProtocolMapper(\"saml_script_mapper\",\n    realm_id=realm.id,\n    client_id=saml_client.id,\n    name=\"script-mapper\",\n    script=\"exports = 'foo';\",\n    saml_attribute_name=\"displayName\",\n    saml_attribute_name_format=\"Unspecified\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var samlClient = new Keycloak.Saml.Client(\"saml_client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"saml-client\",\n        Name = \"saml-client\",\n    });\n\n    var samlScriptMapper = new Keycloak.Saml.ScriptProtocolMapper(\"saml_script_mapper\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = samlClient.Id,\n        Name = \"script-mapper\",\n        Script = \"exports = 'foo';\",\n        SamlAttributeName = \"displayName\",\n        SamlAttributeNameFormat = \"Unspecified\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsamlClient, err := saml.NewClient(ctx, \"saml_client\", \u0026saml.ClientArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: pulumi.String(\"saml-client\"),\n\t\t\tName:     pulumi.String(\"saml-client\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = saml.NewScriptProtocolMapper(ctx, \"saml_script_mapper\", \u0026saml.ScriptProtocolMapperArgs{\n\t\t\tRealmId:                 realm.ID(),\n\t\t\tClientId:                samlClient.ID(),\n\t\t\tName:                    pulumi.String(\"script-mapper\"),\n\t\t\tScript:                  pulumi.String(\"exports = 'foo';\"),\n\t\t\tSamlAttributeName:       pulumi.String(\"displayName\"),\n\t\t\tSamlAttributeNameFormat: pulumi.String(\"Unspecified\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.saml.Client;\nimport com.pulumi.keycloak.saml.ClientArgs;\nimport com.pulumi.keycloak.saml.ScriptProtocolMapper;\nimport com.pulumi.keycloak.saml.ScriptProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var samlClient = new Client(\"samlClient\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"saml-client\")\n            .name(\"saml-client\")\n            .build());\n\n        var samlScriptMapper = new ScriptProtocolMapper(\"samlScriptMapper\", ScriptProtocolMapperArgs.builder()\n            .realmId(realm.id())\n            .clientId(samlClient.id())\n            .name(\"script-mapper\")\n            .script(\"exports = 'foo';\")\n            .samlAttributeName(\"displayName\")\n            .samlAttributeNameFormat(\"Unspecified\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  samlClient:\n    type: keycloak:saml:Client\n    name: saml_client\n    properties:\n      realmId: ${realm.id}\n      clientId: saml-client\n      name: saml-client\n  samlScriptMapper:\n    type: keycloak:saml:ScriptProtocolMapper\n    name: saml_script_mapper\n    properties:\n      realmId: ${realm.id}\n      clientId: ${samlClient.id}\n      name: script-mapper\n      script: exports = 'foo';\n      samlAttributeName: displayName\n      samlAttributeNameFormat: Unspecified\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nProtocol mappers can be imported using one of the following formats:\n\n- Client: `{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}`\n\n- Client Scope: `{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}`\n\nExample:\n\nbash\n\n```sh\n$ pulumi import keycloak:saml/scriptProtocolMapper:ScriptProtocolMapper saml_script_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n```sh\n$ pulumi import keycloak:saml/scriptProtocolMapper:ScriptProtocolMapper saml_script_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "friendlyName": {
                    "type": "string",
                    "description": "An optional human-friendly name for this attribute.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "samlAttributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "samlAttributeNameFormat": {
                    "type": "string",
                    "description": "The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n"
                },
                "script": {
                    "type": "string",
                    "description": "JavaScript code to compute the attribute value.\n"
                },
                "singleValueAttribute": {
                    "type": "boolean",
                    "description": "When `true`, all values will be stored under one attribute with multiple attribute values. Defaults to `true`.\n"
                }
            },
            "required": [
                "name",
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "script"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                    "willReplaceOnChanges": true
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                    "willReplaceOnChanges": true
                },
                "friendlyName": {
                    "type": "string",
                    "description": "An optional human-friendly name for this attribute.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n",
                    "willReplaceOnChanges": true
                },
                "samlAttributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "samlAttributeNameFormat": {
                    "type": "string",
                    "description": "The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n"
                },
                "script": {
                    "type": "string",
                    "description": "JavaScript code to compute the attribute value.\n"
                },
                "singleValueAttribute": {
                    "type": "boolean",
                    "description": "When `true`, all values will be stored under one attribute with multiple attribute values. Defaults to `true`.\n"
                }
            },
            "requiredInputs": [
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "script"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ScriptProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                        "willReplaceOnChanges": true
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n",
                        "willReplaceOnChanges": true
                    },
                    "friendlyName": {
                        "type": "string",
                        "description": "An optional human-friendly name for this attribute.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n",
                        "willReplaceOnChanges": true
                    },
                    "samlAttributeName": {
                        "type": "string",
                        "description": "The name of the SAML attribute.\n"
                    },
                    "samlAttributeNameFormat": {
                        "type": "string",
                        "description": "The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n"
                    },
                    "script": {
                        "type": "string",
                        "description": "JavaScript code to compute the attribute value.\n"
                    },
                    "singleValueAttribute": {
                        "type": "boolean",
                        "description": "When `true`, all values will be stored under one attribute with multiple attribute values. Defaults to `true`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/userAttributeProtocolMapper:UserAttributeProtocolMapper": {
            "description": "## # keycloak.saml.UserAttributeProtocolMapper\n\nAllows for creating and managing user attribute protocol mappers for\nSAML clients within Keycloak.\n\nSAML user attribute protocol mappers allow you to map custom attributes defined\nfor a user within Keycloak to an attribute in a SAML assertion. Protocol mappers\ncan be defined for a single client, or they can be defined for a client scope which\ncan be shared between multiple different clients.\n\n### Example Usage (Client)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClient = new keycloak.saml.Client(\"saml_client\", {\n    realmId: test.id,\n    clientId: \"test-saml-client\",\n    name: \"test-saml-client\",\n});\nconst samlUserAttributeMapper = new keycloak.saml.UserAttributeProtocolMapper(\"saml_user_attribute_mapper\", {\n    realmId: test.id,\n    clientId: samlClient.id,\n    name: \"displayname-user-attribute-mapper\",\n    userAttribute: \"displayName\",\n    samlAttributeName: \"displayName\",\n    samlAttributeNameFormat: \"Unspecified\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client = keycloak.saml.Client(\"saml_client\",\n    realm_id=test[\"id\"],\n    client_id=\"test-saml-client\",\n    name=\"test-saml-client\")\nsaml_user_attribute_mapper = keycloak.saml.UserAttributeProtocolMapper(\"saml_user_attribute_mapper\",\n    realm_id=test[\"id\"],\n    client_id=saml_client.id,\n    name=\"displayname-user-attribute-mapper\",\n    user_attribute=\"displayName\",\n    saml_attribute_name=\"displayName\",\n    saml_attribute_name_format=\"Unspecified\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var samlClient = new Keycloak.Saml.Client(\"saml_client\", new()\n    {\n        RealmId = test.Id,\n        ClientId = \"test-saml-client\",\n        Name = \"test-saml-client\",\n    });\n\n    var samlUserAttributeMapper = new Keycloak.Saml.UserAttributeProtocolMapper(\"saml_user_attribute_mapper\", new()\n    {\n        RealmId = test.Id,\n        ClientId = samlClient.Id,\n        Name = \"displayname-user-attribute-mapper\",\n        UserAttribute = \"displayName\",\n        SamlAttributeName = \"displayName\",\n        SamlAttributeNameFormat = \"Unspecified\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsamlClient, err := saml.NewClient(ctx, \"saml_client\", \u0026saml.ClientArgs{\n\t\t\tRealmId:  pulumi.Any(test.Id),\n\t\t\tClientId: pulumi.String(\"test-saml-client\"),\n\t\t\tName:     pulumi.String(\"test-saml-client\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = saml.NewUserAttributeProtocolMapper(ctx, \"saml_user_attribute_mapper\", \u0026saml.UserAttributeProtocolMapperArgs{\n\t\t\tRealmId:                 pulumi.Any(test.Id),\n\t\t\tClientId:                samlClient.ID(),\n\t\t\tName:                    pulumi.String(\"displayname-user-attribute-mapper\"),\n\t\t\tUserAttribute:           pulumi.String(\"displayName\"),\n\t\t\tSamlAttributeName:       pulumi.String(\"displayName\"),\n\t\t\tSamlAttributeNameFormat: pulumi.String(\"Unspecified\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.saml.Client;\nimport com.pulumi.keycloak.saml.ClientArgs;\nimport com.pulumi.keycloak.saml.UserAttributeProtocolMapper;\nimport com.pulumi.keycloak.saml.UserAttributeProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var samlClient = new Client(\"samlClient\", ClientArgs.builder()\n            .realmId(test.id())\n            .clientId(\"test-saml-client\")\n            .name(\"test-saml-client\")\n            .build());\n\n        var samlUserAttributeMapper = new UserAttributeProtocolMapper(\"samlUserAttributeMapper\", UserAttributeProtocolMapperArgs.builder()\n            .realmId(test.id())\n            .clientId(samlClient.id())\n            .name(\"displayname-user-attribute-mapper\")\n            .userAttribute(\"displayName\")\n            .samlAttributeName(\"displayName\")\n            .samlAttributeNameFormat(\"Unspecified\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  samlClient:\n    type: keycloak:saml:Client\n    name: saml_client\n    properties:\n      realmId: ${test.id}\n      clientId: test-saml-client\n      name: test-saml-client\n  samlUserAttributeMapper:\n    type: keycloak:saml:UserAttributeProtocolMapper\n    name: saml_user_attribute_mapper\n    properties:\n      realmId: ${test.id}\n      clientId: ${samlClient.id}\n      name: displayname-user-attribute-mapper\n      userAttribute: displayName\n      samlAttributeName: displayName\n      samlAttributeNameFormat: Unspecified\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The SAML client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The SAML client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `user_attribute` - (Required) The custom user attribute to map.\n- `friendly_name` - (Optional) An optional human-friendly name for this attribute.\n- `saml_attribute_name` - (Required) The name of the SAML attribute.\n- `saml_attribute_name_format` - (Required) The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n\n### Import\n\nProtocol mappers can be imported using one of the following formats:\n- Client: `{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}`\n- Client Scope: `{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}`\n\nExample:\n\n```bash\n$ terraform import keycloak_saml_user_attribute_protocol_mapper.saml_user_attribute_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n$ terraform import keycloak_saml_user_attribute_protocol_mapper.saml_user_attribute_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n",
            "properties": {
                "clientId": {
                    "type": "string"
                },
                "clientScopeId": {
                    "type": "string"
                },
                "friendlyName": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "samlAttributeName": {
                    "type": "string"
                },
                "samlAttributeNameFormat": {
                    "type": "string"
                },
                "userAttribute": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "userAttribute"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "clientScopeId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "friendlyName": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "samlAttributeName": {
                    "type": "string"
                },
                "samlAttributeNameFormat": {
                    "type": "string"
                },
                "userAttribute": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "userAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserAttributeProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "clientScopeId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "friendlyName": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "samlAttributeName": {
                        "type": "string"
                    },
                    "samlAttributeNameFormat": {
                        "type": "string"
                    },
                    "userAttribute": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/userPropertyProtocolMapper:UserPropertyProtocolMapper": {
            "description": "## # keycloak.saml.UserPropertyProtocolMapper\n\nAllows for creating and managing user property protocol mappers for\nSAML clients within Keycloak.\n\nSAML user property protocol mappers allow you to map properties of the Keycloak\nuser model to an attribute in a SAML assertion. Protocol mappers\ncan be defined for a single client, or they can be defined for a client scope which\ncan be shared between multiple different clients.\n\n### Example Usage (Client)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClient = new keycloak.saml.Client(\"saml_client\", {\n    realmId: test.id,\n    clientId: \"test-saml-client\",\n    name: \"test-saml-client\",\n});\nconst samlUserPropertyMapper = new keycloak.saml.UserPropertyProtocolMapper(\"saml_user_property_mapper\", {\n    realmId: test.id,\n    clientId: samlClient.id,\n    name: \"email-user-property-mapper\",\n    userProperty: \"email\",\n    samlAttributeName: \"email\",\n    samlAttributeNameFormat: \"Unspecified\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client = keycloak.saml.Client(\"saml_client\",\n    realm_id=test[\"id\"],\n    client_id=\"test-saml-client\",\n    name=\"test-saml-client\")\nsaml_user_property_mapper = keycloak.saml.UserPropertyProtocolMapper(\"saml_user_property_mapper\",\n    realm_id=test[\"id\"],\n    client_id=saml_client.id,\n    name=\"email-user-property-mapper\",\n    user_property=\"email\",\n    saml_attribute_name=\"email\",\n    saml_attribute_name_format=\"Unspecified\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var samlClient = new Keycloak.Saml.Client(\"saml_client\", new()\n    {\n        RealmId = test.Id,\n        ClientId = \"test-saml-client\",\n        Name = \"test-saml-client\",\n    });\n\n    var samlUserPropertyMapper = new Keycloak.Saml.UserPropertyProtocolMapper(\"saml_user_property_mapper\", new()\n    {\n        RealmId = test.Id,\n        ClientId = samlClient.Id,\n        Name = \"email-user-property-mapper\",\n        UserProperty = \"email\",\n        SamlAttributeName = \"email\",\n        SamlAttributeNameFormat = \"Unspecified\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsamlClient, err := saml.NewClient(ctx, \"saml_client\", \u0026saml.ClientArgs{\n\t\t\tRealmId:  pulumi.Any(test.Id),\n\t\t\tClientId: pulumi.String(\"test-saml-client\"),\n\t\t\tName:     pulumi.String(\"test-saml-client\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = saml.NewUserPropertyProtocolMapper(ctx, \"saml_user_property_mapper\", \u0026saml.UserPropertyProtocolMapperArgs{\n\t\t\tRealmId:                 pulumi.Any(test.Id),\n\t\t\tClientId:                samlClient.ID(),\n\t\t\tName:                    pulumi.String(\"email-user-property-mapper\"),\n\t\t\tUserProperty:            pulumi.String(\"email\"),\n\t\t\tSamlAttributeName:       pulumi.String(\"email\"),\n\t\t\tSamlAttributeNameFormat: pulumi.String(\"Unspecified\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.saml.Client;\nimport com.pulumi.keycloak.saml.ClientArgs;\nimport com.pulumi.keycloak.saml.UserPropertyProtocolMapper;\nimport com.pulumi.keycloak.saml.UserPropertyProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var samlClient = new Client(\"samlClient\", ClientArgs.builder()\n            .realmId(test.id())\n            .clientId(\"test-saml-client\")\n            .name(\"test-saml-client\")\n            .build());\n\n        var samlUserPropertyMapper = new UserPropertyProtocolMapper(\"samlUserPropertyMapper\", UserPropertyProtocolMapperArgs.builder()\n            .realmId(test.id())\n            .clientId(samlClient.id())\n            .name(\"email-user-property-mapper\")\n            .userProperty(\"email\")\n            .samlAttributeName(\"email\")\n            .samlAttributeNameFormat(\"Unspecified\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  samlClient:\n    type: keycloak:saml:Client\n    name: saml_client\n    properties:\n      realmId: ${test.id}\n      clientId: test-saml-client\n      name: test-saml-client\n  samlUserPropertyMapper:\n    type: keycloak:saml:UserPropertyProtocolMapper\n    name: saml_user_property_mapper\n    properties:\n      realmId: ${test.id}\n      clientId: ${samlClient.id}\n      name: email-user-property-mapper\n      userProperty: email\n      samlAttributeName: email\n      samlAttributeNameFormat: Unspecified\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this protocol mapper exists within.\n- `client_id` - (Required if `client_scope_id` is not specified) The SAML client this protocol mapper is attached to.\n- `client_scope_id` - (Required if `client_id` is not specified) The SAML client scope this protocol mapper is attached to.\n- `name` - (Required) The display name of this protocol mapper in the GUI.\n- `user_property` - (Required) The property of the Keycloak user model to map.\n- `friendly_name` - (Optional) An optional human-friendly name for this attribute.\n- `saml_attribute_name` - (Required) The name of the SAML attribute.\n- `saml_attribute_name_format` - (Required) The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n\n### Import\n\nProtocol mappers can be imported using one of the following formats:\n- Client: `{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}`\n- Client Scope: `{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}`\n\nExample:\n\n```bash\n$ terraform import keycloak_saml_user_property_protocol_mapper.saml_user_property_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n$ terraform import keycloak_saml_user_property_protocol_mapper.saml_user_property_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n",
            "properties": {
                "clientId": {
                    "type": "string"
                },
                "clientScopeId": {
                    "type": "string"
                },
                "friendlyName": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "samlAttributeName": {
                    "type": "string"
                },
                "samlAttributeNameFormat": {
                    "type": "string"
                },
                "userProperty": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "userProperty"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "clientScopeId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "friendlyName": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "samlAttributeName": {
                    "type": "string"
                },
                "samlAttributeNameFormat": {
                    "type": "string"
                },
                "userProperty": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "userProperty"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserPropertyProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "clientScopeId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "friendlyName": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "samlAttributeName": {
                        "type": "string"
                    },
                    "samlAttributeNameFormat": {
                        "type": "string"
                    },
                    "userProperty": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "keycloak:index/getAuthenticationExecution:getAuthenticationExecution": {
            "description": "This data source can be used to fetch the ID of an authentication execution within Keycloak.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst browserAuthCookie = keycloak.getAuthenticationExecutionOutput({\n    realmId: realm.id,\n    parentFlowAlias: \"browser\",\n    providerId: \"auth-cookie\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nbrowser_auth_cookie = keycloak.get_authentication_execution_output(realm_id=realm.id,\n    parent_flow_alias=\"browser\",\n    provider_id=\"auth-cookie\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var browserAuthCookie = Keycloak.GetAuthenticationExecution.Invoke(new()\n    {\n        RealmId = realm.Id,\n        ParentFlowAlias = \"browser\",\n        ProviderId = \"auth-cookie\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = keycloak.GetAuthenticationExecutionOutput(ctx, keycloak.GetAuthenticationExecutionOutputArgs{\n\t\t\tRealmId:         realm.ID(),\n\t\t\tParentFlowAlias: pulumi.String(\"browser\"),\n\t\t\tProviderId:      pulumi.String(\"auth-cookie\"),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.KeycloakFunctions;\nimport com.pulumi.keycloak.inputs.GetAuthenticationExecutionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        final var browserAuthCookie = KeycloakFunctions.getAuthenticationExecution(GetAuthenticationExecutionArgs.builder()\n            .realmId(realm.id())\n            .parentFlowAlias(\"browser\")\n            .providerId(\"auth-cookie\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\nvariables:\n  browserAuthCookie:\n    fn::invoke:\n      Function: keycloak:getAuthenticationExecution\n      Arguments:\n        realmId: ${realm.id}\n        parentFlowAlias: browser\n        providerId: auth-cookie\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthenticationExecution.\n",
                "properties": {
                    "parentFlowAlias": {
                        "type": "string",
                        "description": "The alias of the flow this execution is attached to.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The name of the provider. This can be found by experimenting with the GUI and looking at HTTP requests within the network tab of your browser's development tools. This was previously known as the \"authenticator\".\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm the authentication execution exists in.\n"
                    }
                },
                "type": "object",
                "required": [
                    "parentFlowAlias",
                    "providerId",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthenticationExecution.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "parentFlowAlias": {
                        "type": "string"
                    },
                    "providerId": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "required": [
                    "parentFlowAlias",
                    "providerId",
                    "realmId",
                    "id"
                ],
                "type": "object"
            }
        },
        "keycloak:index/getAuthenticationFlow:getAuthenticationFlow": {
            "description": "This data source can be used to fetch the ID of an authentication flow within Keycloak.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst browserAuthCookie = keycloak.getAuthenticationFlowOutput({\n    realmId: realm.id,\n    alias: \"browser\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nbrowser_auth_cookie = keycloak.get_authentication_flow_output(realm_id=realm.id,\n    alias=\"browser\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var browserAuthCookie = Keycloak.GetAuthenticationFlow.Invoke(new()\n    {\n        RealmId = realm.Id,\n        Alias = \"browser\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = keycloak.GetAuthenticationFlowOutput(ctx, keycloak.GetAuthenticationFlowOutputArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tAlias:   pulumi.String(\"browser\"),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.KeycloakFunctions;\nimport com.pulumi.keycloak.inputs.GetAuthenticationFlowArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        final var browserAuthCookie = KeycloakFunctions.getAuthenticationFlow(GetAuthenticationFlowArgs.builder()\n            .realmId(realm.id())\n            .alias(\"browser\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\nvariables:\n  browserAuthCookie:\n    fn::invoke:\n      Function: keycloak:getAuthenticationFlow\n      Arguments:\n        realmId: ${realm.id}\n        alias: browser\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthenticationFlow.\n",
                "properties": {
                    "alias": {
                        "type": "string",
                        "description": "The alias of the flow.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm the authentication flow exists in.\n"
                    }
                },
                "type": "object",
                "required": [
                    "alias",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthenticationFlow.\n",
                "properties": {
                    "alias": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "required": [
                    "alias",
                    "realmId",
                    "id"
                ],
                "type": "object"
            }
        },
        "keycloak:index/getClientDescriptionConverter:getClientDescriptionConverter": {
            "description": "This data source uses the [ClientDescriptionConverter](https://www.keycloak.org/docs-api/6.0/javadocs/org/keycloak/exportimport/ClientDescriptionConverter.html) API to convert a generic client description into a Keycloak\nclient. This data can then be used to manage the client within Keycloak.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClient = keycloak.getClientDescriptionConverterOutput({\n    realmId: realm.id,\n    body: `\\x09\u003cmd:EntityDescriptor xmlns:md=\"urn:oasis:names:tc:SAML:2.0:metadata\" validUntil=\"2021-04-17T12:41:46Z\" cacheDuration=\"PT604800S\" entityID=\"FakeEntityId\"\u003e\n    \u003cmd:SPSSODescriptor AuthnRequestsSigned=\"false\" WantAssertionsSigned=\"false\" protocolSupportEnumeration=\"urn:oasis:names:tc:SAML:2.0:protocol\"\u003e\n        \u003cmd:KeyDescriptor use=\"signing\"\u003e\n\\x09\\x09\\x09\u003cds:KeyInfo xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\u003e\n\\x09\\x09\\x09\\x09\u003cds:X509Data\u003e\n\\x09\\x09\\x09\\x09\\x09\u003cds:X509Certificate\u003eMIICyDCCAjGgAwIBAgIBADANBgkqhkiG9w0BAQ0FADCBgDELMAkGA1UEBhMCdXMx\n\\x09\\x09\\x09\\x09\\x09CzAJBgNVBAgMAklBMSQwIgYDVQQKDBt0ZXJyYWZvcm0tcHJvdmlkZXIta2V5Y2xv\n\\x09\\x09\\x09\\x09\\x09YWsxHDAaBgNVBAMME21ycGFya2Vycy5naXRodWIuaW8xIDAeBgkqhkiG9w0BCQEW\n\\x09\\x09\\x09\\x09\\x09EW1pY2hhZWxAcGFya2VyLmdnMB4XDTE5MDEwODE0NDYzNloXDTI5MDEwNTE0NDYz\n\\x09\\x09\\x09\\x09\\x09NlowgYAxCzAJBgNVBAYTAnVzMQswCQYDVQQIDAJJQTEkMCIGA1UECgwbdGVycmFm\n\\x09\\x09\\x09\\x09\\x09b3JtLXByb3ZpZGVyLWtleWNsb2FrMRwwGgYDVQQDDBNtcnBhcmtlcnMuZ2l0aHVi\n\\x09\\x09\\x09\\x09\\x09LmlvMSAwHgYJKoZIhvcNAQkBFhFtaWNoYWVsQHBhcmtlci5nZzCBnzANBgkqhkiG\n\\x09\\x09\\x09\\x09\\x099w0BAQEFAAOBjQAwgYkCgYEAxuZny7uyYxGVPtpie14gNQC4tT9sAvO2sVNDhuoe\n\\x09\\x09\\x09\\x09\\x09qIKLRpNwkHnwQmwe5OxSh9K0BPHp/DNuuVWUqvo4tniEYn3jBr7FwLYLTKojQIxj\n\\x09\\x09\\x09\\x09\\x0953S1UTT9EXq3eP5HsHMD0QnTuca2nlNYUDBm6ud2fQj0Jt5qLx86EbEC28N56IRv\n\\x09\\x09\\x09\\x09\\x09GX8CAwEAAaNQME4wHQYDVR0OBBYEFMLnbQh77j7vhGTpAhKpDhCrBsPZMB8GA1Ud\n\\x09\\x09\\x09\\x09\\x09IwQYMBaAFMLnbQh77j7vhGTpAhKpDhCrBsPZMAwGA1UdEwQFMAMBAf8wDQYJKoZI\n\\x09\\x09\\x09\\x09\\x09hvcNAQENBQADgYEAB8wGrAQY0pAfwbnYSyBt4STbebeRTu1/q1ucfrtc3qsegcd5\n\\x09\\x09\\x09\\x09\\x09n01xTR+T2uZJwqHFPpFjr4IPORiHx3+4BWCweslPD53qBjKUPXcbMO1Revjef6Tj\n\\x09\\x09\\x09\\x09\\x09K3K0AuJ94fxgXVoT61Nzu/a6Lj6RhzU/Dao9mlSbJY+YSbm+ZBpsuRUQ84s=\u003c/ds:X509Certificate\u003e\n\\x09\\x09\\x09\\x09\u003c/ds:X509Data\u003e\n\\x09\\x09\\x09\u003c/ds:KeyInfo\u003e\n\\x09\\x09\u003c/md:KeyDescriptor\u003e\n\\x09\\x09\u003cmd:NameIDFormat\u003eurn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\u003c/md:NameIDFormat\u003e\n        \u003cmd:AssertionConsumerService Binding=\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\" Location=\"https://localhost/acs/saml/\" index=\"1\"/\u003e\n    \u003c/md:SPSSODescriptor\u003e\n\u003c/md:EntityDescriptor\u003e\n`,\n});\nconst samlClientClient = new keycloak.saml.Client(\"saml_client\", {\n    realmId: realm.id,\n    clientId: samlClient.apply(samlClient =\u003e samlClient.clientId),\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client = keycloak.get_client_description_converter_output(realm_id=realm.id,\n    body=\"\"\"\\x09\u003cmd:EntityDescriptor xmlns:md=\"urn:oasis:names:tc:SAML:2.0:metadata\" validUntil=\"2021-04-17T12:41:46Z\" cacheDuration=\"PT604800S\" entityID=\"FakeEntityId\"\u003e\n    \u003cmd:SPSSODescriptor AuthnRequestsSigned=\"false\" WantAssertionsSigned=\"false\" protocolSupportEnumeration=\"urn:oasis:names:tc:SAML:2.0:protocol\"\u003e\n        \u003cmd:KeyDescriptor use=\"signing\"\u003e\n\\x09\\x09\\x09\u003cds:KeyInfo xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\u003e\n\\x09\\x09\\x09\\x09\u003cds:X509Data\u003e\n\\x09\\x09\\x09\\x09\\x09\u003cds:X509Certificate\u003eMIICyDCCAjGgAwIBAgIBADANBgkqhkiG9w0BAQ0FADCBgDELMAkGA1UEBhMCdXMx\n\\x09\\x09\\x09\\x09\\x09CzAJBgNVBAgMAklBMSQwIgYDVQQKDBt0ZXJyYWZvcm0tcHJvdmlkZXIta2V5Y2xv\n\\x09\\x09\\x09\\x09\\x09YWsxHDAaBgNVBAMME21ycGFya2Vycy5naXRodWIuaW8xIDAeBgkqhkiG9w0BCQEW\n\\x09\\x09\\x09\\x09\\x09EW1pY2hhZWxAcGFya2VyLmdnMB4XDTE5MDEwODE0NDYzNloXDTI5MDEwNTE0NDYz\n\\x09\\x09\\x09\\x09\\x09NlowgYAxCzAJBgNVBAYTAnVzMQswCQYDVQQIDAJJQTEkMCIGA1UECgwbdGVycmFm\n\\x09\\x09\\x09\\x09\\x09b3JtLXByb3ZpZGVyLWtleWNsb2FrMRwwGgYDVQQDDBNtcnBhcmtlcnMuZ2l0aHVi\n\\x09\\x09\\x09\\x09\\x09LmlvMSAwHgYJKoZIhvcNAQkBFhFtaWNoYWVsQHBhcmtlci5nZzCBnzANBgkqhkiG\n\\x09\\x09\\x09\\x09\\x099w0BAQEFAAOBjQAwgYkCgYEAxuZny7uyYxGVPtpie14gNQC4tT9sAvO2sVNDhuoe\n\\x09\\x09\\x09\\x09\\x09qIKLRpNwkHnwQmwe5OxSh9K0BPHp/DNuuVWUqvo4tniEYn3jBr7FwLYLTKojQIxj\n\\x09\\x09\\x09\\x09\\x0953S1UTT9EXq3eP5HsHMD0QnTuca2nlNYUDBm6ud2fQj0Jt5qLx86EbEC28N56IRv\n\\x09\\x09\\x09\\x09\\x09GX8CAwEAAaNQME4wHQYDVR0OBBYEFMLnbQh77j7vhGTpAhKpDhCrBsPZMB8GA1Ud\n\\x09\\x09\\x09\\x09\\x09IwQYMBaAFMLnbQh77j7vhGTpAhKpDhCrBsPZMAwGA1UdEwQFMAMBAf8wDQYJKoZI\n\\x09\\x09\\x09\\x09\\x09hvcNAQENBQADgYEAB8wGrAQY0pAfwbnYSyBt4STbebeRTu1/q1ucfrtc3qsegcd5\n\\x09\\x09\\x09\\x09\\x09n01xTR+T2uZJwqHFPpFjr4IPORiHx3+4BWCweslPD53qBjKUPXcbMO1Revjef6Tj\n\\x09\\x09\\x09\\x09\\x09K3K0AuJ94fxgXVoT61Nzu/a6Lj6RhzU/Dao9mlSbJY+YSbm+ZBpsuRUQ84s=\u003c/ds:X509Certificate\u003e\n\\x09\\x09\\x09\\x09\u003c/ds:X509Data\u003e\n\\x09\\x09\\x09\u003c/ds:KeyInfo\u003e\n\\x09\\x09\u003c/md:KeyDescriptor\u003e\n\\x09\\x09\u003cmd:NameIDFormat\u003eurn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\u003c/md:NameIDFormat\u003e\n        \u003cmd:AssertionConsumerService Binding=\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\" Location=\"https://localhost/acs/saml/\" index=\"1\"/\u003e\n    \u003c/md:SPSSODescriptor\u003e\n\u003c/md:EntityDescriptor\u003e\n\"\"\")\nsaml_client_client = keycloak.saml.Client(\"saml_client\",\n    realm_id=realm.id,\n    client_id=saml_client.client_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var samlClient = Keycloak.GetClientDescriptionConverter.Invoke(new()\n    {\n        RealmId = realm.Id,\n        Body = @\"\t\u003cmd:EntityDescriptor xmlns:md=\"\"urn:oasis:names:tc:SAML:2.0:metadata\"\" validUntil=\"\"2021-04-17T12:41:46Z\"\" cacheDuration=\"\"PT604800S\"\" entityID=\"\"FakeEntityId\"\"\u003e\n    \u003cmd:SPSSODescriptor AuthnRequestsSigned=\"\"false\"\" WantAssertionsSigned=\"\"false\"\" protocolSupportEnumeration=\"\"urn:oasis:names:tc:SAML:2.0:protocol\"\"\u003e\n        \u003cmd:KeyDescriptor use=\"\"signing\"\"\u003e\n\t\t\t\u003cds:KeyInfo xmlns:ds=\"\"http://www.w3.org/2000/09/xmldsig#\"\"\u003e\n\t\t\t\t\u003cds:X509Data\u003e\n\t\t\t\t\t\u003cds:X509Certificate\u003eMIICyDCCAjGgAwIBAgIBADANBgkqhkiG9w0BAQ0FADCBgDELMAkGA1UEBhMCdXMx\n\t\t\t\t\tCzAJBgNVBAgMAklBMSQwIgYDVQQKDBt0ZXJyYWZvcm0tcHJvdmlkZXIta2V5Y2xv\n\t\t\t\t\tYWsxHDAaBgNVBAMME21ycGFya2Vycy5naXRodWIuaW8xIDAeBgkqhkiG9w0BCQEW\n\t\t\t\t\tEW1pY2hhZWxAcGFya2VyLmdnMB4XDTE5MDEwODE0NDYzNloXDTI5MDEwNTE0NDYz\n\t\t\t\t\tNlowgYAxCzAJBgNVBAYTAnVzMQswCQYDVQQIDAJJQTEkMCIGA1UECgwbdGVycmFm\n\t\t\t\t\tb3JtLXByb3ZpZGVyLWtleWNsb2FrMRwwGgYDVQQDDBNtcnBhcmtlcnMuZ2l0aHVi\n\t\t\t\t\tLmlvMSAwHgYJKoZIhvcNAQkBFhFtaWNoYWVsQHBhcmtlci5nZzCBnzANBgkqhkiG\n\t\t\t\t\t9w0BAQEFAAOBjQAwgYkCgYEAxuZny7uyYxGVPtpie14gNQC4tT9sAvO2sVNDhuoe\n\t\t\t\t\tqIKLRpNwkHnwQmwe5OxSh9K0BPHp/DNuuVWUqvo4tniEYn3jBr7FwLYLTKojQIxj\n\t\t\t\t\t53S1UTT9EXq3eP5HsHMD0QnTuca2nlNYUDBm6ud2fQj0Jt5qLx86EbEC28N56IRv\n\t\t\t\t\tGX8CAwEAAaNQME4wHQYDVR0OBBYEFMLnbQh77j7vhGTpAhKpDhCrBsPZMB8GA1Ud\n\t\t\t\t\tIwQYMBaAFMLnbQh77j7vhGTpAhKpDhCrBsPZMAwGA1UdEwQFMAMBAf8wDQYJKoZI\n\t\t\t\t\thvcNAQENBQADgYEAB8wGrAQY0pAfwbnYSyBt4STbebeRTu1/q1ucfrtc3qsegcd5\n\t\t\t\t\tn01xTR+T2uZJwqHFPpFjr4IPORiHx3+4BWCweslPD53qBjKUPXcbMO1Revjef6Tj\n\t\t\t\t\tK3K0AuJ94fxgXVoT61Nzu/a6Lj6RhzU/Dao9mlSbJY+YSbm+ZBpsuRUQ84s=\u003c/ds:X509Certificate\u003e\n\t\t\t\t\u003c/ds:X509Data\u003e\n\t\t\t\u003c/ds:KeyInfo\u003e\n\t\t\u003c/md:KeyDescriptor\u003e\n\t\t\u003cmd:NameIDFormat\u003eurn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\u003c/md:NameIDFormat\u003e\n        \u003cmd:AssertionConsumerService Binding=\"\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\"\" Location=\"\"https://localhost/acs/saml/\"\" index=\"\"1\"\"/\u003e\n    \u003c/md:SPSSODescriptor\u003e\n\u003c/md:EntityDescriptor\u003e\n\",\n    });\n\n    var samlClientClient = new Keycloak.Saml.Client(\"saml_client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = samlClient.Apply(getClientDescriptionConverterResult =\u003e getClientDescriptionConverterResult.ClientId),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsamlClient := keycloak.GetClientDescriptionConverterOutput(ctx, keycloak.GetClientDescriptionConverterOutputArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tBody: pulumi.String(`\t\u003cmd:EntityDescriptor xmlns:md=\"urn:oasis:names:tc:SAML:2.0:metadata\" validUntil=\"2021-04-17T12:41:46Z\" cacheDuration=\"PT604800S\" entityID=\"FakeEntityId\"\u003e\n    \u003cmd:SPSSODescriptor AuthnRequestsSigned=\"false\" WantAssertionsSigned=\"false\" protocolSupportEnumeration=\"urn:oasis:names:tc:SAML:2.0:protocol\"\u003e\n        \u003cmd:KeyDescriptor use=\"signing\"\u003e\n\t\t\t\u003cds:KeyInfo xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\u003e\n\t\t\t\t\u003cds:X509Data\u003e\n\t\t\t\t\t\u003cds:X509Certificate\u003eMIICyDCCAjGgAwIBAgIBADANBgkqhkiG9w0BAQ0FADCBgDELMAkGA1UEBhMCdXMx\n\t\t\t\t\tCzAJBgNVBAgMAklBMSQwIgYDVQQKDBt0ZXJyYWZvcm0tcHJvdmlkZXIta2V5Y2xv\n\t\t\t\t\tYWsxHDAaBgNVBAMME21ycGFya2Vycy5naXRodWIuaW8xIDAeBgkqhkiG9w0BCQEW\n\t\t\t\t\tEW1pY2hhZWxAcGFya2VyLmdnMB4XDTE5MDEwODE0NDYzNloXDTI5MDEwNTE0NDYz\n\t\t\t\t\tNlowgYAxCzAJBgNVBAYTAnVzMQswCQYDVQQIDAJJQTEkMCIGA1UECgwbdGVycmFm\n\t\t\t\t\tb3JtLXByb3ZpZGVyLWtleWNsb2FrMRwwGgYDVQQDDBNtcnBhcmtlcnMuZ2l0aHVi\n\t\t\t\t\tLmlvMSAwHgYJKoZIhvcNAQkBFhFtaWNoYWVsQHBhcmtlci5nZzCBnzANBgkqhkiG\n\t\t\t\t\t9w0BAQEFAAOBjQAwgYkCgYEAxuZny7uyYxGVPtpie14gNQC4tT9sAvO2sVNDhuoe\n\t\t\t\t\tqIKLRpNwkHnwQmwe5OxSh9K0BPHp/DNuuVWUqvo4tniEYn3jBr7FwLYLTKojQIxj\n\t\t\t\t\t53S1UTT9EXq3eP5HsHMD0QnTuca2nlNYUDBm6ud2fQj0Jt5qLx86EbEC28N56IRv\n\t\t\t\t\tGX8CAwEAAaNQME4wHQYDVR0OBBYEFMLnbQh77j7vhGTpAhKpDhCrBsPZMB8GA1Ud\n\t\t\t\t\tIwQYMBaAFMLnbQh77j7vhGTpAhKpDhCrBsPZMAwGA1UdEwQFMAMBAf8wDQYJKoZI\n\t\t\t\t\thvcNAQENBQADgYEAB8wGrAQY0pAfwbnYSyBt4STbebeRTu1/q1ucfrtc3qsegcd5\n\t\t\t\t\tn01xTR+T2uZJwqHFPpFjr4IPORiHx3+4BWCweslPD53qBjKUPXcbMO1Revjef6Tj\n\t\t\t\t\tK3K0AuJ94fxgXVoT61Nzu/a6Lj6RhzU/Dao9mlSbJY+YSbm+ZBpsuRUQ84s=\u003c/ds:X509Certificate\u003e\n\t\t\t\t\u003c/ds:X509Data\u003e\n\t\t\t\u003c/ds:KeyInfo\u003e\n\t\t\u003c/md:KeyDescriptor\u003e\n\t\t\u003cmd:NameIDFormat\u003eurn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\u003c/md:NameIDFormat\u003e\n        \u003cmd:AssertionConsumerService Binding=\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\" Location=\"https://localhost/acs/saml/\" index=\"1\"/\u003e\n    \u003c/md:SPSSODescriptor\u003e\n\u003c/md:EntityDescriptor\u003e\n`),\n\t\t}, nil)\n\t\t_, err = saml.NewClient(ctx, \"saml_client\", \u0026saml.ClientArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tClientId: samlClient.ApplyT(func(samlClient keycloak.GetClientDescriptionConverterResult) (*string, error) {\n\t\t\t\treturn \u0026samlClient.ClientId, nil\n\t\t\t}).(pulumi.StringPtrOutput),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.KeycloakFunctions;\nimport com.pulumi.keycloak.inputs.GetClientDescriptionConverterArgs;\nimport com.pulumi.keycloak.saml.Client;\nimport com.pulumi.keycloak.saml.ClientArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        final var samlClient = KeycloakFunctions.getClientDescriptionConverter(GetClientDescriptionConverterArgs.builder()\n            .realmId(realm.id())\n            .body(\"\"\"\n\t\u003cmd:EntityDescriptor xmlns:md=\"urn:oasis:names:tc:SAML:2.0:metadata\" validUntil=\"2021-04-17T12:41:46Z\" cacheDuration=\"PT604800S\" entityID=\"FakeEntityId\"\u003e\n    \u003cmd:SPSSODescriptor AuthnRequestsSigned=\"false\" WantAssertionsSigned=\"false\" protocolSupportEnumeration=\"urn:oasis:names:tc:SAML:2.0:protocol\"\u003e\n        \u003cmd:KeyDescriptor use=\"signing\"\u003e\n\t\t\t\u003cds:KeyInfo xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\u003e\n\t\t\t\t\u003cds:X509Data\u003e\n\t\t\t\t\t\u003cds:X509Certificate\u003eMIICyDCCAjGgAwIBAgIBADANBgkqhkiG9w0BAQ0FADCBgDELMAkGA1UEBhMCdXMx\n\t\t\t\t\tCzAJBgNVBAgMAklBMSQwIgYDVQQKDBt0ZXJyYWZvcm0tcHJvdmlkZXIta2V5Y2xv\n\t\t\t\t\tYWsxHDAaBgNVBAMME21ycGFya2Vycy5naXRodWIuaW8xIDAeBgkqhkiG9w0BCQEW\n\t\t\t\t\tEW1pY2hhZWxAcGFya2VyLmdnMB4XDTE5MDEwODE0NDYzNloXDTI5MDEwNTE0NDYz\n\t\t\t\t\tNlowgYAxCzAJBgNVBAYTAnVzMQswCQYDVQQIDAJJQTEkMCIGA1UECgwbdGVycmFm\n\t\t\t\t\tb3JtLXByb3ZpZGVyLWtleWNsb2FrMRwwGgYDVQQDDBNtcnBhcmtlcnMuZ2l0aHVi\n\t\t\t\t\tLmlvMSAwHgYJKoZIhvcNAQkBFhFtaWNoYWVsQHBhcmtlci5nZzCBnzANBgkqhkiG\n\t\t\t\t\t9w0BAQEFAAOBjQAwgYkCgYEAxuZny7uyYxGVPtpie14gNQC4tT9sAvO2sVNDhuoe\n\t\t\t\t\tqIKLRpNwkHnwQmwe5OxSh9K0BPHp/DNuuVWUqvo4tniEYn3jBr7FwLYLTKojQIxj\n\t\t\t\t\t53S1UTT9EXq3eP5HsHMD0QnTuca2nlNYUDBm6ud2fQj0Jt5qLx86EbEC28N56IRv\n\t\t\t\t\tGX8CAwEAAaNQME4wHQYDVR0OBBYEFMLnbQh77j7vhGTpAhKpDhCrBsPZMB8GA1Ud\n\t\t\t\t\tIwQYMBaAFMLnbQh77j7vhGTpAhKpDhCrBsPZMAwGA1UdEwQFMAMBAf8wDQYJKoZI\n\t\t\t\t\thvcNAQENBQADgYEAB8wGrAQY0pAfwbnYSyBt4STbebeRTu1/q1ucfrtc3qsegcd5\n\t\t\t\t\tn01xTR+T2uZJwqHFPpFjr4IPORiHx3+4BWCweslPD53qBjKUPXcbMO1Revjef6Tj\n\t\t\t\t\tK3K0AuJ94fxgXVoT61Nzu/a6Lj6RhzU/Dao9mlSbJY+YSbm+ZBpsuRUQ84s=\u003c/ds:X509Certificate\u003e\n\t\t\t\t\u003c/ds:X509Data\u003e\n\t\t\t\u003c/ds:KeyInfo\u003e\n\t\t\u003c/md:KeyDescriptor\u003e\n\t\t\u003cmd:NameIDFormat\u003eurn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\u003c/md:NameIDFormat\u003e\n        \u003cmd:AssertionConsumerService Binding=\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\" Location=\"https://localhost/acs/saml/\" index=\"1\"/\u003e\n    \u003c/md:SPSSODescriptor\u003e\n\u003c/md:EntityDescriptor\u003e\n            \"\"\")\n            .build());\n\n        var samlClientClient = new Client(\"samlClientClient\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(samlClient.applyValue(getClientDescriptionConverterResult -\u003e getClientDescriptionConverterResult).applyValue(samlClient -\u003e samlClient.applyValue(getClientDescriptionConverterResult -\u003e getClientDescriptionConverterResult.clientId())))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  samlClientClient:\n    type: keycloak:saml:Client\n    name: saml_client\n    properties:\n      realmId: ${realm.id}\n      clientId: ${samlClient.clientId}\nvariables:\n  samlClient:\n    fn::invoke:\n      Function: keycloak:getClientDescriptionConverter\n      Arguments:\n        realmId: ${realm.id}\n        body: |\n          \t\u003cmd:EntityDescriptor xmlns:md=\"urn:oasis:names:tc:SAML:2.0:metadata\" validUntil=\"2021-04-17T12:41:46Z\" cacheDuration=\"PT604800S\" entityID=\"FakeEntityId\"\u003e\n              \u003cmd:SPSSODescriptor AuthnRequestsSigned=\"false\" WantAssertionsSigned=\"false\" protocolSupportEnumeration=\"urn:oasis:names:tc:SAML:2.0:protocol\"\u003e\n                  \u003cmd:KeyDescriptor use=\"signing\"\u003e\n          \t\t\t\u003cds:KeyInfo xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\u003e\n          \t\t\t\t\u003cds:X509Data\u003e\n          \t\t\t\t\t\u003cds:X509Certificate\u003eMIICyDCCAjGgAwIBAgIBADANBgkqhkiG9w0BAQ0FADCBgDELMAkGA1UEBhMCdXMx\n          \t\t\t\t\tCzAJBgNVBAgMAklBMSQwIgYDVQQKDBt0ZXJyYWZvcm0tcHJvdmlkZXIta2V5Y2xv\n          \t\t\t\t\tYWsxHDAaBgNVBAMME21ycGFya2Vycy5naXRodWIuaW8xIDAeBgkqhkiG9w0BCQEW\n          \t\t\t\t\tEW1pY2hhZWxAcGFya2VyLmdnMB4XDTE5MDEwODE0NDYzNloXDTI5MDEwNTE0NDYz\n          \t\t\t\t\tNlowgYAxCzAJBgNVBAYTAnVzMQswCQYDVQQIDAJJQTEkMCIGA1UECgwbdGVycmFm\n          \t\t\t\t\tb3JtLXByb3ZpZGVyLWtleWNsb2FrMRwwGgYDVQQDDBNtcnBhcmtlcnMuZ2l0aHVi\n          \t\t\t\t\tLmlvMSAwHgYJKoZIhvcNAQkBFhFtaWNoYWVsQHBhcmtlci5nZzCBnzANBgkqhkiG\n          \t\t\t\t\t9w0BAQEFAAOBjQAwgYkCgYEAxuZny7uyYxGVPtpie14gNQC4tT9sAvO2sVNDhuoe\n          \t\t\t\t\tqIKLRpNwkHnwQmwe5OxSh9K0BPHp/DNuuVWUqvo4tniEYn3jBr7FwLYLTKojQIxj\n          \t\t\t\t\t53S1UTT9EXq3eP5HsHMD0QnTuca2nlNYUDBm6ud2fQj0Jt5qLx86EbEC28N56IRv\n          \t\t\t\t\tGX8CAwEAAaNQME4wHQYDVR0OBBYEFMLnbQh77j7vhGTpAhKpDhCrBsPZMB8GA1Ud\n          \t\t\t\t\tIwQYMBaAFMLnbQh77j7vhGTpAhKpDhCrBsPZMAwGA1UdEwQFMAMBAf8wDQYJKoZI\n          \t\t\t\t\thvcNAQENBQADgYEAB8wGrAQY0pAfwbnYSyBt4STbebeRTu1/q1ucfrtc3qsegcd5\n          \t\t\t\t\tn01xTR+T2uZJwqHFPpFjr4IPORiHx3+4BWCweslPD53qBjKUPXcbMO1Revjef6Tj\n          \t\t\t\t\tK3K0AuJ94fxgXVoT61Nzu/a6Lj6RhzU/Dao9mlSbJY+YSbm+ZBpsuRUQ84s=\u003c/ds:X509Certificate\u003e\n          \t\t\t\t\u003c/ds:X509Data\u003e\n          \t\t\t\u003c/ds:KeyInfo\u003e\n          \t\t\u003c/md:KeyDescriptor\u003e\n          \t\t\u003cmd:NameIDFormat\u003eurn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\u003c/md:NameIDFormat\u003e\n                  \u003cmd:AssertionConsumerService Binding=\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\" Location=\"https://localhost/acs/saml/\" index=\"1\"/\u003e\n              \u003c/md:SPSSODescriptor\u003e\n          \u003c/md:EntityDescriptor\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getClientDescriptionConverter.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The body of the request to convert.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm to use for the client description converter API call.\n"
                    }
                },
                "type": "object",
                "required": [
                    "body",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClientDescriptionConverter.\n",
                "properties": {
                    "access": {
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "type": "object"
                    },
                    "adminUrl": {
                        "type": "string"
                    },
                    "attributes": {
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "type": "object"
                    },
                    "authenticationFlowBindingOverrides": {
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "type": "object"
                    },
                    "authorizationServicesEnabled": {
                        "type": "boolean"
                    },
                    "authorizationSettings": {
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "type": "object"
                    },
                    "baseUrl": {
                        "type": "string"
                    },
                    "bearerOnly": {
                        "type": "boolean"
                    },
                    "body": {
                        "type": "string"
                    },
                    "clientAuthenticatorType": {
                        "type": "string"
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "consentRequired": {
                        "type": "string"
                    },
                    "defaultClientScopes": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "defaultRoles": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "description": {
                        "type": "string"
                    },
                    "directAccessGrantsEnabled": {
                        "type": "boolean"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "frontchannelLogout": {
                        "type": "boolean"
                    },
                    "fullScopeAllowed": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "implicitFlowEnabled": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "notBefore": {
                        "type": "integer"
                    },
                    "optionalClientScopes": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "origin": {
                        "type": "string"
                    },
                    "protocol": {
                        "type": "string"
                    },
                    "protocolMappers": {
                        "items": {
                            "$ref": "#/types/keycloak:index/getClientDescriptionConverterProtocolMapper:getClientDescriptionConverterProtocolMapper"
                        },
                        "type": "array"
                    },
                    "publicClient": {
                        "type": "boolean"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "redirectUris": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "registeredNodes": {
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "type": "object"
                    },
                    "registrationAccessToken": {
                        "type": "string"
                    },
                    "rootUrl": {
                        "type": "string"
                    },
                    "secret": {
                        "type": "string"
                    },
                    "serviceAccountsEnabled": {
                        "type": "boolean"
                    },
                    "standardFlowEnabled": {
                        "type": "boolean"
                    },
                    "surrogateAuthRequired": {
                        "type": "boolean"
                    },
                    "webOrigins": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "access",
                    "adminUrl",
                    "attributes",
                    "authenticationFlowBindingOverrides",
                    "authorizationServicesEnabled",
                    "authorizationSettings",
                    "baseUrl",
                    "bearerOnly",
                    "body",
                    "clientAuthenticatorType",
                    "clientId",
                    "consentRequired",
                    "defaultClientScopes",
                    "defaultRoles",
                    "description",
                    "directAccessGrantsEnabled",
                    "enabled",
                    "frontchannelLogout",
                    "fullScopeAllowed",
                    "implicitFlowEnabled",
                    "name",
                    "notBefore",
                    "optionalClientScopes",
                    "origin",
                    "protocol",
                    "protocolMappers",
                    "publicClient",
                    "realmId",
                    "redirectUris",
                    "registeredNodes",
                    "registrationAccessToken",
                    "rootUrl",
                    "secret",
                    "serviceAccountsEnabled",
                    "standardFlowEnabled",
                    "surrogateAuthRequired",
                    "webOrigins",
                    "id"
                ],
                "type": "object"
            }
        },
        "keycloak:index/getGroup:getGroup": {
            "description": "## # keycloak.Group data source\n\nThis data source can be used to fetch properties of a Keycloak group for\nusage with other resources, such as `keycloak.GroupRoles`.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  groupRoles:\n    type: keycloak:GroupRoles\n    name: group_roles\n    properties:\n      realmId: ${realm.id}\n      groupId: ${group.id}\n      roles:\n        - ${offlineAccess.id}\nvariables:\n  offlineAccess:\n    fn::invoke:\n      Function: keycloak:getRole\n      Arguments:\n        realmId: ${realm.id}\n        name: offline_access\n  group:\n    fn::invoke:\n      Function: keycloak:getGroup\n      Arguments:\n        realmId: ${realm.id}\n        name: group\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this group exists within.\n- `name` - (Required) The name of the group\n\n### Attributes Reference\n\nIn addition to the arguments listed above, the following computed attributes are exported:\n\n- `id` - The unique ID of the group, which can be used as an argument to\n  other resources supported by this provider.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGroup.\n",
                "properties": {
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroup.\n",
                "properties": {
                    "attributes": {
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "type": "object"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "parentId": {
                        "type": "string"
                    },
                    "path": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "required": [
                    "attributes",
                    "name",
                    "parentId",
                    "path",
                    "realmId",
                    "id"
                ],
                "type": "object"
            }
        },
        "keycloak:index/getRealm:getRealm": {
            "description": "## # keycloak.Realm data source\n\nThis data source can be used to fetch properties of a Keycloak realm for\nusage with other resources.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = keycloak.getRealm({\n    realm: \"my-realm\",\n});\n// use the data source\nconst group = new keycloak.Role(\"group\", {\n    realmId: id,\n    name: \"group\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.get_realm(realm=\"my-realm\")\n# use the data source\ngroup = keycloak.Role(\"group\",\n    realm_id=id,\n    name=\"group\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = Keycloak.GetRealm.Invoke(new()\n    {\n        Realm = \"my-realm\",\n    });\n\n    // use the data source\n    var @group = new Keycloak.Role(\"group\", new()\n    {\n        RealmId = id,\n        Name = \"group\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := keycloak.LookupRealm(ctx, \u0026keycloak.LookupRealmArgs{\n\t\t\tRealm: \"my-realm\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// use the data source\n\t\t_, err = keycloak.NewRole(ctx, \"group\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: pulumi.Any(id),\n\t\t\tName:    pulumi.String(\"group\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.KeycloakFunctions;\nimport com.pulumi.keycloak.inputs.GetRealmArgs;\nimport com.pulumi.keycloak.Role;\nimport com.pulumi.keycloak.RoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var realm = KeycloakFunctions.getRealm(GetRealmArgs.builder()\n            .realm(\"my-realm\")\n            .build());\n\n        // use the data source\n        var group = new Role(\"group\", RoleArgs.builder()\n            .realmId(id)\n            .name(\"group\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # use the data source\n  group:\n    type: keycloak:Role\n    properties:\n      realmId: ${id}\n      name: group\nvariables:\n  realm:\n    fn::invoke:\n      Function: keycloak:getRealm\n      Arguments:\n        realm: my-realm\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm` - (Required) The realm name.\n\n### Attributes Reference\n\nSee the docs for the `keycloak.Realm` resource for details on the exported attributes.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRealm.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "defaultDefaultClientScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "defaultOptionalClientScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "displayNameHtml": {
                        "type": "string"
                    },
                    "internationalizations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmInternationalization:getRealmInternationalization"
                        }
                    },
                    "otpPolicy": {
                        "$ref": "#/types/keycloak:index/getRealmOtpPolicy:getRealmOtpPolicy"
                    },
                    "realm": {
                        "type": "string"
                    },
                    "securityDefenses": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmSecurityDefense:getRealmSecurityDefense"
                        }
                    },
                    "smtpServers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmSmtpServer:getRealmSmtpServer"
                        }
                    },
                    "webAuthnPasswordlessPolicy": {
                        "$ref": "#/types/keycloak:index/getRealmWebAuthnPasswordlessPolicy:getRealmWebAuthnPasswordlessPolicy"
                    },
                    "webAuthnPolicy": {
                        "$ref": "#/types/keycloak:index/getRealmWebAuthnPolicy:getRealmWebAuthnPolicy"
                    }
                },
                "type": "object",
                "required": [
                    "realm"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRealm.\n",
                "properties": {
                    "accessCodeLifespan": {
                        "type": "string"
                    },
                    "accessCodeLifespanLogin": {
                        "type": "string"
                    },
                    "accessCodeLifespanUserAction": {
                        "type": "string"
                    },
                    "accessTokenLifespan": {
                        "type": "string"
                    },
                    "accessTokenLifespanForImplicitFlow": {
                        "type": "string"
                    },
                    "accountTheme": {
                        "type": "string"
                    },
                    "actionTokenGeneratedByAdminLifespan": {
                        "type": "string"
                    },
                    "actionTokenGeneratedByUserLifespan": {
                        "type": "string"
                    },
                    "adminTheme": {
                        "type": "string"
                    },
                    "attributes": {
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "type": "object"
                    },
                    "browserFlow": {
                        "type": "string"
                    },
                    "clientAuthenticationFlow": {
                        "type": "string"
                    },
                    "clientSessionIdleTimeout": {
                        "type": "string"
                    },
                    "clientSessionMaxLifespan": {
                        "type": "string"
                    },
                    "defaultDefaultClientScopes": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "defaultOptionalClientScopes": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "defaultSignatureAlgorithm": {
                        "type": "string"
                    },
                    "directGrantFlow": {
                        "type": "string"
                    },
                    "displayName": {
                        "type": "string"
                    },
                    "displayNameHtml": {
                        "type": "string"
                    },
                    "dockerAuthenticationFlow": {
                        "type": "string"
                    },
                    "duplicateEmailsAllowed": {
                        "type": "boolean"
                    },
                    "editUsernameAllowed": {
                        "type": "boolean"
                    },
                    "emailTheme": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "internalId": {
                        "type": "string"
                    },
                    "internationalizations": {
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmInternationalization:getRealmInternationalization"
                        },
                        "type": "array"
                    },
                    "loginTheme": {
                        "type": "string"
                    },
                    "loginWithEmailAllowed": {
                        "type": "boolean"
                    },
                    "oauth2DeviceCodeLifespan": {
                        "type": "string"
                    },
                    "oauth2DevicePollingInterval": {
                        "type": "integer"
                    },
                    "offlineSessionIdleTimeout": {
                        "type": "string"
                    },
                    "offlineSessionMaxLifespan": {
                        "type": "string"
                    },
                    "offlineSessionMaxLifespanEnabled": {
                        "type": "boolean"
                    },
                    "otpPolicy": {
                        "$ref": "#/types/keycloak:index/getRealmOtpPolicy:getRealmOtpPolicy"
                    },
                    "passwordPolicy": {
                        "type": "string"
                    },
                    "realm": {
                        "type": "string"
                    },
                    "refreshTokenMaxReuse": {
                        "type": "integer"
                    },
                    "registrationAllowed": {
                        "type": "boolean"
                    },
                    "registrationEmailAsUsername": {
                        "type": "boolean"
                    },
                    "registrationFlow": {
                        "type": "string"
                    },
                    "rememberMe": {
                        "type": "boolean"
                    },
                    "resetCredentialsFlow": {
                        "type": "string"
                    },
                    "resetPasswordAllowed": {
                        "type": "boolean"
                    },
                    "revokeRefreshToken": {
                        "type": "boolean"
                    },
                    "securityDefenses": {
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmSecurityDefense:getRealmSecurityDefense"
                        },
                        "type": "array"
                    },
                    "smtpServers": {
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmSmtpServer:getRealmSmtpServer"
                        },
                        "type": "array"
                    },
                    "sslRequired": {
                        "type": "string"
                    },
                    "ssoSessionIdleTimeout": {
                        "type": "string"
                    },
                    "ssoSessionIdleTimeoutRememberMe": {
                        "type": "string"
                    },
                    "ssoSessionMaxLifespan": {
                        "type": "string"
                    },
                    "ssoSessionMaxLifespanRememberMe": {
                        "type": "string"
                    },
                    "userManagedAccess": {
                        "type": "boolean"
                    },
                    "verifyEmail": {
                        "type": "boolean"
                    },
                    "webAuthnPasswordlessPolicy": {
                        "$ref": "#/types/keycloak:index/getRealmWebAuthnPasswordlessPolicy:getRealmWebAuthnPasswordlessPolicy"
                    },
                    "webAuthnPolicy": {
                        "$ref": "#/types/keycloak:index/getRealmWebAuthnPolicy:getRealmWebAuthnPolicy"
                    }
                },
                "required": [
                    "accessCodeLifespan",
                    "accessCodeLifespanLogin",
                    "accessCodeLifespanUserAction",
                    "accessTokenLifespan",
                    "accessTokenLifespanForImplicitFlow",
                    "accountTheme",
                    "actionTokenGeneratedByAdminLifespan",
                    "actionTokenGeneratedByUserLifespan",
                    "adminTheme",
                    "attributes",
                    "browserFlow",
                    "clientAuthenticationFlow",
                    "clientSessionIdleTimeout",
                    "clientSessionMaxLifespan",
                    "defaultDefaultClientScopes",
                    "defaultOptionalClientScopes",
                    "defaultSignatureAlgorithm",
                    "directGrantFlow",
                    "displayName",
                    "dockerAuthenticationFlow",
                    "duplicateEmailsAllowed",
                    "editUsernameAllowed",
                    "emailTheme",
                    "enabled",
                    "internalId",
                    "internationalizations",
                    "loginTheme",
                    "loginWithEmailAllowed",
                    "oauth2DeviceCodeLifespan",
                    "oauth2DevicePollingInterval",
                    "offlineSessionIdleTimeout",
                    "offlineSessionMaxLifespan",
                    "offlineSessionMaxLifespanEnabled",
                    "otpPolicy",
                    "passwordPolicy",
                    "realm",
                    "refreshTokenMaxReuse",
                    "registrationAllowed",
                    "registrationEmailAsUsername",
                    "registrationFlow",
                    "rememberMe",
                    "resetCredentialsFlow",
                    "resetPasswordAllowed",
                    "revokeRefreshToken",
                    "securityDefenses",
                    "smtpServers",
                    "sslRequired",
                    "ssoSessionIdleTimeout",
                    "ssoSessionIdleTimeoutRememberMe",
                    "ssoSessionMaxLifespan",
                    "ssoSessionMaxLifespanRememberMe",
                    "userManagedAccess",
                    "verifyEmail",
                    "webAuthnPasswordlessPolicy",
                    "webAuthnPolicy",
                    "id"
                ],
                "type": "object"
            }
        },
        "keycloak:index/getRealmKeys:getRealmKeys": {
            "description": "## # keycloak.getRealmKeys data source\n\nUse this data source to get the keys of a realm. Keys can be filtered by algorithm and status.\n\nRemarks:\n\n- A key must meet all filter criteria\n- This datasource may return more than one value.\n- If no key matches the filter criteria, then an error is returned.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRealmKeys.\n",
                "properties": {
                    "algorithms": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "statuses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRealmKeys.\n",
                "properties": {
                    "algorithms": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "keys": {
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmKeysKey:getRealmKeysKey"
                        },
                        "type": "array"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "statuses": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "keys",
                    "realmId",
                    "id"
                ],
                "type": "object"
            }
        },
        "keycloak:index/getRole:getRole": {
            "description": "## # keycloak.Role data source\n\nThis data source can be used to fetch properties of a Keycloak role for\nusage with other resources, such as `keycloak.GroupRoles`.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  # use the data source\n  group:\n    type: keycloak:Group\n    properties:\n      realmId: ${realm.id}\n      name: group\n  groupRoles:\n    type: keycloak:GroupRoles\n    name: group_roles\n    properties:\n      realmId: ${realm.id}\n      groupId: ${group.id}\n      roles:\n        - ${offlineAccess.id}\nvariables:\n  offlineAccess:\n    fn::invoke:\n      Function: keycloak:getRole\n      Arguments:\n        realmId: ${realm.id}\n        name: offline_access\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm this role exists within.\n- `client_id` - (Optional) When specified, this role is assumed to be a\n  client role belonging to the client with the provided ID\n- `name` - (Required) The name of the role\n  \n### Attributes Reference\n\nIn addition to the arguments listed above, the following computed attributes are exported:\n\n- `id` - The unique ID of the role, which can be used as an argument to\n  other resources supported by this provider.\n- `description` - The description of the role.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRole.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRole.\n",
                "properties": {
                    "attributes": {
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "type": "object"
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "compositeRoles": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "required": [
                    "attributes",
                    "compositeRoles",
                    "description",
                    "name",
                    "realmId",
                    "id"
                ],
                "type": "object"
            }
        },
        "keycloak:index/getUser:getUser": {
            "description": "This data source can be used to fetch properties of a user within Keycloak.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst masterRealm = keycloak.getRealm({\n    realm: \"master\",\n});\n// use the keycloak_user data source to grab the admin user's ID\nconst defaultAdminUser = masterRealm.then(masterRealm =\u003e keycloak.getUser({\n    realmId: masterRealm.id,\n    username: \"keycloak\",\n}));\nexport const keycloakUserId = defaultAdminUser.then(defaultAdminUser =\u003e defaultAdminUser.id);\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nmaster_realm = keycloak.get_realm(realm=\"master\")\n# use the keycloak_user data source to grab the admin user's ID\ndefault_admin_user = keycloak.get_user(realm_id=master_realm.id,\n    username=\"keycloak\")\npulumi.export(\"keycloakUserId\", default_admin_user.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var masterRealm = Keycloak.GetRealm.Invoke(new()\n    {\n        Realm = \"master\",\n    });\n\n    // use the keycloak_user data source to grab the admin user's ID\n    var defaultAdminUser = Keycloak.GetUser.Invoke(new()\n    {\n        RealmId = masterRealm.Apply(getRealmResult =\u003e getRealmResult.Id),\n        Username = \"keycloak\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"keycloakUserId\"] = defaultAdminUser.Apply(getUserResult =\u003e getUserResult.Id),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmasterRealm, err := keycloak.LookupRealm(ctx, \u0026keycloak.LookupRealmArgs{\n\t\t\tRealm: \"master\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// use the keycloak_user data source to grab the admin user's ID\n\t\tdefaultAdminUser, err := keycloak.LookupUser(ctx, \u0026keycloak.LookupUserArgs{\n\t\t\tRealmId:  masterRealm.Id,\n\t\t\tUsername: \"keycloak\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"keycloakUserId\", defaultAdminUser.Id)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.KeycloakFunctions;\nimport com.pulumi.keycloak.inputs.GetRealmArgs;\nimport com.pulumi.keycloak.inputs.GetUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var masterRealm = KeycloakFunctions.getRealm(GetRealmArgs.builder()\n            .realm(\"master\")\n            .build());\n\n        // use the keycloak_user data source to grab the admin user's ID\n        final var defaultAdminUser = KeycloakFunctions.getUser(GetUserArgs.builder()\n            .realmId(masterRealm.applyValue(getRealmResult -\u003e getRealmResult.id()))\n            .username(\"keycloak\")\n            .build());\n\n        ctx.export(\"keycloakUserId\", defaultAdminUser.applyValue(getUserResult -\u003e getUserResult.id()));\n    }\n}\n```\n```yaml\nvariables:\n  masterRealm:\n    fn::invoke:\n      Function: keycloak:getRealm\n      Arguments:\n        realm: master\n  # use the keycloak_user data source to grab the admin user's ID\n  defaultAdminUser:\n    fn::invoke:\n      Function: keycloak:getUser\n      Arguments:\n        realmId: ${masterRealm.id}\n        username: keycloak\noutputs:\n  keycloakUserId: ${defaultAdminUser.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getUser.\n",
                "properties": {
                    "realmId": {
                        "type": "string",
                        "description": "The realm this user belongs to.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The unique username of this user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "realmId",
                    "username"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getUser.\n",
                "properties": {
                    "attributes": {
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "(Computed) A map representing attributes for the user\n",
                        "type": "object"
                    },
                    "email": {
                        "description": "(Computed) The user's email.\n",
                        "type": "string"
                    },
                    "emailVerified": {
                        "description": "(Computed) Whether the email address was validated or not. Default to `false`.\n",
                        "type": "boolean"
                    },
                    "enabled": {
                        "description": "(Computed) When false, this user cannot log in. Defaults to `true`.\n",
                        "type": "boolean"
                    },
                    "federatedIdentities": {
                        "description": "(Computed) The user's federated identities, if applicable. This block has the following schema:\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "firstName": {
                        "description": "(Computed) The user's first name.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "lastName": {
                        "description": "(Computed) The user's last name.\n",
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "requiredActions": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "required": [
                    "attributes",
                    "email",
                    "emailVerified",
                    "enabled",
                    "federatedIdentities",
                    "firstName",
                    "lastName",
                    "realmId",
                    "requiredActions",
                    "username",
                    "id"
                ],
                "type": "object"
            }
        },
        "keycloak:index/getUserRealmRoles:getUserRealmRoles": {
            "description": "This data source can be used to fetch the realm roles of a user within Keycloak.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst masterRealm = keycloak.getRealm({\n    realm: \"master\",\n});\n// use the keycloak_user data source to grab the admin user's ID\nconst defaultAdminUser = masterRealm.then(masterRealm =\u003e keycloak.getUser({\n    realmId: masterRealm.id,\n    username: \"keycloak\",\n}));\n// use the keycloak_user_realm_roles data source to list role names\nconst userRealmRoles = Promise.all([masterRealm, defaultAdminUser]).then(([masterRealm, defaultAdminUser]) =\u003e keycloak.getUserRealmRoles({\n    realmId: masterRealm.id,\n    userId: defaultAdminUser.id,\n}));\nexport const keycloakUserRoleNames = userRealmRoles.then(userRealmRoles =\u003e userRealmRoles.roleNames);\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nmaster_realm = keycloak.get_realm(realm=\"master\")\n# use the keycloak_user data source to grab the admin user's ID\ndefault_admin_user = keycloak.get_user(realm_id=master_realm.id,\n    username=\"keycloak\")\n# use the keycloak_user_realm_roles data source to list role names\nuser_realm_roles = keycloak.get_user_realm_roles(realm_id=master_realm.id,\n    user_id=default_admin_user.id)\npulumi.export(\"keycloakUserRoleNames\", user_realm_roles.role_names)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var masterRealm = Keycloak.GetRealm.Invoke(new()\n    {\n        Realm = \"master\",\n    });\n\n    // use the keycloak_user data source to grab the admin user's ID\n    var defaultAdminUser = Keycloak.GetUser.Invoke(new()\n    {\n        RealmId = masterRealm.Apply(getRealmResult =\u003e getRealmResult.Id),\n        Username = \"keycloak\",\n    });\n\n    // use the keycloak_user_realm_roles data source to list role names\n    var userRealmRoles = Keycloak.GetUserRealmRoles.Invoke(new()\n    {\n        RealmId = masterRealm.Apply(getRealmResult =\u003e getRealmResult.Id),\n        UserId = defaultAdminUser.Apply(getUserResult =\u003e getUserResult.Id),\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"keycloakUserRoleNames\"] = userRealmRoles.Apply(getUserRealmRolesResult =\u003e getUserRealmRolesResult.RoleNames),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmasterRealm, err := keycloak.LookupRealm(ctx, \u0026keycloak.LookupRealmArgs{\n\t\t\tRealm: \"master\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// use the keycloak_user data source to grab the admin user's ID\n\t\tdefaultAdminUser, err := keycloak.LookupUser(ctx, \u0026keycloak.LookupUserArgs{\n\t\t\tRealmId:  masterRealm.Id,\n\t\t\tUsername: \"keycloak\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// use the keycloak_user_realm_roles data source to list role names\n\t\tuserRealmRoles, err := keycloak.GetUserRealmRoles(ctx, \u0026keycloak.GetUserRealmRolesArgs{\n\t\t\tRealmId: masterRealm.Id,\n\t\t\tUserId:  defaultAdminUser.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"keycloakUserRoleNames\", userRealmRoles.RoleNames)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.KeycloakFunctions;\nimport com.pulumi.keycloak.inputs.GetRealmArgs;\nimport com.pulumi.keycloak.inputs.GetUserArgs;\nimport com.pulumi.keycloak.inputs.GetUserRealmRolesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var masterRealm = KeycloakFunctions.getRealm(GetRealmArgs.builder()\n            .realm(\"master\")\n            .build());\n\n        // use the keycloak_user data source to grab the admin user's ID\n        final var defaultAdminUser = KeycloakFunctions.getUser(GetUserArgs.builder()\n            .realmId(masterRealm.applyValue(getRealmResult -\u003e getRealmResult.id()))\n            .username(\"keycloak\")\n            .build());\n\n        // use the keycloak_user_realm_roles data source to list role names\n        final var userRealmRoles = KeycloakFunctions.getUserRealmRoles(GetUserRealmRolesArgs.builder()\n            .realmId(masterRealm.applyValue(getRealmResult -\u003e getRealmResult.id()))\n            .userId(defaultAdminUser.applyValue(getUserResult -\u003e getUserResult.id()))\n            .build());\n\n        ctx.export(\"keycloakUserRoleNames\", userRealmRoles.applyValue(getUserRealmRolesResult -\u003e getUserRealmRolesResult.roleNames()));\n    }\n}\n```\n```yaml\nvariables:\n  masterRealm:\n    fn::invoke:\n      Function: keycloak:getRealm\n      Arguments:\n        realm: master\n  # use the keycloak_user data source to grab the admin user's ID\n  defaultAdminUser:\n    fn::invoke:\n      Function: keycloak:getUser\n      Arguments:\n        realmId: ${masterRealm.id}\n        username: keycloak\n  # use the keycloak_user_realm_roles data source to list role names\n  userRealmRoles:\n    fn::invoke:\n      Function: keycloak:getUserRealmRoles\n      Arguments:\n        realmId: ${masterRealm.id}\n        userId: ${defaultAdminUser.id}\noutputs:\n  keycloakUserRoleNames: ${userRealmRoles.roleNames}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getUserRealmRoles.\n",
                "properties": {
                    "realmId": {
                        "type": "string",
                        "description": "The realm this user belongs to.\n"
                    },
                    "userId": {
                        "type": "string",
                        "description": "The ID of the user to query realm roles for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "realmId",
                    "userId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getUserRealmRoles.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "roleNames": {
                        "description": "(Computed) A list of realm roles that belong to this user.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "userId": {
                        "type": "string"
                    }
                },
                "required": [
                    "realmId",
                    "roleNames",
                    "userId",
                    "id"
                ],
                "type": "object"
            }
        },
        "keycloak:openid/getClient:getClient": {
            "description": "## # keycloak.openid.Client data source\n\nThis data source can be used to fetch properties of a Keycloak OpenID client for usage with other resources.\n\n### Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realmManagement = keycloak.openid.getClient({\n    realmId: \"my-realm\",\n    clientId: \"realm-management\",\n});\n// use the data source\nconst admin = realmManagement.then(realmManagement =\u003e keycloak.getRole({\n    realmId: \"my-realm\",\n    clientId: realmManagement.id,\n    name: \"realm-admin\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm_management = keycloak.openid.get_client(realm_id=\"my-realm\",\n    client_id=\"realm-management\")\n# use the data source\nadmin = keycloak.get_role(realm_id=\"my-realm\",\n    client_id=realm_management.id,\n    name=\"realm-admin\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realmManagement = Keycloak.OpenId.GetClient.Invoke(new()\n    {\n        RealmId = \"my-realm\",\n        ClientId = \"realm-management\",\n    });\n\n    // use the data source\n    var admin = Keycloak.GetRole.Invoke(new()\n    {\n        RealmId = \"my-realm\",\n        ClientId = realmManagement.Apply(getClientResult =\u003e getClientResult.Id),\n        Name = \"realm-admin\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealmManagement, err := openid.LookupClient(ctx, \u0026openid.LookupClientArgs{\n\t\t\tRealmId:  \"my-realm\",\n\t\t\tClientId: \"realm-management\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// use the data source\n\t\t_, err = keycloak.LookupRole(ctx, \u0026keycloak.LookupRoleArgs{\n\t\t\tRealmId:  \"my-realm\",\n\t\t\tClientId: pulumi.StringRef(realmManagement.Id),\n\t\t\tName:     \"realm-admin\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.openid.OpenidFunctions;\nimport com.pulumi.keycloak.openid.inputs.GetClientArgs;\nimport com.pulumi.keycloak.KeycloakFunctions;\nimport com.pulumi.keycloak.inputs.GetRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var realmManagement = OpenidFunctions.getClient(GetClientArgs.builder()\n            .realmId(\"my-realm\")\n            .clientId(\"realm-management\")\n            .build());\n\n        // use the data source\n        final var admin = KeycloakFunctions.getRole(GetRoleArgs.builder()\n            .realmId(\"my-realm\")\n            .clientId(realmManagement.applyValue(getClientResult -\u003e getClientResult.id()))\n            .name(\"realm-admin\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  realmManagement:\n    fn::invoke:\n      Function: keycloak:openid:getClient\n      Arguments:\n        realmId: my-realm\n        clientId: realm-management\n  # use the data source\n  admin:\n    fn::invoke:\n      Function: keycloak:getRole\n      Arguments:\n        realmId: my-realm\n        clientId: ${realmManagement.id}\n        name: realm-admin\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Argument Reference\n\nThe following arguments are supported:\n\n- `realm_id` - (Required) The realm id.\n- `client_id` - (Required) The client id.\n\n### Attributes Reference\n\nSee the docs for the `keycloak.openid.Client` resource for details on the exported attributes.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getClient.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "consentScreenText": {
                        "type": "string"
                    },
                    "displayOnConsentScreen": {
                        "type": "boolean"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "oauth2DeviceAuthorizationGrantEnabled": {
                        "type": "boolean"
                    },
                    "oauth2DeviceCodeLifespan": {
                        "type": "string"
                    },
                    "oauth2DevicePollingInterval": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clientId",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClient.\n",
                "properties": {
                    "accessTokenLifespan": {
                        "type": "string"
                    },
                    "accessType": {
                        "type": "string"
                    },
                    "adminUrl": {
                        "type": "string"
                    },
                    "authenticationFlowBindingOverrides": {
                        "items": {
                            "$ref": "#/types/keycloak:openid/getClientAuthenticationFlowBindingOverride:getClientAuthenticationFlowBindingOverride"
                        },
                        "type": "array"
                    },
                    "authorizations": {
                        "items": {
                            "$ref": "#/types/keycloak:openid/getClientAuthorization:getClientAuthorization"
                        },
                        "type": "array"
                    },
                    "backchannelLogoutRevokeOfflineSessions": {
                        "type": "boolean"
                    },
                    "backchannelLogoutSessionRequired": {
                        "type": "boolean"
                    },
                    "backchannelLogoutUrl": {
                        "type": "string"
                    },
                    "baseUrl": {
                        "type": "string"
                    },
                    "clientAuthenticatorType": {
                        "type": "string"
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "clientOfflineSessionIdleTimeout": {
                        "type": "string"
                    },
                    "clientOfflineSessionMaxLifespan": {
                        "type": "string"
                    },
                    "clientSecret": {
                        "secret": true,
                        "type": "string"
                    },
                    "clientSessionIdleTimeout": {
                        "type": "string"
                    },
                    "clientSessionMaxLifespan": {
                        "type": "string"
                    },
                    "consentRequired": {
                        "type": "boolean"
                    },
                    "consentScreenText": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "directAccessGrantsEnabled": {
                        "type": "boolean"
                    },
                    "displayOnConsentScreen": {
                        "type": "boolean"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "excludeSessionStateFromAuthResponse": {
                        "type": "boolean"
                    },
                    "extraConfig": {
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "type": "object"
                    },
                    "frontchannelLogoutEnabled": {
                        "type": "boolean"
                    },
                    "frontchannelLogoutUrl": {
                        "type": "string"
                    },
                    "fullScopeAllowed": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "implicitFlowEnabled": {
                        "type": "boolean"
                    },
                    "loginTheme": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "oauth2DeviceAuthorizationGrantEnabled": {
                        "type": "boolean"
                    },
                    "oauth2DeviceCodeLifespan": {
                        "type": "string"
                    },
                    "oauth2DevicePollingInterval": {
                        "type": "string"
                    },
                    "pkceCodeChallengeMethod": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "rootUrl": {
                        "type": "string"
                    },
                    "serviceAccountUserId": {
                        "type": "string"
                    },
                    "serviceAccountsEnabled": {
                        "type": "boolean"
                    },
                    "standardFlowEnabled": {
                        "type": "boolean"
                    },
                    "useRefreshTokens": {
                        "type": "boolean"
                    },
                    "useRefreshTokensClientCredentials": {
                        "type": "boolean"
                    },
                    "validPostLogoutRedirectUris": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "validRedirectUris": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "webOrigins": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "accessTokenLifespan",
                    "accessType",
                    "adminUrl",
                    "authenticationFlowBindingOverrides",
                    "authorizations",
                    "backchannelLogoutRevokeOfflineSessions",
                    "backchannelLogoutSessionRequired",
                    "backchannelLogoutUrl",
                    "baseUrl",
                    "clientAuthenticatorType",
                    "clientId",
                    "clientOfflineSessionIdleTimeout",
                    "clientOfflineSessionMaxLifespan",
                    "clientSecret",
                    "clientSessionIdleTimeout",
                    "clientSessionMaxLifespan",
                    "consentRequired",
                    "description",
                    "directAccessGrantsEnabled",
                    "enabled",
                    "excludeSessionStateFromAuthResponse",
                    "extraConfig",
                    "frontchannelLogoutEnabled",
                    "frontchannelLogoutUrl",
                    "fullScopeAllowed",
                    "implicitFlowEnabled",
                    "loginTheme",
                    "name",
                    "pkceCodeChallengeMethod",
                    "realmId",
                    "resourceServerId",
                    "rootUrl",
                    "serviceAccountUserId",
                    "serviceAccountsEnabled",
                    "standardFlowEnabled",
                    "useRefreshTokens",
                    "useRefreshTokensClientCredentials",
                    "validPostLogoutRedirectUris",
                    "validRedirectUris",
                    "webOrigins",
                    "id"
                ],
                "type": "object"
            }
        },
        "keycloak:openid/getClientAuthorizationPolicy:getClientAuthorizationPolicy": {
            "description": "This data source can be used to fetch policy and permission information for an OpenID client that has authorization enabled.\n\n## Example Usage\n\nIn this example, we'll create a new OpenID client with authorization enabled. This will cause Keycloak to create a default\npermission for this client called \"Default Permission\". We'll use the `keycloak.openid.getClientAuthorizationPolicy` data\nsource to fetch information about this permission, so we can use it to create a new resource-based authorization permission.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientWithAuthz = new keycloak.openid.Client(\"client_with_authz\", {\n    clientId: \"client-with-authz\",\n    name: \"client-with-authz\",\n    realmId: realm.id,\n    accessType: \"CONFIDENTIAL\",\n    serviceAccountsEnabled: true,\n    authorization: {\n        policyEnforcementMode: \"ENFORCING\",\n    },\n});\nconst defaultPermission = keycloak.openid.getClientAuthorizationPolicyOutput({\n    realmId: realm.id,\n    resourceServerId: clientWithAuthz.resourceServerId,\n    name: \"Default Permission\",\n});\nconst resource = new keycloak.openid.ClientAuthorizationResource(\"resource\", {\n    resourceServerId: clientWithAuthz.resourceServerId,\n    name: \"authorization-resource\",\n    realmId: realm.id,\n    uris: [\"/endpoint/*\"],\n    attributes: {\n        foo: \"bar\",\n    },\n});\nconst permission = new keycloak.openid.ClientAuthorizationPermission(\"permission\", {\n    resourceServerId: clientWithAuthz.resourceServerId,\n    realmId: realm.id,\n    name: \"authorization-permission\",\n    policies: [defaultPermission.apply(defaultPermission =\u003e defaultPermission.id)],\n    resources: [resource.id],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_with_authz = keycloak.openid.Client(\"client_with_authz\",\n    client_id=\"client-with-authz\",\n    name=\"client-with-authz\",\n    realm_id=realm.id,\n    access_type=\"CONFIDENTIAL\",\n    service_accounts_enabled=True,\n    authorization=keycloak.openid.ClientAuthorizationArgs(\n        policy_enforcement_mode=\"ENFORCING\",\n    ))\ndefault_permission = keycloak.openid.get_client_authorization_policy_output(realm_id=realm.id,\n    resource_server_id=client_with_authz.resource_server_id,\n    name=\"Default Permission\")\nresource = keycloak.openid.ClientAuthorizationResource(\"resource\",\n    resource_server_id=client_with_authz.resource_server_id,\n    name=\"authorization-resource\",\n    realm_id=realm.id,\n    uris=[\"/endpoint/*\"],\n    attributes={\n        \"foo\": \"bar\",\n    })\npermission = keycloak.openid.ClientAuthorizationPermission(\"permission\",\n    resource_server_id=client_with_authz.resource_server_id,\n    realm_id=realm.id,\n    name=\"authorization-permission\",\n    policies=[default_permission.id],\n    resources=[resource.id])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var clientWithAuthz = new Keycloak.OpenId.Client(\"client_with_authz\", new()\n    {\n        ClientId = \"client-with-authz\",\n        Name = \"client-with-authz\",\n        RealmId = realm.Id,\n        AccessType = \"CONFIDENTIAL\",\n        ServiceAccountsEnabled = true,\n        Authorization = new Keycloak.OpenId.Inputs.ClientAuthorizationArgs\n        {\n            PolicyEnforcementMode = \"ENFORCING\",\n        },\n    });\n\n    var defaultPermission = Keycloak.OpenId.GetClientAuthorizationPolicy.Invoke(new()\n    {\n        RealmId = realm.Id,\n        ResourceServerId = clientWithAuthz.ResourceServerId,\n        Name = \"Default Permission\",\n    });\n\n    var resource = new Keycloak.OpenId.ClientAuthorizationResource(\"resource\", new()\n    {\n        ResourceServerId = clientWithAuthz.ResourceServerId,\n        Name = \"authorization-resource\",\n        RealmId = realm.Id,\n        Uris = new[]\n        {\n            \"/endpoint/*\",\n        },\n        Attributes = \n        {\n            { \"foo\", \"bar\" },\n        },\n    });\n\n    var permission = new Keycloak.OpenId.ClientAuthorizationPermission(\"permission\", new()\n    {\n        ResourceServerId = clientWithAuthz.ResourceServerId,\n        RealmId = realm.Id,\n        Name = \"authorization-permission\",\n        Policies = new[]\n        {\n            defaultPermission.Apply(getClientAuthorizationPolicyResult =\u003e getClientAuthorizationPolicyResult.Id),\n        },\n        Resources = new[]\n        {\n            resource.Id,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientWithAuthz, err := openid.NewClient(ctx, \"client_with_authz\", \u0026openid.ClientArgs{\n\t\t\tClientId:               pulumi.String(\"client-with-authz\"),\n\t\t\tName:                   pulumi.String(\"client-with-authz\"),\n\t\t\tRealmId:                realm.ID(),\n\t\t\tAccessType:             pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tServiceAccountsEnabled: pulumi.Bool(true),\n\t\t\tAuthorization: \u0026openid.ClientAuthorizationArgs{\n\t\t\t\tPolicyEnforcementMode: pulumi.String(\"ENFORCING\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefaultPermission := openid.GetClientAuthorizationPolicyOutput(ctx, openid.GetClientAuthorizationPolicyOutputArgs{\n\t\t\tRealmId:          realm.ID(),\n\t\t\tResourceServerId: clientWithAuthz.ResourceServerId,\n\t\t\tName:             pulumi.String(\"Default Permission\"),\n\t\t}, nil)\n\t\tresource, err := openid.NewClientAuthorizationResource(ctx, \"resource\", \u0026openid.ClientAuthorizationResourceArgs{\n\t\t\tResourceServerId: clientWithAuthz.ResourceServerId,\n\t\t\tName:             pulumi.String(\"authorization-resource\"),\n\t\t\tRealmId:          realm.ID(),\n\t\t\tUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"/endpoint/*\"),\n\t\t\t},\n\t\t\tAttributes: pulumi.Map{\n\t\t\t\t\"foo\": pulumi.Any(\"bar\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientAuthorizationPermission(ctx, \"permission\", \u0026openid.ClientAuthorizationPermissionArgs{\n\t\t\tResourceServerId: clientWithAuthz.ResourceServerId,\n\t\t\tRealmId:          realm.ID(),\n\t\t\tName:             pulumi.String(\"authorization-permission\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tdefaultPermission.ApplyT(func(defaultPermission openid.GetClientAuthorizationPolicyResult) (*string, error) {\n\t\t\t\t\treturn \u0026defaultPermission.Id, nil\n\t\t\t\t}).(pulumi.StringPtrOutput),\n\t\t\t},\n\t\t\tResources: pulumi.StringArray{\n\t\t\t\tresource.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.openid.inputs.ClientAuthorizationArgs;\nimport com.pulumi.keycloak.openid.OpenidFunctions;\nimport com.pulumi.keycloak.openid.inputs.GetClientAuthorizationPolicyArgs;\nimport com.pulumi.keycloak.openid.ClientAuthorizationResource;\nimport com.pulumi.keycloak.openid.ClientAuthorizationResourceArgs;\nimport com.pulumi.keycloak.openid.ClientAuthorizationPermission;\nimport com.pulumi.keycloak.openid.ClientAuthorizationPermissionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var clientWithAuthz = new Client(\"clientWithAuthz\", ClientArgs.builder()\n            .clientId(\"client-with-authz\")\n            .name(\"client-with-authz\")\n            .realmId(realm.id())\n            .accessType(\"CONFIDENTIAL\")\n            .serviceAccountsEnabled(true)\n            .authorization(ClientAuthorizationArgs.builder()\n                .policyEnforcementMode(\"ENFORCING\")\n                .build())\n            .build());\n\n        final var defaultPermission = OpenidFunctions.getClientAuthorizationPolicy(GetClientAuthorizationPolicyArgs.builder()\n            .realmId(realm.id())\n            .resourceServerId(clientWithAuthz.resourceServerId())\n            .name(\"Default Permission\")\n            .build());\n\n        var resource = new ClientAuthorizationResource(\"resource\", ClientAuthorizationResourceArgs.builder()\n            .resourceServerId(clientWithAuthz.resourceServerId())\n            .name(\"authorization-resource\")\n            .realmId(realm.id())\n            .uris(\"/endpoint/*\")\n            .attributes(Map.of(\"foo\", \"bar\"))\n            .build());\n\n        var permission = new ClientAuthorizationPermission(\"permission\", ClientAuthorizationPermissionArgs.builder()\n            .resourceServerId(clientWithAuthz.resourceServerId())\n            .realmId(realm.id())\n            .name(\"authorization-permission\")\n            .policies(defaultPermission.applyValue(getClientAuthorizationPolicyResult -\u003e getClientAuthorizationPolicyResult).applyValue(defaultPermission -\u003e defaultPermission.applyValue(getClientAuthorizationPolicyResult -\u003e getClientAuthorizationPolicyResult.id())))\n            .resources(resource.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  clientWithAuthz:\n    type: keycloak:openid:Client\n    name: client_with_authz\n    properties:\n      clientId: client-with-authz\n      name: client-with-authz\n      realmId: ${realm.id}\n      accessType: CONFIDENTIAL\n      serviceAccountsEnabled: true\n      authorization:\n        policyEnforcementMode: ENFORCING\n  resource:\n    type: keycloak:openid:ClientAuthorizationResource\n    properties:\n      resourceServerId: ${clientWithAuthz.resourceServerId}\n      name: authorization-resource\n      realmId: ${realm.id}\n      uris:\n        - /endpoint/*\n      attributes:\n        foo: bar\n  permission:\n    type: keycloak:openid:ClientAuthorizationPermission\n    properties:\n      resourceServerId: ${clientWithAuthz.resourceServerId}\n      realmId: ${realm.id}\n      name: authorization-permission\n      policies:\n        - ${defaultPermission.id}\n      resources:\n        - ${resource.id}\nvariables:\n  defaultPermission:\n    fn::invoke:\n      Function: keycloak:openid:getClientAuthorizationPolicy\n      Arguments:\n        realmId: ${realm.id}\n        resourceServerId: ${clientWithAuthz.resourceServerId}\n        name: Default Permission\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getClientAuthorizationPolicy.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the authorization policy.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this authorization policy exists within.\n"
                    },
                    "resourceServerId": {
                        "type": "string",
                        "description": "The ID of the resource server this authorization policy is attached to.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "realmId",
                    "resourceServerId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClientAuthorizationPolicy.\n",
                "properties": {
                    "decisionStrategy": {
                        "description": "(Computed) Dictates how the policies associated with a given permission are evaluated and how a final decision is obtained. Could be one of `AFFIRMATIVE`, `CONSENSUS`, or `UNANIMOUS`. Applies to permissions.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "logic": {
                        "description": "(Computed) Dictates how the policy decision should be made. Can be either `POSITIVE` or `NEGATIVE`. Applies to policies.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "owner": {
                        "description": "(Computed) The ID of the owning resource. Applies to resources.\n",
                        "type": "string"
                    },
                    "policies": {
                        "description": "(Computed) The IDs of the policies that must be applied to scopes/resources for this policy/permission. Applies to policies and permissions.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "resources": {
                        "description": "(Computed) The IDs of the resources that this permission applies to. Applies to resource-based permissions.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "scopes": {
                        "description": "(Computed) The IDs of the scopes that this permission applies to. Applies to scope-based permissions.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "type": {
                        "description": "(Computed) The type of this policy / permission. For permissions, this could be `resource` or `scope`. For policies, this could be any type of authorization policy, such as `js`.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "decisionStrategy",
                    "logic",
                    "name",
                    "owner",
                    "policies",
                    "realmId",
                    "resourceServerId",
                    "resources",
                    "scopes",
                    "type",
                    "id"
                ],
                "type": "object"
            }
        },
        "keycloak:openid/getClientScope:getClientScope": {
            "description": "This data source can be used to fetch properties of a Keycloak OpenID client scope for usage with other resources.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst offlineAccess = keycloak.openid.getClientScope({\n    realmId: \"my-realm\",\n    name: \"offline_access\",\n});\n// use the data source\nconst audienceMapper = new keycloak.openid.AudienceProtocolMapper(\"audience_mapper\", {\n    realmId: offlineAccess.then(offlineAccess =\u003e offlineAccess.realmId),\n    clientScopeId: offlineAccess.then(offlineAccess =\u003e offlineAccess.id),\n    name: \"audience-mapper\",\n    includedCustomAudience: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\noffline_access = keycloak.openid.get_client_scope(realm_id=\"my-realm\",\n    name=\"offline_access\")\n# use the data source\naudience_mapper = keycloak.openid.AudienceProtocolMapper(\"audience_mapper\",\n    realm_id=offline_access.realm_id,\n    client_scope_id=offline_access.id,\n    name=\"audience-mapper\",\n    included_custom_audience=\"foo\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var offlineAccess = Keycloak.OpenId.GetClientScope.Invoke(new()\n    {\n        RealmId = \"my-realm\",\n        Name = \"offline_access\",\n    });\n\n    // use the data source\n    var audienceMapper = new Keycloak.OpenId.AudienceProtocolMapper(\"audience_mapper\", new()\n    {\n        RealmId = offlineAccess.Apply(getClientScopeResult =\u003e getClientScopeResult.RealmId),\n        ClientScopeId = offlineAccess.Apply(getClientScopeResult =\u003e getClientScopeResult.Id),\n        Name = \"audience-mapper\",\n        IncludedCustomAudience = \"foo\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tofflineAccess, err := openid.LookupClientScope(ctx, \u0026openid.LookupClientScopeArgs{\n\t\t\tRealmId: \"my-realm\",\n\t\t\tName:    \"offline_access\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// use the data source\n\t\t_, err = openid.NewAudienceProtocolMapper(ctx, \"audience_mapper\", \u0026openid.AudienceProtocolMapperArgs{\n\t\t\tRealmId:                pulumi.String(offlineAccess.RealmId),\n\t\t\tClientScopeId:          pulumi.String(offlineAccess.Id),\n\t\t\tName:                   pulumi.String(\"audience-mapper\"),\n\t\t\tIncludedCustomAudience: pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.openid.OpenidFunctions;\nimport com.pulumi.keycloak.openid.inputs.GetClientScopeArgs;\nimport com.pulumi.keycloak.openid.AudienceProtocolMapper;\nimport com.pulumi.keycloak.openid.AudienceProtocolMapperArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var offlineAccess = OpenidFunctions.getClientScope(GetClientScopeArgs.builder()\n            .realmId(\"my-realm\")\n            .name(\"offline_access\")\n            .build());\n\n        // use the data source\n        var audienceMapper = new AudienceProtocolMapper(\"audienceMapper\", AudienceProtocolMapperArgs.builder()\n            .realmId(offlineAccess.applyValue(getClientScopeResult -\u003e getClientScopeResult.realmId()))\n            .clientScopeId(offlineAccess.applyValue(getClientScopeResult -\u003e getClientScopeResult.id()))\n            .name(\"audience-mapper\")\n            .includedCustomAudience(\"foo\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # use the data source\n  audienceMapper:\n    type: keycloak:openid:AudienceProtocolMapper\n    name: audience_mapper\n    properties:\n      realmId: ${offlineAccess.realmId}\n      clientScopeId: ${offlineAccess.id}\n      name: audience-mapper\n      includedCustomAudience: foo\nvariables:\n  offlineAccess:\n    fn::invoke:\n      Function: keycloak:openid:getClientScope\n      Arguments:\n        realmId: my-realm\n        name: offline_access\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getClientScope.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the client scope.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClientScope.\n",
                "properties": {
                    "consentScreenText": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "guiOrder": {
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "includeInTokenScope": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "required": [
                    "consentScreenText",
                    "description",
                    "guiOrder",
                    "includeInTokenScope",
                    "name",
                    "realmId",
                    "id"
                ],
                "type": "object"
            }
        },
        "keycloak:openid/getClientServiceAccountUser:getClientServiceAccountUser": {
            "description": "This data source can be used to fetch information about the service account user that is associated with an OpenID client\nthat has service accounts enabled.\n\n## Example Usage\n\nIn this example, we'll create an OpenID client with service accounts enabled. This causes Keycloak to create a special user\nthat represents the service account. We'll use this data source to grab this user's ID in order to assign some roles to this\nuser, using the `keycloak.UserRoles` resource.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    name: \"client\",\n    accessType: \"CONFIDENTIAL\",\n    serviceAccountsEnabled: true,\n});\nconst serviceAccountUser = keycloak.openid.getClientServiceAccountUserOutput({\n    realmId: realm.id,\n    clientId: client.id,\n});\nconst offlineAccess = keycloak.getRoleOutput({\n    realmId: realm.id,\n    name: \"offline_access\",\n});\nconst serviceAccountUserRoles = new keycloak.UserRoles(\"service_account_user_roles\", {\n    realmId: realm.id,\n    userId: serviceAccountUser.apply(serviceAccountUser =\u003e serviceAccountUser.id),\n    roleIds: [offlineAccess.apply(offlineAccess =\u003e offlineAccess.id)],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    name=\"client\",\n    access_type=\"CONFIDENTIAL\",\n    service_accounts_enabled=True)\nservice_account_user = keycloak.openid.get_client_service_account_user_output(realm_id=realm.id,\n    client_id=client.id)\noffline_access = keycloak.get_role_output(realm_id=realm.id,\n    name=\"offline_access\")\nservice_account_user_roles = keycloak.UserRoles(\"service_account_user_roles\",\n    realm_id=realm.id,\n    user_id=service_account_user.id,\n    role_ids=[offline_access.id])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realm = new Keycloak.Realm(\"realm\", new()\n    {\n        RealmName = \"my-realm\",\n        Enabled = true,\n    });\n\n    var client = new Keycloak.OpenId.Client(\"client\", new()\n    {\n        RealmId = realm.Id,\n        ClientId = \"client\",\n        Name = \"client\",\n        AccessType = \"CONFIDENTIAL\",\n        ServiceAccountsEnabled = true,\n    });\n\n    var serviceAccountUser = Keycloak.OpenId.GetClientServiceAccountUser.Invoke(new()\n    {\n        RealmId = realm.Id,\n        ClientId = client.Id,\n    });\n\n    var offlineAccess = Keycloak.GetRole.Invoke(new()\n    {\n        RealmId = realm.Id,\n        Name = \"offline_access\",\n    });\n\n    var serviceAccountUserRoles = new Keycloak.UserRoles(\"service_account_user_roles\", new()\n    {\n        RealmId = realm.Id,\n        UserId = serviceAccountUser.Apply(getClientServiceAccountUserResult =\u003e getClientServiceAccountUserResult.Id),\n        RoleIds = new[]\n        {\n            offlineAccess.Apply(getRoleResult =\u003e getRoleResult.Id),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:                realm.ID(),\n\t\t\tClientId:               pulumi.String(\"client\"),\n\t\t\tName:                   pulumi.String(\"client\"),\n\t\t\tAccessType:             pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tServiceAccountsEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tserviceAccountUser := openid.GetClientServiceAccountUserOutput(ctx, openid.GetClientServiceAccountUserOutputArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: client.ID(),\n\t\t}, nil)\n\t\tofflineAccess := keycloak.LookupRoleOutput(ctx, keycloak.GetRoleOutputArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"offline_access\"),\n\t\t}, nil)\n\t\t_, err = keycloak.NewUserRoles(ctx, \"service_account_user_roles\", \u0026keycloak.UserRolesArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tUserId: serviceAccountUser.ApplyT(func(serviceAccountUser openid.GetClientServiceAccountUserResult) (*string, error) {\n\t\t\t\treturn \u0026serviceAccountUser.Id, nil\n\t\t\t}).(pulumi.StringPtrOutput),\n\t\t\tRoleIds: pulumi.StringArray{\n\t\t\t\tofflineAccess.ApplyT(func(offlineAccess keycloak.GetRoleResult) (*string, error) {\n\t\t\t\t\treturn \u0026offlineAccess.Id, nil\n\t\t\t\t}).(pulumi.StringPtrOutput),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.Realm;\nimport com.pulumi.keycloak.RealmArgs;\nimport com.pulumi.keycloak.openid.Client;\nimport com.pulumi.keycloak.openid.ClientArgs;\nimport com.pulumi.keycloak.openid.OpenidFunctions;\nimport com.pulumi.keycloak.openid.inputs.GetClientServiceAccountUserArgs;\nimport com.pulumi.keycloak.KeycloakFunctions;\nimport com.pulumi.keycloak.inputs.GetRoleArgs;\nimport com.pulumi.keycloak.UserRoles;\nimport com.pulumi.keycloak.UserRolesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var realm = new Realm(\"realm\", RealmArgs.builder()\n            .realm(\"my-realm\")\n            .enabled(true)\n            .build());\n\n        var client = new Client(\"client\", ClientArgs.builder()\n            .realmId(realm.id())\n            .clientId(\"client\")\n            .name(\"client\")\n            .accessType(\"CONFIDENTIAL\")\n            .serviceAccountsEnabled(true)\n            .build());\n\n        final var serviceAccountUser = OpenidFunctions.getClientServiceAccountUser(GetClientServiceAccountUserArgs.builder()\n            .realmId(realm.id())\n            .clientId(client.id())\n            .build());\n\n        final var offlineAccess = KeycloakFunctions.getRole(GetRoleArgs.builder()\n            .realmId(realm.id())\n            .name(\"offline_access\")\n            .build());\n\n        var serviceAccountUserRoles = new UserRoles(\"serviceAccountUserRoles\", UserRolesArgs.builder()\n            .realmId(realm.id())\n            .userId(serviceAccountUser.applyValue(getClientServiceAccountUserResult -\u003e getClientServiceAccountUserResult).applyValue(serviceAccountUser -\u003e serviceAccountUser.applyValue(getClientServiceAccountUserResult -\u003e getClientServiceAccountUserResult.id())))\n            .roleIds(offlineAccess.applyValue(getRoleResult -\u003e getRoleResult).applyValue(offlineAccess -\u003e offlineAccess.applyValue(getRoleResult -\u003e getRoleResult.id())))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  realm:\n    type: keycloak:Realm\n    properties:\n      realm: my-realm\n      enabled: true\n  client:\n    type: keycloak:openid:Client\n    properties:\n      realmId: ${realm.id}\n      clientId: client\n      name: client\n      accessType: CONFIDENTIAL\n      serviceAccountsEnabled: true\n  serviceAccountUserRoles:\n    type: keycloak:UserRoles\n    name: service_account_user_roles\n    properties:\n      realmId: ${realm.id}\n      userId: ${serviceAccountUser.id}\n      roleIds:\n        - ${offlineAccess.id}\nvariables:\n  serviceAccountUser:\n    fn::invoke:\n      Function: keycloak:openid:getClientServiceAccountUser\n      Arguments:\n        realmId: ${realm.id}\n        clientId: ${client.id}\n  offlineAccess:\n    fn::invoke:\n      Function: keycloak:getRole\n      Arguments:\n        realmId: ${realm.id}\n        name: offline_access\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getClientServiceAccountUser.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The ID of the OpenID client with service accounts enabled.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that the OpenID client exists within.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clientId",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClientServiceAccountUser.\n",
                "properties": {
                    "attributes": {
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "type": "object"
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "email": {
                        "type": "string"
                    },
                    "emailVerified": {
                        "type": "boolean"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "federatedIdentities": {
                        "items": {
                            "$ref": "#/types/keycloak:openid/getClientServiceAccountUserFederatedIdentity:getClientServiceAccountUserFederatedIdentity"
                        },
                        "type": "array"
                    },
                    "firstName": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "lastName": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "requiredActions": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "required": [
                    "attributes",
                    "clientId",
                    "email",
                    "emailVerified",
                    "enabled",
                    "federatedIdentities",
                    "firstName",
                    "lastName",
                    "realmId",
                    "requiredActions",
                    "username",
                    "id"
                ],
                "type": "object"
            }
        },
        "keycloak:saml/getClient:getClient": {
            "description": "This data source can be used to fetch properties of a Keycloak client that uses the SAML protocol.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realmManagement = keycloak.saml.getClient({\n    realmId: \"my-realm\",\n    clientId: \"realm-management\",\n});\n// use the data source\nconst admin = realmManagement.then(realmManagement =\u003e keycloak.getRole({\n    realmId: \"my-realm\",\n    clientId: realmManagement.id,\n    name: \"realm-admin\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm_management = keycloak.saml.get_client(realm_id=\"my-realm\",\n    client_id=\"realm-management\")\n# use the data source\nadmin = keycloak.get_role(realm_id=\"my-realm\",\n    client_id=realm_management.id,\n    name=\"realm-admin\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var realmManagement = Keycloak.Saml.GetClient.Invoke(new()\n    {\n        RealmId = \"my-realm\",\n        ClientId = \"realm-management\",\n    });\n\n    // use the data source\n    var admin = Keycloak.GetRole.Invoke(new()\n    {\n        RealmId = \"my-realm\",\n        ClientId = realmManagement.Apply(getClientResult =\u003e getClientResult.Id),\n        Name = \"realm-admin\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v5/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealmManagement, err := saml.LookupClient(ctx, \u0026saml.LookupClientArgs{\n\t\t\tRealmId:  \"my-realm\",\n\t\t\tClientId: \"realm-management\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// use the data source\n\t\t_, err = keycloak.LookupRole(ctx, \u0026keycloak.LookupRoleArgs{\n\t\t\tRealmId:  \"my-realm\",\n\t\t\tClientId: pulumi.StringRef(realmManagement.Id),\n\t\t\tName:     \"realm-admin\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.keycloak.saml.SamlFunctions;\nimport com.pulumi.keycloak.saml.inputs.GetClientArgs;\nimport com.pulumi.keycloak.KeycloakFunctions;\nimport com.pulumi.keycloak.inputs.GetRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var realmManagement = SamlFunctions.getClient(GetClientArgs.builder()\n            .realmId(\"my-realm\")\n            .clientId(\"realm-management\")\n            .build());\n\n        // use the data source\n        final var admin = KeycloakFunctions.getRole(GetRoleArgs.builder()\n            .realmId(\"my-realm\")\n            .clientId(realmManagement.applyValue(getClientResult -\u003e getClientResult.id()))\n            .name(\"realm-admin\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  realmManagement:\n    fn::invoke:\n      Function: keycloak:saml:getClient\n      Arguments:\n        realmId: my-realm\n        clientId: realm-management\n  # use the data source\n  admin:\n    fn::invoke:\n      Function: keycloak:getRole\n      Arguments:\n        realmId: my-realm\n        clientId: ${realmManagement.id}\n        name: realm-admin\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getClient.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The client id (not its unique ID).\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clientId",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClient.\n",
                "properties": {
                    "assertionConsumerPostUrl": {
                        "type": "string"
                    },
                    "assertionConsumerRedirectUrl": {
                        "type": "string"
                    },
                    "authenticationFlowBindingOverrides": {
                        "items": {
                            "$ref": "#/types/keycloak:saml/getClientAuthenticationFlowBindingOverride:getClientAuthenticationFlowBindingOverride"
                        },
                        "type": "array"
                    },
                    "baseUrl": {
                        "type": "string"
                    },
                    "canonicalizationMethod": {
                        "type": "string"
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "clientSignatureRequired": {
                        "type": "boolean"
                    },
                    "description": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "encryptAssertions": {
                        "type": "boolean"
                    },
                    "encryptionCertificate": {
                        "type": "string"
                    },
                    "encryptionCertificateSha1": {
                        "type": "string"
                    },
                    "extraConfig": {
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "type": "object"
                    },
                    "forceNameIdFormat": {
                        "type": "boolean"
                    },
                    "forcePostBinding": {
                        "type": "boolean"
                    },
                    "frontChannelLogout": {
                        "type": "boolean"
                    },
                    "fullScopeAllowed": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "idpInitiatedSsoRelayState": {
                        "type": "string"
                    },
                    "idpInitiatedSsoUrlName": {
                        "type": "string"
                    },
                    "includeAuthnStatement": {
                        "type": "boolean"
                    },
                    "loginTheme": {
                        "type": "string"
                    },
                    "logoutServicePostBindingUrl": {
                        "type": "string"
                    },
                    "logoutServiceRedirectBindingUrl": {
                        "type": "string"
                    },
                    "masterSamlProcessingUrl": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nameIdFormat": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "rootUrl": {
                        "type": "string"
                    },
                    "samlSignatureKeyName": {
                        "type": "string"
                    },
                    "signAssertions": {
                        "type": "boolean"
                    },
                    "signDocuments": {
                        "type": "boolean"
                    },
                    "signatureAlgorithm": {
                        "type": "string"
                    },
                    "signatureKeyName": {
                        "type": "string"
                    },
                    "signingCertificate": {
                        "type": "string"
                    },
                    "signingCertificateSha1": {
                        "type": "string"
                    },
                    "signingPrivateKey": {
                        "type": "string"
                    },
                    "signingPrivateKeySha1": {
                        "type": "string"
                    },
                    "validRedirectUris": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "assertionConsumerPostUrl",
                    "assertionConsumerRedirectUrl",
                    "authenticationFlowBindingOverrides",
                    "baseUrl",
                    "canonicalizationMethod",
                    "clientId",
                    "clientSignatureRequired",
                    "description",
                    "enabled",
                    "encryptAssertions",
                    "encryptionCertificate",
                    "encryptionCertificateSha1",
                    "extraConfig",
                    "forceNameIdFormat",
                    "forcePostBinding",
                    "frontChannelLogout",
                    "fullScopeAllowed",
                    "idpInitiatedSsoRelayState",
                    "idpInitiatedSsoUrlName",
                    "includeAuthnStatement",
                    "loginTheme",
                    "logoutServicePostBindingUrl",
                    "logoutServiceRedirectBindingUrl",
                    "masterSamlProcessingUrl",
                    "name",
                    "nameIdFormat",
                    "realmId",
                    "rootUrl",
                    "samlSignatureKeyName",
                    "signAssertions",
                    "signDocuments",
                    "signatureAlgorithm",
                    "signatureKeyName",
                    "signingCertificate",
                    "signingCertificateSha1",
                    "signingPrivateKey",
                    "signingPrivateKeySha1",
                    "validRedirectUris",
                    "id"
                ],
                "type": "object"
            }
        },
        "keycloak:saml/getClientInstallationProvider:getClientInstallationProvider": {
            "description": "This data source can be used to retrieve Installation Provider of a SAML Client.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getClientInstallationProvider.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The ID of the SAML client. The `id` attribute of a `keycloak_client` resource should be used here.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The ID of the SAML installation provider. Could be one of `saml-idp-descriptor`, `keycloak-saml`, `saml-sp-descriptor`, `keycloak-saml-subsystem`, `mod-auth-mellon`, etc.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that the SAML client exists within.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clientId",
                    "providerId",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClientInstallationProvider.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "providerId": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "value": {
                        "description": "(Computed) The returned document needed for SAML installation.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "clientId",
                    "providerId",
                    "realmId",
                    "value",
                    "id"
                ],
                "type": "object"
            }
        }
    }
}