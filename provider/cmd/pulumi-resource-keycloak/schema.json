{
    "name": "keycloak",
    "description": "A Pulumi package for creating and managing keycloak cloud resources.",
    "keywords": [
        "pulumi",
        "keycloak"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`keycloak` Terraform Provider](https://github.com/mrparkers/terraform-provider-keycloak).",
    "repository": "https://github.com/pulumi/pulumi-keycloak",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "config": {
        "variables": {
            "additionalHeaders": {
                "type": "object",
                "additionalProperties": {
                    "type": "string"
                }
            },
            "basePath": {
                "type": "string"
            },
            "clientId": {
                "type": "string"
            },
            "clientSecret": {
                "type": "string"
            },
            "clientTimeout": {
                "type": "integer",
                "description": "Timeout (in seconds) of the Keycloak client\n",
                "default": 5,
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_CLIENT_TIMEOUT"
                    ]
                }
            },
            "initialLogin": {
                "type": "boolean",
                "description": "Whether or not to login to Keycloak instance on provider initialization\n"
            },
            "password": {
                "type": "string"
            },
            "realm": {
                "type": "string"
            },
            "rootCaCertificate": {
                "type": "string",
                "description": "Allows x509 calls using an unknown CA certificate (for development purposes)\n"
            },
            "tlsInsecureSkipVerify": {
                "type": "boolean",
                "description": "Allows ignoring insecure certificates when set to true. Defaults to false. Disabling security check is dangerous and\nshould be avoided.\n"
            },
            "url": {
                "type": "string",
                "description": "The base URL of the Keycloak instance, before `/auth`\n"
            },
            "username": {
                "type": "string"
            }
        },
        "defaults": [
            "clientId",
            "url"
        ]
    },
    "types": {
        "keycloak:index/GroupPermissionsManageMembersScope:GroupPermissionsManageMembersScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/GroupPermissionsManageMembershipScope:GroupPermissionsManageMembershipScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/GroupPermissionsManageScope:GroupPermissionsManageScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/GroupPermissionsViewMembersScope:GroupPermissionsViewMembersScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/GroupPermissionsViewScope:GroupPermissionsViewScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/RealmInternationalization:RealmInternationalization": {
            "properties": {
                "defaultLocale": {
                    "type": "string",
                    "description": "The locale to use by default. This locale code must be present within the `supported_locales` list.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "supportedLocales": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) locale codes that the realm should support.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "defaultLocale",
                "supportedLocales"
            ]
        },
        "keycloak:index/RealmOtpPolicy:RealmOtpPolicy": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "What hashing algorithm should be used to generate the OTP, Valid options are `HmacSHA1`,`HmacSHA256` and `HmacSHA512`. Defaults to `HmacSHA1`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "digits": {
                    "type": "integer",
                    "description": "How many digits the OTP have. Defaults to `6`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "initialCounter": {
                    "type": "integer",
                    "description": "What should the initial counter value be. Defaults to `2`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lookAheadWindow": {
                    "type": "integer",
                    "description": "How far ahead should the server look just in case the token generator and server are out of time sync or counter sync. Defaults to `1`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "period": {
                    "type": "integer",
                    "description": "How many seconds should an OTP token be valid. Defaults to `30`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "One Time Password Type, supported Values are `totp` for Time-Based One Time Password and `hotp` for Counter Based. Defaults to `totp`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/RealmSecurityDefenses:RealmSecurityDefenses": {
            "properties": {
                "bruteForceDetection": {
                    "$ref": "#/types/keycloak:index/RealmSecurityDefensesBruteForceDetection:RealmSecurityDefensesBruteForceDetection",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "headers": {
                    "$ref": "#/types/keycloak:index/RealmSecurityDefensesHeaders:RealmSecurityDefensesHeaders",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/RealmSecurityDefensesBruteForceDetection:RealmSecurityDefensesBruteForceDetection": {
            "properties": {
                "failureResetTimeSeconds": {
                    "type": "integer",
                    "description": "When will failure count be reset?\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxFailureWaitSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLoginFailures": {
                    "type": "integer",
                    "description": "How many failures before wait is triggered.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minimumQuickLoginWaitSeconds": {
                    "type": "integer",
                    "description": "How long to wait after a quick login failure.\n- `max_failure_wait_seconds ` - (Optional) Max. time a user will be locked out.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "permanentLockout": {
                    "type": "boolean",
                    "description": "When `true`, this will lock the user permanently when the user exceeds the maximum login failures.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "quickLoginCheckMilliSeconds": {
                    "type": "integer",
                    "description": "Configures the amount of time, in milliseconds, for consecutive failures to lock a user out.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "waitIncrementSeconds": {
                    "type": "integer",
                    "description": "This represents the amount of time a user should be locked out when the login failure threshold has been met.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/RealmSecurityDefensesHeaders:RealmSecurityDefensesHeaders": {
            "properties": {
                "contentSecurityPolicy": {
                    "type": "string",
                    "description": "Sets the Content Security Policy, which can be used for prevent pages from being included by non-origin iframes. More information can be found in the [W3C-CSP](https://www.w3.org/TR/CSP/) Abstract.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contentSecurityPolicyReportOnly": {
                    "type": "string",
                    "description": "Used for testing Content Security Policies.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "strictTransportSecurity": {
                    "type": "string",
                    "description": "The Script-Transport-Security HTTP header tells browsers to always use HTTPS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xContentTypeOptions": {
                    "type": "string",
                    "description": "Sets the X-Content-Type-Options, which can be used for prevent MIME-sniffing a response away from the declared content-type\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xFrameOptions": {
                    "type": "string",
                    "description": "Sets the x-frame-option, which can be used to prevent pages from being included by non-origin iframes. More information can be found in the [RFC7034](https://tools.ietf.org/html/rfc7034)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xRobotsTag": {
                    "type": "string",
                    "description": "Prevent pages from appearing in search engines.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xXssProtection": {
                    "type": "string",
                    "description": "This header configures the Cross-site scripting (XSS) filter in your browser.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/RealmSmtpServer:RealmSmtpServer": {
            "properties": {
                "auth": {
                    "$ref": "#/types/keycloak:index/RealmSmtpServerAuth:RealmSmtpServerAuth",
                    "description": "Enables authentication to the SMTP server.  This block supports the following arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "envelopeFrom": {
                    "type": "string",
                    "description": "The email address uses for bounces.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "from": {
                    "type": "string",
                    "description": "The email address for the sender.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fromDisplayName": {
                    "type": "string",
                    "description": "The display name of the sender email address.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "description": "The host of the SMTP server.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "string",
                    "description": "The port of the SMTP server (defaults to 25).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replyTo": {
                    "type": "string",
                    "description": "The \"reply to\" email address.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replyToDisplayName": {
                    "type": "string",
                    "description": "The display name of the \"reply to\" email address.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssl": {
                    "type": "boolean",
                    "description": "When `true`, enables SSL. Defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "starttls": {
                    "type": "boolean",
                    "description": "When `true`, enables StartTLS. Defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "from",
                "host"
            ]
        },
        "keycloak:index/RealmSmtpServerAuth:RealmSmtpServerAuth": {
            "properties": {
                "password": {
                    "type": "string",
                    "description": "The SMTP server password.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The SMTP server username.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "password",
                "username"
            ]
        },
        "keycloak:index/RealmWebAuthnPasswordlessPolicy:RealmWebAuthnPasswordlessPolicy": {
            "properties": {
                "acceptableAaguids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of AAGUIDs for which an authenticator can be registered.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attestationConveyancePreference": {
                    "type": "string",
                    "description": "The preference of how to generate a WebAuthn attestation statement. Valid options are `not specified`, `none`, `indirect`, `direct`, or `enterprise`. Defaults to `not specified`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authenticatorAttachment": {
                    "type": "string",
                    "description": "The acceptable attachment pattern for the WebAuthn authenticator. Valid options are `not specified`, `platform`, or `cross-platform`. Defaults to `not specified`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "avoidSameAuthenticatorRegister": {
                    "type": "boolean",
                    "description": "When `true`, Keycloak will avoid registering the authenticator for WebAuthn if it has already been registered. Defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createTimeout": {
                    "type": "integer",
                    "description": "The timeout value for creating a user's public key credential in seconds. When set to `0`, this timeout option is not adapted. Defaults to `0`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "relyingPartyEntityName": {
                    "type": "string",
                    "description": "A human readable server name for the WebAuthn Relying Party. Defaults to `keycloak`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "relyingPartyId": {
                    "type": "string",
                    "description": "The WebAuthn relying party ID.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requireResidentKey": {
                    "type": "string",
                    "description": "Specifies whether or not a public key should be created to represent the resident key. Valid options are `not specified`, `Yes`, or `No`. Defaults to `not specified`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "signatureAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of signature algorithms that should be used for the authentication assertion. Valid options at the time these docs were written are `ES256`, `ES384`, `ES512`, `RS256`, `RS384`, `RS512`, and `RS1`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userVerificationRequirement": {
                    "type": "string",
                    "description": "Specifies the policy for verifying a user logging in via WebAuthn. Valid options are `not specified`, `required`, `preferred`, or `discouraged`. Defaults to `not specified`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "signatureAlgorithms"
                    ]
                }
            }
        },
        "keycloak:index/RealmWebAuthnPolicy:RealmWebAuthnPolicy": {
            "properties": {
                "acceptableAaguids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of AAGUIDs for which an authenticator can be registered.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attestationConveyancePreference": {
                    "type": "string",
                    "description": "The preference of how to generate a WebAuthn attestation statement. Valid options are `not specified`, `none`, `indirect`, `direct`, or `enterprise`. Defaults to `not specified`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authenticatorAttachment": {
                    "type": "string",
                    "description": "The acceptable attachment pattern for the WebAuthn authenticator. Valid options are `not specified`, `platform`, or `cross-platform`. Defaults to `not specified`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "avoidSameAuthenticatorRegister": {
                    "type": "boolean",
                    "description": "When `true`, Keycloak will avoid registering the authenticator for WebAuthn if it has already been registered. Defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createTimeout": {
                    "type": "integer",
                    "description": "The timeout value for creating a user's public key credential in seconds. When set to `0`, this timeout option is not adapted. Defaults to `0`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "relyingPartyEntityName": {
                    "type": "string",
                    "description": "A human readable server name for the WebAuthn Relying Party. Defaults to `keycloak`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "relyingPartyId": {
                    "type": "string",
                    "description": "The WebAuthn relying party ID.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requireResidentKey": {
                    "type": "string",
                    "description": "Specifies whether or not a public key should be created to represent the resident key. Valid options are `not specified`, `Yes`, or `No`. Defaults to `not specified`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "signatureAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of signature algorithms that should be used for the authentication assertion. Valid options at the time these docs were written are `ES256`, `ES384`, `ES512`, `RS256`, `RS384`, `RS512`, and `RS1`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userVerificationRequirement": {
                    "type": "string",
                    "description": "Specifies the policy for verifying a user logging in via WebAuthn. Valid options are `not specified`, `required`, `preferred`, or `discouraged`. Defaults to `not specified`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "signatureAlgorithms"
                    ]
                }
            }
        },
        "keycloak:index/UserFederatedIdentity:UserFederatedIdentity": {
            "properties": {
                "identityProvider": {
                    "type": "string",
                    "description": "The name of the identity provider\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userId": {
                    "type": "string",
                    "description": "The ID of the user defined in the identity provider\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userName": {
                    "type": "string",
                    "description": "The user name of the user defined in the identity provider\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "identityProvider",
                "userId",
                "userName"
            ]
        },
        "keycloak:index/UserInitialPassword:UserInitialPassword": {
            "properties": {
                "temporary": {
                    "type": "boolean",
                    "description": "If set to `true`, the initial password is set up for renewal on first use. Default to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The initial password.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "value"
            ]
        },
        "keycloak:index/UsersPermissionsImpersonateScope:UsersPermissionsImpersonateScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/UsersPermissionsManageGroupMembershipScope:UsersPermissionsManageGroupMembershipScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/UsersPermissionsManageScope:UsersPermissionsManageScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/UsersPermissionsMapRolesScope:UsersPermissionsMapRolesScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/UsersPermissionsUserImpersonatedScope:UsersPermissionsUserImpersonatedScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/UsersPermissionsViewScope:UsersPermissionsViewScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/getClientDescriptionConverterProtocolMapper:getClientDescriptionConverterProtocolMapper": {
            "properties": {
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "protocol": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "protocolMapper": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "config",
                "id",
                "name",
                "protocol",
                "protocolMapper"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmInternationalization:getRealmInternationalization": {
            "properties": {
                "defaultLocale": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "supportedLocales": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "defaultLocale",
                "supportedLocales"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmKeysKey:getRealmKeysKey": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "Key algorithm (string)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "string",
                    "description": "Key certificate (string)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "kid": {
                    "type": "string",
                    "description": "Key ID (string)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerId": {
                    "type": "string",
                    "description": "Key provider ID (string)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerPriority": {
                    "type": "integer",
                    "description": "Key provider priority (int64)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "publicKey": {
                    "type": "string",
                    "description": "Key public key (string)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "description": "When specified, keys will be filtered by status. The statuses can be any of `ACTIVE`, `DISABLED` and `PASSIVE`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "Key type (string)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "algorithm",
                "certificate",
                "kid",
                "providerId",
                "providerPriority",
                "publicKey",
                "status",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmOtpPolicy:getRealmOtpPolicy": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "digits": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "initialCounter": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lookAheadWindow": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "period": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "algorithm",
                "digits",
                "initialCounter",
                "lookAheadWindow",
                "period",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmSecurityDefense:getRealmSecurityDefense": {
            "properties": {
                "bruteForceDetections": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/getRealmSecurityDefenseBruteForceDetection:getRealmSecurityDefenseBruteForceDetection"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/getRealmSecurityDefenseHeader:getRealmSecurityDefenseHeader"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "bruteForceDetections",
                "headers"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmSecurityDefenseBruteForceDetection:getRealmSecurityDefenseBruteForceDetection": {
            "properties": {
                "failureResetTimeSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxFailureWaitSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLoginFailures": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minimumQuickLoginWaitSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "permanentLockout": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "quickLoginCheckMilliSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "waitIncrementSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "failureResetTimeSeconds",
                "maxFailureWaitSeconds",
                "maxLoginFailures",
                "minimumQuickLoginWaitSeconds",
                "permanentLockout",
                "quickLoginCheckMilliSeconds",
                "waitIncrementSeconds"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmSecurityDefenseHeader:getRealmSecurityDefenseHeader": {
            "properties": {
                "contentSecurityPolicy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contentSecurityPolicyReportOnly": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "strictTransportSecurity": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xContentTypeOptions": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xFrameOptions": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xRobotsTag": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xXssProtection": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "contentSecurityPolicy",
                "contentSecurityPolicyReportOnly",
                "strictTransportSecurity",
                "xContentTypeOptions",
                "xFrameOptions",
                "xRobotsTag",
                "xXssProtection"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmSmtpServer:getRealmSmtpServer": {
            "properties": {
                "auths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/getRealmSmtpServerAuth:getRealmSmtpServerAuth"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "envelopeFrom": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "from": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fromDisplayName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replyTo": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replyToDisplayName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssl": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "starttls": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "auths",
                "envelopeFrom",
                "from",
                "fromDisplayName",
                "host",
                "port",
                "replyTo",
                "replyToDisplayName",
                "ssl",
                "starttls"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmSmtpServerAuth:getRealmSmtpServerAuth": {
            "properties": {
                "password": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "password",
                "username"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmWebAuthnPasswordlessPolicy:getRealmWebAuthnPasswordlessPolicy": {
            "properties": {
                "acceptableAaguids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attestationConveyancePreference": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authenticatorAttachment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "avoidSameAuthenticatorRegister": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createTimeout": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "relyingPartyEntityName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "relyingPartyId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requireResidentKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "signatureAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userVerificationRequirement": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "acceptableAaguids",
                "attestationConveyancePreference",
                "authenticatorAttachment",
                "avoidSameAuthenticatorRegister",
                "createTimeout",
                "relyingPartyEntityName",
                "relyingPartyId",
                "requireResidentKey",
                "signatureAlgorithms",
                "userVerificationRequirement"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmWebAuthnPolicy:getRealmWebAuthnPolicy": {
            "properties": {
                "acceptableAaguids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attestationConveyancePreference": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authenticatorAttachment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "avoidSameAuthenticatorRegister": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createTimeout": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "relyingPartyEntityName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "relyingPartyId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requireResidentKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "signatureAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userVerificationRequirement": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "acceptableAaguids",
                "attestationConveyancePreference",
                "authenticatorAttachment",
                "avoidSameAuthenticatorRegister",
                "createTimeout",
                "relyingPartyEntityName",
                "relyingPartyId",
                "requireResidentKey",
                "signatureAlgorithms",
                "userVerificationRequirement"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:ldap/UserFederationCache:UserFederationCache": {
            "properties": {
                "evictionDay": {
                    "type": "integer",
                    "description": "Day of the week the entry will become invalid on\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "evictionHour": {
                    "type": "integer",
                    "description": "Hour of day the entry will become invalid on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "evictionMinute": {
                    "type": "integer",
                    "description": "Minute of day the entry will become invalid on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLifespan": {
                    "type": "string",
                    "description": "Max lifespan of cache entry (duration string).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policy": {
                    "type": "string",
                    "description": "Can be one of `DEFAULT`, `EVICT_DAILY`, `EVICT_WEEKLY`, `MAX_LIFESPAN`, or `NO_CACHE`. Defaults to `DEFAULT`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:ldap/UserFederationKerberos:UserFederationKerberos": {
            "properties": {
                "kerberosRealm": {
                    "type": "string",
                    "description": "The name of the kerberos realm, e.g. FOO.LOCAL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyTab": {
                    "type": "string",
                    "description": "Path to the kerberos keytab file on the server with credentials of the service principal.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serverPrincipal": {
                    "type": "string",
                    "description": "The kerberos server principal, e.g. 'HTTP/host.foo.com@FOO.LOCAL'.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "useKerberosForPasswordAuthentication": {
                    "type": "boolean",
                    "description": "Use kerberos login module instead of ldap service api. Defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "kerberosRealm",
                "keyTab",
                "serverPrincipal"
            ]
        },
        "keycloak:openid/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides": {
            "properties": {
                "browserId": {
                    "type": "string",
                    "description": "Browser flow id, (flow needs to exist)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "directGrantId": {
                    "type": "string",
                    "description": "Direct grant flow id (flow needs to exist)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:openid/ClientAuthorization:ClientAuthorization": {
            "properties": {
                "allowRemoteResourceManagement": {
                    "type": "boolean",
                    "description": "When `true`, resources can be managed remotely by the resource server. Defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "decisionStrategy": {
                    "type": "string",
                    "description": "Dictates how the policies associated with a given permission are evaluated and how a final decision is obtained. Could be one of `AFFIRMATIVE`, `CONSENSUS`, or `UNANIMOUS`. Applies to permissions.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keepDefaults": {
                    "type": "boolean",
                    "description": "When `true`, defaults set by Keycloak will be respected. Defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policyEnforcementMode": {
                    "type": "string",
                    "description": "Dictates how policies are enforced when evaluating authorization requests. Can be one of `ENFORCING`, `PERMISSIVE`, or `DISABLED`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "policyEnforcementMode"
            ]
        },
        "keycloak:openid/ClientGroupPolicyGroup:ClientGroupPolicyGroup": {
            "properties": {
                "extendChildren": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "extendChildren",
                "id",
                "path"
            ]
        },
        "keycloak:openid/ClientPermissionsConfigureScope:ClientPermissionsConfigureScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:openid/ClientPermissionsManageScope:ClientPermissionsManageScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:openid/ClientPermissionsMapRolesClientScopeScope:ClientPermissionsMapRolesClientScopeScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:openid/ClientPermissionsMapRolesCompositeScope:ClientPermissionsMapRolesCompositeScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:openid/ClientPermissionsMapRolesScope:ClientPermissionsMapRolesScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:openid/ClientPermissionsTokenExchangeScope:ClientPermissionsTokenExchangeScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:openid/ClientPermissionsViewScope:ClientPermissionsViewScope": {
            "properties": {
                "decisionStrategy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:openid/ClientRolePolicyRole:ClientRolePolicyRole": {
            "properties": {
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "required": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "id",
                "required"
            ]
        },
        "keycloak:openid/getClientAuthenticationFlowBindingOverride:getClientAuthenticationFlowBindingOverride": {
            "properties": {
                "browserId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "directGrantId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "browserId",
                "directGrantId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:openid/getClientAuthorization:getClientAuthorization": {
            "properties": {
                "allowRemoteResourceManagement": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "decisionStrategy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keepDefaults": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policyEnforcementMode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "allowRemoteResourceManagement",
                "decisionStrategy",
                "keepDefaults",
                "policyEnforcementMode"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:openid/getClientServiceAccountUserFederatedIdentity:getClientServiceAccountUserFederatedIdentity": {
            "properties": {
                "identityProvider": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "identityProvider",
                "userId",
                "userName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:saml/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides": {
            "properties": {
                "browserId": {
                    "type": "string",
                    "description": "Browser flow id, (flow needs to exist)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "directGrantId": {
                    "type": "string",
                    "description": "Direct grant flow id (flow needs to exist)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:saml/getClientAuthenticationFlowBindingOverride:getClientAuthenticationFlowBindingOverride": {
            "properties": {
                "browserId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "directGrantId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "browserId",
                "directGrantId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the keycloak package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "additionalHeaders": {
                "type": "object",
                "additionalProperties": {
                    "type": "string"
                }
            },
            "basePath": {
                "type": "string"
            },
            "clientId": {
                "type": "string"
            },
            "clientSecret": {
                "type": "string"
            },
            "clientTimeout": {
                "type": "integer",
                "description": "Timeout (in seconds) of the Keycloak client\n"
            },
            "initialLogin": {
                "type": "boolean",
                "description": "Whether or not to login to Keycloak instance on provider initialization\n"
            },
            "password": {
                "type": "string"
            },
            "realm": {
                "type": "string"
            },
            "rootCaCertificate": {
                "type": "string",
                "description": "Allows x509 calls using an unknown CA certificate (for development purposes)\n"
            },
            "tlsInsecureSkipVerify": {
                "type": "boolean",
                "description": "Allows ignoring insecure certificates when set to true. Defaults to false. Disabling security check is dangerous and\nshould be avoided.\n"
            },
            "url": {
                "type": "string",
                "description": "The base URL of the Keycloak instance, before `/auth`\n"
            },
            "username": {
                "type": "string"
            }
        },
        "required": [
            "clientId",
            "url"
        ],
        "inputProperties": {
            "additionalHeaders": {
                "type": "object",
                "additionalProperties": {
                    "type": "string"
                }
            },
            "basePath": {
                "type": "string"
            },
            "clientId": {
                "type": "string"
            },
            "clientSecret": {
                "type": "string"
            },
            "clientTimeout": {
                "type": "integer",
                "description": "Timeout (in seconds) of the Keycloak client\n",
                "default": 5,
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_CLIENT_TIMEOUT"
                    ]
                }
            },
            "initialLogin": {
                "type": "boolean",
                "description": "Whether or not to login to Keycloak instance on provider initialization\n"
            },
            "password": {
                "type": "string"
            },
            "realm": {
                "type": "string"
            },
            "rootCaCertificate": {
                "type": "string",
                "description": "Allows x509 calls using an unknown CA certificate (for development purposes)\n"
            },
            "tlsInsecureSkipVerify": {
                "type": "boolean",
                "description": "Allows ignoring insecure certificates when set to true. Defaults to false. Disabling security check is dangerous and\nshould be avoided.\n"
            },
            "url": {
                "type": "string",
                "description": "The base URL of the Keycloak instance, before `/auth`\n"
            },
            "username": {
                "type": "string"
            }
        },
        "requiredInputs": [
            "clientId",
            "url"
        ]
    },
    "resources": {
        "keycloak:authentication/execution:Execution": {
            "description": "Allows for creating and managing an authentication execution within Keycloak.\n\nAn authentication execution is an action that the user or service may or may not take when authenticating through an authentication\nflow.\n\n\u003e Due to limitations in the Keycloak API, the ordering of authentication executions within a flow must be specified using `depends_on`. Authentication executions that are created first will appear first within the flow.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst flow = new keycloak.authentication.Flow(\"flow\", {\n    realmId: realm.id,\n    alias: \"my-flow-alias\",\n});\n// first execution\nconst executionOne = new keycloak.authentication.Execution(\"executionOne\", {\n    realmId: realm.id,\n    parentFlowAlias: flow.alias,\n    authenticator: \"auth-cookie\",\n    requirement: \"ALTERNATIVE\",\n});\n// second execution\nconst executionTwo = new keycloak.authentication.Execution(\"executionTwo\", {\n    realmId: realm.id,\n    parentFlowAlias: flow.alias,\n    authenticator: \"identity-provider-redirector\",\n    requirement: \"ALTERNATIVE\",\n}, {\n    dependsOn: [executionOne],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nflow = keycloak.authentication.Flow(\"flow\",\n    realm_id=realm.id,\n    alias=\"my-flow-alias\")\n# first execution\nexecution_one = keycloak.authentication.Execution(\"executionOne\",\n    realm_id=realm.id,\n    parent_flow_alias=flow.alias,\n    authenticator=\"auth-cookie\",\n    requirement=\"ALTERNATIVE\")\n# second execution\nexecution_two = keycloak.authentication.Execution(\"executionTwo\",\n    realm_id=realm.id,\n    parent_flow_alias=flow.alias,\n    authenticator=\"identity-provider-redirector\",\n    requirement=\"ALTERNATIVE\",\n    opts=pulumi.ResourceOptions(depends_on=[execution_one]))\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var flow = new Keycloak.Authentication.Flow(\"flow\", new Keycloak.Authentication.FlowArgs\n        {\n            RealmId = realm.Id,\n            Alias = \"my-flow-alias\",\n        });\n        // first execution\n        var executionOne = new Keycloak.Authentication.Execution(\"executionOne\", new Keycloak.Authentication.ExecutionArgs\n        {\n            RealmId = realm.Id,\n            ParentFlowAlias = flow.Alias,\n            Authenticator = \"auth-cookie\",\n            Requirement = \"ALTERNATIVE\",\n        });\n        // second execution\n        var executionTwo = new Keycloak.Authentication.Execution(\"executionTwo\", new Keycloak.Authentication.ExecutionArgs\n        {\n            RealmId = realm.Id,\n            ParentFlowAlias = flow.Alias,\n            Authenticator = \"identity-provider-redirector\",\n            Requirement = \"ALTERNATIVE\",\n        }, new CustomResourceOptions\n        {\n            DependsOn = \n            {\n                executionOne,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/authentication\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tflow, err := authentication.NewFlow(ctx, \"flow\", \u0026authentication.FlowArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tAlias:   pulumi.String(\"my-flow-alias\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texecutionOne, err := authentication.NewExecution(ctx, \"executionOne\", \u0026authentication.ExecutionArgs{\n\t\t\tRealmId:         realm.ID(),\n\t\t\tParentFlowAlias: flow.Alias,\n\t\t\tAuthenticator:   pulumi.String(\"auth-cookie\"),\n\t\t\tRequirement:     pulumi.String(\"ALTERNATIVE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = authentication.NewExecution(ctx, \"executionTwo\", \u0026authentication.ExecutionArgs{\n\t\t\tRealmId:         realm.ID(),\n\t\t\tParentFlowAlias: flow.Alias,\n\t\t\tAuthenticator:   pulumi.String(\"identity-provider-redirector\"),\n\t\t\tRequirement:     pulumi.String(\"ALTERNATIVE\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\texecutionOne,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAuthentication executions can be imported using the formats`{{realmId}}/{{parentFlowAlias}}/{{authenticationExecutionId}}`. Examplebash\n\n```sh\n $ pulumi import keycloak:authentication/execution:Execution execution_one my-realm/my-flow-alias/30559fcf-6fb8-45ea-8c46-2b86f46ebc17\n```\n\n ",
            "properties": {
                "authenticator": {
                    "type": "string",
                    "description": "The name of the authenticator. This can be found by experimenting with the GUI and looking at HTTP requests within the network tab of your browser's development tools.\n"
                },
                "parentFlowAlias": {
                    "type": "string",
                    "description": "The alias of the flow this execution is attached to.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the authentication execution exists in.\n"
                },
                "requirement": {
                    "type": "string",
                    "description": "The requirement setting, which can be one of `REQUIRED`, `ALTERNATIVE`, `OPTIONAL`, `CONDITIONAL`, or `DISABLED`. Defaults to `DISABLED`.\n"
                }
            },
            "required": [
                "authenticator",
                "parentFlowAlias",
                "realmId"
            ],
            "inputProperties": {
                "authenticator": {
                    "type": "string",
                    "description": "The name of the authenticator. This can be found by experimenting with the GUI and looking at HTTP requests within the network tab of your browser's development tools.\n"
                },
                "parentFlowAlias": {
                    "type": "string",
                    "description": "The alias of the flow this execution is attached to.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the authentication execution exists in.\n"
                },
                "requirement": {
                    "type": "string",
                    "description": "The requirement setting, which can be one of `REQUIRED`, `ALTERNATIVE`, `OPTIONAL`, `CONDITIONAL`, or `DISABLED`. Defaults to `DISABLED`.\n"
                }
            },
            "requiredInputs": [
                "authenticator",
                "parentFlowAlias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Execution resources.\n",
                "properties": {
                    "authenticator": {
                        "type": "string",
                        "description": "The name of the authenticator. This can be found by experimenting with the GUI and looking at HTTP requests within the network tab of your browser's development tools.\n"
                    },
                    "parentFlowAlias": {
                        "type": "string",
                        "description": "The alias of the flow this execution is attached to.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm the authentication execution exists in.\n"
                    },
                    "requirement": {
                        "type": "string",
                        "description": "The requirement setting, which can be one of `REQUIRED`, `ALTERNATIVE`, `OPTIONAL`, `CONDITIONAL`, or `DISABLED`. Defaults to `DISABLED`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:authentication/executionConfig:ExecutionConfig": {
            "description": "Allows for managing an authentication execution's configuration. If a particular authentication execution supports additional\nconfiguration (such as with the `identity-provider-redirector` execution), this can be managed with this resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst flow = new keycloak.authentication.Flow(\"flow\", {\n    realmId: realm.id,\n    alias: \"my-flow-alias\",\n});\nconst execution = new keycloak.authentication.Execution(\"execution\", {\n    realmId: realm.id,\n    parentFlowAlias: flow.alias,\n    authenticator: \"identity-provider-redirector\",\n});\nconst config = new keycloak.authentication.ExecutionConfig(\"config\", {\n    realmId: realm.id,\n    executionId: execution.id,\n    alias: \"my-config-alias\",\n    config: {\n        defaultProvider: \"my-config-default-idp\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nflow = keycloak.authentication.Flow(\"flow\",\n    realm_id=realm.id,\n    alias=\"my-flow-alias\")\nexecution = keycloak.authentication.Execution(\"execution\",\n    realm_id=realm.id,\n    parent_flow_alias=flow.alias,\n    authenticator=\"identity-provider-redirector\")\nconfig = keycloak.authentication.ExecutionConfig(\"config\",\n    realm_id=realm.id,\n    execution_id=execution.id,\n    alias=\"my-config-alias\",\n    config={\n        \"defaultProvider\": \"my-config-default-idp\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var flow = new Keycloak.Authentication.Flow(\"flow\", new Keycloak.Authentication.FlowArgs\n        {\n            RealmId = realm.Id,\n            Alias = \"my-flow-alias\",\n        });\n        var execution = new Keycloak.Authentication.Execution(\"execution\", new Keycloak.Authentication.ExecutionArgs\n        {\n            RealmId = realm.Id,\n            ParentFlowAlias = flow.Alias,\n            Authenticator = \"identity-provider-redirector\",\n        });\n        var config = new Keycloak.Authentication.ExecutionConfig(\"config\", new Keycloak.Authentication.ExecutionConfigArgs\n        {\n            RealmId = realm.Id,\n            ExecutionId = execution.Id,\n            Alias = \"my-config-alias\",\n            Config = \n            {\n                { \"defaultProvider\", \"my-config-default-idp\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/authentication\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tflow, err := authentication.NewFlow(ctx, \"flow\", \u0026authentication.FlowArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tAlias:   pulumi.String(\"my-flow-alias\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texecution, err := authentication.NewExecution(ctx, \"execution\", \u0026authentication.ExecutionArgs{\n\t\t\tRealmId:         realm.ID(),\n\t\t\tParentFlowAlias: flow.Alias,\n\t\t\tAuthenticator:   pulumi.String(\"identity-provider-redirector\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = authentication.NewExecutionConfig(ctx, \"config\", \u0026authentication.ExecutionConfigArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tExecutionId: execution.ID(),\n\t\t\tAlias:       pulumi.String(\"my-config-alias\"),\n\t\t\tConfig: pulumi.StringMap{\n\t\t\t\t\"defaultProvider\": pulumi.String(\"my-config-default-idp\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nConfigurations can be imported using the format `{{realm}}/{{authenticationExecutionId}}/{{authenticationExecutionConfigId}}`. If the `authenticationExecutionId` is incorrect, the import will still be successful. A subsequent apply will change the `authenticationExecutionId` to the correct one, which causes the configuration to be replaced. Examplebash\n\n```sh\n $ pulumi import keycloak:authentication/executionConfig:ExecutionConfig config my-realm/be081463-ddbf-4b42-9eff-9c97886f24ff/30559fcf-6fb8-45ea-8c46-2b86f46ebc17\n```\n\n ",
            "properties": {
                "alias": {
                    "type": "string",
                    "description": "The name of the configuration.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The configuration. Keys are specific to each configurable authentication execution and not checked when applying.\n"
                },
                "executionId": {
                    "type": "string",
                    "description": "The authentication execution this configuration is attached to.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the authentication execution exists in.\n"
                }
            },
            "required": [
                "alias",
                "config",
                "executionId",
                "realmId"
            ],
            "inputProperties": {
                "alias": {
                    "type": "string",
                    "description": "The name of the configuration.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The configuration. Keys are specific to each configurable authentication execution and not checked when applying.\n"
                },
                "executionId": {
                    "type": "string",
                    "description": "The authentication execution this configuration is attached to.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the authentication execution exists in.\n"
                }
            },
            "requiredInputs": [
                "alias",
                "config",
                "executionId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ExecutionConfig resources.\n",
                "properties": {
                    "alias": {
                        "type": "string",
                        "description": "The name of the configuration.\n"
                    },
                    "config": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The configuration. Keys are specific to each configurable authentication execution and not checked when applying.\n"
                    },
                    "executionId": {
                        "type": "string",
                        "description": "The authentication execution this configuration is attached to.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm the authentication execution exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:authentication/flow:Flow": {
            "description": "Allows for creating and managing an authentication flow within Keycloak.\n\n[Authentication flows](https://www.keycloak.org/docs/11.0/server_admin/index.html#_authentication-flows) describe a sequence\nof actions that a user or service must perform in order to be authenticated to Keycloak. The authentication flow itself\nis a container for these actions, which are otherwise known as executions.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst flow = new keycloak.authentication.Flow(\"flow\", {\n    realmId: realm.id,\n    alias: \"my-flow-alias\",\n});\nconst execution = new keycloak.authentication.Execution(\"execution\", {\n    realmId: realm.id,\n    parentFlowAlias: flow.alias,\n    authenticator: \"identity-provider-redirector\",\n    requirement: \"REQUIRED\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nflow = keycloak.authentication.Flow(\"flow\",\n    realm_id=realm.id,\n    alias=\"my-flow-alias\")\nexecution = keycloak.authentication.Execution(\"execution\",\n    realm_id=realm.id,\n    parent_flow_alias=flow.alias,\n    authenticator=\"identity-provider-redirector\",\n    requirement=\"REQUIRED\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var flow = new Keycloak.Authentication.Flow(\"flow\", new Keycloak.Authentication.FlowArgs\n        {\n            RealmId = realm.Id,\n            Alias = \"my-flow-alias\",\n        });\n        var execution = new Keycloak.Authentication.Execution(\"execution\", new Keycloak.Authentication.ExecutionArgs\n        {\n            RealmId = realm.Id,\n            ParentFlowAlias = flow.Alias,\n            Authenticator = \"identity-provider-redirector\",\n            Requirement = \"REQUIRED\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/authentication\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tflow, err := authentication.NewFlow(ctx, \"flow\", \u0026authentication.FlowArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tAlias:   pulumi.String(\"my-flow-alias\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = authentication.NewExecution(ctx, \"execution\", \u0026authentication.ExecutionArgs{\n\t\t\tRealmId:         realm.ID(),\n\t\t\tParentFlowAlias: flow.Alias,\n\t\t\tAuthenticator:   pulumi.String(\"identity-provider-redirector\"),\n\t\t\tRequirement:     pulumi.String(\"REQUIRED\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAuthentication flows can be imported using the format `{{realmId}}/{{authenticationFlowId}}`. The authentication flow ID is typically a GUID which is autogenerated when the flow is created via Keycloak. Unfortunately, it is not trivial to retrieve the authentication flow ID from the UI. The best way to do this is to visit the \"Authentication\" page in Keycloak, and use the network tab of your browser to view the response of the API call to `/auth/admin/realms/${realm}/authentication/flows`, which will be a list of authentication flows. Examplebash\n\n```sh\n $ pulumi import keycloak:authentication/flow:Flow flow my-realm/e9a5641e-778c-4daf-89c0-f4ef617987d1\n```\n\n ",
            "properties": {
                "alias": {
                    "type": "string",
                    "description": "The alias for this authentication flow.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the authentication flow.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The type of authentication flow to create. Valid choices include `basic-flow` and `client-flow`. Defaults to `basic-flow`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that the authentication flow exists in.\n"
                }
            },
            "required": [
                "alias",
                "realmId"
            ],
            "inputProperties": {
                "alias": {
                    "type": "string",
                    "description": "The alias for this authentication flow.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the authentication flow.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The type of authentication flow to create. Valid choices include `basic-flow` and `client-flow`. Defaults to `basic-flow`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that the authentication flow exists in.\n"
                }
            },
            "requiredInputs": [
                "alias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Flow resources.\n",
                "properties": {
                    "alias": {
                        "type": "string",
                        "description": "The alias for this authentication flow.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description for the authentication flow.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The type of authentication flow to create. Valid choices include `basic-flow` and `client-flow`. Defaults to `basic-flow`.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that the authentication flow exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:authentication/subflow:Subflow": {
            "properties": {
                "alias": {
                    "type": "string"
                },
                "authenticator": {
                    "type": "string",
                    "description": "Might be needed to be set with certain custom subflow with specific authenticator, in general this will remain empty\n"
                },
                "description": {
                    "type": "string"
                },
                "parentFlowAlias": {
                    "type": "string"
                },
                "providerId": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "requirement": {
                    "type": "string"
                }
            },
            "required": [
                "alias",
                "parentFlowAlias",
                "realmId"
            ],
            "inputProperties": {
                "alias": {
                    "type": "string"
                },
                "authenticator": {
                    "type": "string",
                    "description": "Might be needed to be set with certain custom subflow with specific authenticator, in general this will remain empty\n"
                },
                "description": {
                    "type": "string"
                },
                "parentFlowAlias": {
                    "type": "string"
                },
                "providerId": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "requirement": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "alias",
                "parentFlowAlias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Subflow resources.\n",
                "properties": {
                    "alias": {
                        "type": "string"
                    },
                    "authenticator": {
                        "type": "string",
                        "description": "Might be needed to be set with certain custom subflow with specific authenticator, in general this will remain empty\n"
                    },
                    "description": {
                        "type": "string"
                    },
                    "parentFlowAlias": {
                        "type": "string"
                    },
                    "providerId": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "requirement": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/attributeImporterIdentityProviderMapper:AttributeImporterIdentityProviderMapper": {
            "description": "Allows for creating and managing an attribute importer identity provider mapper within Keycloak.\n\nThe attribute importer mapper can be used to map attributes from externally defined users to attributes or properties of the imported Keycloak user:\n- For the OIDC identity provider, this will map a claim on the ID or access token to an attribute for the imported Keycloak user.\n- For the SAML identity provider, this will map a SAML attribute found within the assertion to an attribute for the imported Keycloak user.\n- For social identity providers, this will map a JSON field from the user profile to an attribute for the imported Keycloak user.\n\n\u003e If you are using Keycloak 10 or higher, you will need to specify the `extra_config` argument in order to define a `syncMode` for the mapper.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst oidcIdentityProvider = new keycloak.oidc.IdentityProvider(\"oidcIdentityProvider\", {\n    realm: realm.id,\n    alias: \"oidc\",\n    authorizationUrl: \"https://example.com/auth\",\n    tokenUrl: \"https://example.com/token\",\n    clientId: \"example_id\",\n    clientSecret: \"example_token\",\n    defaultScopes: \"openid random profile\",\n});\nconst oidcAttributeImporterIdentityProviderMapper = new keycloak.AttributeImporterIdentityProviderMapper(\"oidcAttributeImporterIdentityProviderMapper\", {\n    realm: realm.id,\n    claimName: \"my-email-claim\",\n    identityProviderAlias: oidcIdentityProvider.alias,\n    userAttribute: \"email\",\n    extraConfig: {\n        syncMode: \"INHERIT\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\noidc_identity_provider = keycloak.oidc.IdentityProvider(\"oidcIdentityProvider\",\n    realm=realm.id,\n    alias=\"oidc\",\n    authorization_url=\"https://example.com/auth\",\n    token_url=\"https://example.com/token\",\n    client_id=\"example_id\",\n    client_secret=\"example_token\",\n    default_scopes=\"openid random profile\")\noidc_attribute_importer_identity_provider_mapper = keycloak.AttributeImporterIdentityProviderMapper(\"oidcAttributeImporterIdentityProviderMapper\",\n    realm=realm.id,\n    claim_name=\"my-email-claim\",\n    identity_provider_alias=oidc_identity_provider.alias,\n    user_attribute=\"email\",\n    extra_config={\n        \"syncMode\": \"INHERIT\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var oidcIdentityProvider = new Keycloak.Oidc.IdentityProvider(\"oidcIdentityProvider\", new Keycloak.Oidc.IdentityProviderArgs\n        {\n            Realm = realm.Id,\n            Alias = \"oidc\",\n            AuthorizationUrl = \"https://example.com/auth\",\n            TokenUrl = \"https://example.com/token\",\n            ClientId = \"example_id\",\n            ClientSecret = \"example_token\",\n            DefaultScopes = \"openid random profile\",\n        });\n        var oidcAttributeImporterIdentityProviderMapper = new Keycloak.AttributeImporterIdentityProviderMapper(\"oidcAttributeImporterIdentityProviderMapper\", new Keycloak.AttributeImporterIdentityProviderMapperArgs\n        {\n            Realm = realm.Id,\n            ClaimName = \"my-email-claim\",\n            IdentityProviderAlias = oidcIdentityProvider.Alias,\n            UserAttribute = \"email\",\n            ExtraConfig = \n            {\n                { \"syncMode\", \"INHERIT\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/oidc\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\toidcIdentityProvider, err := oidc.NewIdentityProvider(ctx, \"oidcIdentityProvider\", \u0026oidc.IdentityProviderArgs{\n\t\t\tRealm:            realm.ID(),\n\t\t\tAlias:            pulumi.String(\"oidc\"),\n\t\t\tAuthorizationUrl: pulumi.String(\"https://example.com/auth\"),\n\t\t\tTokenUrl:         pulumi.String(\"https://example.com/token\"),\n\t\t\tClientId:         pulumi.String(\"example_id\"),\n\t\t\tClientSecret:     pulumi.String(\"example_token\"),\n\t\t\tDefaultScopes:    pulumi.String(\"openid random profile\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewAttributeImporterIdentityProviderMapper(ctx, \"oidcAttributeImporterIdentityProviderMapper\", \u0026keycloak.AttributeImporterIdentityProviderMapperArgs{\n\t\t\tRealm:                 realm.ID(),\n\t\t\tClaimName:             pulumi.String(\"my-email-claim\"),\n\t\t\tIdentityProviderAlias: oidcIdentityProvider.Alias,\n\t\t\tUserAttribute:         pulumi.String(\"email\"),\n\t\t\tExtraConfig: pulumi.AnyMap{\n\t\t\t\t\"syncMode\": pulumi.Any(\"INHERIT\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nIdentity provider mappers can be imported using the format `{{realm_id}}/{{idp_alias}}/{{idp_mapper_id}}`, where `idp_alias` is the identity provider alias, and `idp_mapper_id` is the unique ID that Keycloak assigns to the mapper upon creation. This value can be found in the URI when editing this mapper in the GUI, and is typically a GUID. Examplebash\n\n```sh\n $ pulumi import keycloak:index/attributeImporterIdentityProviderMapper:AttributeImporterIdentityProviderMapper test_mapper my-realm/my-mapper/f446db98-7133-4e30-b18a-3d28fde7ca1b\n```\n\n ",
            "properties": {
                "attributeFriendlyName": {
                    "type": "string",
                    "description": "For SAML based providers, this is the friendly name of the attribute to search for in the assertion. Conflicts with `attribute_name`.\n"
                },
                "attributeName": {
                    "type": "string",
                    "description": "For SAML based providers, this is the name of the attribute to search for in the assertion. Conflicts with `attribute_friendly_name`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "For OIDC based providers, this is the name of the claim to use.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "The alias of the associated identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the mapper.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm.\n"
                },
                "userAttribute": {
                    "type": "string",
                    "description": "The user attribute or property name to store the mapped result.\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm",
                "userAttribute"
            ],
            "inputProperties": {
                "attributeFriendlyName": {
                    "type": "string",
                    "description": "For SAML based providers, this is the friendly name of the attribute to search for in the assertion. Conflicts with `attribute_name`.\n"
                },
                "attributeName": {
                    "type": "string",
                    "description": "For SAML based providers, this is the name of the attribute to search for in the assertion. Conflicts with `attribute_friendly_name`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "For OIDC based providers, this is the name of the claim to use.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "The alias of the associated identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the mapper.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm.\n"
                },
                "userAttribute": {
                    "type": "string",
                    "description": "The user attribute or property name to store the mapped result.\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm",
                "userAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AttributeImporterIdentityProviderMapper resources.\n",
                "properties": {
                    "attributeFriendlyName": {
                        "type": "string",
                        "description": "For SAML based providers, this is the friendly name of the attribute to search for in the assertion. Conflicts with `attribute_name`.\n"
                    },
                    "attributeName": {
                        "type": "string",
                        "description": "For SAML based providers, this is the name of the attribute to search for in the assertion. Conflicts with `attribute_friendly_name`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "For OIDC based providers, this is the name of the claim to use.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "The alias of the associated identity provider.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the mapper.\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "The name of the realm.\n"
                    },
                    "userAttribute": {
                        "type": "string",
                        "description": "The user attribute or property name to store the mapped result.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/attributeToRoleIdentityMapper:AttributeToRoleIdentityMapper": {
            "properties": {
                "attributeFriendlyName": {
                    "type": "string",
                    "description": "Attribute Friendly Name\n"
                },
                "attributeName": {
                    "type": "string",
                    "description": "Attribute Name\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "Attribute Value\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "OIDC Claim Name\n"
                },
                "claimValue": {
                    "type": "string",
                    "description": "OIDC Claim Value\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role Name\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm",
                "role"
            ],
            "inputProperties": {
                "attributeFriendlyName": {
                    "type": "string",
                    "description": "Attribute Friendly Name\n"
                },
                "attributeName": {
                    "type": "string",
                    "description": "Attribute Name\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "Attribute Value\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "OIDC Claim Name\n"
                },
                "claimValue": {
                    "type": "string",
                    "description": "OIDC Claim Value\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role Name\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm",
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AttributeToRoleIdentityMapper resources.\n",
                "properties": {
                    "attributeFriendlyName": {
                        "type": "string",
                        "description": "Attribute Friendly Name\n"
                    },
                    "attributeName": {
                        "type": "string",
                        "description": "Attribute Name\n"
                    },
                    "attributeValue": {
                        "type": "string",
                        "description": "Attribute Value\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "OIDC Claim Name\n"
                    },
                    "claimValue": {
                        "type": "string",
                        "description": "OIDC Claim Value\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "IDP Alias\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "IDP Mapper Name\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "Realm Name\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Role Name\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/customIdentityProviderMapping:CustomIdentityProviderMapping": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst oidcIdentityProvider = new keycloak.oidc.IdentityProvider(\"oidcIdentityProvider\", {\n    realm: realm.id,\n    alias: \"oidc\",\n    authorizationUrl: \"https://example.com/auth\",\n    tokenUrl: \"https://example.com/token\",\n    clientId: \"example_id\",\n    clientSecret: \"example_token\",\n    defaultScopes: \"openid random profile\",\n});\nconst oidcCustomIdentityProviderMapping = new keycloak.CustomIdentityProviderMapping(\"oidcCustomIdentityProviderMapping\", {\n    realm: realm.id,\n    identityProviderAlias: oidcIdentityProvider.alias,\n    identityProviderMapper: `%s-user-attribute-idp-mapper`,\n    extraConfig: {\n        syncMode: \"INHERIT\",\n        Claim: \"my-email-claim\",\n        UserAttribute: \"email\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\noidc_identity_provider = keycloak.oidc.IdentityProvider(\"oidcIdentityProvider\",\n    realm=realm.id,\n    alias=\"oidc\",\n    authorization_url=\"https://example.com/auth\",\n    token_url=\"https://example.com/token\",\n    client_id=\"example_id\",\n    client_secret=\"example_token\",\n    default_scopes=\"openid random profile\")\noidc_custom_identity_provider_mapping = keycloak.CustomIdentityProviderMapping(\"oidcCustomIdentityProviderMapping\",\n    realm=realm.id,\n    identity_provider_alias=oidc_identity_provider.alias,\n    identity_provider_mapper=\"%s-user-attribute-idp-mapper\",\n    extra_config={\n        \"syncMode\": \"INHERIT\",\n        \"Claim\": \"my-email-claim\",\n        \"UserAttribute\": \"email\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var oidcIdentityProvider = new Keycloak.Oidc.IdentityProvider(\"oidcIdentityProvider\", new Keycloak.Oidc.IdentityProviderArgs\n        {\n            Realm = realm.Id,\n            Alias = \"oidc\",\n            AuthorizationUrl = \"https://example.com/auth\",\n            TokenUrl = \"https://example.com/token\",\n            ClientId = \"example_id\",\n            ClientSecret = \"example_token\",\n            DefaultScopes = \"openid random profile\",\n        });\n        var oidcCustomIdentityProviderMapping = new Keycloak.CustomIdentityProviderMapping(\"oidcCustomIdentityProviderMapping\", new Keycloak.CustomIdentityProviderMappingArgs\n        {\n            Realm = realm.Id,\n            IdentityProviderAlias = oidcIdentityProvider.Alias,\n            IdentityProviderMapper = \"%s-user-attribute-idp-mapper\",\n            ExtraConfig = \n            {\n                { \"syncMode\", \"INHERIT\" },\n                { \"Claim\", \"my-email-claim\" },\n                { \"UserAttribute\", \"email\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/oidc\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\toidcIdentityProvider, err := oidc.NewIdentityProvider(ctx, \"oidcIdentityProvider\", \u0026oidc.IdentityProviderArgs{\n\t\t\tRealm:            realm.ID(),\n\t\t\tAlias:            pulumi.String(\"oidc\"),\n\t\t\tAuthorizationUrl: pulumi.String(\"https://example.com/auth\"),\n\t\t\tTokenUrl:         pulumi.String(\"https://example.com/token\"),\n\t\t\tClientId:         pulumi.String(\"example_id\"),\n\t\t\tClientSecret:     pulumi.String(\"example_token\"),\n\t\t\tDefaultScopes:    pulumi.String(\"openid random profile\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewCustomIdentityProviderMapping(ctx, \"oidcCustomIdentityProviderMapping\", \u0026keycloak.CustomIdentityProviderMappingArgs{\n\t\t\tRealm:                  realm.ID(),\n\t\t\tIdentityProviderAlias:  oidcIdentityProvider.Alias,\n\t\t\tIdentityProviderMapper: pulumi.String(fmt.Sprintf(\"%v%v\", \"%\", \"s-user-attribute-idp-mapper\")),\n\t\t\tExtraConfig: pulumi.AnyMap{\n\t\t\t\t\"syncMode\":      pulumi.Any(\"INHERIT\"),\n\t\t\t\t\"Claim\":         pulumi.Any(\"my-email-claim\"),\n\t\t\t\t\"UserAttribute\": pulumi.Any(\"email\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nIdentity provider mappers can be imported using the format `{{realm_id}}/{{idp_alias}}/{{idp_mapper_id}}`, where `idp_alias` is the identity provider alias, and `idp_mapper_id` is the unique ID that Keycloak assigns to the mapper upon creation. This value can be found in the URI when editing this mapper in the GUI, and is typically a GUID. Examplebash\n\n```sh\n $ pulumi import keycloak:index/customIdentityProviderMapping:CustomIdentityProviderMapping test_mapper my-realm/my-mapper/f446db98-7133-4e30-b18a-3d28fde7ca1b\n```\n\n ",
            "properties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "The alias of the associated identity provider.\n"
                },
                "identityProviderMapper": {
                    "type": "string",
                    "description": "The type of the identity provider mapper. This can be a format string that includes a `%s` - this will be replaced by the provider id.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the mapper.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm.\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "identityProviderMapper",
                "name",
                "realm"
            ],
            "inputProperties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "The alias of the associated identity provider.\n"
                },
                "identityProviderMapper": {
                    "type": "string",
                    "description": "The type of the identity provider mapper. This can be a format string that includes a `%s` - this will be replaced by the provider id.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the mapper.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm.\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "identityProviderMapper",
                "realm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomIdentityProviderMapping resources.\n",
                "properties": {
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "The alias of the associated identity provider.\n"
                    },
                    "identityProviderMapper": {
                        "type": "string",
                        "description": "The type of the identity provider mapper. This can be a format string that includes a `%s` - this will be replaced by the provider id.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the mapper.\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "The name of the realm.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/customUserFederation:CustomUserFederation": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"test\",\n    enabled: true,\n});\nconst customUserFederation = new keycloak.CustomUserFederation(\"customUserFederation\", {\n    realmId: realm.id,\n    providerId: \"custom\",\n    enabled: true,\n    config: {\n        dummyString: \"foobar\",\n        dummyBool: true,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"test\",\n    enabled=True)\ncustom_user_federation = keycloak.CustomUserFederation(\"customUserFederation\",\n    realm_id=realm.id,\n    provider_id=\"custom\",\n    enabled=True,\n    config={\n        \"dummyString\": \"foobar\",\n        \"dummyBool\": True,\n    })\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"test\",\n            Enabled = true,\n        });\n        var customUserFederation = new Keycloak.CustomUserFederation(\"customUserFederation\", new Keycloak.CustomUserFederationArgs\n        {\n            RealmId = realm.Id,\n            ProviderId = \"custom\",\n            Enabled = true,\n            Config = \n            {\n                { \"dummyString\", \"foobar\" },\n                { \"dummyBool\", true },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"test\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewCustomUserFederation(ctx, \"customUserFederation\", \u0026keycloak.CustomUserFederationArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tProviderId: pulumi.String(\"custom\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tConfig: pulumi.AnyMap{\n\t\t\t\t\"dummyString\": pulumi.Any(\"foobar\"),\n\t\t\t\t\"dummyBool\":   pulumi.Any(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nCustom user federation providers can be imported using the format `{{realm_id}}/{{custom_user_federation_id}}`. The ID of the custom user federation provider can be found within the Keycloak GUI and is typically a GUIDbash\n\n```sh\n $ pulumi import keycloak:index/customUserFederation:CustomUserFederation custom_user_federation my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860\n```\n\n ",
            "properties": {
                "cachePolicy": {
                    "type": "string",
                    "description": "Can be one of `DEFAULT`, `EVICT_DAILY`, `EVICT_WEEKLY`, `MAX_LIFESPAN`, or `NO_CACHE`. Defaults to `DEFAULT`.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "The provider configuration handed over to your custom user federation provider.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, this provider will not be used when performing queries for users. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the provider when displayed in the console.\n"
                },
                "parentId": {
                    "type": "string",
                    "description": "Must be set to the realms' `internal_id`  when it differs from the realm. This can happen when existing resources are imported into the state.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of this provider when looking up users. Lower values are first. Defaults to `0`.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The unique ID of the custom provider, specified in the `getId` implementation for the `UserStorageProviderFactory` interface.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this provider will provide user federation for.\n"
                }
            },
            "required": [
                "name",
                "providerId",
                "realmId"
            ],
            "inputProperties": {
                "cachePolicy": {
                    "type": "string",
                    "description": "Can be one of `DEFAULT`, `EVICT_DAILY`, `EVICT_WEEKLY`, `MAX_LIFESPAN`, or `NO_CACHE`. Defaults to `DEFAULT`.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "The provider configuration handed over to your custom user federation provider.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, this provider will not be used when performing queries for users. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the provider when displayed in the console.\n"
                },
                "parentId": {
                    "type": "string",
                    "description": "Must be set to the realms' `internal_id`  when it differs from the realm. This can happen when existing resources are imported into the state.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of this provider when looking up users. Lower values are first. Defaults to `0`.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The unique ID of the custom provider, specified in the `getId` implementation for the `UserStorageProviderFactory` interface.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this provider will provide user federation for.\n"
                }
            },
            "requiredInputs": [
                "providerId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomUserFederation resources.\n",
                "properties": {
                    "cachePolicy": {
                        "type": "string",
                        "description": "Can be one of `DEFAULT`, `EVICT_DAILY`, `EVICT_WEEKLY`, `MAX_LIFESPAN`, or `NO_CACHE`. Defaults to `DEFAULT`.\n"
                    },
                    "config": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "The provider configuration handed over to your custom user federation provider.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, this provider will not be used when performing queries for users. Defaults to `true`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the provider when displayed in the console.\n"
                    },
                    "parentId": {
                        "type": "string",
                        "description": "Must be set to the realms' `internal_id`  when it differs from the realm. This can happen when existing resources are imported into the state.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority of this provider when looking up users. Lower values are first. Defaults to `0`.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The unique ID of the custom provider, specified in the `getId` implementation for the `UserStorageProviderFactory` interface.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this provider will provide user federation for.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/defaultGroups:DefaultGroups": {
            "description": "Allows for managing a realm's default groups.\n\n\u003e You should not use `keycloak.DefaultGroups` with a group whose members are managed by `keycloak.GroupMemberships`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst group = new keycloak.Group(\"group\", {realmId: realm.id});\nconst _default = new keycloak.DefaultGroups(\"default\", {\n    realmId: realm.id,\n    groupIds: [group.id],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\ngroup = keycloak.Group(\"group\", realm_id=realm.id)\ndefault = keycloak.DefaultGroups(\"default\",\n    realm_id=realm.id,\n    group_ids=[group.id])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var @group = new Keycloak.Group(\"group\", new Keycloak.GroupArgs\n        {\n            RealmId = realm.Id,\n        });\n        var @default = new Keycloak.DefaultGroups(\"default\", new Keycloak.DefaultGroupsArgs\n        {\n            RealmId = realm.Id,\n            GroupIds = \n            {\n                @group.Id,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgroup, err := keycloak.NewGroup(ctx, \"group\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewDefaultGroups(ctx, \"default\", \u0026keycloak.DefaultGroupsArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tGroupIds: pulumi.StringArray{\n\t\t\t\tgroup.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nDefault groups can be imported using the format `{{realm_id}}` where `realm_id` is the realm the group exists in. Examplebash\n\n```sh\n $ pulumi import keycloak:index/defaultGroups:DefaultGroups default my-realm\n```\n\n ",
            "properties": {
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of group ids that should be default groups on the realm referenced by `realm_id`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n"
                }
            },
            "required": [
                "groupIds",
                "realmId"
            ],
            "inputProperties": {
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of group ids that should be default groups on the realm referenced by `realm_id`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n"
                }
            },
            "requiredInputs": [
                "groupIds",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DefaultGroups resources.\n",
                "properties": {
                    "groupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of group ids that should be default groups on the realm referenced by `realm_id`.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this group exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/defaultRoles:DefaultRoles": {
            "description": "Allows managing default realm roles within Keycloak.\n\nNote: This feature was added in Keycloak v13, so this resource will not work on older versions of Keycloak.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Realm Role)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst defalutRoles = new keycloak.DefaultRoles(\"defalutRoles\", {\n    realmId: realm.id,\n    defaultRoles: [\"uma_authorization\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\ndefalut_roles = keycloak.DefaultRoles(\"defalutRoles\",\n    realm_id=realm.id,\n    default_roles=[\"uma_authorization\"])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var defalutRoles = new Keycloak.DefaultRoles(\"defalutRoles\", new Keycloak.DefaultRolesArgs\n        {\n            RealmId = realm.Id,\n            DefaultRoles = \n            {\n                \"uma_authorization\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewDefaultRoles(ctx, \"defalutRoles\", \u0026keycloak.DefaultRolesArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tDefaultRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"uma_authorization\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nDefault roles can be imported using the format `{{realm_id}}/{{default_role_id}}`, where `default_role_id` is the unique ID of the composite role that Keycloak uses to control default realm level roles. The ID is not easy to find in the GUI, but it appears in the dev tools when editing the default roles. Examplebash\n\n```sh\n $ pulumi import keycloak:index/defaultRoles:DefaultRoles default_roles my-realm/a04c35c2-e95a-4dc5-bd32-e83a21be9e7d\n```\n\n ",
            "properties": {
                "defaultRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Realm level roles assigned to new users by default.\n",
                    "language": {
                        "csharp": {
                            "name": "RoleNames"
                        }
                    }
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this role exists within.\n"
                }
            },
            "required": [
                "defaultRoles",
                "realmId"
            ],
            "inputProperties": {
                "defaultRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Realm level roles assigned to new users by default.\n",
                    "language": {
                        "csharp": {
                            "name": "RoleNames"
                        }
                    }
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this role exists within.\n"
                }
            },
            "requiredInputs": [
                "defaultRoles",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DefaultRoles resources.\n",
                "properties": {
                    "defaultRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Realm level roles assigned to new users by default.\n",
                        "language": {
                            "csharp": {
                                "name": "RoleNames"
                            }
                        }
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this role exists within.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/genericClientProtocolMapper:GenericClientProtocolMapper": {
            "description": "Allows for creating and managing protocol mappers for both types of clients (openid-connect and saml) within Keycloak.\n\nThere are two uses cases for using this resource:\n* If you implemented a custom protocol mapper, this resource can be used to configure it\n* If the provider doesn't support a particular protocol mapper, this resource can be used instead.\n\nDue to the generic nature of this mapper, it is less user-friendly and more prone to configuration errors.\nTherefore, if possible, a specific mapper should be used.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClient = new keycloak.saml.Client(\"samlClient\", {\n    realmId: realm.id,\n    clientId: \"test-client\",\n});\nconst samlHardcodeAttributeMapper = new keycloak.GenericClientProtocolMapper(\"samlHardcodeAttributeMapper\", {\n    realmId: realm.id,\n    clientId: samlClient.id,\n    protocol: \"saml\",\n    protocolMapper: \"saml-hardcode-attribute-mapper\",\n    config: {\n        \"attribute.name\": \"name\",\n        \"attribute.nameformat\": \"Basic\",\n        \"attribute.value\": \"value\",\n        \"friendly.name\": \"display name\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client = keycloak.saml.Client(\"samlClient\",\n    realm_id=realm.id,\n    client_id=\"test-client\")\nsaml_hardcode_attribute_mapper = keycloak.GenericClientProtocolMapper(\"samlHardcodeAttributeMapper\",\n    realm_id=realm.id,\n    client_id=saml_client.id,\n    protocol=\"saml\",\n    protocol_mapper=\"saml-hardcode-attribute-mapper\",\n    config={\n        \"attribute.name\": \"name\",\n        \"attribute.nameformat\": \"Basic\",\n        \"attribute.value\": \"value\",\n        \"friendly.name\": \"display name\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var samlClient = new Keycloak.Saml.Client(\"samlClient\", new Keycloak.Saml.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"test-client\",\n        });\n        var samlHardcodeAttributeMapper = new Keycloak.GenericClientProtocolMapper(\"samlHardcodeAttributeMapper\", new Keycloak.GenericClientProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = samlClient.Id,\n            Protocol = \"saml\",\n            ProtocolMapper = \"saml-hardcode-attribute-mapper\",\n            Config = \n            {\n                { \"attribute.name\", \"name\" },\n                { \"attribute.nameformat\", \"Basic\" },\n                { \"attribute.value\", \"value\" },\n                { \"friendly.name\", \"display name\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsamlClient, err := saml.NewClient(ctx, \"samlClient\", \u0026saml.ClientArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: pulumi.String(\"test-client\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientProtocolMapper(ctx, \"samlHardcodeAttributeMapper\", \u0026keycloak.GenericClientProtocolMapperArgs{\n\t\t\tRealmId:        realm.ID(),\n\t\t\tClientId:       samlClient.ID(),\n\t\t\tProtocol:       pulumi.String(\"saml\"),\n\t\t\tProtocolMapper: pulumi.String(\"saml-hardcode-attribute-mapper\"),\n\t\t\tConfig: pulumi.AnyMap{\n\t\t\t\t\"attribute.name\":       pulumi.Any(\"name\"),\n\t\t\t\t\"attribute.nameformat\": pulumi.Any(\"Basic\"),\n\t\t\t\t\"attribute.value\":      pulumi.Any(\"value\"),\n\t\t\t\t\"friendly.name\":        pulumi.Any(\"display name\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nProtocol mappers can be imported using the following format`{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}` Examplebash\n\n```sh\n $ pulumi import keycloak:index/genericClientProtocolMapper:GenericClientProtocolMapper saml_hardcode_attribute_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n ",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper is attached to.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map with key / value pairs for configuring the protocol mapper. The supported keys depends on the protocol mapper.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The type of client (either `openid-connect` or `saml`). The type must match the type of the client.\n"
                },
                "protocolMapper": {
                    "type": "string",
                    "description": "The name of the protocol mapper. The protocol mapper must be compatible with the specified client.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "required": [
                "config",
                "name",
                "protocol",
                "protocolMapper",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper is attached to.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map with key / value pairs for configuring the protocol mapper. The supported keys depends on the protocol mapper.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The type of client (either `openid-connect` or `saml`). The type must match the type of the client.\n"
                },
                "protocolMapper": {
                    "type": "string",
                    "description": "The name of the protocol mapper. The protocol mapper must be compatible with the specified client.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "requiredInputs": [
                "config",
                "protocol",
                "protocolMapper",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GenericClientProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper is attached to.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                    },
                    "config": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map with key / value pairs for configuring the protocol mapper. The supported keys depends on the protocol mapper.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "The type of client (either `openid-connect` or `saml`). The type must match the type of the client.\n"
                    },
                    "protocolMapper": {
                        "type": "string",
                        "description": "The name of the protocol mapper. The protocol mapper must be compatible with the specified client.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/genericClientRoleMapper:GenericClientRoleMapper": {
            "description": "Allow for creating and managing a client's scope mappings within Keycloak.\n\nBy default, all the user role mappings of the user are added as claims within the token (OIDC) or assertion (SAML). When\n`full_scope_allowed` is set to `false` for a client, role scope mapping allows you to limit the roles that get declared\ninside an access token for a client.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Realm Role To Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst realmRole = new keycloak.Role(\"realmRole\", {\n    realmId: realm.id,\n    description: \"My Realm Role\",\n});\nconst clientRoleMapper = new keycloak.GenericClientRoleMapper(\"clientRoleMapper\", {\n    realmId: realm.id,\n    clientId: client.id,\n    roleId: realmRole.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nrealm_role = keycloak.Role(\"realmRole\",\n    realm_id=realm.id,\n    description=\"My Realm Role\")\nclient_role_mapper = keycloak.GenericClientRoleMapper(\"clientRoleMapper\",\n    realm_id=realm.id,\n    client_id=client.id,\n    role_id=realm_role.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var client = new Keycloak.OpenId.Client(\"client\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"BEARER-ONLY\",\n        });\n        var realmRole = new Keycloak.Role(\"realmRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            Description = \"My Realm Role\",\n        });\n        var clientRoleMapper = new Keycloak.GenericClientRoleMapper(\"clientRoleMapper\", new Keycloak.GenericClientRoleMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = client.Id,\n            RoleId = realmRole.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmRole, err := keycloak.NewRole(ctx, \"realmRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientRoleMapper(ctx, \"clientRoleMapper\", \u0026keycloak.GenericClientRoleMapperArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: client.ID(),\n\t\t\tRoleId:   realmRole.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Role To Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientA = new keycloak.openid.Client(\"clientA\", {\n    realmId: realm.id,\n    clientId: \"client-a\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n    fullScopeAllowed: false,\n});\nconst clientRoleA = new keycloak.Role(\"clientRoleA\", {\n    realmId: realm.id,\n    clientId: clientA.id,\n    description: \"My Client Role\",\n});\nconst clientB = new keycloak.openid.Client(\"clientB\", {\n    realmId: realm.id,\n    clientId: \"client-b\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst clientRoleB = new keycloak.Role(\"clientRoleB\", {\n    realmId: realm.id,\n    clientId: clientB.id,\n    description: \"My Client Role\",\n});\nconst clientBRoleMapper = new keycloak.GenericClientRoleMapper(\"clientBRoleMapper\", {\n    realmId: realm.id,\n    clientId: clientB.id,\n    roleId: clientRoleA.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_a = keycloak.openid.Client(\"clientA\",\n    realm_id=realm.id,\n    client_id=\"client-a\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\",\n    full_scope_allowed=False)\nclient_role_a = keycloak.Role(\"clientRoleA\",\n    realm_id=realm.id,\n    client_id=client_a.id,\n    description=\"My Client Role\")\nclient_b = keycloak.openid.Client(\"clientB\",\n    realm_id=realm.id,\n    client_id=\"client-b\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nclient_role_b = keycloak.Role(\"clientRoleB\",\n    realm_id=realm.id,\n    client_id=client_b.id,\n    description=\"My Client Role\")\nclient_b_role_mapper = keycloak.GenericClientRoleMapper(\"clientBRoleMapper\",\n    realm_id=realm.id,\n    client_id=client_b.id,\n    role_id=client_role_a.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientA = new Keycloak.OpenId.Client(\"clientA\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client-a\",\n            Enabled = true,\n            AccessType = \"BEARER-ONLY\",\n            FullScopeAllowed = false,\n        });\n        var clientRoleA = new Keycloak.Role(\"clientRoleA\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            ClientId = clientA.Id,\n            Description = \"My Client Role\",\n        });\n        var clientB = new Keycloak.OpenId.Client(\"clientB\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client-b\",\n            Enabled = true,\n            AccessType = \"BEARER-ONLY\",\n        });\n        var clientRoleB = new Keycloak.Role(\"clientRoleB\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            ClientId = clientB.Id,\n            Description = \"My Client Role\",\n        });\n        var clientBRoleMapper = new Keycloak.GenericClientRoleMapper(\"clientBRoleMapper\", new Keycloak.GenericClientRoleMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = clientB.Id,\n            RoleId = clientRoleA.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientA, err := openid.NewClient(ctx, \"clientA\", \u0026openid.ClientArgs{\n\t\t\tRealmId:          realm.ID(),\n\t\t\tClientId:         pulumi.String(\"client-a\"),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t\tAccessType:       pulumi.String(\"BEARER-ONLY\"),\n\t\t\tFullScopeAllowed: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientRoleA, err := keycloak.NewRole(ctx, \"clientRoleA\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    clientA.ID(),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientB, err := openid.NewClient(ctx, \"clientB\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client-b\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"clientRoleB\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    clientB.ID(),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientRoleMapper(ctx, \"clientBRoleMapper\", \u0026keycloak.GenericClientRoleMapperArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: clientB.ID(),\n\t\t\tRoleId:   clientRoleA.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Realm Role To Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst realmRole = new keycloak.Role(\"realmRole\", {\n    realmId: realm.id,\n    description: \"My Realm Role\",\n});\nconst clientRoleMapper = new keycloak.GenericClientRoleMapper(\"clientRoleMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    roleId: realmRole.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nrealm_role = keycloak.Role(\"realmRole\",\n    realm_id=realm.id,\n    description=\"My Realm Role\")\nclient_role_mapper = keycloak.GenericClientRoleMapper(\"clientRoleMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    role_id=realm_role.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var realmRole = new Keycloak.Role(\"realmRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            Description = \"My Realm Role\",\n        });\n        var clientRoleMapper = new Keycloak.GenericClientRoleMapper(\"clientRoleMapper\", new Keycloak.GenericClientRoleMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            RoleId = realmRole.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmRole, err := keycloak.NewRole(ctx, \"realmRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientRoleMapper(ctx, \"clientRoleMapper\", \u0026keycloak.GenericClientRoleMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tRoleId:        realmRole.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Role To Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst clientRole = new keycloak.Role(\"clientRole\", {\n    realmId: realm.id,\n    clientId: client.id,\n    description: \"My Client Role\",\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst clientBRoleMapper = new keycloak.GenericClientRoleMapper(\"clientBRoleMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    roleId: clientRole.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nclient_role = keycloak.Role(\"clientRole\",\n    realm_id=realm.id,\n    client_id=client.id,\n    description=\"My Client Role\")\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nclient_b_role_mapper = keycloak.GenericClientRoleMapper(\"clientBRoleMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    role_id=client_role.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var client = new Keycloak.OpenId.Client(\"client\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"BEARER-ONLY\",\n        });\n        var clientRole = new Keycloak.Role(\"clientRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            ClientId = client.Id,\n            Description = \"My Client Role\",\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var clientBRoleMapper = new Keycloak.GenericClientRoleMapper(\"clientBRoleMapper\", new Keycloak.GenericClientRoleMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            RoleId = clientRole.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientRole, err := keycloak.NewRole(ctx, \"clientRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    client.ID(),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientRoleMapper(ctx, \"clientBRoleMapper\", \u0026keycloak.GenericClientRoleMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tRoleId:        clientRole.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGeneric client role mappers can be imported using one of the following two formats- When mapping a role to a client, use the format `{{realmId}}/client/{{clientId}}/scope-mappings/{{roleClientId}}/{{roleId}}` - When mapping a role to a client scope, use the format `{{realmId}}/client-scope/{{clientScopeId}}/scope-mappings/{{roleClientId}}/{{roleId}}` Examplebash\n\n```sh\n $ pulumi import keycloak:index/genericClientRoleMapper:GenericClientRoleMapper client_role_mapper my-realm/client/23888550-5dcd-41f6-85ba-554233021e9c/scope-mappings/ce51f004-bdfb-4dd5-a963-c4487d2dec5b/ff3aa49f-bc07-4030-8783-41918c3614a3\n```\n\n ",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client this role mapper should be added to. Conflicts with `client_scope_id`. This argument is required if `client_scope_id` is not set.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The ID of the client scope this role mapper should be added to. Conflicts with `client_id`. This argument is required if `client_id` is not set.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this role mapper exists within.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to be added to this role mapper.\n"
                }
            },
            "required": [
                "realmId",
                "roleId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client this role mapper should be added to. Conflicts with `client_scope_id`. This argument is required if `client_scope_id` is not set.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The ID of the client scope this role mapper should be added to. Conflicts with `client_id`. This argument is required if `client_id` is not set.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this role mapper exists within.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to be added to this role mapper.\n"
                }
            },
            "requiredInputs": [
                "realmId",
                "roleId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GenericClientRoleMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The ID of the client this role mapper should be added to. Conflicts with `client_scope_id`. This argument is required if `client_scope_id` is not set.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The ID of the client scope this role mapper should be added to. Conflicts with `client_id`. This argument is required if `client_id` is not set.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this role mapper exists within.\n"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The ID of the role to be added to this role mapper.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/group:Group": {
            "description": "Allows for creating and managing Groups within Keycloak.\n\nGroups provide a logical wrapping for users within Keycloak. Users within a group can share attributes and roles, and\ngroup membership can be mapped to a claim.\n\nAttributes can also be defined on Groups.\n\nGroups can also be federated from external data sources, such as LDAP or Active Directory. This resource **should not**\nbe used to manage groups that were created this way.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst parentGroup = new keycloak.Group(\"parentGroup\", {realmId: realm.id});\nconst childGroup = new keycloak.Group(\"childGroup\", {\n    realmId: realm.id,\n    parentId: parentGroup.id,\n});\nconst childGroupWithOptionalAttributes = new keycloak.Group(\"childGroupWithOptionalAttributes\", {\n    realmId: realm.id,\n    parentId: parentGroup.id,\n    attributes: {\n        foo: \"bar\",\n        multivalue: \"value1##value2\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nparent_group = keycloak.Group(\"parentGroup\", realm_id=realm.id)\nchild_group = keycloak.Group(\"childGroup\",\n    realm_id=realm.id,\n    parent_id=parent_group.id)\nchild_group_with_optional_attributes = keycloak.Group(\"childGroupWithOptionalAttributes\",\n    realm_id=realm.id,\n    parent_id=parent_group.id,\n    attributes={\n        \"foo\": \"bar\",\n        \"multivalue\": \"value1##value2\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var parentGroup = new Keycloak.Group(\"parentGroup\", new Keycloak.GroupArgs\n        {\n            RealmId = realm.Id,\n        });\n        var childGroup = new Keycloak.Group(\"childGroup\", new Keycloak.GroupArgs\n        {\n            RealmId = realm.Id,\n            ParentId = parentGroup.Id,\n        });\n        var childGroupWithOptionalAttributes = new Keycloak.Group(\"childGroupWithOptionalAttributes\", new Keycloak.GroupArgs\n        {\n            RealmId = realm.Id,\n            ParentId = parentGroup.Id,\n            Attributes = \n            {\n                { \"foo\", \"bar\" },\n                { \"multivalue\", \"value1##value2\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tparentGroup, err := keycloak.NewGroup(ctx, \"parentGroup\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGroup(ctx, \"childGroup\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tParentId: parentGroup.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGroup(ctx, \"childGroupWithOptionalAttributes\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tParentId: parentGroup.ID(),\n\t\t\tAttributes: pulumi.AnyMap{\n\t\t\t\t\"foo\":        pulumi.Any(\"bar\"),\n\t\t\t\t\"multivalue\": pulumi.Any(\"value1##value2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nGroups can be imported using the format `{{realm_id}}/{{group_id}}`, where `group_id` is the unique ID that Keycloak assigns to the group upon creation. This value can be found in the URI when editing this group in the GUI, and is typically a GUID. Examplebash\n\n```sh\n $ pulumi import keycloak:index/group:Group child_group my-realm/934a4a4e-28bd-4703-a0fa-332df153aabd\n```\n\n ",
            "properties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map representing attributes for the group. In order to add multivalue attributes, use `##` to seperate the values. Max length for each value is 255 chars\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the group.\n"
                },
                "parentId": {
                    "type": "string",
                    "description": "The ID of this group's parent. If omitted, this group will be defined at the root level.\n"
                },
                "path": {
                    "type": "string",
                    "description": "(Computed) The complete path of the group. For example, the child group's path in the example configuration would be `/parent-group/child-group`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n"
                }
            },
            "required": [
                "name",
                "path",
                "realmId"
            ],
            "inputProperties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map representing attributes for the group. In order to add multivalue attributes, use `##` to seperate the values. Max length for each value is 255 chars\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the group.\n"
                },
                "parentId": {
                    "type": "string",
                    "description": "The ID of this group's parent. If omitted, this group will be defined at the root level.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Group resources.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map representing attributes for the group. In order to add multivalue attributes, use `##` to seperate the values. Max length for each value is 255 chars\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the group.\n"
                    },
                    "parentId": {
                        "type": "string",
                        "description": "The ID of this group's parent. If omitted, this group will be defined at the root level.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "(Computed) The complete path of the group. For example, the child group's path in the example configuration would be `/parent-group/child-group`.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this group exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/groupMemberships:GroupMemberships": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst group = new keycloak.Group(\"group\", {realmId: realm.id});\nconst user = new keycloak.User(\"user\", {\n    realmId: realm.id,\n    username: \"my-user\",\n});\nconst groupMembers = new keycloak.GroupMemberships(\"groupMembers\", {\n    realmId: realm.id,\n    groupId: group.id,\n    members: [user.username],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\ngroup = keycloak.Group(\"group\", realm_id=realm.id)\nuser = keycloak.User(\"user\",\n    realm_id=realm.id,\n    username=\"my-user\")\ngroup_members = keycloak.GroupMemberships(\"groupMembers\",\n    realm_id=realm.id,\n    group_id=group.id,\n    members=[user.username])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var @group = new Keycloak.Group(\"group\", new Keycloak.GroupArgs\n        {\n            RealmId = realm.Id,\n        });\n        var user = new Keycloak.User(\"user\", new Keycloak.UserArgs\n        {\n            RealmId = realm.Id,\n            Username = \"my-user\",\n        });\n        var groupMembers = new Keycloak.GroupMemberships(\"groupMembers\", new Keycloak.GroupMembershipsArgs\n        {\n            RealmId = realm.Id,\n            GroupId = @group.Id,\n            Members = \n            {\n                user.Username,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgroup, err := keycloak.NewGroup(ctx, \"group\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuser, err := keycloak.NewUser(ctx, \"user\", \u0026keycloak.UserArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tUsername: pulumi.String(\"my-user\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGroupMemberships(ctx, \"groupMembers\", \u0026keycloak.GroupMembershipsArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tGroupId: group.ID(),\n\t\t\tMembers: pulumi.StringArray{\n\t\t\t\tuser.Username,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThis resource does not support import. Instead of importing, feel free to create this resource as if it did not already exist on the server. [1]providers/mrparkers/keycloak/latest/docs/resources/group_memberships ",
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "The ID of the group this resource should manage memberships for.\n"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of usernames that belong to this group.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n"
                }
            },
            "required": [
                "members",
                "realmId"
            ],
            "inputProperties": {
                "groupId": {
                    "type": "string",
                    "description": "The ID of the group this resource should manage memberships for.\n"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of usernames that belong to this group.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n"
                }
            },
            "requiredInputs": [
                "members",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupMemberships resources.\n",
                "properties": {
                    "groupId": {
                        "type": "string",
                        "description": "The ID of the group this resource should manage memberships for.\n"
                    },
                    "members": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of usernames that belong to this group.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this group exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/groupPermissions:GroupPermissions": {
            "properties": {
                "authorizationResourceServerId": {
                    "type": "string",
                    "description": "Resource server id representing the realm management client on which this permission is managed\n"
                },
                "enabled": {
                    "type": "boolean"
                },
                "groupId": {
                    "type": "string"
                },
                "manageMembersScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsManageMembersScope:GroupPermissionsManageMembersScope"
                },
                "manageMembershipScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsManageMembershipScope:GroupPermissionsManageMembershipScope"
                },
                "manageScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsManageScope:GroupPermissionsManageScope"
                },
                "realmId": {
                    "type": "string"
                },
                "viewMembersScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsViewMembersScope:GroupPermissionsViewMembersScope"
                },
                "viewScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsViewScope:GroupPermissionsViewScope"
                }
            },
            "required": [
                "authorizationResourceServerId",
                "enabled",
                "groupId",
                "realmId"
            ],
            "inputProperties": {
                "groupId": {
                    "type": "string"
                },
                "manageMembersScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsManageMembersScope:GroupPermissionsManageMembersScope"
                },
                "manageMembershipScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsManageMembershipScope:GroupPermissionsManageMembershipScope"
                },
                "manageScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsManageScope:GroupPermissionsManageScope"
                },
                "realmId": {
                    "type": "string"
                },
                "viewMembersScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsViewMembersScope:GroupPermissionsViewMembersScope"
                },
                "viewScope": {
                    "$ref": "#/types/keycloak:index/GroupPermissionsViewScope:GroupPermissionsViewScope"
                }
            },
            "requiredInputs": [
                "groupId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupPermissions resources.\n",
                "properties": {
                    "authorizationResourceServerId": {
                        "type": "string",
                        "description": "Resource server id representing the realm management client on which this permission is managed\n"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "groupId": {
                        "type": "string"
                    },
                    "manageMembersScope": {
                        "$ref": "#/types/keycloak:index/GroupPermissionsManageMembersScope:GroupPermissionsManageMembersScope"
                    },
                    "manageMembershipScope": {
                        "$ref": "#/types/keycloak:index/GroupPermissionsManageMembershipScope:GroupPermissionsManageMembershipScope"
                    },
                    "manageScope": {
                        "$ref": "#/types/keycloak:index/GroupPermissionsManageScope:GroupPermissionsManageScope"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "viewMembersScope": {
                        "$ref": "#/types/keycloak:index/GroupPermissionsViewMembersScope:GroupPermissionsViewMembersScope"
                    },
                    "viewScope": {
                        "$ref": "#/types/keycloak:index/GroupPermissionsViewScope:GroupPermissionsViewScope"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/groupRoles:GroupRoles": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### Exhaustive Roles)\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst realmRole = new keycloak.Role(\"realmRole\", {\n    realmId: realm.id,\n    description: \"My Realm Role\",\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst clientRole = new keycloak.Role(\"clientRole\", {\n    realmId: realm.id,\n    clientId: keycloak_client.client.id,\n    description: \"My Client Role\",\n});\nconst group = new keycloak.Group(\"group\", {realmId: realm.id});\nconst groupRoles = new keycloak.GroupRoles(\"groupRoles\", {\n    realmId: realm.id,\n    groupId: group.id,\n    roleIds: [\n        realmRole.id,\n        clientRole.id,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrealm_role = keycloak.Role(\"realmRole\",\n    realm_id=realm.id,\n    description=\"My Realm Role\")\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nclient_role = keycloak.Role(\"clientRole\",\n    realm_id=realm.id,\n    client_id=keycloak_client[\"client\"][\"id\"],\n    description=\"My Client Role\")\ngroup = keycloak.Group(\"group\", realm_id=realm.id)\ngroup_roles = keycloak.GroupRoles(\"groupRoles\",\n    realm_id=realm.id,\n    group_id=group.id,\n    role_ids=[\n        realm_role.id,\n        client_role.id,\n    ])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var realmRole = new Keycloak.Role(\"realmRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            Description = \"My Realm Role\",\n        });\n        var client = new Keycloak.OpenId.Client(\"client\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"BEARER-ONLY\",\n        });\n        var clientRole = new Keycloak.Role(\"clientRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            ClientId = keycloak_client.Client.Id,\n            Description = \"My Client Role\",\n        });\n        var @group = new Keycloak.Group(\"group\", new Keycloak.GroupArgs\n        {\n            RealmId = realm.Id,\n        });\n        var groupRoles = new Keycloak.GroupRoles(\"groupRoles\", new Keycloak.GroupRolesArgs\n        {\n            RealmId = realm.Id,\n            GroupId = @group.Id,\n            RoleIds = \n            {\n                realmRole.Id,\n                clientRole.Id,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmRole, err := keycloak.NewRole(ctx, \"realmRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientRole, err := keycloak.NewRole(ctx, \"clientRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    pulumi.Any(keycloak_client.Client.Id),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgroup, err := keycloak.NewGroup(ctx, \"group\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGroupRoles(ctx, \"groupRoles\", \u0026keycloak.GroupRolesArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tGroupId: group.ID(),\n\t\t\tRoleIds: pulumi.StringArray{\n\t\t\t\trealmRole.ID(),\n\t\t\t\tclientRole.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Non Exhaustive Roles)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst realmRole = new keycloak.Role(\"realmRole\", {\n    realmId: realm.id,\n    description: \"My Realm Role\",\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst clientRole = new keycloak.Role(\"clientRole\", {\n    realmId: realm.id,\n    clientId: keycloak_client.client.id,\n    description: \"My Client Role\",\n});\nconst group = new keycloak.Group(\"group\", {realmId: realm.id});\nconst groupRoleAssociation1 = new keycloak.GroupRoles(\"groupRoleAssociation1\", {\n    realmId: realm.id,\n    groupId: group.id,\n    exhaustive: false,\n    roleIds: [realmRole.id],\n});\nconst groupRoleAssociation2 = new keycloak.GroupRoles(\"groupRoleAssociation2\", {\n    realmId: realm.id,\n    groupId: group.id,\n    exhaustive: false,\n    roleIds: [clientRole.id],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrealm_role = keycloak.Role(\"realmRole\",\n    realm_id=realm.id,\n    description=\"My Realm Role\")\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nclient_role = keycloak.Role(\"clientRole\",\n    realm_id=realm.id,\n    client_id=keycloak_client[\"client\"][\"id\"],\n    description=\"My Client Role\")\ngroup = keycloak.Group(\"group\", realm_id=realm.id)\ngroup_role_association1 = keycloak.GroupRoles(\"groupRoleAssociation1\",\n    realm_id=realm.id,\n    group_id=group.id,\n    exhaustive=False,\n    role_ids=[realm_role.id])\ngroup_role_association2 = keycloak.GroupRoles(\"groupRoleAssociation2\",\n    realm_id=realm.id,\n    group_id=group.id,\n    exhaustive=False,\n    role_ids=[client_role.id])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var realmRole = new Keycloak.Role(\"realmRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            Description = \"My Realm Role\",\n        });\n        var client = new Keycloak.OpenId.Client(\"client\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"BEARER-ONLY\",\n        });\n        var clientRole = new Keycloak.Role(\"clientRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            ClientId = keycloak_client.Client.Id,\n            Description = \"My Client Role\",\n        });\n        var @group = new Keycloak.Group(\"group\", new Keycloak.GroupArgs\n        {\n            RealmId = realm.Id,\n        });\n        var groupRoleAssociation1 = new Keycloak.GroupRoles(\"groupRoleAssociation1\", new Keycloak.GroupRolesArgs\n        {\n            RealmId = realm.Id,\n            GroupId = @group.Id,\n            Exhaustive = false,\n            RoleIds = \n            {\n                realmRole.Id,\n            },\n        });\n        var groupRoleAssociation2 = new Keycloak.GroupRoles(\"groupRoleAssociation2\", new Keycloak.GroupRolesArgs\n        {\n            RealmId = realm.Id,\n            GroupId = @group.Id,\n            Exhaustive = false,\n            RoleIds = \n            {\n                clientRole.Id,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmRole, err := keycloak.NewRole(ctx, \"realmRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientRole, err := keycloak.NewRole(ctx, \"clientRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    pulumi.Any(keycloak_client.Client.Id),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgroup, err := keycloak.NewGroup(ctx, \"group\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGroupRoles(ctx, \"groupRoleAssociation1\", \u0026keycloak.GroupRolesArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tGroupId:    group.ID(),\n\t\t\tExhaustive: pulumi.Bool(false),\n\t\t\tRoleIds: pulumi.StringArray{\n\t\t\t\trealmRole.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGroupRoles(ctx, \"groupRoleAssociation2\", \u0026keycloak.GroupRolesArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tGroupId:    group.ID(),\n\t\t\tExhaustive: pulumi.Bool(false),\n\t\t\tRoleIds: pulumi.StringArray{\n\t\t\t\tclientRole.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThis resource can be imported using the format `{{realm_id}}/{{group_id}}`, where `group_id` is the unique ID that Keycloak assigns to the group upon creation. This value can be found in the URI when editing this group in the GUI, and is typically a GUID. Examplebash\n\n```sh\n $ pulumi import keycloak:index/groupRoles:GroupRoles group_roles my-realm/18cc6b87-2ce7-4e59-bdc8-b9d49ec98a94\n```\n\n ",
            "properties": {
                "exhaustive": {
                    "type": "boolean",
                    "description": "Indicates if the list of roles is exhaustive. In this case, roles that are manually added to the group will be removed. Defaults to `true`.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "The ID of the group this resource should manage roles for.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of role IDs to map to the group.\n"
                }
            },
            "required": [
                "groupId",
                "realmId",
                "roleIds"
            ],
            "inputProperties": {
                "exhaustive": {
                    "type": "boolean",
                    "description": "Indicates if the list of roles is exhaustive. In this case, roles that are manually added to the group will be removed. Defaults to `true`.\n"
                },
                "groupId": {
                    "type": "string",
                    "description": "The ID of the group this resource should manage roles for.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of role IDs to map to the group.\n"
                }
            },
            "requiredInputs": [
                "groupId",
                "realmId",
                "roleIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupRoles resources.\n",
                "properties": {
                    "exhaustive": {
                        "type": "boolean",
                        "description": "Indicates if the list of roles is exhaustive. In this case, roles that are manually added to the group will be removed. Defaults to `true`.\n"
                    },
                    "groupId": {
                        "type": "string",
                        "description": "The ID of the group this resource should manage roles for.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this group exists in.\n"
                    },
                    "roleIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of role IDs to map to the group.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/hardcodedAttributeIdentityProviderMapper:HardcodedAttributeIdentityProviderMapper": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "description": "OIDC Claim\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "User Attribute\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "userSession": {
                    "type": "boolean",
                    "description": "Is Attribute Related To a User Session\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm",
                "userSession"
            ],
            "inputProperties": {
                "attributeName": {
                    "type": "string",
                    "description": "OIDC Claim\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "User Attribute\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "userSession": {
                    "type": "boolean",
                    "description": "Is Attribute Related To a User Session\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm",
                "userSession"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedAttributeIdentityProviderMapper resources.\n",
                "properties": {
                    "attributeName": {
                        "type": "string",
                        "description": "OIDC Claim\n"
                    },
                    "attributeValue": {
                        "type": "string",
                        "description": "User Attribute\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "IDP Alias\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "IDP Mapper Name\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "Realm Name\n"
                    },
                    "userSession": {
                        "type": "boolean",
                        "description": "Is Attribute Related To a User Session\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/hardcodedRoleIdentityMapper:HardcodedRoleIdentityMapper": {
            "properties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role Name\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm"
            ],
            "inputProperties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role Name\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedRoleIdentityMapper resources.\n",
                "properties": {
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "IDP Alias\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "IDP Mapper Name\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "Realm Name\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Role Name\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/identityProviderTokenExchangeScopePermission:IdentityProviderTokenExchangeScopePermission": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst tokenExchangeRealm = new keycloak.Realm(\"tokenExchangeRealm\", {\n    realm: \"token-exchange_destination_realm\",\n    enabled: true,\n});\nconst tokenExchangeMyOidcIdp = new keycloak.oidc.IdentityProvider(\"tokenExchangeMyOidcIdp\", {\n    realm: tokenExchangeRealm.id,\n    alias: \"myIdp\",\n    authorizationUrl: \"http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/auth\",\n    tokenUrl: \"http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/token\",\n    clientId: \"clientId\",\n    clientSecret: \"secret\",\n    defaultScopes: \"openid\",\n});\nconst token_exchangeWebappClient = new keycloak.openid.Client(\"token-exchangeWebappClient\", {\n    realmId: tokenExchangeRealm.id,\n    clientId: \"webapp_client\",\n    clientSecret: \"secret\",\n    description: \"a webapp client on the destination realm\",\n    accessType: \"CONFIDENTIAL\",\n    standardFlowEnabled: true,\n    validRedirectUris: [\"http://localhost:8080/*\"],\n});\n//relevant part\nconst oidcIdpPermission = new keycloak.IdentityProviderTokenExchangeScopePermission(\"oidcIdpPermission\", {\n    realmId: tokenExchangeRealm.id,\n    providerAlias: tokenExchangeMyOidcIdp.alias,\n    policyType: \"client\",\n    clients: [token_exchangeWebappClient.id],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\ntoken_exchange_realm = keycloak.Realm(\"tokenExchangeRealm\",\n    realm=\"token-exchange_destination_realm\",\n    enabled=True)\ntoken_exchange_my_oidc_idp = keycloak.oidc.IdentityProvider(\"tokenExchangeMyOidcIdp\",\n    realm=token_exchange_realm.id,\n    alias=\"myIdp\",\n    authorization_url=\"http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/auth\",\n    token_url=\"http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/token\",\n    client_id=\"clientId\",\n    client_secret=\"secret\",\n    default_scopes=\"openid\")\ntoken_exchange_webapp_client = keycloak.openid.Client(\"token-exchangeWebappClient\",\n    realm_id=token_exchange_realm.id,\n    client_id=\"webapp_client\",\n    client_secret=\"secret\",\n    description=\"a webapp client on the destination realm\",\n    access_type=\"CONFIDENTIAL\",\n    standard_flow_enabled=True,\n    valid_redirect_uris=[\"http://localhost:8080/*\"])\n#relevant part\noidc_idp_permission = keycloak.IdentityProviderTokenExchangeScopePermission(\"oidcIdpPermission\",\n    realm_id=token_exchange_realm.id,\n    provider_alias=token_exchange_my_oidc_idp.alias,\n    policy_type=\"client\",\n    clients=[token_exchange_webapp_client.id])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var tokenExchangeRealm = new Keycloak.Realm(\"tokenExchangeRealm\", new Keycloak.RealmArgs\n        {\n            Realm = \"token-exchange_destination_realm\",\n            Enabled = true,\n        });\n        var tokenExchangeMyOidcIdp = new Keycloak.Oidc.IdentityProvider(\"tokenExchangeMyOidcIdp\", new Keycloak.Oidc.IdentityProviderArgs\n        {\n            Realm = tokenExchangeRealm.Id,\n            Alias = \"myIdp\",\n            AuthorizationUrl = \"http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/auth\",\n            TokenUrl = \"http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/token\",\n            ClientId = \"clientId\",\n            ClientSecret = \"secret\",\n            DefaultScopes = \"openid\",\n        });\n        var token_exchangeWebappClient = new Keycloak.OpenId.Client(\"token-exchangeWebappClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = tokenExchangeRealm.Id,\n            ClientId = \"webapp_client\",\n            ClientSecret = \"secret\",\n            Description = \"a webapp client on the destination realm\",\n            AccessType = \"CONFIDENTIAL\",\n            StandardFlowEnabled = true,\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/*\",\n            },\n        });\n        //relevant part\n        var oidcIdpPermission = new Keycloak.IdentityProviderTokenExchangeScopePermission(\"oidcIdpPermission\", new Keycloak.IdentityProviderTokenExchangeScopePermissionArgs\n        {\n            RealmId = tokenExchangeRealm.Id,\n            ProviderAlias = tokenExchangeMyOidcIdp.Alias,\n            PolicyType = \"client\",\n            Clients = \n            {\n                token_exchangeWebappClient.Id,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/oidc\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttokenExchangeRealm, err := keycloak.NewRealm(ctx, \"tokenExchangeRealm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"token-exchange_destination_realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttokenExchangeMyOidcIdp, err := oidc.NewIdentityProvider(ctx, \"tokenExchangeMyOidcIdp\", \u0026oidc.IdentityProviderArgs{\n\t\t\tRealm:            tokenExchangeRealm.ID(),\n\t\t\tAlias:            pulumi.String(\"myIdp\"),\n\t\t\tAuthorizationUrl: pulumi.String(\"http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/auth\"),\n\t\t\tTokenUrl:         pulumi.String(\"http://localhost:8080/auth/realms/someRealm/protocol/openid-connect/token\"),\n\t\t\tClientId:         pulumi.String(\"clientId\"),\n\t\t\tClientSecret:     pulumi.String(\"secret\"),\n\t\t\tDefaultScopes:    pulumi.String(\"openid\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClient(ctx, \"token-exchangeWebappClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:             tokenExchangeRealm.ID(),\n\t\t\tClientId:            pulumi.String(\"webapp_client\"),\n\t\t\tClientSecret:        pulumi.String(\"secret\"),\n\t\t\tDescription:         pulumi.String(\"a webapp client on the destination realm\"),\n\t\t\tAccessType:          pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tStandardFlowEnabled: pulumi.Bool(true),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/*\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewIdentityProviderTokenExchangeScopePermission(ctx, \"oidcIdpPermission\", \u0026keycloak.IdentityProviderTokenExchangeScopePermissionArgs{\n\t\t\tRealmId:       tokenExchangeRealm.ID(),\n\t\t\tProviderAlias: tokenExchangeMyOidcIdp.Alias,\n\t\t\tPolicyType:    pulumi.String(\"client\"),\n\t\t\tClients: pulumi.StringArray{\n\t\t\t\ttoken_exchangeWebappClient.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThis resource can be imported using the format `{{realm_id}}/{{provider_alias}}`, where `provider_alias` is the alias that you assign to the identity provider upon creation. Examplebash\n\n```sh\n $ pulumi import keycloak:index/identityProviderTokenExchangeScopePermission:IdentityProviderTokenExchangeScopePermission oidc_idp_permission my-realm/myIdp\n```\n\n ",
            "properties": {
                "authorizationIdpResourceId": {
                    "type": "string",
                    "description": "(Computed) Resource ID representing the identity provider, this automatically created by keycloak.\n"
                },
                "authorizationResourceServerId": {
                    "type": "string",
                    "description": "(Computed) Resource server ID representing the realm management client on which this permission is managed.\n"
                },
                "authorizationTokenExchangeScopePermissionId": {
                    "type": "string",
                    "description": "(Computed) Permission ID representing the Permission with scope 'Token Exchange' and the resource 'authorization_idp_resource_id', this automatically created by keycloak, the policy ID will be set on this permission.\n"
                },
                "clients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IDs of the clients for which a policy will be created and set on scope based token exchange permission.\n"
                },
                "policyId": {
                    "type": "string",
                    "description": "(Computed) Policy ID that will be set on the scope based token exchange permission automatically created by enabling permissions on the reference identity provider.\n"
                },
                "policyType": {
                    "type": "string",
                    "description": "Defaults to \"client\" This is also the only value policy type supported by this provider.\n"
                },
                "providerAlias": {
                    "type": "string",
                    "description": "Alias of the identity provider.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that the identity provider exists in.\n"
                }
            },
            "required": [
                "authorizationIdpResourceId",
                "authorizationResourceServerId",
                "authorizationTokenExchangeScopePermissionId",
                "clients",
                "policyId",
                "providerAlias",
                "realmId"
            ],
            "inputProperties": {
                "clients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IDs of the clients for which a policy will be created and set on scope based token exchange permission.\n"
                },
                "policyType": {
                    "type": "string",
                    "description": "Defaults to \"client\" This is also the only value policy type supported by this provider.\n"
                },
                "providerAlias": {
                    "type": "string",
                    "description": "Alias of the identity provider.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that the identity provider exists in.\n"
                }
            },
            "requiredInputs": [
                "clients",
                "providerAlias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IdentityProviderTokenExchangeScopePermission resources.\n",
                "properties": {
                    "authorizationIdpResourceId": {
                        "type": "string",
                        "description": "(Computed) Resource ID representing the identity provider, this automatically created by keycloak.\n"
                    },
                    "authorizationResourceServerId": {
                        "type": "string",
                        "description": "(Computed) Resource server ID representing the realm management client on which this permission is managed.\n"
                    },
                    "authorizationTokenExchangeScopePermissionId": {
                        "type": "string",
                        "description": "(Computed) Permission ID representing the Permission with scope 'Token Exchange' and the resource 'authorization_idp_resource_id', this automatically created by keycloak, the policy ID will be set on this permission.\n"
                    },
                    "clients": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of IDs of the clients for which a policy will be created and set on scope based token exchange permission.\n"
                    },
                    "policyId": {
                        "type": "string",
                        "description": "(Computed) Policy ID that will be set on the scope based token exchange permission automatically created by enabling permissions on the reference identity provider.\n"
                    },
                    "policyType": {
                        "type": "string",
                        "description": "Defaults to \"client\" This is also the only value policy type supported by this provider.\n"
                    },
                    "providerAlias": {
                        "type": "string",
                        "description": "Alias of the identity provider.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that the identity provider exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realm:Realm": {
            "description": "Allows for creating and managing Realms within Keycloak.\n\nA realm manages a logical collection of users, credentials, roles, and groups. Users log in to realms and can be federated\nfrom multiple sources.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    accessCodeLifespan: \"1h\",\n    attributes: {\n        mycustomAttribute: \"myCustomValue\",\n    },\n    displayName: \"my realm\",\n    displayNameHtml: \"\u003cb\u003emy realm\u003c/b\u003e\",\n    enabled: true,\n    internationalization: {\n        defaultLocale: \"en\",\n        supportedLocales: [\n            \"en\",\n            \"de\",\n            \"es\",\n        ],\n    },\n    loginTheme: \"base\",\n    passwordPolicy: \"upperCase(1) and length(8) and forceExpiredPasswordChange(365) and notUsername\",\n    realm: \"my-realm\",\n    securityDefenses: {\n        bruteForceDetection: {\n            failureResetTimeSeconds: 43200,\n            maxFailureWaitSeconds: 900,\n            maxLoginFailures: 30,\n            minimumQuickLoginWaitSeconds: 60,\n            permanentLockout: false,\n            quickLoginCheckMilliSeconds: 1000,\n            waitIncrementSeconds: 60,\n        },\n        headers: {\n            contentSecurityPolicy: \"frame-src 'self'; frame-ancestors 'self'; object-src 'none';\",\n            contentSecurityPolicyReportOnly: \"\",\n            strictTransportSecurity: \"max-age=31536000; includeSubDomains\",\n            xContentTypeOptions: \"nosniff\",\n            xFrameOptions: \"DENY\",\n            xRobotsTag: \"none\",\n            xXssProtection: \"1; mode=block\",\n        },\n    },\n    smtpServer: {\n        auth: {\n            password: \"password\",\n            username: \"tom\",\n        },\n        from: \"example@example.com\",\n        host: \"smtp.example.com\",\n    },\n    sslRequired: \"external\",\n    webAuthnPolicy: {\n        relyingPartyEntityName: \"Example\",\n        relyingPartyId: \"keycloak.example.com\",\n        signatureAlgorithms: [\n            \"ES256\",\n            \"RS256\",\n        ],\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    access_code_lifespan=\"1h\",\n    attributes={\n        \"mycustomAttribute\": \"myCustomValue\",\n    },\n    display_name=\"my realm\",\n    display_name_html=\"\u003cb\u003emy realm\u003c/b\u003e\",\n    enabled=True,\n    internationalization=keycloak.RealmInternationalizationArgs(\n        default_locale=\"en\",\n        supported_locales=[\n            \"en\",\n            \"de\",\n            \"es\",\n        ],\n    ),\n    login_theme=\"base\",\n    password_policy=\"upperCase(1) and length(8) and forceExpiredPasswordChange(365) and notUsername\",\n    realm=\"my-realm\",\n    security_defenses=keycloak.RealmSecurityDefensesArgs(\n        brute_force_detection=keycloak.RealmSecurityDefensesBruteForceDetectionArgs(\n            failure_reset_time_seconds=43200,\n            max_failure_wait_seconds=900,\n            max_login_failures=30,\n            minimum_quick_login_wait_seconds=60,\n            permanent_lockout=False,\n            quick_login_check_milli_seconds=1000,\n            wait_increment_seconds=60,\n        ),\n        headers=keycloak.RealmSecurityDefensesHeadersArgs(\n            content_security_policy=\"frame-src 'self'; frame-ancestors 'self'; object-src 'none';\",\n            content_security_policy_report_only=\"\",\n            strict_transport_security=\"max-age=31536000; includeSubDomains\",\n            x_content_type_options=\"nosniff\",\n            x_frame_options=\"DENY\",\n            x_robots_tag=\"none\",\n            x_xss_protection=\"1; mode=block\",\n        ),\n    ),\n    smtp_server=keycloak.RealmSmtpServerArgs(\n        auth=keycloak.RealmSmtpServerAuthArgs(\n            password=\"password\",\n            username=\"tom\",\n        ),\n        from_=\"example@example.com\",\n        host=\"smtp.example.com\",\n    ),\n    ssl_required=\"external\",\n    web_authn_policy=keycloak.RealmWebAuthnPolicyArgs(\n        relying_party_entity_name=\"Example\",\n        relying_party_id=\"keycloak.example.com\",\n        signature_algorithms=[\n            \"ES256\",\n            \"RS256\",\n        ],\n    ))\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            AccessCodeLifespan = \"1h\",\n            Attributes = \n            {\n                { \"mycustomAttribute\", \"myCustomValue\" },\n            },\n            DisplayName = \"my realm\",\n            DisplayNameHtml = \"\u003cb\u003emy realm\u003c/b\u003e\",\n            Enabled = true,\n            Internationalization = new Keycloak.Inputs.RealmInternationalizationArgs\n            {\n                DefaultLocale = \"en\",\n                SupportedLocales = \n                {\n                    \"en\",\n                    \"de\",\n                    \"es\",\n                },\n            },\n            LoginTheme = \"base\",\n            PasswordPolicy = \"upperCase(1) and length(8) and forceExpiredPasswordChange(365) and notUsername\",\n            Realm = \"my-realm\",\n            SecurityDefenses = new Keycloak.Inputs.RealmSecurityDefensesArgs\n            {\n                BruteForceDetection = new Keycloak.Inputs.RealmSecurityDefensesBruteForceDetectionArgs\n                {\n                    FailureResetTimeSeconds = 43200,\n                    MaxFailureWaitSeconds = 900,\n                    MaxLoginFailures = 30,\n                    MinimumQuickLoginWaitSeconds = 60,\n                    PermanentLockout = false,\n                    QuickLoginCheckMilliSeconds = 1000,\n                    WaitIncrementSeconds = 60,\n                },\n                Headers = new Keycloak.Inputs.RealmSecurityDefensesHeadersArgs\n                {\n                    ContentSecurityPolicy = \"frame-src 'self'; frame-ancestors 'self'; object-src 'none';\",\n                    ContentSecurityPolicyReportOnly = \"\",\n                    StrictTransportSecurity = \"max-age=31536000; includeSubDomains\",\n                    XContentTypeOptions = \"nosniff\",\n                    XFrameOptions = \"DENY\",\n                    XRobotsTag = \"none\",\n                    XXssProtection = \"1; mode=block\",\n                },\n            },\n            SmtpServer = new Keycloak.Inputs.RealmSmtpServerArgs\n            {\n                Auth = new Keycloak.Inputs.RealmSmtpServerAuthArgs\n                {\n                    Password = \"password\",\n                    Username = \"tom\",\n                },\n                From = \"example@example.com\",\n                Host = \"smtp.example.com\",\n            },\n            SslRequired = \"external\",\n            WebAuthnPolicy = new Keycloak.Inputs.RealmWebAuthnPolicyArgs\n            {\n                RelyingPartyEntityName = \"Example\",\n                RelyingPartyId = \"keycloak.example.com\",\n                SignatureAlgorithms = \n                {\n                    \"ES256\",\n                    \"RS256\",\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tAccessCodeLifespan: pulumi.String(\"1h\"),\n\t\t\tAttributes: pulumi.AnyMap{\n\t\t\t\t\"mycustomAttribute\": pulumi.Any(\"myCustomValue\"),\n\t\t\t},\n\t\t\tDisplayName:     pulumi.String(\"my realm\"),\n\t\t\tDisplayNameHtml: pulumi.String(\"\u003cb\u003emy realm\u003c/b\u003e\"),\n\t\t\tEnabled:         pulumi.Bool(true),\n\t\t\tInternationalization: \u0026RealmInternationalizationArgs{\n\t\t\t\tDefaultLocale: pulumi.String(\"en\"),\n\t\t\t\tSupportedLocales: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"en\"),\n\t\t\t\t\tpulumi.String(\"de\"),\n\t\t\t\t\tpulumi.String(\"es\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLoginTheme:     pulumi.String(\"base\"),\n\t\t\tPasswordPolicy: pulumi.String(\"upperCase(1) and length(8) and forceExpiredPasswordChange(365) and notUsername\"),\n\t\t\tRealm:          pulumi.String(\"my-realm\"),\n\t\t\tSecurityDefenses: \u0026RealmSecurityDefensesArgs{\n\t\t\t\tBruteForceDetection: \u0026RealmSecurityDefensesBruteForceDetectionArgs{\n\t\t\t\t\tFailureResetTimeSeconds:      pulumi.Int(43200),\n\t\t\t\t\tMaxFailureWaitSeconds:        pulumi.Int(900),\n\t\t\t\t\tMaxLoginFailures:             pulumi.Int(30),\n\t\t\t\t\tMinimumQuickLoginWaitSeconds: pulumi.Int(60),\n\t\t\t\t\tPermanentLockout:             pulumi.Bool(false),\n\t\t\t\t\tQuickLoginCheckMilliSeconds:  pulumi.Int(1000),\n\t\t\t\t\tWaitIncrementSeconds:         pulumi.Int(60),\n\t\t\t\t},\n\t\t\t\tHeaders: \u0026RealmSecurityDefensesHeadersArgs{\n\t\t\t\t\tContentSecurityPolicy:           pulumi.String(\"frame-src 'self'; frame-ancestors 'self'; object-src 'none';\"),\n\t\t\t\t\tContentSecurityPolicyReportOnly: pulumi.String(\"\"),\n\t\t\t\t\tStrictTransportSecurity:         pulumi.String(\"max-age=31536000; includeSubDomains\"),\n\t\t\t\t\tXContentTypeOptions:             pulumi.String(\"nosniff\"),\n\t\t\t\t\tXFrameOptions:                   pulumi.String(\"DENY\"),\n\t\t\t\t\tXRobotsTag:                      pulumi.String(\"none\"),\n\t\t\t\t\tXXssProtection:                  pulumi.String(\"1; mode=block\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tSmtpServer: \u0026RealmSmtpServerArgs{\n\t\t\t\tAuth: \u0026RealmSmtpServerAuthArgs{\n\t\t\t\t\tPassword: pulumi.String(\"password\"),\n\t\t\t\t\tUsername: pulumi.String(\"tom\"),\n\t\t\t\t},\n\t\t\t\tFrom: pulumi.String(\"example@example.com\"),\n\t\t\t\tHost: pulumi.String(\"smtp.example.com\"),\n\t\t\t},\n\t\t\tSslRequired: pulumi.String(\"external\"),\n\t\t\tWebAuthnPolicy: \u0026RealmWebAuthnPolicyArgs{\n\t\t\t\tRelyingPartyEntityName: pulumi.String(\"Example\"),\n\t\t\t\tRelyingPartyId:         pulumi.String(\"keycloak.example.com\"),\n\t\t\t\tSignatureAlgorithms: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"ES256\"),\n\t\t\t\t\tpulumi.String(\"RS256\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n## Default Client Scopes\n\n- `default_default_client_scopes` - (Optional) A list of default default client scopes to be used for client definitions. Defaults to `[]` or keycloak's built-in default default client-scopes.\n- `default_optional_client_scopes` - (Optional) A list of default optional client scopes to be used for client definitions. Defaults to `[]` or keycloak's built-in default optional client-scopes.\n\n\n## Import\n\nRealms can be imported using their name. Examplebash\n\n```sh\n $ pulumi import keycloak:index/realm:Realm realm my-realm\n```\n\n ",
            "properties": {
                "accessCodeLifespan": {
                    "type": "string",
                    "description": "The maximum amount of time a client has to finish the authorization code flow.\n"
                },
                "accessCodeLifespanLogin": {
                    "type": "string",
                    "description": "The maximum amount of time a user is permitted to stay on the login page before the authentication process must be restarted.\n"
                },
                "accessCodeLifespanUserAction": {
                    "type": "string",
                    "description": "The maximum amount of time a user has to complete login related actions, such as updating a password.\n"
                },
                "accessTokenLifespan": {
                    "type": "string",
                    "description": "The amount of time an access token can be used before it expires.\n"
                },
                "accessTokenLifespanForImplicitFlow": {
                    "type": "string",
                    "description": "The amount of time an access token issued with the OpenID Connect Implicit Flow can be used before it expires.\n"
                },
                "accountTheme": {
                    "type": "string",
                    "description": "Used for account management pages.\n"
                },
                "actionTokenGeneratedByAdminLifespan": {
                    "type": "string",
                    "description": "The maximum time a user has to use an admin-generated permit before it expires.\n"
                },
                "actionTokenGeneratedByUserLifespan": {
                    "type": "string",
                    "description": "The maximum time a user has to use a user-generated permit before it expires.\n"
                },
                "adminTheme": {
                    "type": "string",
                    "description": "Used for the admin console.\n"
                },
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of custom attributes to add to the realm.\n"
                },
                "browserFlow": {
                    "type": "string",
                    "description": "The desired flow for browser authentication. Defaults to `browser`.\n"
                },
                "clientAuthenticationFlow": {
                    "type": "string",
                    "description": "The desired flow for client authentication. Defaults to `clients`.\n"
                },
                "defaultDefaultClientScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "defaultOptionalClientScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "defaultSignatureAlgorithm": {
                    "type": "string",
                    "description": "Default algorithm used to sign tokens for the realm.\n"
                },
                "directGrantFlow": {
                    "type": "string",
                    "description": "The desired flow for direct access authentication. Defaults to `direct grant`.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "The display name for the realm that is shown when logging in to the admin console.\n"
                },
                "displayNameHtml": {
                    "type": "string",
                    "description": "The display name for the realm that is rendered as HTML on the screen when logging in to the admin console.\n"
                },
                "dockerAuthenticationFlow": {
                    "type": "string",
                    "description": "The desired flow for Docker authentication. Defaults to `docker auth`.\n"
                },
                "duplicateEmailsAllowed": {
                    "type": "boolean",
                    "description": "When true, multiple users will be allowed to have the same email address. This argument must be set to `false` if `login_with_email_allowed` is set to `true`.\n"
                },
                "editUsernameAllowed": {
                    "type": "boolean",
                    "description": "When true, the username field is editable.\n"
                },
                "emailTheme": {
                    "type": "string",
                    "description": "Used for emails that are sent by Keycloak.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, users and clients will not be able to access this realm. Defaults to `true`.\n"
                },
                "internalId": {
                    "type": "string"
                },
                "internationalization": {
                    "$ref": "#/types/keycloak:index/RealmInternationalization:RealmInternationalization"
                },
                "loginTheme": {
                    "type": "string",
                    "description": "Used for the login, forgot password, and registration pages.\n"
                },
                "loginWithEmailAllowed": {
                    "type": "boolean",
                    "description": "When true, users may log in with their email address.\n"
                },
                "oauth2DeviceCodeLifespan": {
                    "type": "string",
                    "description": "The maximum amount of time a client has to finish the device code flow before it expires.\n"
                },
                "oauth2DevicePollingInterval": {
                    "type": "integer",
                    "description": "The minimum amount of time in seconds that the client should wait between polling requests to the token endpoint.\n"
                },
                "offlineSessionIdleTimeout": {
                    "type": "string",
                    "description": "The amount of time an offline session can be idle before it expires.\n"
                },
                "offlineSessionMaxLifespan": {
                    "type": "string",
                    "description": "The maximum amount of time before an offline session expires regardless of activity.\n"
                },
                "offlineSessionMaxLifespanEnabled": {
                    "type": "boolean",
                    "description": "Enable `offline_session_max_lifespan`.\n"
                },
                "otpPolicy": {
                    "$ref": "#/types/keycloak:index/RealmOtpPolicy:RealmOtpPolicy"
                },
                "passwordPolicy": {
                    "type": "string",
                    "description": "The password policy for users within the realm.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak. This will also be used as the realm's internal ID within Keycloak.\n",
                    "language": {
                        "csharp": {
                            "name": "RealmName"
                        }
                    }
                },
                "refreshTokenMaxReuse": {
                    "type": "integer",
                    "description": "Maximum number of times a refresh token can be reused before they are revoked. If unspecified and 'revoke_refresh_token' is enabled the default value is 0 and refresh tokens can not be reused.\n"
                },
                "registrationAllowed": {
                    "type": "boolean",
                    "description": "When true, user registration will be enabled, and a link for registration will be displayed on the login page.\n"
                },
                "registrationEmailAsUsername": {
                    "type": "boolean",
                    "description": "When true, the user's email will be used as their username during registration.\n"
                },
                "registrationFlow": {
                    "type": "string",
                    "description": "The desired flow for user registration. Defaults to `registration`.\n"
                },
                "rememberMe": {
                    "type": "boolean",
                    "description": "When true, a \"remember me\" checkbox will be displayed on the login page, and the user's session will not expire between browser restarts.\n"
                },
                "resetCredentialsFlow": {
                    "type": "string",
                    "description": "The desired flow to use when a user attempts to reset their credentials. Defaults to `reset credentials`.\n"
                },
                "resetPasswordAllowed": {
                    "type": "boolean",
                    "description": "When true, a \"forgot password\" link will be displayed on the login page.\n"
                },
                "revokeRefreshToken": {
                    "type": "boolean",
                    "description": "If enabled a refresh token can only be used number of times specified in 'refresh_token_max_reuse' before they are revoked. If unspecified, refresh tokens can be reused.\n"
                },
                "securityDefenses": {
                    "$ref": "#/types/keycloak:index/RealmSecurityDefenses:RealmSecurityDefenses"
                },
                "smtpServer": {
                    "$ref": "#/types/keycloak:index/RealmSmtpServer:RealmSmtpServer"
                },
                "sslRequired": {
                    "type": "string",
                    "description": "Can be one of following values: 'none, 'external' or 'all'\n"
                },
                "ssoSessionIdleTimeout": {
                    "type": "string",
                    "description": "The amount of time a session can be idle before it expires.\n"
                },
                "ssoSessionIdleTimeoutRememberMe": {
                    "type": "string"
                },
                "ssoSessionMaxLifespan": {
                    "type": "string",
                    "description": "The maximum amount of time before a session expires regardless of activity.\n"
                },
                "ssoSessionMaxLifespanRememberMe": {
                    "type": "string"
                },
                "userManagedAccess": {
                    "type": "boolean",
                    "description": "When `true`, users are allowed to manage their own resources. Defaults to `false`.\n"
                },
                "verifyEmail": {
                    "type": "boolean",
                    "description": "When true, users are required to verify their email address after registration and after email address changes.\n"
                },
                "webAuthnPasswordlessPolicy": {
                    "$ref": "#/types/keycloak:index/RealmWebAuthnPasswordlessPolicy:RealmWebAuthnPasswordlessPolicy",
                    "description": "Configuration for WebAuthn Passwordless Policy authentication.\n"
                },
                "webAuthnPolicy": {
                    "$ref": "#/types/keycloak:index/RealmWebAuthnPolicy:RealmWebAuthnPolicy",
                    "description": "Configuration for WebAuthn Policy authentication.\n"
                }
            },
            "required": [
                "accessCodeLifespan",
                "accessCodeLifespanLogin",
                "accessCodeLifespanUserAction",
                "accessTokenLifespan",
                "accessTokenLifespanForImplicitFlow",
                "actionTokenGeneratedByAdminLifespan",
                "actionTokenGeneratedByUserLifespan",
                "duplicateEmailsAllowed",
                "editUsernameAllowed",
                "internalId",
                "loginWithEmailAllowed",
                "oauth2DeviceCodeLifespan",
                "oauth2DevicePollingInterval",
                "offlineSessionIdleTimeout",
                "offlineSessionMaxLifespan",
                "otpPolicy",
                "realm",
                "registrationAllowed",
                "registrationEmailAsUsername",
                "rememberMe",
                "resetPasswordAllowed",
                "ssoSessionIdleTimeout",
                "ssoSessionIdleTimeoutRememberMe",
                "ssoSessionMaxLifespan",
                "ssoSessionMaxLifespanRememberMe",
                "verifyEmail",
                "webAuthnPasswordlessPolicy",
                "webAuthnPolicy"
            ],
            "inputProperties": {
                "accessCodeLifespan": {
                    "type": "string",
                    "description": "The maximum amount of time a client has to finish the authorization code flow.\n"
                },
                "accessCodeLifespanLogin": {
                    "type": "string",
                    "description": "The maximum amount of time a user is permitted to stay on the login page before the authentication process must be restarted.\n"
                },
                "accessCodeLifespanUserAction": {
                    "type": "string",
                    "description": "The maximum amount of time a user has to complete login related actions, such as updating a password.\n"
                },
                "accessTokenLifespan": {
                    "type": "string",
                    "description": "The amount of time an access token can be used before it expires.\n"
                },
                "accessTokenLifespanForImplicitFlow": {
                    "type": "string",
                    "description": "The amount of time an access token issued with the OpenID Connect Implicit Flow can be used before it expires.\n"
                },
                "accountTheme": {
                    "type": "string",
                    "description": "Used for account management pages.\n"
                },
                "actionTokenGeneratedByAdminLifespan": {
                    "type": "string",
                    "description": "The maximum time a user has to use an admin-generated permit before it expires.\n"
                },
                "actionTokenGeneratedByUserLifespan": {
                    "type": "string",
                    "description": "The maximum time a user has to use a user-generated permit before it expires.\n"
                },
                "adminTheme": {
                    "type": "string",
                    "description": "Used for the admin console.\n"
                },
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of custom attributes to add to the realm.\n"
                },
                "browserFlow": {
                    "type": "string",
                    "description": "The desired flow for browser authentication. Defaults to `browser`.\n"
                },
                "clientAuthenticationFlow": {
                    "type": "string",
                    "description": "The desired flow for client authentication. Defaults to `clients`.\n"
                },
                "defaultDefaultClientScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "defaultOptionalClientScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "defaultSignatureAlgorithm": {
                    "type": "string",
                    "description": "Default algorithm used to sign tokens for the realm.\n"
                },
                "directGrantFlow": {
                    "type": "string",
                    "description": "The desired flow for direct access authentication. Defaults to `direct grant`.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "The display name for the realm that is shown when logging in to the admin console.\n"
                },
                "displayNameHtml": {
                    "type": "string",
                    "description": "The display name for the realm that is rendered as HTML on the screen when logging in to the admin console.\n"
                },
                "dockerAuthenticationFlow": {
                    "type": "string",
                    "description": "The desired flow for Docker authentication. Defaults to `docker auth`.\n"
                },
                "duplicateEmailsAllowed": {
                    "type": "boolean",
                    "description": "When true, multiple users will be allowed to have the same email address. This argument must be set to `false` if `login_with_email_allowed` is set to `true`.\n"
                },
                "editUsernameAllowed": {
                    "type": "boolean",
                    "description": "When true, the username field is editable.\n"
                },
                "emailTheme": {
                    "type": "string",
                    "description": "Used for emails that are sent by Keycloak.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, users and clients will not be able to access this realm. Defaults to `true`.\n"
                },
                "internationalization": {
                    "$ref": "#/types/keycloak:index/RealmInternationalization:RealmInternationalization"
                },
                "loginTheme": {
                    "type": "string",
                    "description": "Used for the login, forgot password, and registration pages.\n"
                },
                "loginWithEmailAllowed": {
                    "type": "boolean",
                    "description": "When true, users may log in with their email address.\n"
                },
                "oauth2DeviceCodeLifespan": {
                    "type": "string",
                    "description": "The maximum amount of time a client has to finish the device code flow before it expires.\n"
                },
                "oauth2DevicePollingInterval": {
                    "type": "integer",
                    "description": "The minimum amount of time in seconds that the client should wait between polling requests to the token endpoint.\n"
                },
                "offlineSessionIdleTimeout": {
                    "type": "string",
                    "description": "The amount of time an offline session can be idle before it expires.\n"
                },
                "offlineSessionMaxLifespan": {
                    "type": "string",
                    "description": "The maximum amount of time before an offline session expires regardless of activity.\n"
                },
                "offlineSessionMaxLifespanEnabled": {
                    "type": "boolean",
                    "description": "Enable `offline_session_max_lifespan`.\n"
                },
                "otpPolicy": {
                    "$ref": "#/types/keycloak:index/RealmOtpPolicy:RealmOtpPolicy"
                },
                "passwordPolicy": {
                    "type": "string",
                    "description": "The password policy for users within the realm.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak. This will also be used as the realm's internal ID within Keycloak.\n",
                    "language": {
                        "csharp": {
                            "name": "RealmName"
                        }
                    }
                },
                "refreshTokenMaxReuse": {
                    "type": "integer",
                    "description": "Maximum number of times a refresh token can be reused before they are revoked. If unspecified and 'revoke_refresh_token' is enabled the default value is 0 and refresh tokens can not be reused.\n"
                },
                "registrationAllowed": {
                    "type": "boolean",
                    "description": "When true, user registration will be enabled, and a link for registration will be displayed on the login page.\n"
                },
                "registrationEmailAsUsername": {
                    "type": "boolean",
                    "description": "When true, the user's email will be used as their username during registration.\n"
                },
                "registrationFlow": {
                    "type": "string",
                    "description": "The desired flow for user registration. Defaults to `registration`.\n"
                },
                "rememberMe": {
                    "type": "boolean",
                    "description": "When true, a \"remember me\" checkbox will be displayed on the login page, and the user's session will not expire between browser restarts.\n"
                },
                "resetCredentialsFlow": {
                    "type": "string",
                    "description": "The desired flow to use when a user attempts to reset their credentials. Defaults to `reset credentials`.\n"
                },
                "resetPasswordAllowed": {
                    "type": "boolean",
                    "description": "When true, a \"forgot password\" link will be displayed on the login page.\n"
                },
                "revokeRefreshToken": {
                    "type": "boolean",
                    "description": "If enabled a refresh token can only be used number of times specified in 'refresh_token_max_reuse' before they are revoked. If unspecified, refresh tokens can be reused.\n"
                },
                "securityDefenses": {
                    "$ref": "#/types/keycloak:index/RealmSecurityDefenses:RealmSecurityDefenses"
                },
                "smtpServer": {
                    "$ref": "#/types/keycloak:index/RealmSmtpServer:RealmSmtpServer"
                },
                "sslRequired": {
                    "type": "string",
                    "description": "Can be one of following values: 'none, 'external' or 'all'\n"
                },
                "ssoSessionIdleTimeout": {
                    "type": "string",
                    "description": "The amount of time a session can be idle before it expires.\n"
                },
                "ssoSessionIdleTimeoutRememberMe": {
                    "type": "string"
                },
                "ssoSessionMaxLifespan": {
                    "type": "string",
                    "description": "The maximum amount of time before a session expires regardless of activity.\n"
                },
                "ssoSessionMaxLifespanRememberMe": {
                    "type": "string"
                },
                "userManagedAccess": {
                    "type": "boolean",
                    "description": "When `true`, users are allowed to manage their own resources. Defaults to `false`.\n"
                },
                "verifyEmail": {
                    "type": "boolean",
                    "description": "When true, users are required to verify their email address after registration and after email address changes.\n"
                },
                "webAuthnPasswordlessPolicy": {
                    "$ref": "#/types/keycloak:index/RealmWebAuthnPasswordlessPolicy:RealmWebAuthnPasswordlessPolicy",
                    "description": "Configuration for WebAuthn Passwordless Policy authentication.\n"
                },
                "webAuthnPolicy": {
                    "$ref": "#/types/keycloak:index/RealmWebAuthnPolicy:RealmWebAuthnPolicy",
                    "description": "Configuration for WebAuthn Policy authentication.\n"
                }
            },
            "requiredInputs": [
                "realm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Realm resources.\n",
                "properties": {
                    "accessCodeLifespan": {
                        "type": "string",
                        "description": "The maximum amount of time a client has to finish the authorization code flow.\n"
                    },
                    "accessCodeLifespanLogin": {
                        "type": "string",
                        "description": "The maximum amount of time a user is permitted to stay on the login page before the authentication process must be restarted.\n"
                    },
                    "accessCodeLifespanUserAction": {
                        "type": "string",
                        "description": "The maximum amount of time a user has to complete login related actions, such as updating a password.\n"
                    },
                    "accessTokenLifespan": {
                        "type": "string",
                        "description": "The amount of time an access token can be used before it expires.\n"
                    },
                    "accessTokenLifespanForImplicitFlow": {
                        "type": "string",
                        "description": "The amount of time an access token issued with the OpenID Connect Implicit Flow can be used before it expires.\n"
                    },
                    "accountTheme": {
                        "type": "string",
                        "description": "Used for account management pages.\n"
                    },
                    "actionTokenGeneratedByAdminLifespan": {
                        "type": "string",
                        "description": "The maximum time a user has to use an admin-generated permit before it expires.\n"
                    },
                    "actionTokenGeneratedByUserLifespan": {
                        "type": "string",
                        "description": "The maximum time a user has to use a user-generated permit before it expires.\n"
                    },
                    "adminTheme": {
                        "type": "string",
                        "description": "Used for the admin console.\n"
                    },
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map of custom attributes to add to the realm.\n"
                    },
                    "browserFlow": {
                        "type": "string",
                        "description": "The desired flow for browser authentication. Defaults to `browser`.\n"
                    },
                    "clientAuthenticationFlow": {
                        "type": "string",
                        "description": "The desired flow for client authentication. Defaults to `clients`.\n"
                    },
                    "defaultDefaultClientScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "defaultOptionalClientScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "defaultSignatureAlgorithm": {
                        "type": "string",
                        "description": "Default algorithm used to sign tokens for the realm.\n"
                    },
                    "directGrantFlow": {
                        "type": "string",
                        "description": "The desired flow for direct access authentication. Defaults to `direct grant`.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "The display name for the realm that is shown when logging in to the admin console.\n"
                    },
                    "displayNameHtml": {
                        "type": "string",
                        "description": "The display name for the realm that is rendered as HTML on the screen when logging in to the admin console.\n"
                    },
                    "dockerAuthenticationFlow": {
                        "type": "string",
                        "description": "The desired flow for Docker authentication. Defaults to `docker auth`.\n"
                    },
                    "duplicateEmailsAllowed": {
                        "type": "boolean",
                        "description": "When true, multiple users will be allowed to have the same email address. This argument must be set to `false` if `login_with_email_allowed` is set to `true`.\n"
                    },
                    "editUsernameAllowed": {
                        "type": "boolean",
                        "description": "When true, the username field is editable.\n"
                    },
                    "emailTheme": {
                        "type": "string",
                        "description": "Used for emails that are sent by Keycloak.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, users and clients will not be able to access this realm. Defaults to `true`.\n"
                    },
                    "internalId": {
                        "type": "string"
                    },
                    "internationalization": {
                        "$ref": "#/types/keycloak:index/RealmInternationalization:RealmInternationalization"
                    },
                    "loginTheme": {
                        "type": "string",
                        "description": "Used for the login, forgot password, and registration pages.\n"
                    },
                    "loginWithEmailAllowed": {
                        "type": "boolean",
                        "description": "When true, users may log in with their email address.\n"
                    },
                    "oauth2DeviceCodeLifespan": {
                        "type": "string",
                        "description": "The maximum amount of time a client has to finish the device code flow before it expires.\n"
                    },
                    "oauth2DevicePollingInterval": {
                        "type": "integer",
                        "description": "The minimum amount of time in seconds that the client should wait between polling requests to the token endpoint.\n"
                    },
                    "offlineSessionIdleTimeout": {
                        "type": "string",
                        "description": "The amount of time an offline session can be idle before it expires.\n"
                    },
                    "offlineSessionMaxLifespan": {
                        "type": "string",
                        "description": "The maximum amount of time before an offline session expires regardless of activity.\n"
                    },
                    "offlineSessionMaxLifespanEnabled": {
                        "type": "boolean",
                        "description": "Enable `offline_session_max_lifespan`.\n"
                    },
                    "otpPolicy": {
                        "$ref": "#/types/keycloak:index/RealmOtpPolicy:RealmOtpPolicy"
                    },
                    "passwordPolicy": {
                        "type": "string",
                        "description": "The password policy for users within the realm.\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "The name of the realm. This is unique across Keycloak. This will also be used as the realm's internal ID within Keycloak.\n",
                        "language": {
                            "csharp": {
                                "name": "RealmName"
                            }
                        }
                    },
                    "refreshTokenMaxReuse": {
                        "type": "integer",
                        "description": "Maximum number of times a refresh token can be reused before they are revoked. If unspecified and 'revoke_refresh_token' is enabled the default value is 0 and refresh tokens can not be reused.\n"
                    },
                    "registrationAllowed": {
                        "type": "boolean",
                        "description": "When true, user registration will be enabled, and a link for registration will be displayed on the login page.\n"
                    },
                    "registrationEmailAsUsername": {
                        "type": "boolean",
                        "description": "When true, the user's email will be used as their username during registration.\n"
                    },
                    "registrationFlow": {
                        "type": "string",
                        "description": "The desired flow for user registration. Defaults to `registration`.\n"
                    },
                    "rememberMe": {
                        "type": "boolean",
                        "description": "When true, a \"remember me\" checkbox will be displayed on the login page, and the user's session will not expire between browser restarts.\n"
                    },
                    "resetCredentialsFlow": {
                        "type": "string",
                        "description": "The desired flow to use when a user attempts to reset their credentials. Defaults to `reset credentials`.\n"
                    },
                    "resetPasswordAllowed": {
                        "type": "boolean",
                        "description": "When true, a \"forgot password\" link will be displayed on the login page.\n"
                    },
                    "revokeRefreshToken": {
                        "type": "boolean",
                        "description": "If enabled a refresh token can only be used number of times specified in 'refresh_token_max_reuse' before they are revoked. If unspecified, refresh tokens can be reused.\n"
                    },
                    "securityDefenses": {
                        "$ref": "#/types/keycloak:index/RealmSecurityDefenses:RealmSecurityDefenses"
                    },
                    "smtpServer": {
                        "$ref": "#/types/keycloak:index/RealmSmtpServer:RealmSmtpServer"
                    },
                    "sslRequired": {
                        "type": "string",
                        "description": "Can be one of following values: 'none, 'external' or 'all'\n"
                    },
                    "ssoSessionIdleTimeout": {
                        "type": "string",
                        "description": "The amount of time a session can be idle before it expires.\n"
                    },
                    "ssoSessionIdleTimeoutRememberMe": {
                        "type": "string"
                    },
                    "ssoSessionMaxLifespan": {
                        "type": "string",
                        "description": "The maximum amount of time before a session expires regardless of activity.\n"
                    },
                    "ssoSessionMaxLifespanRememberMe": {
                        "type": "string"
                    },
                    "userManagedAccess": {
                        "type": "boolean",
                        "description": "When `true`, users are allowed to manage their own resources. Defaults to `false`.\n"
                    },
                    "verifyEmail": {
                        "type": "boolean",
                        "description": "When true, users are required to verify their email address after registration and after email address changes.\n"
                    },
                    "webAuthnPasswordlessPolicy": {
                        "$ref": "#/types/keycloak:index/RealmWebAuthnPasswordlessPolicy:RealmWebAuthnPasswordlessPolicy",
                        "description": "Configuration for WebAuthn Passwordless Policy authentication.\n"
                    },
                    "webAuthnPolicy": {
                        "$ref": "#/types/keycloak:index/RealmWebAuthnPolicy:RealmWebAuthnPolicy",
                        "description": "Configuration for WebAuthn Policy authentication.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realmEvents:RealmEvents": {
            "description": "Allows for managing Realm Events settings within Keycloak.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst realmEvents = new keycloak.RealmEvents(\"realmEvents\", {\n    realmId: realm.id,\n    eventsEnabled: true,\n    eventsExpiration: 3600,\n    adminEventsEnabled: true,\n    adminEventsDetailsEnabled: true,\n    enabledEventTypes: [\n        \"LOGIN\",\n        \"LOGOUT\",\n    ],\n    eventsListeners: [\"jboss-logging\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrealm_events = keycloak.RealmEvents(\"realmEvents\",\n    realm_id=realm.id,\n    events_enabled=True,\n    events_expiration=3600,\n    admin_events_enabled=True,\n    admin_events_details_enabled=True,\n    enabled_event_types=[\n        \"LOGIN\",\n        \"LOGOUT\",\n    ],\n    events_listeners=[\"jboss-logging\"])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var realmEvents = new Keycloak.RealmEvents(\"realmEvents\", new Keycloak.RealmEventsArgs\n        {\n            RealmId = realm.Id,\n            EventsEnabled = true,\n            EventsExpiration = 3600,\n            AdminEventsEnabled = true,\n            AdminEventsDetailsEnabled = true,\n            EnabledEventTypes = \n            {\n                \"LOGIN\",\n                \"LOGOUT\",\n            },\n            EventsListeners = \n            {\n                \"jboss-logging\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRealmEvents(ctx, \"realmEvents\", \u0026keycloak.RealmEventsArgs{\n\t\t\tRealmId:                   realm.ID(),\n\t\t\tEventsEnabled:             pulumi.Bool(true),\n\t\t\tEventsExpiration:          pulumi.Int(3600),\n\t\t\tAdminEventsEnabled:        pulumi.Bool(true),\n\t\t\tAdminEventsDetailsEnabled: pulumi.Bool(true),\n\t\t\tEnabledEventTypes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"LOGIN\"),\n\t\t\t\tpulumi.String(\"LOGOUT\"),\n\t\t\t},\n\t\t\tEventsListeners: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"jboss-logging\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThis resource currently does not support importing. ",
            "properties": {
                "adminEventsDetailsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, saved admin events will included detailed information for create/update requests. Defaults to `false`.\n"
                },
                "adminEventsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, admin events are saved to the database, making them available through the admin console. Defaults to `false`.\n"
                },
                "enabledEventTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The event types that will be saved to the database. Omitting this field enables all event types. Defaults to `[]` or all event types.\n"
                },
                "eventsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, events from `enabled_event_types` are saved to the database, making them available through the admin console. Defaults to `false`.\n"
                },
                "eventsExpiration": {
                    "type": "integer",
                    "description": "The amount of time in seconds events will be saved in the database. Defaults to `0` or never.\n"
                },
                "eventsListeners": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The event listeners that events should be sent to. Defaults to `[]` or none. Note that new realms enable the `jboss-logging` listener by default, and this resource will remove that unless it is specified.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The name of the realm the event settings apply to.\n"
                }
            },
            "required": [
                "realmId"
            ],
            "inputProperties": {
                "adminEventsDetailsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, saved admin events will included detailed information for create/update requests. Defaults to `false`.\n"
                },
                "adminEventsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, admin events are saved to the database, making them available through the admin console. Defaults to `false`.\n"
                },
                "enabledEventTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The event types that will be saved to the database. Omitting this field enables all event types. Defaults to `[]` or all event types.\n"
                },
                "eventsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, events from `enabled_event_types` are saved to the database, making them available through the admin console. Defaults to `false`.\n"
                },
                "eventsExpiration": {
                    "type": "integer",
                    "description": "The amount of time in seconds events will be saved in the database. Defaults to `0` or never.\n"
                },
                "eventsListeners": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The event listeners that events should be sent to. Defaults to `[]` or none. Note that new realms enable the `jboss-logging` listener by default, and this resource will remove that unless it is specified.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The name of the realm the event settings apply to.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RealmEvents resources.\n",
                "properties": {
                    "adminEventsDetailsEnabled": {
                        "type": "boolean",
                        "description": "When `true`, saved admin events will included detailed information for create/update requests. Defaults to `false`.\n"
                    },
                    "adminEventsEnabled": {
                        "type": "boolean",
                        "description": "When `true`, admin events are saved to the database, making them available through the admin console. Defaults to `false`.\n"
                    },
                    "enabledEventTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The event types that will be saved to the database. Omitting this field enables all event types. Defaults to `[]` or all event types.\n"
                    },
                    "eventsEnabled": {
                        "type": "boolean",
                        "description": "When `true`, events from `enabled_event_types` are saved to the database, making them available through the admin console. Defaults to `false`.\n"
                    },
                    "eventsExpiration": {
                        "type": "integer",
                        "description": "The amount of time in seconds events will be saved in the database. Defaults to `0` or never.\n"
                    },
                    "eventsListeners": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The event listeners that events should be sent to. Defaults to `[]` or none. Note that new realms enable the `jboss-logging` listener by default, and this resource will remove that unless it is specified.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The name of the realm the event settings apply to.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realmKeystoreAesGenerated:RealmKeystoreAesGenerated": {
            "description": "Allows for creating and managing `aes-generated` Realm keystores within Keycloak.\n\nA realm keystore manages generated key pairs that are used by Keycloak to perform cryptographic signatures and encryption.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {realm: \"my-realm\"});\nconst keystoreAesGenerated = new keycloak.RealmKeystoreAesGenerated(\"keystoreAesGenerated\", {\n    realmId: realm.realm,\n    enabled: true,\n    active: true,\n    priority: 100,\n    secretSize: 16,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\", realm=\"my-realm\")\nkeystore_aes_generated = keycloak.RealmKeystoreAesGenerated(\"keystoreAesGenerated\",\n    realm_id=realm.realm,\n    enabled=True,\n    active=True,\n    priority=100,\n    secret_size=16)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n        });\n        var keystoreAesGenerated = new Keycloak.RealmKeystoreAesGenerated(\"keystoreAesGenerated\", new Keycloak.RealmKeystoreAesGeneratedArgs\n        {\n            RealmId = realm.RealmName,\n            Enabled = true,\n            Active = true,\n            Priority = 100,\n            SecretSize = 16,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm: pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRealmKeystoreAesGenerated(ctx, \"keystoreAesGenerated\", \u0026keycloak.RealmKeystoreAesGeneratedArgs{\n\t\t\tRealmId:    realm.Realm,\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tActive:     pulumi.Bool(true),\n\t\t\tPriority:   pulumi.Int(100),\n\t\t\tSecretSize: pulumi.Int(16),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRealm keys can be imported using realm name and keystore id, you can find it in web UI. Examplebash\n\n```sh\n $ pulumi import keycloak:index/realmKeystoreAesGenerated:RealmKeystoreAesGenerated keystore_aes_generated my-realm/my-realm/618cfba7-49aa-4c09-9a19-2f699b576f0b\n```\n\n ",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n"
                },
                "secretSize": {
                    "type": "integer",
                    "description": "Size in bytes for the generated AES Key. Size 16 is for AES-128, Size 24 for AES-192 and Size 32 for AES-256. WARN: Bigger keys then 128 bits are not allowed on some JDK implementations. Defaults to `16`.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n"
                },
                "secretSize": {
                    "type": "integer",
                    "description": "Size in bytes for the generated AES Key. Size 16 is for AES-128, Size 24 for AES-192 and Size 32 for AES-256. WARN: Bigger keys then 128 bits are not allowed on some JDK implementations. Defaults to `16`.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RealmKeystoreAesGenerated resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of provider when linked in admin console.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority for the provider. Defaults to `0`\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this keystore exists in.\n"
                    },
                    "secretSize": {
                        "type": "integer",
                        "description": "Size in bytes for the generated AES Key. Size 16 is for AES-128, Size 24 for AES-192 and Size 32 for AES-256. WARN: Bigger keys then 128 bits are not allowed on some JDK implementations. Defaults to `16`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realmKeystoreEcdsaGenerated:RealmKeystoreEcdsaGenerated": {
            "description": "Allows for creating and managing `acdsa_generated` Realm keystores within Keycloak.\n\nA realm keystore manages generated key pairs that are used by Keycloak to perform cryptographic signatures and encryption.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {realm: \"my-realm\"});\nconst keystoreEcdsaGenerated = new keycloak.RealmKeystoreEcdsaGenerated(\"keystoreEcdsaGenerated\", {\n    realmId: realm.realm,\n    enabled: true,\n    active: true,\n    priority: 100,\n    ellipticCurveKey: \"P-256\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\", realm=\"my-realm\")\nkeystore_ecdsa_generated = keycloak.RealmKeystoreEcdsaGenerated(\"keystoreEcdsaGenerated\",\n    realm_id=realm.realm,\n    enabled=True,\n    active=True,\n    priority=100,\n    elliptic_curve_key=\"P-256\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n        });\n        var keystoreEcdsaGenerated = new Keycloak.RealmKeystoreEcdsaGenerated(\"keystoreEcdsaGenerated\", new Keycloak.RealmKeystoreEcdsaGeneratedArgs\n        {\n            RealmId = realm.RealmName,\n            Enabled = true,\n            Active = true,\n            Priority = 100,\n            EllipticCurveKey = \"P-256\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm: pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRealmKeystoreEcdsaGenerated(ctx, \"keystoreEcdsaGenerated\", \u0026keycloak.RealmKeystoreEcdsaGeneratedArgs{\n\t\t\tRealmId:          realm.Realm,\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t\tActive:           pulumi.Bool(true),\n\t\t\tPriority:         pulumi.Int(100),\n\t\t\tEllipticCurveKey: pulumi.String(\"P-256\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRealm keys can be imported using realm name and keystore id, you can find it in web UI. Examplebash\n\n```sh\n $ pulumi import keycloak:index/realmKeystoreEcdsaGenerated:RealmKeystoreEcdsaGenerated keystore_ecdsa_generated my-realm/my-realm/618cfba7-49aa-4c09-9a19-2f699b576f0b\n```\n\n ",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "ellipticCurveKey": {
                    "type": "string",
                    "description": "Elliptic Curve used in ECDSA. Defaults to `P-256`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "ellipticCurveKey": {
                    "type": "string",
                    "description": "Elliptic Curve used in ECDSA. Defaults to `P-256`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RealmKeystoreEcdsaGenerated resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                    },
                    "ellipticCurveKey": {
                        "type": "string",
                        "description": "Elliptic Curve used in ECDSA. Defaults to `P-256`.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of provider when linked in admin console.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority for the provider. Defaults to `0`\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this keystore exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realmKeystoreHmacGenerated:RealmKeystoreHmacGenerated": {
            "description": "Allows for creating and managing `hmac-generated` Realm keystores within Keycloak.\n\nA realm keystore manages generated key pairs that are used by Keycloak to perform cryptographic signatures and encryption.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {realm: \"my-realm\"});\nconst keystoreHmacGenerated = new keycloak.RealmKeystoreHmacGenerated(\"keystoreHmacGenerated\", {\n    realmId: realm.realm,\n    enabled: true,\n    active: true,\n    priority: 100,\n    algorithm: \"HS256\",\n    secretSize: 64,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\", realm=\"my-realm\")\nkeystore_hmac_generated = keycloak.RealmKeystoreHmacGenerated(\"keystoreHmacGenerated\",\n    realm_id=realm.realm,\n    enabled=True,\n    active=True,\n    priority=100,\n    algorithm=\"HS256\",\n    secret_size=64)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n        });\n        var keystoreHmacGenerated = new Keycloak.RealmKeystoreHmacGenerated(\"keystoreHmacGenerated\", new Keycloak.RealmKeystoreHmacGeneratedArgs\n        {\n            RealmId = realm.RealmName,\n            Enabled = true,\n            Active = true,\n            Priority = 100,\n            Algorithm = \"HS256\",\n            SecretSize = 64,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm: pulumi.String(\"my-realm\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRealmKeystoreHmacGenerated(ctx, \"keystoreHmacGenerated\", \u0026keycloak.RealmKeystoreHmacGeneratedArgs{\n\t\t\tRealmId:    realm.Realm,\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tActive:     pulumi.Bool(true),\n\t\t\tPriority:   pulumi.Int(100),\n\t\t\tAlgorithm:  pulumi.String(\"HS256\"),\n\t\t\tSecretSize: pulumi.Int(64),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRealm keys can be imported using realm name and keystore id, you can find it in web UI. Examplebash\n\n```sh\n $ pulumi import keycloak:index/realmKeystoreHmacGenerated:RealmKeystoreHmacGenerated keystore_hmac_generated my-realm/my-realm/618cfba7-49aa-4c09-9a19-2f699b576f0b\n```\n\n ",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "algorithm": {
                    "type": "string",
                    "description": "Intended algorithm for the key. Defaults to `HS256`\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n"
                },
                "secretSize": {
                    "type": "integer",
                    "description": "Size in bytes for the generated secret. Defaults to `64`.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "algorithm": {
                    "type": "string",
                    "description": "Intended algorithm for the key. Defaults to `HS256`\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n"
                },
                "secretSize": {
                    "type": "integer",
                    "description": "Size in bytes for the generated secret. Defaults to `64`.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RealmKeystoreHmacGenerated resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                    },
                    "algorithm": {
                        "type": "string",
                        "description": "Intended algorithm for the key. Defaults to `HS256`\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of provider when linked in admin console.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority for the provider. Defaults to `0`\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this keystore exists in.\n"
                    },
                    "secretSize": {
                        "type": "integer",
                        "description": "Size in bytes for the generated secret. Defaults to `64`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realmKeystoreJavaGenerated:RealmKeystoreJavaGenerated": {
            "description": "Allows for creating and managing `java-keystore` Realm keystores within Keycloak.\n\nA realm keystore manages generated key pairs that are used by Keycloak to perform cryptographic signatures and encryption.\n\n\n## Import\n\nRealm keys can be imported using realm name and keystore id, you can find it in web UI. Examplebash\n\n```sh\n $ pulumi import keycloak:index/realmKeystoreJavaGenerated:RealmKeystoreJavaGenerated java_keystore my-realm/my-realm/618cfba7-49aa-4c09-9a19-2f699b576f0b\n```\n\n ",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "algorithm": {
                    "type": "string",
                    "description": "Intended algorithm for the key. Defaults to `RS256`\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "keyAlias": {
                    "type": "string",
                    "description": "Alias for the private key\n"
                },
                "keyPassword": {
                    "type": "string",
                    "description": "Password for the private key\n"
                },
                "keystore": {
                    "type": "string",
                    "description": "Path to keys file on keycloak instance.\n"
                },
                "keystorePassword": {
                    "type": "string",
                    "description": "Password for the private key.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n"
                }
            },
            "required": [
                "keyAlias",
                "keyPassword",
                "keystore",
                "keystorePassword",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "algorithm": {
                    "type": "string",
                    "description": "Intended algorithm for the key. Defaults to `RS256`\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "keyAlias": {
                    "type": "string",
                    "description": "Alias for the private key\n"
                },
                "keyPassword": {
                    "type": "string",
                    "description": "Password for the private key\n"
                },
                "keystore": {
                    "type": "string",
                    "description": "Path to keys file on keycloak instance.\n"
                },
                "keystorePassword": {
                    "type": "string",
                    "description": "Password for the private key.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n"
                }
            },
            "requiredInputs": [
                "keyAlias",
                "keyPassword",
                "keystore",
                "keystorePassword",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RealmKeystoreJavaGenerated resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                    },
                    "algorithm": {
                        "type": "string",
                        "description": "Intended algorithm for the key. Defaults to `RS256`\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                    },
                    "keyAlias": {
                        "type": "string",
                        "description": "Alias for the private key\n"
                    },
                    "keyPassword": {
                        "type": "string",
                        "description": "Password for the private key\n"
                    },
                    "keystore": {
                        "type": "string",
                        "description": "Path to keys file on keycloak instance.\n"
                    },
                    "keystorePassword": {
                        "type": "string",
                        "description": "Password for the private key.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of provider when linked in admin console.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority for the provider. Defaults to `0`\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this keystore exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realmKeystoreRsa:RealmKeystoreRsa": {
            "description": "Allows for creating and managing `rsa` Realm keystores within Keycloak.\n\nA realm keystore manages generated key pairs that are used by Keycloak to perform cryptographic signatures and encryption.\n\n\n## Import\n\nRealm keys can be imported using realm name and keystore id, you can find it in web UI. Examplebash\n\n```sh\n $ pulumi import keycloak:index/realmKeystoreRsa:RealmKeystoreRsa keystore_rsa my-realm/my-realm/618cfba7-49aa-4c09-9a19-2f699b576f0b\n```\n\n ",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "algorithm": {
                    "type": "string",
                    "description": "Intended algorithm for the key. Defaults to `RS256`\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "X509 Certificate encoded in PEM format.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "Private RSA Key encoded in PEM format.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n"
                }
            },
            "required": [
                "certificate",
                "name",
                "privateKey",
                "realmId"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "algorithm": {
                    "type": "string",
                    "description": "Intended algorithm for the key. Defaults to `RS256`\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "X509 Certificate encoded in PEM format.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "Private RSA Key encoded in PEM format.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n"
                }
            },
            "requiredInputs": [
                "certificate",
                "privateKey",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RealmKeystoreRsa resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                    },
                    "algorithm": {
                        "type": "string",
                        "description": "Intended algorithm for the key. Defaults to `RS256`\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "X509 Certificate encoded in PEM format.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of provider when linked in admin console.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority for the provider. Defaults to `0`\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "Private RSA Key encoded in PEM format.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this keystore exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realmKeystoreRsaGenerated:RealmKeystoreRsaGenerated": {
            "description": "Allows for creating and managing `rsa-generated` Realm keystores within Keycloak.\n\nA realm keystore manages generated key pairs that are used by Keycloak to perform cryptographic signatures and encryption.\n\n\n## Import\n\nRealm keys can be imported using realm name and keystore id, you can find it in web UI. Examplebash\n\n```sh\n $ pulumi import keycloak:index/realmKeystoreRsaGenerated:RealmKeystoreRsaGenerated keystore_rsa_generated my-realm/my-realm/618cfba7-49aa-4c09-9a19-2f699b576f0b\n```\n\n ",
            "properties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "algorithm": {
                    "type": "string",
                    "description": "Intended algorithm for the key. Defaults to `RS256`\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "keySize": {
                    "type": "integer",
                    "description": "Size for the generated keys\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "active": {
                    "type": "boolean",
                    "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                },
                "algorithm": {
                    "type": "string",
                    "description": "Intended algorithm for the key. Defaults to `RS256`\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                },
                "keySize": {
                    "type": "integer",
                    "description": "Size for the generated keys\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of provider when linked in admin console.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority for the provider. Defaults to `0`\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this keystore exists in.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RealmKeystoreRsaGenerated resources.\n",
                "properties": {
                    "active": {
                        "type": "boolean",
                        "description": "When `false`, key in not used for signing. Defaults to `true`.\n"
                    },
                    "algorithm": {
                        "type": "string",
                        "description": "Intended algorithm for the key. Defaults to `RS256`\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, key is not accessible in this realm. Defaults to `true`.\n"
                    },
                    "keySize": {
                        "type": "integer",
                        "description": "Size for the generated keys\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of provider when linked in admin console.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority for the provider. Defaults to `0`\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this keystore exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/requiredAction:RequiredAction": {
            "properties": {
                "alias": {
                    "type": "string"
                },
                "defaultAction": {
                    "type": "boolean"
                },
                "enabled": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "priority": {
                    "type": "integer"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "alias",
                "name",
                "priority",
                "realmId"
            ],
            "inputProperties": {
                "alias": {
                    "type": "string"
                },
                "defaultAction": {
                    "type": "boolean"
                },
                "enabled": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "priority": {
                    "type": "integer"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "alias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RequiredAction resources.\n",
                "properties": {
                    "alias": {
                        "type": "string"
                    },
                    "defaultAction": {
                        "type": "boolean"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "priority": {
                        "type": "integer"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/role:Role": {
            "description": "Allows for creating and managing roles within Keycloak.\n\nRoles allow you define privileges within Keycloak and map them to users and groups.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Realm Role)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst realmRole = new keycloak.Role(\"realmRole\", {\n    realmId: realm.id,\n    description: \"My Realm Role\",\n    attributes: {\n        key: \"value\",\n        multivalue: \"value1##value2\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrealm_role = keycloak.Role(\"realmRole\",\n    realm_id=realm.id,\n    description=\"My Realm Role\",\n    attributes={\n        \"key\": \"value\",\n        \"multivalue\": \"value1##value2\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var realmRole = new Keycloak.Role(\"realmRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            Description = \"My Realm Role\",\n            Attributes = \n            {\n                { \"key\", \"value\" },\n                { \"multivalue\", \"value1##value2\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"realmRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t\tAttributes: pulumi.AnyMap{\n\t\t\t\t\"key\":        pulumi.Any(\"value\"),\n\t\t\t\t\"multivalue\": pulumi.Any(\"value1##value2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Role)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst clientRole = new keycloak.Role(\"clientRole\", {\n    realmId: realm.id,\n    clientId: keycloak_client.openid_client.id,\n    description: \"My Client Role\",\n    attributes: {\n        key: \"value\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nclient_role = keycloak.Role(\"clientRole\",\n    realm_id=realm.id,\n    client_id=keycloak_client[\"openid_client\"][\"id\"],\n    description=\"My Client Role\",\n    attributes={\n        \"key\": \"value\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var clientRole = new Keycloak.Role(\"clientRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            ClientId = keycloak_client.Openid_client.Id,\n            Description = \"My Client Role\",\n            Attributes = \n            {\n                { \"key\", \"value\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"clientRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    pulumi.Any(keycloak_client.Openid_client.Id),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t\tAttributes: pulumi.AnyMap{\n\t\t\t\t\"key\": pulumi.Any(\"value\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Composite Role)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\n// realm roles\nconst createRole = new keycloak.Role(\"createRole\", {\n    realmId: realm.id,\n    attributes: {\n        key: \"value\",\n    },\n});\nconst readRole = new keycloak.Role(\"readRole\", {\n    realmId: realm.id,\n    attributes: {\n        key: \"value\",\n    },\n});\nconst updateRole = new keycloak.Role(\"updateRole\", {\n    realmId: realm.id,\n    attributes: {\n        key: \"value\",\n    },\n});\nconst deleteRole = new keycloak.Role(\"deleteRole\", {\n    realmId: realm.id,\n    attributes: {\n        key: \"value\",\n    },\n});\n// client role\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst clientRole = new keycloak.Role(\"clientRole\", {\n    realmId: realm.id,\n    clientId: keycloak_client.openid_client.id,\n    description: \"My Client Role\",\n    attributes: {\n        key: \"value\",\n    },\n});\nconst adminRole = new keycloak.Role(\"adminRole\", {\n    realmId: realm.id,\n    compositeRoles: [\n        createRole.id,\n        readRole.id,\n        updateRole.id,\n        deleteRole.id,\n        clientRole.id,\n    ],\n    attributes: {\n        key: \"value\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\n# realm roles\ncreate_role = keycloak.Role(\"createRole\",\n    realm_id=realm.id,\n    attributes={\n        \"key\": \"value\",\n    })\nread_role = keycloak.Role(\"readRole\",\n    realm_id=realm.id,\n    attributes={\n        \"key\": \"value\",\n    })\nupdate_role = keycloak.Role(\"updateRole\",\n    realm_id=realm.id,\n    attributes={\n        \"key\": \"value\",\n    })\ndelete_role = keycloak.Role(\"deleteRole\",\n    realm_id=realm.id,\n    attributes={\n        \"key\": \"value\",\n    })\n# client role\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nclient_role = keycloak.Role(\"clientRole\",\n    realm_id=realm.id,\n    client_id=keycloak_client[\"openid_client\"][\"id\"],\n    description=\"My Client Role\",\n    attributes={\n        \"key\": \"value\",\n    })\nadmin_role = keycloak.Role(\"adminRole\",\n    realm_id=realm.id,\n    composite_roles=[\n        create_role.id,\n        read_role.id,\n        update_role.id,\n        delete_role.id,\n        client_role.id,\n    ],\n    attributes={\n        \"key\": \"value\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        // realm roles\n        var createRole = new Keycloak.Role(\"createRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            Attributes = \n            {\n                { \"key\", \"value\" },\n            },\n        });\n        var readRole = new Keycloak.Role(\"readRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            Attributes = \n            {\n                { \"key\", \"value\" },\n            },\n        });\n        var updateRole = new Keycloak.Role(\"updateRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            Attributes = \n            {\n                { \"key\", \"value\" },\n            },\n        });\n        var deleteRole = new Keycloak.Role(\"deleteRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            Attributes = \n            {\n                { \"key\", \"value\" },\n            },\n        });\n        // client role\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var clientRole = new Keycloak.Role(\"clientRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            ClientId = keycloak_client.Openid_client.Id,\n            Description = \"My Client Role\",\n            Attributes = \n            {\n                { \"key\", \"value\" },\n            },\n        });\n        var adminRole = new Keycloak.Role(\"adminRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            CompositeRoles = \n            {\n                createRole.Id,\n                readRole.Id,\n                updateRole.Id,\n                deleteRole.Id,\n                clientRole.Id,\n            },\n            Attributes = \n            {\n                { \"key\", \"value\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcreateRole, err := keycloak.NewRole(ctx, \"createRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tAttributes: pulumi.AnyMap{\n\t\t\t\t\"key\": pulumi.Any(\"value\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treadRole, err := keycloak.NewRole(ctx, \"readRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tAttributes: pulumi.AnyMap{\n\t\t\t\t\"key\": pulumi.Any(\"value\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tupdateRole, err := keycloak.NewRole(ctx, \"updateRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tAttributes: pulumi.AnyMap{\n\t\t\t\t\"key\": pulumi.Any(\"value\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdeleteRole, err := keycloak.NewRole(ctx, \"deleteRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tAttributes: pulumi.AnyMap{\n\t\t\t\t\"key\": pulumi.Any(\"value\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientRole, err := keycloak.NewRole(ctx, \"clientRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    pulumi.Any(keycloak_client.Openid_client.Id),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t\tAttributes: pulumi.AnyMap{\n\t\t\t\t\"key\": pulumi.Any(\"value\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"adminRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tCompositeRoles: pulumi.StringArray{\n\t\t\t\tcreateRole.ID(),\n\t\t\t\treadRole.ID(),\n\t\t\t\tupdateRole.ID(),\n\t\t\t\tdeleteRole.ID(),\n\t\t\t\tclientRole.ID(),\n\t\t\t},\n\t\t\tAttributes: pulumi.AnyMap{\n\t\t\t\t\"key\": pulumi.Any(\"value\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nRoles can be imported using the format `{{realm_id}}/{{role_id}}`, where `role_id` is the unique ID that Keycloak assigns to the role. The ID is not easy to find in the GUI, but it appears in the URL when editing the role. Examplebash\n\n```sh\n $ pulumi import keycloak:index/role:Role role my-realm/7e8cf32a-8acb-4d34-89c4-04fb1d10ccad\n```\n\n ",
            "properties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map representing attributes for the role. In order to add multivalue attributes, use `##` to seperate the values. Max length for each value is 255 chars\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "When specified, this role will be created as a client role attached to the client with the provided ID\n"
                },
                "compositeRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "When specified, this role will be a composite role, composed of all roles that have an ID present within this list.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the role\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the role\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this role exists within.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map representing attributes for the role. In order to add multivalue attributes, use `##` to seperate the values. Max length for each value is 255 chars\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "When specified, this role will be created as a client role attached to the client with the provided ID\n"
                },
                "compositeRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "When specified, this role will be a composite role, composed of all roles that have an ID present within this list.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the role\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the role\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this role exists within.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Role resources.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map representing attributes for the role. In order to add multivalue attributes, use `##` to seperate the values. Max length for each value is 255 chars\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "When specified, this role will be created as a client role attached to the client with the provided ID\n"
                    },
                    "compositeRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "When specified, this role will be a composite role, composed of all roles that have an ID present within this list.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the role\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the role\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this role exists within.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/user:User": {
            "description": "Allows for creating and managing Users within Keycloak.\n\nThis resource was created primarily to enable the acceptance tests for the `keycloak.Group` resource. Creating users within\nKeycloak is not recommended. Instead, users should be federated from external sources by configuring user federation providers\nor identity providers.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst user = new keycloak.User(\"user\", {\n    realmId: realm.id,\n    username: \"bob\",\n    enabled: true,\n    email: \"bob@domain.com\",\n    firstName: \"Bob\",\n    lastName: \"Bobson\",\n});\nconst userWithInitialPassword = new keycloak.User(\"userWithInitialPassword\", {\n    realmId: realm.id,\n    username: \"alice\",\n    enabled: true,\n    email: \"alice@domain.com\",\n    firstName: \"Alice\",\n    lastName: \"Aliceberg\",\n    attributes: {\n        foo: \"bar\",\n        multivalue: \"value1##value2\",\n    },\n    initialPassword: {\n        value: \"some password\",\n        temporary: true,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nuser = keycloak.User(\"user\",\n    realm_id=realm.id,\n    username=\"bob\",\n    enabled=True,\n    email=\"bob@domain.com\",\n    first_name=\"Bob\",\n    last_name=\"Bobson\")\nuser_with_initial_password = keycloak.User(\"userWithInitialPassword\",\n    realm_id=realm.id,\n    username=\"alice\",\n    enabled=True,\n    email=\"alice@domain.com\",\n    first_name=\"Alice\",\n    last_name=\"Aliceberg\",\n    attributes={\n        \"foo\": \"bar\",\n        \"multivalue\": \"value1##value2\",\n    },\n    initial_password=keycloak.UserInitialPasswordArgs(\n        value=\"some password\",\n        temporary=True,\n    ))\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var user = new Keycloak.User(\"user\", new Keycloak.UserArgs\n        {\n            RealmId = realm.Id,\n            Username = \"bob\",\n            Enabled = true,\n            Email = \"bob@domain.com\",\n            FirstName = \"Bob\",\n            LastName = \"Bobson\",\n        });\n        var userWithInitialPassword = new Keycloak.User(\"userWithInitialPassword\", new Keycloak.UserArgs\n        {\n            RealmId = realm.Id,\n            Username = \"alice\",\n            Enabled = true,\n            Email = \"alice@domain.com\",\n            FirstName = \"Alice\",\n            LastName = \"Aliceberg\",\n            Attributes = \n            {\n                { \"foo\", \"bar\" },\n                { \"multivalue\", \"value1##value2\" },\n            },\n            InitialPassword = new Keycloak.Inputs.UserInitialPasswordArgs\n            {\n                Value = \"some password\",\n                Temporary = true,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewUser(ctx, \"user\", \u0026keycloak.UserArgs{\n\t\t\tRealmId:   realm.ID(),\n\t\t\tUsername:  pulumi.String(\"bob\"),\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tEmail:     pulumi.String(\"bob@domain.com\"),\n\t\t\tFirstName: pulumi.String(\"Bob\"),\n\t\t\tLastName:  pulumi.String(\"Bobson\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewUser(ctx, \"userWithInitialPassword\", \u0026keycloak.UserArgs{\n\t\t\tRealmId:   realm.ID(),\n\t\t\tUsername:  pulumi.String(\"alice\"),\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tEmail:     pulumi.String(\"alice@domain.com\"),\n\t\t\tFirstName: pulumi.String(\"Alice\"),\n\t\t\tLastName:  pulumi.String(\"Aliceberg\"),\n\t\t\tAttributes: pulumi.AnyMap{\n\t\t\t\t\"foo\":        pulumi.Any(\"bar\"),\n\t\t\t\t\"multivalue\": pulumi.Any(\"value1##value2\"),\n\t\t\t},\n\t\t\tInitialPassword: \u0026UserInitialPasswordArgs{\n\t\t\t\tValue:     pulumi.String(\"some password\"),\n\t\t\t\tTemporary: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nUsers can be imported using the format `{{realm_id}}/{{user_id}}`, where `user_id` is the unique ID that Keycloak assigns to the user upon creation. This value can be found in the GUI when editing the user. Examplebash\n\n```sh\n $ pulumi import keycloak:index/user:User user my-realm/60c3f971-b1d3-4b3a-9035-d16d7540a5e4\n```\n\n ",
            "properties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map representing attributes for the user. In order to add multivalue attributes, use `##` to seperate the values. Max length for each value is 255 chars\n"
                },
                "email": {
                    "type": "string",
                    "description": "The user's email.\n"
                },
                "emailVerified": {
                    "type": "boolean",
                    "description": "Whether the email address was validated or not. Default to `false`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When false, this user cannot log in. Defaults to `true`.\n"
                },
                "federatedIdentities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/UserFederatedIdentity:UserFederatedIdentity"
                    }
                },
                "firstName": {
                    "type": "string",
                    "description": "The user's first name.\n"
                },
                "initialPassword": {
                    "$ref": "#/types/keycloak:index/UserInitialPassword:UserInitialPassword",
                    "description": "When given, the user's initial password will be set. This attribute is only respected during initial user creation.\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "The user's last name.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this user belongs to.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The unique username of this user.\n"
                }
            },
            "required": [
                "realmId",
                "username"
            ],
            "inputProperties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map representing attributes for the user. In order to add multivalue attributes, use `##` to seperate the values. Max length for each value is 255 chars\n"
                },
                "email": {
                    "type": "string",
                    "description": "The user's email.\n"
                },
                "emailVerified": {
                    "type": "boolean",
                    "description": "Whether the email address was validated or not. Default to `false`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When false, this user cannot log in. Defaults to `true`.\n"
                },
                "federatedIdentities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/UserFederatedIdentity:UserFederatedIdentity"
                    }
                },
                "firstName": {
                    "type": "string",
                    "description": "The user's first name.\n"
                },
                "initialPassword": {
                    "$ref": "#/types/keycloak:index/UserInitialPassword:UserInitialPassword",
                    "description": "When given, the user's initial password will be set. This attribute is only respected during initial user creation.\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "The user's last name.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this user belongs to.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The unique username of this user.\n"
                }
            },
            "requiredInputs": [
                "realmId",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering User resources.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map representing attributes for the user. In order to add multivalue attributes, use `##` to seperate the values. Max length for each value is 255 chars\n"
                    },
                    "email": {
                        "type": "string",
                        "description": "The user's email.\n"
                    },
                    "emailVerified": {
                        "type": "boolean",
                        "description": "Whether the email address was validated or not. Default to `false`.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When false, this user cannot log in. Defaults to `true`.\n"
                    },
                    "federatedIdentities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/UserFederatedIdentity:UserFederatedIdentity"
                        }
                    },
                    "firstName": {
                        "type": "string",
                        "description": "The user's first name.\n"
                    },
                    "initialPassword": {
                        "$ref": "#/types/keycloak:index/UserInitialPassword:UserInitialPassword",
                        "description": "When given, the user's initial password will be set. This attribute is only respected during initial user creation.\n"
                    },
                    "lastName": {
                        "type": "string",
                        "description": "The user's last name.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this user belongs to.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The unique username of this user.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/userGroups:UserGroups": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### Exhaustive Groups)\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst group = new keycloak.Group(\"group\", {realmId: realm.id});\nconst user = new keycloak.User(\"user\", {\n    realmId: realm.id,\n    username: \"my-user\",\n});\nconst userGroups = new keycloak.UserGroups(\"userGroups\", {\n    realmId: realm.id,\n    userId: user.id,\n    groupIds: [group.id],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\ngroup = keycloak.Group(\"group\", realm_id=realm.id)\nuser = keycloak.User(\"user\",\n    realm_id=realm.id,\n    username=\"my-user\")\nuser_groups = keycloak.UserGroups(\"userGroups\",\n    realm_id=realm.id,\n    user_id=user.id,\n    group_ids=[group.id])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var @group = new Keycloak.Group(\"group\", new Keycloak.GroupArgs\n        {\n            RealmId = realm.Id,\n        });\n        var user = new Keycloak.User(\"user\", new Keycloak.UserArgs\n        {\n            RealmId = realm.Id,\n            Username = \"my-user\",\n        });\n        var userGroups = new Keycloak.UserGroups(\"userGroups\", new Keycloak.UserGroupsArgs\n        {\n            RealmId = realm.Id,\n            UserId = user.Id,\n            GroupIds = \n            {\n                @group.Id,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgroup, err := keycloak.NewGroup(ctx, \"group\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuser, err := keycloak.NewUser(ctx, \"user\", \u0026keycloak.UserArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tUsername: pulumi.String(\"my-user\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewUserGroups(ctx, \"userGroups\", \u0026keycloak.UserGroupsArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tUserId:  user.ID(),\n\t\t\tGroupIds: pulumi.StringArray{\n\t\t\t\tgroup.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Non Exhaustive Groups)\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst groupFoo = new keycloak.Group(\"groupFoo\", {realmId: realm.id});\nconst groupBar = new keycloak.Group(\"groupBar\", {realmId: realm.id});\nconst user = new keycloak.User(\"user\", {\n    realmId: realm.id,\n    username: \"my-user\",\n});\nconst userGroupsAssociation1UserGroups = new keycloak.UserGroups(\"userGroupsAssociation1UserGroups\", {\n    realmId: realm.id,\n    userId: user.id,\n    exhaustive: false,\n    groupIds: [groupFoo.id],\n});\nconst userGroupsAssociation1Index_userGroupsUserGroups = new keycloak.UserGroups(\"userGroupsAssociation1Index/userGroupsUserGroups\", {\n    realmId: realm.id,\n    userId: user.id,\n    exhaustive: false,\n    groupIds: [groupBar.id],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\ngroup_foo = keycloak.Group(\"groupFoo\", realm_id=realm.id)\ngroup_bar = keycloak.Group(\"groupBar\", realm_id=realm.id)\nuser = keycloak.User(\"user\",\n    realm_id=realm.id,\n    username=\"my-user\")\nuser_groups_association1_user_groups = keycloak.UserGroups(\"userGroupsAssociation1UserGroups\",\n    realm_id=realm.id,\n    user_id=user.id,\n    exhaustive=False,\n    group_ids=[group_foo.id])\nuser_groups_association1_index_user_groups_user_groups = keycloak.UserGroups(\"userGroupsAssociation1Index/userGroupsUserGroups\",\n    realm_id=realm.id,\n    user_id=user.id,\n    exhaustive=False,\n    group_ids=[group_bar.id])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var groupFoo = new Keycloak.Group(\"groupFoo\", new Keycloak.GroupArgs\n        {\n            RealmId = realm.Id,\n        });\n        var groupBar = new Keycloak.Group(\"groupBar\", new Keycloak.GroupArgs\n        {\n            RealmId = realm.Id,\n        });\n        var user = new Keycloak.User(\"user\", new Keycloak.UserArgs\n        {\n            RealmId = realm.Id,\n            Username = \"my-user\",\n        });\n        var userGroupsAssociation1UserGroups = new Keycloak.UserGroups(\"userGroupsAssociation1UserGroups\", new Keycloak.UserGroupsArgs\n        {\n            RealmId = realm.Id,\n            UserId = user.Id,\n            Exhaustive = false,\n            GroupIds = \n            {\n                groupFoo.Id,\n            },\n        });\n        var userGroupsAssociation1Index_userGroupsUserGroups = new Keycloak.UserGroups(\"userGroupsAssociation1Index/userGroupsUserGroups\", new Keycloak.UserGroupsArgs\n        {\n            RealmId = realm.Id,\n            UserId = user.Id,\n            Exhaustive = false,\n            GroupIds = \n            {\n                groupBar.Id,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgroupFoo, err := keycloak.NewGroup(ctx, \"groupFoo\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgroupBar, err := keycloak.NewGroup(ctx, \"groupBar\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuser, err := keycloak.NewUser(ctx, \"user\", \u0026keycloak.UserArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tUsername: pulumi.String(\"my-user\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewUserGroups(ctx, \"userGroupsAssociation1UserGroups\", \u0026keycloak.UserGroupsArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tUserId:     user.ID(),\n\t\t\tExhaustive: pulumi.Bool(false),\n\t\t\tGroupIds: pulumi.StringArray{\n\t\t\t\tgroupFoo.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewUserGroups(ctx, \"userGroupsAssociation1Index/userGroupsUserGroups\", \u0026keycloak.UserGroupsArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tUserId:     user.ID(),\n\t\t\tExhaustive: pulumi.Bool(false),\n\t\t\tGroupIds: pulumi.StringArray{\n\t\t\t\tgroupBar.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThis resource does not support import. Instead of importing, feel free to create this resource as if it did not already exist on the server. ",
            "properties": {
                "exhaustive": {
                    "type": "boolean",
                    "description": "Indicates if the list of the user's groups is exhaustive. In this case, groups that are manually added to the user will be removed. Defaults to `true`.\n"
                },
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of group IDs that the user is member of.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "The ID of the user this resource should manage groups for.\n"
                }
            },
            "required": [
                "groupIds",
                "realmId",
                "userId"
            ],
            "inputProperties": {
                "exhaustive": {
                    "type": "boolean",
                    "description": "Indicates if the list of the user's groups is exhaustive. In this case, groups that are manually added to the user will be removed. Defaults to `true`.\n"
                },
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of group IDs that the user is member of.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "The ID of the user this resource should manage groups for.\n"
                }
            },
            "requiredInputs": [
                "groupIds",
                "realmId",
                "userId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserGroups resources.\n",
                "properties": {
                    "exhaustive": {
                        "type": "boolean",
                        "description": "Indicates if the list of the user's groups is exhaustive. In this case, groups that are manually added to the user will be removed. Defaults to `true`.\n"
                    },
                    "groupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of group IDs that the user is member of.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this group exists in.\n"
                    },
                    "userId": {
                        "type": "string",
                        "description": "The ID of the user this resource should manage groups for.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/userRoles:UserRoles": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### Exhaustive Roles)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst realmRole = new keycloak.Role(\"realmRole\", {\n    realmId: realm.id,\n    description: \"My Realm Role\",\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst clientRole = new keycloak.Role(\"clientRole\", {\n    realmId: realm.id,\n    clientId: keycloak_client.client.id,\n    description: \"My Client Role\",\n});\nconst user = new keycloak.User(\"user\", {\n    realmId: realm.id,\n    username: \"bob\",\n    enabled: true,\n    email: \"bob@domain.com\",\n    firstName: \"Bob\",\n    lastName: \"Bobson\",\n});\nconst userRoles = new keycloak.UserRoles(\"userRoles\", {\n    realmId: realm.id,\n    userId: user.id,\n    roleIds: [\n        realmRole.id,\n        clientRole.id,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrealm_role = keycloak.Role(\"realmRole\",\n    realm_id=realm.id,\n    description=\"My Realm Role\")\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nclient_role = keycloak.Role(\"clientRole\",\n    realm_id=realm.id,\n    client_id=keycloak_client[\"client\"][\"id\"],\n    description=\"My Client Role\")\nuser = keycloak.User(\"user\",\n    realm_id=realm.id,\n    username=\"bob\",\n    enabled=True,\n    email=\"bob@domain.com\",\n    first_name=\"Bob\",\n    last_name=\"Bobson\")\nuser_roles = keycloak.UserRoles(\"userRoles\",\n    realm_id=realm.id,\n    user_id=user.id,\n    role_ids=[\n        realm_role.id,\n        client_role.id,\n    ])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var realmRole = new Keycloak.Role(\"realmRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            Description = \"My Realm Role\",\n        });\n        var client = new Keycloak.OpenId.Client(\"client\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"BEARER-ONLY\",\n        });\n        var clientRole = new Keycloak.Role(\"clientRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            ClientId = keycloak_client.Client.Id,\n            Description = \"My Client Role\",\n        });\n        var user = new Keycloak.User(\"user\", new Keycloak.UserArgs\n        {\n            RealmId = realm.Id,\n            Username = \"bob\",\n            Enabled = true,\n            Email = \"bob@domain.com\",\n            FirstName = \"Bob\",\n            LastName = \"Bobson\",\n        });\n        var userRoles = new Keycloak.UserRoles(\"userRoles\", new Keycloak.UserRolesArgs\n        {\n            RealmId = realm.Id,\n            UserId = user.Id,\n            RoleIds = \n            {\n                realmRole.Id,\n                clientRole.Id,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmRole, err := keycloak.NewRole(ctx, \"realmRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientRole, err := keycloak.NewRole(ctx, \"clientRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    pulumi.Any(keycloak_client.Client.Id),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuser, err := keycloak.NewUser(ctx, \"user\", \u0026keycloak.UserArgs{\n\t\t\tRealmId:   realm.ID(),\n\t\t\tUsername:  pulumi.String(\"bob\"),\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tEmail:     pulumi.String(\"bob@domain.com\"),\n\t\t\tFirstName: pulumi.String(\"Bob\"),\n\t\t\tLastName:  pulumi.String(\"Bobson\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewUserRoles(ctx, \"userRoles\", \u0026keycloak.UserRolesArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tUserId:  user.ID(),\n\t\t\tRoleIds: pulumi.StringArray{\n\t\t\t\trealmRole.ID(),\n\t\t\t\tclientRole.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThis resource can be imported using the format `{{realm_id}}/{{user_id}}`, where `user_id` is the unique ID that Keycloak assigns to the user upon creation. This value can be found in the GUI when editing the user, and is typically a GUID. Examplebash\n\n```sh\n $ pulumi import keycloak:index/userRoles:UserRoles user_roles my-realm/b0ae6924-1bd5-4655-9e38-dae7c5e42924\n```\n\n ",
            "properties": {
                "exhaustive": {
                    "type": "boolean",
                    "description": "Indicates if the list of roles is exhaustive. In this case, roles that are manually added to the user will be removed. Defaults to `true`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this user exists in.\n"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of role IDs to map to the user\n"
                },
                "userId": {
                    "type": "string",
                    "description": "The ID of the user this resource should manage roles for.\n"
                }
            },
            "required": [
                "realmId",
                "roleIds",
                "userId"
            ],
            "inputProperties": {
                "exhaustive": {
                    "type": "boolean",
                    "description": "Indicates if the list of roles is exhaustive. In this case, roles that are manually added to the user will be removed. Defaults to `true`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this user exists in.\n"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of role IDs to map to the user\n"
                },
                "userId": {
                    "type": "string",
                    "description": "The ID of the user this resource should manage roles for.\n"
                }
            },
            "requiredInputs": [
                "realmId",
                "roleIds",
                "userId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserRoles resources.\n",
                "properties": {
                    "exhaustive": {
                        "type": "boolean",
                        "description": "Indicates if the list of roles is exhaustive. In this case, roles that are manually added to the user will be removed. Defaults to `true`.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this user exists in.\n"
                    },
                    "roleIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of role IDs to map to the user\n"
                    },
                    "userId": {
                        "type": "string",
                        "description": "The ID of the user this resource should manage roles for.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/userTemplateImporterIdentityProviderMapper:UserTemplateImporterIdentityProviderMapper": {
            "description": "Allows for creating and managing an username template importer identity provider mapper within Keycloak.\n\nThe username template importer mapper can be used to map externally defined OIDC claims or SAML attributes with a template to the username of the imported Keycloak user:\n\n- Substitutions are enclosed in \\${}. For example: '\\${ALIAS}.\\${CLAIM.sub}'. ALIAS is the provider alias. CLAIM.\\\u003cNAME\\\u003e references an ID or Access token claim.\n\n\u003e If you are using Keycloak 10 or higher, you will need to specify the `extra_config` argument in order to define a `syncMode` for the mapper.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst oidc = new keycloak.oidc.IdentityProvider(\"oidc\", {\n    realm: realm.id,\n    alias: \"oidc\",\n    authorizationUrl: \"https://example.com/auth\",\n    tokenUrl: \"https://example.com/token\",\n    clientId: \"example_id\",\n    clientSecret: \"example_token\",\n    defaultScopes: \"openid random profile\",\n});\nconst usernameImporter = new keycloak.UserTemplateImporterIdentityProviderMapper(\"usernameImporter\", {\n    realm: realm.id,\n    identityProviderAlias: oidc.alias,\n    template: `${ALIAS}.${CLAIM.email}`,\n    extraConfig: {\n        syncMode: \"INHERIT\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\noidc = keycloak.oidc.IdentityProvider(\"oidc\",\n    realm=realm.id,\n    alias=\"oidc\",\n    authorization_url=\"https://example.com/auth\",\n    token_url=\"https://example.com/token\",\n    client_id=\"example_id\",\n    client_secret=\"example_token\",\n    default_scopes=\"openid random profile\")\nusername_importer = keycloak.UserTemplateImporterIdentityProviderMapper(\"usernameImporter\",\n    realm=realm.id,\n    identity_provider_alias=oidc.alias,\n    template=f\"{alias}.{claim['email']}\",\n    extra_config={\n        \"syncMode\": \"INHERIT\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var oidc = new Keycloak.Oidc.IdentityProvider(\"oidc\", new Keycloak.Oidc.IdentityProviderArgs\n        {\n            Realm = realm.Id,\n            Alias = \"oidc\",\n            AuthorizationUrl = \"https://example.com/auth\",\n            TokenUrl = \"https://example.com/token\",\n            ClientId = \"example_id\",\n            ClientSecret = \"example_token\",\n            DefaultScopes = \"openid random profile\",\n        });\n        var usernameImporter = new Keycloak.UserTemplateImporterIdentityProviderMapper(\"usernameImporter\", new Keycloak.UserTemplateImporterIdentityProviderMapperArgs\n        {\n            Realm = realm.Id,\n            IdentityProviderAlias = oidc.Alias,\n            Template = $\"{ALIAS}.{CLAIM.Email}\",\n            ExtraConfig = \n            {\n                { \"syncMode\", \"INHERIT\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/oidc\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\toidc, err := oidc.NewIdentityProvider(ctx, \"oidc\", \u0026oidc.IdentityProviderArgs{\n\t\t\tRealm:            realm.ID(),\n\t\t\tAlias:            pulumi.String(\"oidc\"),\n\t\t\tAuthorizationUrl: pulumi.String(\"https://example.com/auth\"),\n\t\t\tTokenUrl:         pulumi.String(\"https://example.com/token\"),\n\t\t\tClientId:         pulumi.String(\"example_id\"),\n\t\t\tClientSecret:     pulumi.String(\"example_token\"),\n\t\t\tDefaultScopes:    pulumi.String(\"openid random profile\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewUserTemplateImporterIdentityProviderMapper(ctx, \"usernameImporter\", \u0026keycloak.UserTemplateImporterIdentityProviderMapperArgs{\n\t\t\tRealm:                 realm.ID(),\n\t\t\tIdentityProviderAlias: oidc.Alias,\n\t\t\tTemplate:              pulumi.String(fmt.Sprintf(\"%v%v%v\", ALIAS, \".\", CLAIM.Email)),\n\t\t\tExtraConfig: pulumi.AnyMap{\n\t\t\t\t\"syncMode\": pulumi.Any(\"INHERIT\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nIdentity provider mappers can be imported using the format `{{realm_id}}/{{idp_alias}}/{{idp_mapper_id}}`, where `idp_alias` is the identity provider alias, and `idp_mapper_id` is the unique ID that Keycloak assigns to the mapper upon creation. This value can be found in the URI when editing this mapper in the GUI, and is typically a GUID. Examplebash\n\n```sh\n $ pulumi import keycloak:index/userTemplateImporterIdentityProviderMapper:UserTemplateImporterIdentityProviderMapper username_importer my-realm/my-mapper/f446db98-7133-4e30-b18a-3d28fde7ca1b\n```\n\n ",
            "properties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "The alias of the associated identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the mapper.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm.\n"
                },
                "template": {
                    "type": "string",
                    "description": "Template to use to format the username to import. Substitutions are enclosed in \\${}. For example: '\\$\\${ALIAS}.\\$\\${CLAIM.sub}'. ALIAS is the provider alias. CLAIM.\\\u003cNAME\\\u003e references an ID or Access token claim.\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm"
            ],
            "inputProperties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "The alias of the associated identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the mapper.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm.\n"
                },
                "template": {
                    "type": "string",
                    "description": "Template to use to format the username to import. Substitutions are enclosed in \\${}. For example: '\\$\\${ALIAS}.\\$\\${CLAIM.sub}'. ALIAS is the provider alias. CLAIM.\\\u003cNAME\\\u003e references an ID or Access token claim.\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserTemplateImporterIdentityProviderMapper resources.\n",
                "properties": {
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "The alias of the associated identity provider.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the mapper.\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "The name of the realm.\n"
                    },
                    "template": {
                        "type": "string",
                        "description": "Template to use to format the username to import. Substitutions are enclosed in \\${}. For example: '\\$\\${ALIAS}.\\$\\${CLAIM.sub}'. ALIAS is the provider alias. CLAIM.\\\u003cNAME\\\u003e references an ID or Access token claim.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/usersPermissions:UsersPermissions": {
            "properties": {
                "authorizationResourceServerId": {
                    "type": "string",
                    "description": "Resource server id representing the realm management client on which this permission is managed\n"
                },
                "enabled": {
                    "type": "boolean"
                },
                "impersonateScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsImpersonateScope:UsersPermissionsImpersonateScope"
                },
                "manageGroupMembershipScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsManageGroupMembershipScope:UsersPermissionsManageGroupMembershipScope"
                },
                "manageScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsManageScope:UsersPermissionsManageScope"
                },
                "mapRolesScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsMapRolesScope:UsersPermissionsMapRolesScope"
                },
                "realmId": {
                    "type": "string"
                },
                "userImpersonatedScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsUserImpersonatedScope:UsersPermissionsUserImpersonatedScope"
                },
                "viewScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsViewScope:UsersPermissionsViewScope"
                }
            },
            "required": [
                "authorizationResourceServerId",
                "enabled",
                "realmId"
            ],
            "inputProperties": {
                "impersonateScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsImpersonateScope:UsersPermissionsImpersonateScope"
                },
                "manageGroupMembershipScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsManageGroupMembershipScope:UsersPermissionsManageGroupMembershipScope"
                },
                "manageScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsManageScope:UsersPermissionsManageScope"
                },
                "mapRolesScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsMapRolesScope:UsersPermissionsMapRolesScope"
                },
                "realmId": {
                    "type": "string"
                },
                "userImpersonatedScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsUserImpersonatedScope:UsersPermissionsUserImpersonatedScope"
                },
                "viewScope": {
                    "$ref": "#/types/keycloak:index/UsersPermissionsViewScope:UsersPermissionsViewScope"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UsersPermissions resources.\n",
                "properties": {
                    "authorizationResourceServerId": {
                        "type": "string",
                        "description": "Resource server id representing the realm management client on which this permission is managed\n"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "impersonateScope": {
                        "$ref": "#/types/keycloak:index/UsersPermissionsImpersonateScope:UsersPermissionsImpersonateScope"
                    },
                    "manageGroupMembershipScope": {
                        "$ref": "#/types/keycloak:index/UsersPermissionsManageGroupMembershipScope:UsersPermissionsManageGroupMembershipScope"
                    },
                    "manageScope": {
                        "$ref": "#/types/keycloak:index/UsersPermissionsManageScope:UsersPermissionsManageScope"
                    },
                    "mapRolesScope": {
                        "$ref": "#/types/keycloak:index/UsersPermissionsMapRolesScope:UsersPermissionsMapRolesScope"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "userImpersonatedScope": {
                        "$ref": "#/types/keycloak:index/UsersPermissionsUserImpersonatedScope:UsersPermissionsUserImpersonatedScope"
                    },
                    "viewScope": {
                        "$ref": "#/types/keycloak:index/UsersPermissionsViewScope:UsersPermissionsViewScope"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/fullNameMapper:FullNameMapper": {
            "description": "Allows for creating and managing full name mappers for Keycloak users federated via LDAP.\n\nThe LDAP full name mapper can map a user's full name from an LDAP attribute to the first and last name attributes of a\nKeycloak user.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldapUserFederation\", {\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst ldapFullNameMapper = new keycloak.ldap.FullNameMapper(\"ldapFullNameMapper\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    ldapFullNameAttribute: \"cn\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nldap_full_name_mapper = keycloak.ldap.FullNameMapper(\"ldapFullNameMapper\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    ldap_full_name_attribute=\"cn\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            RealmId = realm.Id,\n            UsernameLdapAttribute = \"cn\",\n            RdnLdapAttribute = \"cn\",\n            UuidLdapAttribute = \"entryDN\",\n            UserObjectClasses = \n            {\n                \"simpleSecurityObject\",\n                \"organizationalRole\",\n            },\n            ConnectionUrl = \"ldap://openldap\",\n            UsersDn = \"dc=example,dc=org\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            BindCredential = \"admin\",\n        });\n        var ldapFullNameMapper = new Keycloak.Ldap.FullNameMapper(\"ldapFullNameMapper\", new Keycloak.Ldap.FullNameMapperArgs\n        {\n            RealmId = realm.Id,\n            LdapUserFederationId = ldapUserFederation.Id,\n            LdapFullNameAttribute = \"cn\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewFullNameMapper(ctx, \"ldapFullNameMapper\", \u0026ldap.FullNameMapperArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tLdapUserFederationId:  ldapUserFederation.ID(),\n\t\t\tLdapFullNameAttribute: pulumi.String(\"cn\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP mappers can be imported using the format `{{realm_id}}/{{ldap_user_federation_id}}/{{ldap_mapper_id}}`. The ID of the LDAP user federation provider and the mapper can be found within the Keycloak GUI, and they are typically GUIDs. Examplebash\n\n```sh\n $ pulumi import keycloak:ldap/fullNameMapper:FullNameMapper ldap_full_name_mapper my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860/3d923ece-1a91-4bf7-adaf-3b82f2a12b67\n```\n\n ",
            "properties": {
                "ldapFullNameAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute containing the user's full name.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "When `true`, updates to a user within Keycloak will not be written back to LDAP. Defaults to `false`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                },
                "writeOnly": {
                    "type": "boolean",
                    "description": "When `true`, this mapper will only be used to write updates to LDAP. Defaults to `false`.\n"
                }
            },
            "required": [
                "ldapFullNameAttribute",
                "ldapUserFederationId",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "ldapFullNameAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute containing the user's full name.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "When `true`, updates to a user within Keycloak will not be written back to LDAP. Defaults to `false`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                },
                "writeOnly": {
                    "type": "boolean",
                    "description": "When `true`, this mapper will only be used to write updates to LDAP. Defaults to `false`.\n"
                }
            },
            "requiredInputs": [
                "ldapFullNameAttribute",
                "ldapUserFederationId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FullNameMapper resources.\n",
                "properties": {
                    "ldapFullNameAttribute": {
                        "type": "string",
                        "description": "The name of the LDAP attribute containing the user's full name.\n"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n"
                    },
                    "readOnly": {
                        "type": "boolean",
                        "description": "When `true`, updates to a user within Keycloak will not be written back to LDAP. Defaults to `false`.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this LDAP mapper will exist in.\n"
                    },
                    "writeOnly": {
                        "type": "boolean",
                        "description": "When `true`, this mapper will only be used to write updates to LDAP. Defaults to `false`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/groupMapper:GroupMapper": {
            "description": "Allows for creating and managing group mappers for Keycloak users federated via LDAP.\n\nThe LDAP group mapper can be used to map an LDAP user's groups from some DN to Keycloak groups. This group mapper will also\ncreate the groups within Keycloak if they do not already exist.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldapUserFederation\", {\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst ldapGroupMapper = new keycloak.ldap.GroupMapper(\"ldapGroupMapper\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    ldapGroupsDn: \"dc=example,dc=org\",\n    groupNameLdapAttribute: \"cn\",\n    groupObjectClasses: [\"groupOfNames\"],\n    membershipAttributeType: \"DN\",\n    membershipLdapAttribute: \"member\",\n    membershipUserLdapAttribute: \"cn\",\n    memberofLdapAttribute: \"memberOf\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nldap_group_mapper = keycloak.ldap.GroupMapper(\"ldapGroupMapper\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    ldap_groups_dn=\"dc=example,dc=org\",\n    group_name_ldap_attribute=\"cn\",\n    group_object_classes=[\"groupOfNames\"],\n    membership_attribute_type=\"DN\",\n    membership_ldap_attribute=\"member\",\n    membership_user_ldap_attribute=\"cn\",\n    memberof_ldap_attribute=\"memberOf\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            RealmId = realm.Id,\n            UsernameLdapAttribute = \"cn\",\n            RdnLdapAttribute = \"cn\",\n            UuidLdapAttribute = \"entryDN\",\n            UserObjectClasses = \n            {\n                \"simpleSecurityObject\",\n                \"organizationalRole\",\n            },\n            ConnectionUrl = \"ldap://openldap\",\n            UsersDn = \"dc=example,dc=org\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            BindCredential = \"admin\",\n        });\n        var ldapGroupMapper = new Keycloak.Ldap.GroupMapper(\"ldapGroupMapper\", new Keycloak.Ldap.GroupMapperArgs\n        {\n            RealmId = realm.Id,\n            LdapUserFederationId = ldapUserFederation.Id,\n            LdapGroupsDn = \"dc=example,dc=org\",\n            GroupNameLdapAttribute = \"cn\",\n            GroupObjectClasses = \n            {\n                \"groupOfNames\",\n            },\n            MembershipAttributeType = \"DN\",\n            MembershipLdapAttribute = \"member\",\n            MembershipUserLdapAttribute = \"cn\",\n            MemberofLdapAttribute = \"memberOf\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewGroupMapper(ctx, \"ldapGroupMapper\", \u0026ldap.GroupMapperArgs{\n\t\t\tRealmId:                realm.ID(),\n\t\t\tLdapUserFederationId:   ldapUserFederation.ID(),\n\t\t\tLdapGroupsDn:           pulumi.String(\"dc=example,dc=org\"),\n\t\t\tGroupNameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tGroupObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"groupOfNames\"),\n\t\t\t},\n\t\t\tMembershipAttributeType:     pulumi.String(\"DN\"),\n\t\t\tMembershipLdapAttribute:     pulumi.String(\"member\"),\n\t\t\tMembershipUserLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tMemberofLdapAttribute:       pulumi.String(\"memberOf\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP mappers can be imported using the format `{{realm_id}}/{{ldap_user_federation_id}}/{{ldap_mapper_id}}`. The ID of the LDAP user federation provider and the mapper can be found within the Keycloak GUI, and they are typically GUIDs. Examplebash\n\n```sh\n $ pulumi import keycloak:ldap/groupMapper:GroupMapper ldap_group_mapper my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860/3d923ece-1a91-4bf7-adaf-3b82f2a12b67\n```\n\n ",
            "properties": {
                "dropNonExistingGroupsDuringSync": {
                    "type": "boolean",
                    "description": "When `true`, groups that no longer exist within LDAP will be dropped in Keycloak during sync. Defaults to `false`.\n"
                },
                "groupNameLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute that is used in group objects for the name and RDN of the group. Typically `cn`.\n"
                },
                "groupObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings representing the object classes for the group. Must contain at least one.\n"
                },
                "groupsLdapFilter": {
                    "type": "string",
                    "description": "When specified, adds an additional custom filter to be used when querying for groups. Must start with `(` and end with `)`.\n"
                },
                "groupsPath": {
                    "type": "string",
                    "description": "Keycloak group path the LDAP groups are added to. For example if value `/Applications/App1` is used, then LDAP groups will be available in Keycloak under group `App1`, which is the child of top level group `Applications`. The configured group path must already exist in Keycloak when creating this mapper.\n"
                },
                "ignoreMissingGroups": {
                    "type": "boolean",
                    "description": "When `true`, missing groups in the hierarchy will be ignored.\n"
                },
                "ldapGroupsDn": {
                    "type": "string",
                    "description": "The LDAP DN where groups can be found.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "mappedGroupAttributes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of strings representing attributes on the LDAP group which will be mapped to attributes on the Keycloak group.\n"
                },
                "memberofLdapAttribute": {
                    "type": "string",
                    "description": "Specifies the name of the LDAP attribute on the LDAP user that contains the groups the user is a member of. Defaults to `memberOf`.\n"
                },
                "membershipAttributeType": {
                    "type": "string",
                    "description": "Can be one of `DN` or `UID`. Defaults to `DN`.\n"
                },
                "membershipLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute that is used for membership mappings.\n"
                },
                "membershipUserLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute on a user that is used for membership mappings.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Can be one of `READ_ONLY`, `LDAP_ONLY` or `IMPORT`. Defaults to `READ_ONLY`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "preserveGroupInheritance": {
                    "type": "boolean",
                    "description": "When `true`, group inheritance will be propagated from LDAP to Keycloak. When `false`, all LDAP groups will be propagated as top level groups within Keycloak.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                },
                "userRolesRetrieveStrategy": {
                    "type": "string",
                    "description": "Can be one of `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE`, `GET_GROUPS_FROM_USER_MEMBEROF_ATTRIBUTE`, or `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE_RECURSIVELY`. Defaults to `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE`.\n"
                }
            },
            "required": [
                "groupNameLdapAttribute",
                "groupObjectClasses",
                "groupsPath",
                "ldapGroupsDn",
                "ldapUserFederationId",
                "membershipLdapAttribute",
                "membershipUserLdapAttribute",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "dropNonExistingGroupsDuringSync": {
                    "type": "boolean",
                    "description": "When `true`, groups that no longer exist within LDAP will be dropped in Keycloak during sync. Defaults to `false`.\n"
                },
                "groupNameLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute that is used in group objects for the name and RDN of the group. Typically `cn`.\n"
                },
                "groupObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings representing the object classes for the group. Must contain at least one.\n"
                },
                "groupsLdapFilter": {
                    "type": "string",
                    "description": "When specified, adds an additional custom filter to be used when querying for groups. Must start with `(` and end with `)`.\n"
                },
                "groupsPath": {
                    "type": "string",
                    "description": "Keycloak group path the LDAP groups are added to. For example if value `/Applications/App1` is used, then LDAP groups will be available in Keycloak under group `App1`, which is the child of top level group `Applications`. The configured group path must already exist in Keycloak when creating this mapper.\n"
                },
                "ignoreMissingGroups": {
                    "type": "boolean",
                    "description": "When `true`, missing groups in the hierarchy will be ignored.\n"
                },
                "ldapGroupsDn": {
                    "type": "string",
                    "description": "The LDAP DN where groups can be found.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "mappedGroupAttributes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of strings representing attributes on the LDAP group which will be mapped to attributes on the Keycloak group.\n"
                },
                "memberofLdapAttribute": {
                    "type": "string",
                    "description": "Specifies the name of the LDAP attribute on the LDAP user that contains the groups the user is a member of. Defaults to `memberOf`.\n"
                },
                "membershipAttributeType": {
                    "type": "string",
                    "description": "Can be one of `DN` or `UID`. Defaults to `DN`.\n"
                },
                "membershipLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute that is used for membership mappings.\n"
                },
                "membershipUserLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute on a user that is used for membership mappings.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Can be one of `READ_ONLY`, `LDAP_ONLY` or `IMPORT`. Defaults to `READ_ONLY`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "preserveGroupInheritance": {
                    "type": "boolean",
                    "description": "When `true`, group inheritance will be propagated from LDAP to Keycloak. When `false`, all LDAP groups will be propagated as top level groups within Keycloak.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                },
                "userRolesRetrieveStrategy": {
                    "type": "string",
                    "description": "Can be one of `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE`, `GET_GROUPS_FROM_USER_MEMBEROF_ATTRIBUTE`, or `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE_RECURSIVELY`. Defaults to `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE`.\n"
                }
            },
            "requiredInputs": [
                "groupNameLdapAttribute",
                "groupObjectClasses",
                "ldapGroupsDn",
                "ldapUserFederationId",
                "membershipLdapAttribute",
                "membershipUserLdapAttribute",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupMapper resources.\n",
                "properties": {
                    "dropNonExistingGroupsDuringSync": {
                        "type": "boolean",
                        "description": "When `true`, groups that no longer exist within LDAP will be dropped in Keycloak during sync. Defaults to `false`.\n"
                    },
                    "groupNameLdapAttribute": {
                        "type": "string",
                        "description": "The name of the LDAP attribute that is used in group objects for the name and RDN of the group. Typically `cn`.\n"
                    },
                    "groupObjectClasses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings representing the object classes for the group. Must contain at least one.\n"
                    },
                    "groupsLdapFilter": {
                        "type": "string",
                        "description": "When specified, adds an additional custom filter to be used when querying for groups. Must start with `(` and end with `)`.\n"
                    },
                    "groupsPath": {
                        "type": "string",
                        "description": "Keycloak group path the LDAP groups are added to. For example if value `/Applications/App1` is used, then LDAP groups will be available in Keycloak under group `App1`, which is the child of top level group `Applications`. The configured group path must already exist in Keycloak when creating this mapper.\n"
                    },
                    "ignoreMissingGroups": {
                        "type": "boolean",
                        "description": "When `true`, missing groups in the hierarchy will be ignored.\n"
                    },
                    "ldapGroupsDn": {
                        "type": "string",
                        "description": "The LDAP DN where groups can be found.\n"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                    },
                    "mappedGroupAttributes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Array of strings representing attributes on the LDAP group which will be mapped to attributes on the Keycloak group.\n"
                    },
                    "memberofLdapAttribute": {
                        "type": "string",
                        "description": "Specifies the name of the LDAP attribute on the LDAP user that contains the groups the user is a member of. Defaults to `memberOf`.\n"
                    },
                    "membershipAttributeType": {
                        "type": "string",
                        "description": "Can be one of `DN` or `UID`. Defaults to `DN`.\n"
                    },
                    "membershipLdapAttribute": {
                        "type": "string",
                        "description": "The name of the LDAP attribute that is used for membership mappings.\n"
                    },
                    "membershipUserLdapAttribute": {
                        "type": "string",
                        "description": "The name of the LDAP attribute on a user that is used for membership mappings.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "Can be one of `READ_ONLY`, `LDAP_ONLY` or `IMPORT`. Defaults to `READ_ONLY`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n"
                    },
                    "preserveGroupInheritance": {
                        "type": "boolean",
                        "description": "When `true`, group inheritance will be propagated from LDAP to Keycloak. When `false`, all LDAP groups will be propagated as top level groups within Keycloak.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this LDAP mapper will exist in.\n"
                    },
                    "userRolesRetrieveStrategy": {
                        "type": "string",
                        "description": "Can be one of `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE`, `GET_GROUPS_FROM_USER_MEMBEROF_ATTRIBUTE`, or `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE_RECURSIVELY`. Defaults to `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/hardcodedGroupMapper:HardcodedGroupMapper": {
            "properties": {
                "group": {
                    "type": "string",
                    "description": "Group to grant to user.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                }
            },
            "required": [
                "group",
                "ldapUserFederationId",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "group": {
                    "type": "string",
                    "description": "Group to grant to user.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                }
            },
            "requiredInputs": [
                "group",
                "ldapUserFederationId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedGroupMapper resources.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "description": "Group to grant to user.\n"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ldap user federation provider to attach this mapper to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm in which the ldap user federation provider exists.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/hardcodedRoleMapper:HardcodedRoleMapper": {
            "description": "Allows for creating and managing hardcoded role mappers for Keycloak users federated via LDAP.\n\nThe LDAP hardcoded role mapper will grant a specified Keycloak role to each Keycloak user linked with LDAP.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Realm Role)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldapUserFederation\", {\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst realmAdminRole = new keycloak.Role(\"realmAdminRole\", {\n    realmId: realm.id,\n    description: \"My Realm Role\",\n});\nconst assignAdminRoleToAllUsers = new keycloak.ldap.HardcodedRoleMapper(\"assignAdminRoleToAllUsers\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    role: realmAdminRole.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nrealm_admin_role = keycloak.Role(\"realmAdminRole\",\n    realm_id=realm.id,\n    description=\"My Realm Role\")\nassign_admin_role_to_all_users = keycloak.ldap.HardcodedRoleMapper(\"assignAdminRoleToAllUsers\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    role=realm_admin_role.name)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            RealmId = realm.Id,\n            UsernameLdapAttribute = \"cn\",\n            RdnLdapAttribute = \"cn\",\n            UuidLdapAttribute = \"entryDN\",\n            UserObjectClasses = \n            {\n                \"simpleSecurityObject\",\n                \"organizationalRole\",\n            },\n            ConnectionUrl = \"ldap://openldap\",\n            UsersDn = \"dc=example,dc=org\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            BindCredential = \"admin\",\n        });\n        var realmAdminRole = new Keycloak.Role(\"realmAdminRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            Description = \"My Realm Role\",\n        });\n        var assignAdminRoleToAllUsers = new Keycloak.Ldap.HardcodedRoleMapper(\"assignAdminRoleToAllUsers\", new Keycloak.Ldap.HardcodedRoleMapperArgs\n        {\n            RealmId = realm.Id,\n            LdapUserFederationId = ldapUserFederation.Id,\n            Role = realmAdminRole.Name,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmAdminRole, err := keycloak.NewRole(ctx, \"realmAdminRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewHardcodedRoleMapper(ctx, \"assignAdminRoleToAllUsers\", \u0026ldap.HardcodedRoleMapperArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t\tRole:                 realmAdminRole.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Role)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldapUserFederation\", {\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst realmManagement = keycloak.openid.getClientOutput({\n    realmId: realm.id,\n    clientId: \"realm-management\",\n});\nconst createClient = pulumi.all([realm.id, realmManagement]).apply(([id, realmManagement]) =\u003e keycloak.getRoleOutput({\n    realmId: id,\n    clientId: realmManagement.id,\n    name: \"create-client\",\n}));\nconst assignAdminRoleToAllUsers = new keycloak.ldap.HardcodedRoleMapper(\"assignAdminRoleToAllUsers\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    role: pulumi.all([realmManagement, createClient]).apply(([realmManagement, createClient]) =\u003e `${realmManagement.clientId}.${createClient.name}`),\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nrealm_management = keycloak.openid.get_client_output(realm_id=realm.id,\n    client_id=\"realm-management\")\ncreate_client = pulumi.Output.all(realm.id, realm_management).apply(lambda id, realm_management: keycloak.get_role_output(realm_id=id,\n    client_id=realm_management.id,\n    name=\"create-client\"))\nassign_admin_role_to_all_users = keycloak.ldap.HardcodedRoleMapper(\"assignAdminRoleToAllUsers\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    role=pulumi.Output.all(realm_management, create_client).apply(lambda realm_management, create_client: f\"{realm_management.client_id}.{create_client.name}\"))\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            RealmId = realm.Id,\n            UsernameLdapAttribute = \"cn\",\n            RdnLdapAttribute = \"cn\",\n            UuidLdapAttribute = \"entryDN\",\n            UserObjectClasses = \n            {\n                \"simpleSecurityObject\",\n                \"organizationalRole\",\n            },\n            ConnectionUrl = \"ldap://openldap\",\n            UsersDn = \"dc=example,dc=org\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            BindCredential = \"admin\",\n        });\n        var realmManagement = Keycloak.OpenId.GetClient.Invoke(new Keycloak.OpenId.GetClientInvokeArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"realm-management\",\n        });\n        var createClient = Output.Tuple(realm.Id, realmManagement).Apply(values =\u003e\n        {\n            var id = values.Item1;\n            var realmManagement = values.Item2;\n            return Keycloak.GetRole.Invoke(new Keycloak.GetRoleInvokeArgs\n            {\n                RealmId = id,\n                ClientId = realmManagement.Id,\n                Name = \"create-client\",\n            });\n        });\n        var assignAdminRoleToAllUsers = new Keycloak.Ldap.HardcodedRoleMapper(\"assignAdminRoleToAllUsers\", new Keycloak.Ldap.HardcodedRoleMapperArgs\n        {\n            RealmId = realm.Id,\n            LdapUserFederationId = ldapUserFederation.Id,\n            Role = Output.Tuple(realmManagement, createClient).Apply(values =\u003e\n            {\n                var realmManagement = values.Item1;\n                var createClient = values.Item2;\n                return $\"{realmManagement.ClientId}.{createClient.Name}\";\n            }),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmManagement := openid.LookupClientOutput(ctx, openid.GetClientOutputArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: pulumi.String(\"realm-management\"),\n\t\t}, nil)\n\t\t_, err = ldap.NewHardcodedRoleMapper(ctx, \"assignAdminRoleToAllUsers\", \u0026ldap.HardcodedRoleMapperArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t\tRole: pulumi.All(realmManagement, createClient).ApplyT(func(_args []interface{}) (string, error) {\n\t\t\t\trealmManagement := _args[0].(openid.GetClientResult)\n\t\t\t\tcreateClient := _args[1].(GetRoleResult)\n\t\t\t\treturn fmt.Sprintf(\"%v%v%v\", realmManagement.ClientId, \".\", createClient.Name), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP mappers can be imported using the format `{{realm_id}}/{{ldap_user_federation_id}}/{{ldap_mapper_id}}`. The ID of the LDAP user federation provider and the mapper can be found within the Keycloak GUI, and they are typically GUIDs. Examplebash\n\n```sh\n $ pulumi import keycloak:ldap/hardcodedRoleMapper:HardcodedRoleMapper assign_admin_role_to_all_users my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860/3d923ece-1a91-4bf7-adaf-3b82f2a12b67\n```\n\n ",
            "properties": {
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role which should be assigned to the users. Client roles should use the format `{{client_id}}.{{client_role_name}}`.\n"
                }
            },
            "required": [
                "ldapUserFederationId",
                "name",
                "realmId",
                "role"
            ],
            "inputProperties": {
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role which should be assigned to the users. Client roles should use the format `{{client_id}}.{{client_role_name}}`.\n"
                }
            },
            "requiredInputs": [
                "ldapUserFederationId",
                "realmId",
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedRoleMapper resources.\n",
                "properties": {
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this LDAP mapper will exist in.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the role which should be assigned to the users. Client roles should use the format `{{client_id}}.{{client_role_name}}`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/msadLdsUserAccountControlMapper:MsadLdsUserAccountControlMapper": {
            "description": "Allows for creating and managing MSAD-LDS user account control mappers for Keycloak\nusers federated via LDAP.\n\nThe MSAD-LDS (Microsoft Active Directory Lightweight Directory Service) user account control mapper is specific\nto LDAP user federation providers that are pulling from AD-LDS, and it can propagate\nAD-LDS user state to Keycloak in order to enforce settings like expired passwords\nor disabled accounts.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldapUserFederation\", {\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"objectGUID\",\n    userObjectClasses: [\n        \"person\",\n        \"organizationalPerson\",\n        \"user\",\n    ],\n    connectionUrl: \"ldap://my-ad-server\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst msadLdsUserAccountControlMapper = new keycloak.ldap.MsadLdsUserAccountControlMapper(\"msadLdsUserAccountControlMapper\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"objectGUID\",\n    user_object_classes=[\n        \"person\",\n        \"organizationalPerson\",\n        \"user\",\n    ],\n    connection_url=\"ldap://my-ad-server\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nmsad_lds_user_account_control_mapper = keycloak.ldap.MsadLdsUserAccountControlMapper(\"msadLdsUserAccountControlMapper\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            RealmId = realm.Id,\n            UsernameLdapAttribute = \"cn\",\n            RdnLdapAttribute = \"cn\",\n            UuidLdapAttribute = \"objectGUID\",\n            UserObjectClasses = \n            {\n                \"person\",\n                \"organizationalPerson\",\n                \"user\",\n            },\n            ConnectionUrl = \"ldap://my-ad-server\",\n            UsersDn = \"dc=example,dc=org\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            BindCredential = \"admin\",\n        });\n        var msadLdsUserAccountControlMapper = new Keycloak.Ldap.MsadLdsUserAccountControlMapper(\"msadLdsUserAccountControlMapper\", new Keycloak.Ldap.MsadLdsUserAccountControlMapperArgs\n        {\n            RealmId = realm.Id,\n            LdapUserFederationId = ldapUserFederation.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"objectGUID\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"person\"),\n\t\t\t\tpulumi.String(\"organizationalPerson\"),\n\t\t\t\tpulumi.String(\"user\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://my-ad-server\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewMsadLdsUserAccountControlMapper(ctx, \"msadLdsUserAccountControlMapper\", \u0026ldap.MsadLdsUserAccountControlMapperArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP mappers can be imported using the format `{{realm_id}}/{{ldap_user_federation_id}}/{{ldap_mapper_id}}`. The ID of the LDAP user federation provider and the mapper can be found within the Keycloak GUI, and they are typically GUIDs. Examplebash\n\n```sh\n $ pulumi import keycloak:ldap/msadLdsUserAccountControlMapper:MsadLdsUserAccountControlMapper msad_lds_user_account_control_mapper my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860/3d923ece-1a91-4bf7-adaf-3b82f2a12b67\n```\n\n ",
            "properties": {
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                }
            },
            "required": [
                "ldapUserFederationId",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                }
            },
            "requiredInputs": [
                "ldapUserFederationId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MsadLdsUserAccountControlMapper resources.\n",
                "properties": {
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this LDAP mapper will exist in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/msadUserAccountControlMapper:MsadUserAccountControlMapper": {
            "description": "Allows for creating and managing MSAD user account control mappers for Keycloak\nusers federated via LDAP.\n\nThe MSAD (Microsoft Active Directory) user account control mapper is specific\nto LDAP user federation providers that are pulling from AD, and it can propagate\nAD user state to Keycloak in order to enforce settings like expired passwords\nor disabled accounts.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldapUserFederation\", {\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"objectGUID\",\n    userObjectClasses: [\n        \"person\",\n        \"organizationalPerson\",\n        \"user\",\n    ],\n    connectionUrl: \"ldap://my-ad-server\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst msadUserAccountControlMapper = new keycloak.ldap.MsadUserAccountControlMapper(\"msadUserAccountControlMapper\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"objectGUID\",\n    user_object_classes=[\n        \"person\",\n        \"organizationalPerson\",\n        \"user\",\n    ],\n    connection_url=\"ldap://my-ad-server\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nmsad_user_account_control_mapper = keycloak.ldap.MsadUserAccountControlMapper(\"msadUserAccountControlMapper\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            RealmId = realm.Id,\n            UsernameLdapAttribute = \"cn\",\n            RdnLdapAttribute = \"cn\",\n            UuidLdapAttribute = \"objectGUID\",\n            UserObjectClasses = \n            {\n                \"person\",\n                \"organizationalPerson\",\n                \"user\",\n            },\n            ConnectionUrl = \"ldap://my-ad-server\",\n            UsersDn = \"dc=example,dc=org\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            BindCredential = \"admin\",\n        });\n        var msadUserAccountControlMapper = new Keycloak.Ldap.MsadUserAccountControlMapper(\"msadUserAccountControlMapper\", new Keycloak.Ldap.MsadUserAccountControlMapperArgs\n        {\n            RealmId = realm.Id,\n            LdapUserFederationId = ldapUserFederation.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"objectGUID\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"person\"),\n\t\t\t\tpulumi.String(\"organizationalPerson\"),\n\t\t\t\tpulumi.String(\"user\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://my-ad-server\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewMsadUserAccountControlMapper(ctx, \"msadUserAccountControlMapper\", \u0026ldap.MsadUserAccountControlMapperArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP mappers can be imported using the format `{{realm_id}}/{{ldap_user_federation_id}}/{{ldap_mapper_id}}`. The ID of the LDAP user federation provider and the mapper can be found within the Keycloak GUI, and they are typically GUIDs. Examplebash\n\n```sh\n $ pulumi import keycloak:ldap/msadUserAccountControlMapper:MsadUserAccountControlMapper msad_user_account_control_mapper my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860/3d923ece-1a91-4bf7-adaf-3b82f2a12b67\n```\n\n ",
            "properties": {
                "ldapPasswordPolicyHintsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, advanced password policies, such as password hints and previous password history will be used when writing new passwords to AD. Defaults to `false`.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                }
            },
            "required": [
                "ldapUserFederationId",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "ldapPasswordPolicyHintsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, advanced password policies, such as password hints and previous password history will be used when writing new passwords to AD. Defaults to `false`.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                }
            },
            "requiredInputs": [
                "ldapUserFederationId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MsadUserAccountControlMapper resources.\n",
                "properties": {
                    "ldapPasswordPolicyHintsEnabled": {
                        "type": "boolean",
                        "description": "When `true`, advanced password policies, such as password hints and previous password history will be used when writing new passwords to AD. Defaults to `false`.\n"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this LDAP mapper will exist in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/roleMapper:RoleMapper": {
            "description": "Allows for creating and managing role mappers for Keycloak users federated via LDAP.\n\nThe LDAP group mapper can be used to map an LDAP user's roles from some DN to Keycloak roles.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldapUserFederation\", {\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst ldapRoleMapper = new keycloak.ldap.RoleMapper(\"ldapRoleMapper\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    ldapRolesDn: \"dc=example,dc=org\",\n    roleNameLdapAttribute: \"cn\",\n    roleObjectClasses: [\"groupOfNames\"],\n    membershipAttributeType: \"DN\",\n    membershipLdapAttribute: \"member\",\n    membershipUserLdapAttribute: \"cn\",\n    userRolesRetrieveStrategy: \"GET_ROLES_FROM_USER_MEMBEROF_ATTRIBUTE\",\n    memberofLdapAttribute: \"memberOf\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nldap_role_mapper = keycloak.ldap.RoleMapper(\"ldapRoleMapper\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    ldap_roles_dn=\"dc=example,dc=org\",\n    role_name_ldap_attribute=\"cn\",\n    role_object_classes=[\"groupOfNames\"],\n    membership_attribute_type=\"DN\",\n    membership_ldap_attribute=\"member\",\n    membership_user_ldap_attribute=\"cn\",\n    user_roles_retrieve_strategy=\"GET_ROLES_FROM_USER_MEMBEROF_ATTRIBUTE\",\n    memberof_ldap_attribute=\"memberOf\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            RealmId = realm.Id,\n            UsernameLdapAttribute = \"cn\",\n            RdnLdapAttribute = \"cn\",\n            UuidLdapAttribute = \"entryDN\",\n            UserObjectClasses = \n            {\n                \"simpleSecurityObject\",\n                \"organizationalRole\",\n            },\n            ConnectionUrl = \"ldap://openldap\",\n            UsersDn = \"dc=example,dc=org\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            BindCredential = \"admin\",\n        });\n        var ldapRoleMapper = new Keycloak.Ldap.RoleMapper(\"ldapRoleMapper\", new Keycloak.Ldap.RoleMapperArgs\n        {\n            RealmId = realm.Id,\n            LdapUserFederationId = ldapUserFederation.Id,\n            LdapRolesDn = \"dc=example,dc=org\",\n            RoleNameLdapAttribute = \"cn\",\n            RoleObjectClasses = \n            {\n                \"groupOfNames\",\n            },\n            MembershipAttributeType = \"DN\",\n            MembershipLdapAttribute = \"member\",\n            MembershipUserLdapAttribute = \"cn\",\n            UserRolesRetrieveStrategy = \"GET_ROLES_FROM_USER_MEMBEROF_ATTRIBUTE\",\n            MemberofLdapAttribute = \"memberOf\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewRoleMapper(ctx, \"ldapRoleMapper\", \u0026ldap.RoleMapperArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tLdapUserFederationId:  ldapUserFederation.ID(),\n\t\t\tLdapRolesDn:           pulumi.String(\"dc=example,dc=org\"),\n\t\t\tRoleNameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRoleObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"groupOfNames\"),\n\t\t\t},\n\t\t\tMembershipAttributeType:     pulumi.String(\"DN\"),\n\t\t\tMembershipLdapAttribute:     pulumi.String(\"member\"),\n\t\t\tMembershipUserLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tUserRolesRetrieveStrategy:   pulumi.String(\"GET_ROLES_FROM_USER_MEMBEROF_ATTRIBUTE\"),\n\t\t\tMemberofLdapAttribute:       pulumi.String(\"memberOf\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP mappers can be imported using the format `{{realm_id}}/{{ldap_user_federation_id}}/{{ldap_mapper_id}}`. The ID of the LDAP user federation provider and the mapper can be found within the Keycloak GUI, and they are typically GUIDs. Examplebash\n\n```sh\n $ pulumi import keycloak:ldap/roleMapper:RoleMapper ldap_role_mapper my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860/3d923ece-1a91-4bf7-adaf-3b82f2a12b67\n```\n\n ",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "When specified, LDAP role mappings will be mapped to client role mappings tied to this client ID. Can only be set if `use_realm_roles_mapping` is `false`.\n"
                },
                "ldapRolesDn": {
                    "type": "string",
                    "description": "The LDAP DN where roles can be found.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "memberofLdapAttribute": {
                    "type": "string",
                    "description": "Specifies the name of the LDAP attribute on the LDAP user that contains the roles the user has. Defaults to `memberOf`. This is only used when\n"
                },
                "membershipAttributeType": {
                    "type": "string",
                    "description": "Can be one of `DN` or `UID`. Defaults to `DN`.\n"
                },
                "membershipLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute that is used for membership mappings.\n"
                },
                "membershipUserLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute on a user that is used for membership mappings.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Can be one of `READ_ONLY`, `LDAP_ONLY` or `IMPORT`. Defaults to `READ_ONLY`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                },
                "roleNameLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute that is used in role objects for the name and RDN of the role. Typically `cn`.\n"
                },
                "roleObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings representing the object classes for the role. Must contain at least one.\n"
                },
                "rolesLdapFilter": {
                    "type": "string",
                    "description": "When specified, adds an additional custom filter to be used when querying for roles. Must start with `(` and end with `)`.\n"
                },
                "useRealmRolesMapping": {
                    "type": "boolean",
                    "description": "When `true`, LDAP role mappings will be mapped to realm roles within Keycloak. Defaults to `true`.\n"
                },
                "userRolesRetrieveStrategy": {
                    "type": "string",
                    "description": "Can be one of `LOAD_ROLES_BY_MEMBER_ATTRIBUTE`, `GET_ROLES_FROM_USER_MEMBEROF_ATTRIBUTE`, or `LOAD_ROLES_BY_MEMBER_ATTRIBUTE_RECURSIVELY`. Defaults to `LOAD_ROLES_BY_MEMBER_ATTRIBUTE`.\n"
                }
            },
            "required": [
                "ldapRolesDn",
                "ldapUserFederationId",
                "membershipLdapAttribute",
                "membershipUserLdapAttribute",
                "name",
                "realmId",
                "roleNameLdapAttribute",
                "roleObjectClasses"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "When specified, LDAP role mappings will be mapped to client role mappings tied to this client ID. Can only be set if `use_realm_roles_mapping` is `false`.\n"
                },
                "ldapRolesDn": {
                    "type": "string",
                    "description": "The LDAP DN where roles can be found.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "memberofLdapAttribute": {
                    "type": "string",
                    "description": "Specifies the name of the LDAP attribute on the LDAP user that contains the roles the user has. Defaults to `memberOf`. This is only used when\n"
                },
                "membershipAttributeType": {
                    "type": "string",
                    "description": "Can be one of `DN` or `UID`. Defaults to `DN`.\n"
                },
                "membershipLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute that is used for membership mappings.\n"
                },
                "membershipUserLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute on a user that is used for membership mappings.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Can be one of `READ_ONLY`, `LDAP_ONLY` or `IMPORT`. Defaults to `READ_ONLY`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                },
                "roleNameLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute that is used in role objects for the name and RDN of the role. Typically `cn`.\n"
                },
                "roleObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings representing the object classes for the role. Must contain at least one.\n"
                },
                "rolesLdapFilter": {
                    "type": "string",
                    "description": "When specified, adds an additional custom filter to be used when querying for roles. Must start with `(` and end with `)`.\n"
                },
                "useRealmRolesMapping": {
                    "type": "boolean",
                    "description": "When `true`, LDAP role mappings will be mapped to realm roles within Keycloak. Defaults to `true`.\n"
                },
                "userRolesRetrieveStrategy": {
                    "type": "string",
                    "description": "Can be one of `LOAD_ROLES_BY_MEMBER_ATTRIBUTE`, `GET_ROLES_FROM_USER_MEMBEROF_ATTRIBUTE`, or `LOAD_ROLES_BY_MEMBER_ATTRIBUTE_RECURSIVELY`. Defaults to `LOAD_ROLES_BY_MEMBER_ATTRIBUTE`.\n"
                }
            },
            "requiredInputs": [
                "ldapRolesDn",
                "ldapUserFederationId",
                "membershipLdapAttribute",
                "membershipUserLdapAttribute",
                "realmId",
                "roleNameLdapAttribute",
                "roleObjectClasses"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RoleMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "When specified, LDAP role mappings will be mapped to client role mappings tied to this client ID. Can only be set if `use_realm_roles_mapping` is `false`.\n"
                    },
                    "ldapRolesDn": {
                        "type": "string",
                        "description": "The LDAP DN where roles can be found.\n"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                    },
                    "memberofLdapAttribute": {
                        "type": "string",
                        "description": "Specifies the name of the LDAP attribute on the LDAP user that contains the roles the user has. Defaults to `memberOf`. This is only used when\n"
                    },
                    "membershipAttributeType": {
                        "type": "string",
                        "description": "Can be one of `DN` or `UID`. Defaults to `DN`.\n"
                    },
                    "membershipLdapAttribute": {
                        "type": "string",
                        "description": "The name of the LDAP attribute that is used for membership mappings.\n"
                    },
                    "membershipUserLdapAttribute": {
                        "type": "string",
                        "description": "The name of the LDAP attribute on a user that is used for membership mappings.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "Can be one of `READ_ONLY`, `LDAP_ONLY` or `IMPORT`. Defaults to `READ_ONLY`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this LDAP mapper will exist in.\n"
                    },
                    "roleNameLdapAttribute": {
                        "type": "string",
                        "description": "The name of the LDAP attribute that is used in role objects for the name and RDN of the role. Typically `cn`.\n"
                    },
                    "roleObjectClasses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings representing the object classes for the role. Must contain at least one.\n"
                    },
                    "rolesLdapFilter": {
                        "type": "string",
                        "description": "When specified, adds an additional custom filter to be used when querying for roles. Must start with `(` and end with `)`.\n"
                    },
                    "useRealmRolesMapping": {
                        "type": "boolean",
                        "description": "When `true`, LDAP role mappings will be mapped to realm roles within Keycloak. Defaults to `true`.\n"
                    },
                    "userRolesRetrieveStrategy": {
                        "type": "string",
                        "description": "Can be one of `LOAD_ROLES_BY_MEMBER_ATTRIBUTE`, `GET_ROLES_FROM_USER_MEMBEROF_ATTRIBUTE`, or `LOAD_ROLES_BY_MEMBER_ATTRIBUTE_RECURSIVELY`. Defaults to `LOAD_ROLES_BY_MEMBER_ATTRIBUTE`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/userAttributeMapper:UserAttributeMapper": {
            "description": "Allows for creating and managing user attribute mappers for Keycloak users\nfederated via LDAP.\n\nThe LDAP user attribute mapper can be used to map a single LDAP attribute\nto an attribute on the Keycloak user model.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldapUserFederation\", {\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst ldapUserAttributeMapper = new keycloak.ldap.UserAttributeMapper(\"ldapUserAttributeMapper\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    userModelAttribute: \"foo\",\n    ldapAttribute: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nldap_user_attribute_mapper = keycloak.ldap.UserAttributeMapper(\"ldapUserAttributeMapper\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    user_model_attribute=\"foo\",\n    ldap_attribute=\"bar\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            RealmId = realm.Id,\n            UsernameLdapAttribute = \"cn\",\n            RdnLdapAttribute = \"cn\",\n            UuidLdapAttribute = \"entryDN\",\n            UserObjectClasses = \n            {\n                \"simpleSecurityObject\",\n                \"organizationalRole\",\n            },\n            ConnectionUrl = \"ldap://openldap\",\n            UsersDn = \"dc=example,dc=org\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            BindCredential = \"admin\",\n        });\n        var ldapUserAttributeMapper = new Keycloak.Ldap.UserAttributeMapper(\"ldapUserAttributeMapper\", new Keycloak.Ldap.UserAttributeMapperArgs\n        {\n            RealmId = realm.Id,\n            LdapUserFederationId = ldapUserFederation.Id,\n            UserModelAttribute = \"foo\",\n            LdapAttribute = \"bar\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewUserAttributeMapper(ctx, \"ldapUserAttributeMapper\", \u0026ldap.UserAttributeMapperArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t\tUserModelAttribute:   pulumi.String(\"foo\"),\n\t\t\tLdapAttribute:        pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP mappers can be imported using the format `{{realm_id}}/{{ldap_user_federation_id}}/{{ldap_mapper_id}}`. The ID of the LDAP user federation provider and the mapper can be found within the Keycloak GUI, and they are typically GUIDs. Examplebash\n\n```sh\n $ pulumi import keycloak:ldap/userAttributeMapper:UserAttributeMapper ldap_user_attribute_mapper my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860/3d923ece-1a91-4bf7-adaf-3b82f2a12b67\n```\n\n ",
            "properties": {
                "alwaysReadValueFromLdap": {
                    "type": "boolean",
                    "description": "When `true`, the value fetched from LDAP will override the value stored in Keycloak. Defaults to `false`.\n"
                },
                "isMandatoryInLdap": {
                    "type": "boolean",
                    "description": "When `true`, this attribute must exist in LDAP. Defaults to `false`.\n"
                },
                "ldapAttribute": {
                    "type": "string",
                    "description": "Name of the mapped attribute on the LDAP object.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "When `true`, this attribute is not saved back to LDAP when the user attribute is updated in Keycloak. Defaults to `false`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                },
                "userModelAttribute": {
                    "type": "string",
                    "description": "Name of the user property or attribute you want to map the LDAP attribute into.\n"
                }
            },
            "required": [
                "ldapAttribute",
                "ldapUserFederationId",
                "name",
                "realmId",
                "userModelAttribute"
            ],
            "inputProperties": {
                "alwaysReadValueFromLdap": {
                    "type": "boolean",
                    "description": "When `true`, the value fetched from LDAP will override the value stored in Keycloak. Defaults to `false`.\n"
                },
                "isMandatoryInLdap": {
                    "type": "boolean",
                    "description": "When `true`, this attribute must exist in LDAP. Defaults to `false`.\n"
                },
                "ldapAttribute": {
                    "type": "string",
                    "description": "Name of the mapped attribute on the LDAP object.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "When `true`, this attribute is not saved back to LDAP when the user attribute is updated in Keycloak. Defaults to `false`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                },
                "userModelAttribute": {
                    "type": "string",
                    "description": "Name of the user property or attribute you want to map the LDAP attribute into.\n"
                }
            },
            "requiredInputs": [
                "ldapAttribute",
                "ldapUserFederationId",
                "realmId",
                "userModelAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserAttributeMapper resources.\n",
                "properties": {
                    "alwaysReadValueFromLdap": {
                        "type": "boolean",
                        "description": "When `true`, the value fetched from LDAP will override the value stored in Keycloak. Defaults to `false`.\n"
                    },
                    "isMandatoryInLdap": {
                        "type": "boolean",
                        "description": "When `true`, this attribute must exist in LDAP. Defaults to `false`.\n"
                    },
                    "ldapAttribute": {
                        "type": "string",
                        "description": "Name of the mapped attribute on the LDAP object.\n"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n"
                    },
                    "readOnly": {
                        "type": "boolean",
                        "description": "When `true`, this attribute is not saved back to LDAP when the user attribute is updated in Keycloak. Defaults to `false`.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this LDAP mapper will exist in.\n"
                    },
                    "userModelAttribute": {
                        "type": "string",
                        "description": "Name of the user property or attribute you want to map the LDAP attribute into.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/userFederation:UserFederation": {
            "description": "Allows for creating and managing LDAP user federation providers within Keycloak.\n\nKeycloak can use an LDAP user federation provider to federate users to Keycloak\nfrom a directory system such as LDAP or Active Directory. Federated users\nwill exist within the realm and will be able to log in to clients. Federated\nusers can have their attributes defined using mappers.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldapUserFederation\", {\n    realmId: realm.id,\n    enabled: true,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n    connectionTimeout: \"5s\",\n    readTimeout: \"10s\",\n    kerberos: {\n        kerberosRealm: \"FOO.LOCAL\",\n        serverPrincipal: \"HTTP/host.foo.com@FOO.LOCAL\",\n        keyTab: \"/etc/host.keytab\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    realm_id=realm.id,\n    enabled=True,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\",\n    connection_timeout=\"5s\",\n    read_timeout=\"10s\",\n    kerberos=keycloak.ldap.UserFederationKerberosArgs(\n        kerberos_realm=\"FOO.LOCAL\",\n        server_principal=\"HTTP/host.foo.com@FOO.LOCAL\",\n        key_tab=\"/etc/host.keytab\",\n    ))\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            RealmId = realm.Id,\n            Enabled = true,\n            UsernameLdapAttribute = \"cn\",\n            RdnLdapAttribute = \"cn\",\n            UuidLdapAttribute = \"entryDN\",\n            UserObjectClasses = \n            {\n                \"simpleSecurityObject\",\n                \"organizationalRole\",\n            },\n            ConnectionUrl = \"ldap://openldap\",\n            UsersDn = \"dc=example,dc=org\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            BindCredential = \"admin\",\n            ConnectionTimeout = \"5s\",\n            ReadTimeout = \"10s\",\n            Kerberos = new Keycloak.Ldap.Inputs.UserFederationKerberosArgs\n            {\n                KerberosRealm = \"FOO.LOCAL\",\n                ServerPrincipal = \"HTTP/host.foo.com@FOO.LOCAL\",\n                KeyTab = \"/etc/host.keytab\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tEnabled:               pulumi.Bool(true),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:     pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:           pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:            pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential:    pulumi.String(\"admin\"),\n\t\t\tConnectionTimeout: pulumi.String(\"5s\"),\n\t\t\tReadTimeout:       pulumi.String(\"10s\"),\n\t\t\tKerberos: \u0026ldap.UserFederationKerberosArgs{\n\t\t\t\tKerberosRealm:   pulumi.String(\"FOO.LOCAL\"),\n\t\t\t\tServerPrincipal: pulumi.String(\"HTTP/host.foo.com@FOO.LOCAL\"),\n\t\t\t\tKeyTab:          pulumi.String(\"/etc/host.keytab\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP user federation providers can be imported using the format `{{realm_id}}/{{ldap_user_federation_id}}`. The ID of the LDAP user federation provider can be found within the Keycloak GUI and is typically a GUIDbash\n\n```sh\n $ pulumi import keycloak:ldap/userFederation:UserFederation ldap_user_federation my-realm/af2a6ca3-e4d7-49c3-b08b-1b3c70b4b860\n```\n\n ",
            "properties": {
                "batchSizeForSync": {
                    "type": "integer",
                    "description": "The number of users to sync within a single transaction. Defaults to `1000`.\n"
                },
                "bindCredential": {
                    "type": "string",
                    "description": "Password of LDAP admin. This attribute must be set if `bind_dn` is set.\n"
                },
                "bindDn": {
                    "type": "string",
                    "description": "DN of LDAP admin, which will be used by Keycloak to access LDAP server. This attribute must be set if `bind_credential` is set.\n"
                },
                "cache": {
                    "$ref": "#/types/keycloak:ldap/UserFederationCache:UserFederationCache",
                    "description": "A block containing the cache settings.\n"
                },
                "changedSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync changed LDAP users, in seconds. Omit this property to disable periodic changed users sync.\n"
                },
                "connectionTimeout": {
                    "type": "string",
                    "description": "LDAP connection timeout in the format of a [Go duration string](https://golang.org/pkg/time/#Duration.String).\n"
                },
                "connectionUrl": {
                    "type": "string",
                    "description": "Connection URL to the LDAP server.\n"
                },
                "customUserSearchFilter": {
                    "type": "string",
                    "description": "Additional LDAP filter for filtering searched users. Must begin with `(` and end with `)`.\n"
                },
                "editMode": {
                    "type": "string",
                    "description": "Can be one of `READ_ONLY`, `WRITABLE`, or `UNSYNCED`. `UNSYNCED` allows user data to be imported but not synced back to LDAP. Defaults to `READ_ONLY`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, this provider will not be used when performing queries for users. Defaults to `true`.\n"
                },
                "fullSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync all LDAP users, in seconds. Omit this property to disable periodic full sync.\n"
                },
                "importEnabled": {
                    "type": "boolean",
                    "description": "When `true`, LDAP users will be imported into the Keycloak database. Defaults to `true`.\n"
                },
                "kerberos": {
                    "$ref": "#/types/keycloak:ldap/UserFederationKerberos:UserFederationKerberos",
                    "description": "A block containing the kerberos settings.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the provider when displayed in the console.\n"
                },
                "pagination": {
                    "type": "boolean",
                    "description": "When true, Keycloak assumes the LDAP server supports pagination. Defaults to `true`.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of this provider when looking up users. Lower values are first. Defaults to `0`.\n"
                },
                "rdnLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as the relative distinguished name.\n"
                },
                "readTimeout": {
                    "type": "string",
                    "description": "LDAP read timeout in the format of a [Go duration string](https://golang.org/pkg/time/#Duration.String).\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this provider will provide user federation for.\n"
                },
                "searchScope": {
                    "type": "string",
                    "description": "Can be one of `ONE_LEVEL` or `SUBTREE`:\n- `ONE_LEVEL`: Only search for users in the DN specified by `user_dn`.\n- `SUBTREE`: Search entire LDAP subtree.\n"
                },
                "startTls": {
                    "type": "boolean",
                    "description": "When `true`, Keycloak will encrypt the connection to LDAP using STARTTLS, which will disable connection pooling.\n"
                },
                "syncRegistrations": {
                    "type": "boolean",
                    "description": "When `true`, newly created users will be synced back to LDAP. Defaults to `false`.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "If enabled, email provided by this provider is not verified even if verification is enabled for the realm.\n"
                },
                "usePasswordModifyExtendedOp": {
                    "type": "boolean",
                    "description": "When `true`, use the LDAPv3 Password Modify Extended Operation (RFC-3062).\n"
                },
                "useTruststoreSpi": {
                    "type": "string",
                    "description": "Can be one of `ALWAYS`, `ONLY_FOR_LDAPS`, or `NEVER`:\n"
                },
                "userObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of all values of LDAP objectClass attribute for users in LDAP. Must contain at least one.\n"
                },
                "usernameLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as the Keycloak username.\n"
                },
                "usersDn": {
                    "type": "string",
                    "description": "Full DN of LDAP tree where your users are.\n"
                },
                "uuidLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as a unique object identifier for objects in LDAP.\n"
                },
                "validatePasswordPolicy": {
                    "type": "boolean",
                    "description": "When `true`, Keycloak will validate passwords using the realm policy before updating it.\n"
                },
                "vendor": {
                    "type": "string",
                    "description": "Can be one of `OTHER`, `EDIRECTORY`, `AD`, `RHDS`, or `TIVOLI`. When this is selected in the GUI, it provides reasonable defaults for other fields. When used with the Keycloak API, this attribute does nothing, but is still required. Defaults to `OTHER`.\n"
                }
            },
            "required": [
                "connectionUrl",
                "name",
                "rdnLdapAttribute",
                "realmId",
                "userObjectClasses",
                "usernameLdapAttribute",
                "usersDn",
                "uuidLdapAttribute"
            ],
            "inputProperties": {
                "batchSizeForSync": {
                    "type": "integer",
                    "description": "The number of users to sync within a single transaction. Defaults to `1000`.\n"
                },
                "bindCredential": {
                    "type": "string",
                    "description": "Password of LDAP admin. This attribute must be set if `bind_dn` is set.\n"
                },
                "bindDn": {
                    "type": "string",
                    "description": "DN of LDAP admin, which will be used by Keycloak to access LDAP server. This attribute must be set if `bind_credential` is set.\n"
                },
                "cache": {
                    "$ref": "#/types/keycloak:ldap/UserFederationCache:UserFederationCache",
                    "description": "A block containing the cache settings.\n"
                },
                "changedSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync changed LDAP users, in seconds. Omit this property to disable periodic changed users sync.\n"
                },
                "connectionTimeout": {
                    "type": "string",
                    "description": "LDAP connection timeout in the format of a [Go duration string](https://golang.org/pkg/time/#Duration.String).\n"
                },
                "connectionUrl": {
                    "type": "string",
                    "description": "Connection URL to the LDAP server.\n"
                },
                "customUserSearchFilter": {
                    "type": "string",
                    "description": "Additional LDAP filter for filtering searched users. Must begin with `(` and end with `)`.\n"
                },
                "editMode": {
                    "type": "string",
                    "description": "Can be one of `READ_ONLY`, `WRITABLE`, or `UNSYNCED`. `UNSYNCED` allows user data to be imported but not synced back to LDAP. Defaults to `READ_ONLY`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, this provider will not be used when performing queries for users. Defaults to `true`.\n"
                },
                "fullSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync all LDAP users, in seconds. Omit this property to disable periodic full sync.\n"
                },
                "importEnabled": {
                    "type": "boolean",
                    "description": "When `true`, LDAP users will be imported into the Keycloak database. Defaults to `true`.\n"
                },
                "kerberos": {
                    "$ref": "#/types/keycloak:ldap/UserFederationKerberos:UserFederationKerberos",
                    "description": "A block containing the kerberos settings.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the provider when displayed in the console.\n"
                },
                "pagination": {
                    "type": "boolean",
                    "description": "When true, Keycloak assumes the LDAP server supports pagination. Defaults to `true`.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of this provider when looking up users. Lower values are first. Defaults to `0`.\n"
                },
                "rdnLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as the relative distinguished name.\n"
                },
                "readTimeout": {
                    "type": "string",
                    "description": "LDAP read timeout in the format of a [Go duration string](https://golang.org/pkg/time/#Duration.String).\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this provider will provide user federation for.\n"
                },
                "searchScope": {
                    "type": "string",
                    "description": "Can be one of `ONE_LEVEL` or `SUBTREE`:\n- `ONE_LEVEL`: Only search for users in the DN specified by `user_dn`.\n- `SUBTREE`: Search entire LDAP subtree.\n"
                },
                "startTls": {
                    "type": "boolean",
                    "description": "When `true`, Keycloak will encrypt the connection to LDAP using STARTTLS, which will disable connection pooling.\n"
                },
                "syncRegistrations": {
                    "type": "boolean",
                    "description": "When `true`, newly created users will be synced back to LDAP. Defaults to `false`.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "If enabled, email provided by this provider is not verified even if verification is enabled for the realm.\n"
                },
                "usePasswordModifyExtendedOp": {
                    "type": "boolean",
                    "description": "When `true`, use the LDAPv3 Password Modify Extended Operation (RFC-3062).\n"
                },
                "useTruststoreSpi": {
                    "type": "string",
                    "description": "Can be one of `ALWAYS`, `ONLY_FOR_LDAPS`, or `NEVER`:\n"
                },
                "userObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of all values of LDAP objectClass attribute for users in LDAP. Must contain at least one.\n"
                },
                "usernameLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as the Keycloak username.\n"
                },
                "usersDn": {
                    "type": "string",
                    "description": "Full DN of LDAP tree where your users are.\n"
                },
                "uuidLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as a unique object identifier for objects in LDAP.\n"
                },
                "validatePasswordPolicy": {
                    "type": "boolean",
                    "description": "When `true`, Keycloak will validate passwords using the realm policy before updating it.\n"
                },
                "vendor": {
                    "type": "string",
                    "description": "Can be one of `OTHER`, `EDIRECTORY`, `AD`, `RHDS`, or `TIVOLI`. When this is selected in the GUI, it provides reasonable defaults for other fields. When used with the Keycloak API, this attribute does nothing, but is still required. Defaults to `OTHER`.\n"
                }
            },
            "requiredInputs": [
                "connectionUrl",
                "rdnLdapAttribute",
                "realmId",
                "userObjectClasses",
                "usernameLdapAttribute",
                "usersDn",
                "uuidLdapAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserFederation resources.\n",
                "properties": {
                    "batchSizeForSync": {
                        "type": "integer",
                        "description": "The number of users to sync within a single transaction. Defaults to `1000`.\n"
                    },
                    "bindCredential": {
                        "type": "string",
                        "description": "Password of LDAP admin. This attribute must be set if `bind_dn` is set.\n"
                    },
                    "bindDn": {
                        "type": "string",
                        "description": "DN of LDAP admin, which will be used by Keycloak to access LDAP server. This attribute must be set if `bind_credential` is set.\n"
                    },
                    "cache": {
                        "$ref": "#/types/keycloak:ldap/UserFederationCache:UserFederationCache",
                        "description": "A block containing the cache settings.\n"
                    },
                    "changedSyncPeriod": {
                        "type": "integer",
                        "description": "How frequently Keycloak should sync changed LDAP users, in seconds. Omit this property to disable periodic changed users sync.\n"
                    },
                    "connectionTimeout": {
                        "type": "string",
                        "description": "LDAP connection timeout in the format of a [Go duration string](https://golang.org/pkg/time/#Duration.String).\n"
                    },
                    "connectionUrl": {
                        "type": "string",
                        "description": "Connection URL to the LDAP server.\n"
                    },
                    "customUserSearchFilter": {
                        "type": "string",
                        "description": "Additional LDAP filter for filtering searched users. Must begin with `(` and end with `)`.\n"
                    },
                    "editMode": {
                        "type": "string",
                        "description": "Can be one of `READ_ONLY`, `WRITABLE`, or `UNSYNCED`. `UNSYNCED` allows user data to be imported but not synced back to LDAP. Defaults to `READ_ONLY`.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, this provider will not be used when performing queries for users. Defaults to `true`.\n"
                    },
                    "fullSyncPeriod": {
                        "type": "integer",
                        "description": "How frequently Keycloak should sync all LDAP users, in seconds. Omit this property to disable periodic full sync.\n"
                    },
                    "importEnabled": {
                        "type": "boolean",
                        "description": "When `true`, LDAP users will be imported into the Keycloak database. Defaults to `true`.\n"
                    },
                    "kerberos": {
                        "$ref": "#/types/keycloak:ldap/UserFederationKerberos:UserFederationKerberos",
                        "description": "A block containing the kerberos settings.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the provider when displayed in the console.\n"
                    },
                    "pagination": {
                        "type": "boolean",
                        "description": "When true, Keycloak assumes the LDAP server supports pagination. Defaults to `true`.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority of this provider when looking up users. Lower values are first. Defaults to `0`.\n"
                    },
                    "rdnLdapAttribute": {
                        "type": "string",
                        "description": "Name of the LDAP attribute to use as the relative distinguished name.\n"
                    },
                    "readTimeout": {
                        "type": "string",
                        "description": "LDAP read timeout in the format of a [Go duration string](https://golang.org/pkg/time/#Duration.String).\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this provider will provide user federation for.\n"
                    },
                    "searchScope": {
                        "type": "string",
                        "description": "Can be one of `ONE_LEVEL` or `SUBTREE`:\n- `ONE_LEVEL`: Only search for users in the DN specified by `user_dn`.\n- `SUBTREE`: Search entire LDAP subtree.\n"
                    },
                    "startTls": {
                        "type": "boolean",
                        "description": "When `true`, Keycloak will encrypt the connection to LDAP using STARTTLS, which will disable connection pooling.\n"
                    },
                    "syncRegistrations": {
                        "type": "boolean",
                        "description": "When `true`, newly created users will be synced back to LDAP. Defaults to `false`.\n"
                    },
                    "trustEmail": {
                        "type": "boolean",
                        "description": "If enabled, email provided by this provider is not verified even if verification is enabled for the realm.\n"
                    },
                    "usePasswordModifyExtendedOp": {
                        "type": "boolean",
                        "description": "When `true`, use the LDAPv3 Password Modify Extended Operation (RFC-3062).\n"
                    },
                    "useTruststoreSpi": {
                        "type": "string",
                        "description": "Can be one of `ALWAYS`, `ONLY_FOR_LDAPS`, or `NEVER`:\n"
                    },
                    "userObjectClasses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Array of all values of LDAP objectClass attribute for users in LDAP. Must contain at least one.\n"
                    },
                    "usernameLdapAttribute": {
                        "type": "string",
                        "description": "Name of the LDAP attribute to use as the Keycloak username.\n"
                    },
                    "usersDn": {
                        "type": "string",
                        "description": "Full DN of LDAP tree where your users are.\n"
                    },
                    "uuidLdapAttribute": {
                        "type": "string",
                        "description": "Name of the LDAP attribute to use as a unique object identifier for objects in LDAP.\n"
                    },
                    "validatePasswordPolicy": {
                        "type": "boolean",
                        "description": "When `true`, Keycloak will validate passwords using the realm policy before updating it.\n"
                    },
                    "vendor": {
                        "type": "string",
                        "description": "Can be one of `OTHER`, `EDIRECTORY`, `AD`, `RHDS`, or `TIVOLI`. When this is selected in the GUI, it provides reasonable defaults for other fields. When used with the Keycloak API, this attribute does nothing, but is still required. Defaults to `OTHER`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:oidc/googleIdentityProvider:GoogleIdentityProvider": {
            "description": "Allows for creating and managing OIDC Identity Providers within Keycloak.\n\nOIDC (OpenID Connect) identity providers allows users to authenticate through a third party system using the OIDC standard.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst google = new keycloak.oidc.GoogleIdentityProvider(\"google\", {\n    realm: realm.id,\n    clientId: _var.google_identity_provider_client_id,\n    clientSecret: _var.google_identity_provider_client_secret,\n    trustEmail: true,\n    hostedDomain: \"example.com\",\n    syncMode: \"IMPORT\",\n    extraConfig: {\n        myCustomConfigKey: \"myValue\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\ngoogle = keycloak.oidc.GoogleIdentityProvider(\"google\",\n    realm=realm.id,\n    client_id=var[\"google_identity_provider_client_id\"],\n    client_secret=var[\"google_identity_provider_client_secret\"],\n    trust_email=True,\n    hosted_domain=\"example.com\",\n    sync_mode=\"IMPORT\",\n    extra_config={\n        \"myCustomConfigKey\": \"myValue\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var google = new Keycloak.Oidc.GoogleIdentityProvider(\"google\", new Keycloak.Oidc.GoogleIdentityProviderArgs\n        {\n            Realm = realm.Id,\n            ClientId = @var.Google_identity_provider_client_id,\n            ClientSecret = @var.Google_identity_provider_client_secret,\n            TrustEmail = true,\n            HostedDomain = \"example.com\",\n            SyncMode = \"IMPORT\",\n            ExtraConfig = \n            {\n                { \"myCustomConfigKey\", \"myValue\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/oidc\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = oidc.NewGoogleIdentityProvider(ctx, \"google\", \u0026oidc.GoogleIdentityProviderArgs{\n\t\t\tRealm:        realm.ID(),\n\t\t\tClientId:     pulumi.Any(_var.Google_identity_provider_client_id),\n\t\t\tClientSecret: pulumi.Any(_var.Google_identity_provider_client_secret),\n\t\t\tTrustEmail:   pulumi.Bool(true),\n\t\t\tHostedDomain: pulumi.String(\"example.com\"),\n\t\t\tSyncMode:     pulumi.String(\"IMPORT\"),\n\t\t\tExtraConfig: pulumi.AnyMap{\n\t\t\t\t\"myCustomConfigKey\": pulumi.Any(\"myValue\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThis resource does not yet support importing. ",
            "properties": {
                "acceptsPromptNoneForwardFromClient": {
                    "type": "boolean",
                    "description": "When `true`, unauthenticated requests with `prompt=none` will be forwarded to Google instead of returning an error. Defaults to `false`.\n"
                },
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                },
                "alias": {
                    "type": "string",
                    "description": "(Computed) The alias for the Google identity provider.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client or client identifier registered within the identity provider.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use $${vault.ID} format.\n"
                },
                "defaultScopes": {
                    "type": "string",
                    "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to `openid profile email`.\n"
                },
                "disableUserInfo": {
                    "type": "boolean",
                    "description": "When `true`, disables the usage of the user info service to obtain additional user information. Defaults to `false`.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "(Computed) Display name for the Google identity provider in the GUI.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `true`, users will be able to log in to this realm using this identity provider. Defaults to `true`.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use when users log in for the first time through this identity provider. Defaults to `first broker login`.\n"
                },
                "guiOrder": {
                    "type": "string",
                    "description": "A number defining the order of this identity provider in the GUI.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "When `true`, this identity provider will be hidden on the login page. Defaults to `false`.\n"
                },
                "hostedDomain": {
                    "type": "string",
                    "description": "Sets the \"hd\" query parameter when logging in with Google. Google will only list accounts for this domain. Keycloak will validate that the returned identity token has a claim for this domain. When `*` is entered, an account from any domain can be used.\n"
                },
                "internalId": {
                    "type": "string",
                    "description": "(Computed) The unique ID that Keycloak assigns to the identity provider upon creation.\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use after users have successfully logged in, which can be used to perform additional user verification (such as OTP checking). Defaults to an empty string, which means no post login flow will be used.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The ID of the identity provider to use. Defaults to `google`, which should be used unless you have extended Keycloak and provided your own implementation.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak.\n"
                },
                "requestRefreshToken": {
                    "type": "boolean",
                    "description": "Sets the \"access_type\" query parameter to \"offline\" when redirecting to google authorization endpoint,to get a refresh token back. This is useful for using Token Exchange to retrieve a Google token to access Google APIs when the user is offline.\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                },
                "syncMode": {
                    "type": "string",
                    "description": "The default sync mode to use for all mappers attached to this identity provider. Can be once of `IMPORT`, `FORCE`, or `LEGACY`.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                },
                "useUserIpParam": {
                    "type": "boolean",
                    "description": "Sets the \"userIp\" query parameter when querying Google's User Info service. This will use the user's IP address. This is useful if Google is throttling Keycloak's access to the User Info service.\n"
                }
            },
            "required": [
                "alias",
                "clientId",
                "clientSecret",
                "displayName",
                "internalId",
                "realm"
            ],
            "inputProperties": {
                "acceptsPromptNoneForwardFromClient": {
                    "type": "boolean",
                    "description": "When `true`, unauthenticated requests with `prompt=none` will be forwarded to Google instead of returning an error. Defaults to `false`.\n"
                },
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client or client identifier registered within the identity provider.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use $${vault.ID} format.\n"
                },
                "defaultScopes": {
                    "type": "string",
                    "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to `openid profile email`.\n"
                },
                "disableUserInfo": {
                    "type": "boolean",
                    "description": "When `true`, disables the usage of the user info service to obtain additional user information. Defaults to `false`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `true`, users will be able to log in to this realm using this identity provider. Defaults to `true`.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use when users log in for the first time through this identity provider. Defaults to `first broker login`.\n"
                },
                "guiOrder": {
                    "type": "string",
                    "description": "A number defining the order of this identity provider in the GUI.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "When `true`, this identity provider will be hidden on the login page. Defaults to `false`.\n"
                },
                "hostedDomain": {
                    "type": "string",
                    "description": "Sets the \"hd\" query parameter when logging in with Google. Google will only list accounts for this domain. Keycloak will validate that the returned identity token has a claim for this domain. When `*` is entered, an account from any domain can be used.\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use after users have successfully logged in, which can be used to perform additional user verification (such as OTP checking). Defaults to an empty string, which means no post login flow will be used.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The ID of the identity provider to use. Defaults to `google`, which should be used unless you have extended Keycloak and provided your own implementation.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak.\n"
                },
                "requestRefreshToken": {
                    "type": "boolean",
                    "description": "Sets the \"access_type\" query parameter to \"offline\" when redirecting to google authorization endpoint,to get a refresh token back. This is useful for using Token Exchange to retrieve a Google token to access Google APIs when the user is offline.\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                },
                "syncMode": {
                    "type": "string",
                    "description": "The default sync mode to use for all mappers attached to this identity provider. Can be once of `IMPORT`, `FORCE`, or `LEGACY`.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                },
                "useUserIpParam": {
                    "type": "boolean",
                    "description": "Sets the \"userIp\" query parameter when querying Google's User Info service. This will use the user's IP address. This is useful if Google is throttling Keycloak's access to the User Info service.\n"
                }
            },
            "requiredInputs": [
                "clientId",
                "clientSecret",
                "realm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GoogleIdentityProvider resources.\n",
                "properties": {
                    "acceptsPromptNoneForwardFromClient": {
                        "type": "boolean",
                        "description": "When `true`, unauthenticated requests with `prompt=none` will be forwarded to Google instead of returning an error. Defaults to `false`.\n"
                    },
                    "addReadTokenRoleOnCreate": {
                        "type": "boolean",
                        "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                    },
                    "alias": {
                        "type": "string",
                        "description": "(Computed) The alias for the Google identity provider.\n"
                    },
                    "authenticateByDefault": {
                        "type": "boolean",
                        "description": "Enable/disable authenticate users by default.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client or client identifier registered within the identity provider.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use $${vault.ID} format.\n"
                    },
                    "defaultScopes": {
                        "type": "string",
                        "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to `openid profile email`.\n"
                    },
                    "disableUserInfo": {
                        "type": "boolean",
                        "description": "When `true`, disables the usage of the user info service to obtain additional user information. Defaults to `false`.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "(Computed) Display name for the Google identity provider in the GUI.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `true`, users will be able to log in to this realm using this identity provider. Defaults to `true`.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "firstBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "The authentication flow to use when users log in for the first time through this identity provider. Defaults to `first broker login`.\n"
                    },
                    "guiOrder": {
                        "type": "string",
                        "description": "A number defining the order of this identity provider in the GUI.\n"
                    },
                    "hideOnLoginPage": {
                        "type": "boolean",
                        "description": "When `true`, this identity provider will be hidden on the login page. Defaults to `false`.\n"
                    },
                    "hostedDomain": {
                        "type": "string",
                        "description": "Sets the \"hd\" query parameter when logging in with Google. Google will only list accounts for this domain. Keycloak will validate that the returned identity token has a claim for this domain. When `*` is entered, an account from any domain can be used.\n"
                    },
                    "internalId": {
                        "type": "string",
                        "description": "(Computed) The unique ID that Keycloak assigns to the identity provider upon creation.\n"
                    },
                    "linkOnly": {
                        "type": "boolean",
                        "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                    },
                    "postBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "The authentication flow to use after users have successfully logged in, which can be used to perform additional user verification (such as OTP checking). Defaults to an empty string, which means no post login flow will be used.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The ID of the identity provider to use. Defaults to `google`, which should be used unless you have extended Keycloak and provided your own implementation.\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "The name of the realm. This is unique across Keycloak.\n"
                    },
                    "requestRefreshToken": {
                        "type": "boolean",
                        "description": "Sets the \"access_type\" query parameter to \"offline\" when redirecting to google authorization endpoint,to get a refresh token back. This is useful for using Token Exchange to retrieve a Google token to access Google APIs when the user is offline.\n"
                    },
                    "storeToken": {
                        "type": "boolean",
                        "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                    },
                    "syncMode": {
                        "type": "string",
                        "description": "The default sync mode to use for all mappers attached to this identity provider. Can be once of `IMPORT`, `FORCE`, or `LEGACY`.\n"
                    },
                    "trustEmail": {
                        "type": "boolean",
                        "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                    },
                    "useUserIpParam": {
                        "type": "boolean",
                        "description": "Sets the \"userIp\" query parameter when querying Google's User Info service. This will use the user's IP address. This is useful if Google is throttling Keycloak's access to the User Info service.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:oidc/identityProvider:IdentityProvider": {
            "description": "Allows for creating and managing OIDC Identity Providers within Keycloak.\n\nOIDC (OpenID Connect) identity providers allows users to authenticate through a third party system using the OIDC standard.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst realmIdentityProvider = new keycloak.oidc.IdentityProvider(\"realmIdentityProvider\", {\n    realm: realm.id,\n    alias: \"my-idp\",\n    authorizationUrl: \"https://authorizationurl.com\",\n    clientId: \"clientID\",\n    clientSecret: \"clientSecret\",\n    tokenUrl: \"https://tokenurl.com\",\n    extraConfig: {\n        clientAuthMethod: \"client_secret_post\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrealm_identity_provider = keycloak.oidc.IdentityProvider(\"realmIdentityProvider\",\n    realm=realm.id,\n    alias=\"my-idp\",\n    authorization_url=\"https://authorizationurl.com\",\n    client_id=\"clientID\",\n    client_secret=\"clientSecret\",\n    token_url=\"https://tokenurl.com\",\n    extra_config={\n        \"clientAuthMethod\": \"client_secret_post\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var realmIdentityProvider = new Keycloak.Oidc.IdentityProvider(\"realmIdentityProvider\", new Keycloak.Oidc.IdentityProviderArgs\n        {\n            Realm = realm.Id,\n            Alias = \"my-idp\",\n            AuthorizationUrl = \"https://authorizationurl.com\",\n            ClientId = \"clientID\",\n            ClientSecret = \"clientSecret\",\n            TokenUrl = \"https://tokenurl.com\",\n            ExtraConfig = \n            {\n                { \"clientAuthMethod\", \"client_secret_post\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/oidc\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = oidc.NewIdentityProvider(ctx, \"realmIdentityProvider\", \u0026oidc.IdentityProviderArgs{\n\t\t\tRealm:            realm.ID(),\n\t\t\tAlias:            pulumi.String(\"my-idp\"),\n\t\t\tAuthorizationUrl: pulumi.String(\"https://authorizationurl.com\"),\n\t\t\tClientId:         pulumi.String(\"clientID\"),\n\t\t\tClientSecret:     pulumi.String(\"clientSecret\"),\n\t\t\tTokenUrl:         pulumi.String(\"https://tokenurl.com\"),\n\t\t\tExtraConfig: pulumi.AnyMap{\n\t\t\t\t\"clientAuthMethod\": pulumi.Any(\"client_secret_post\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nIdentity providers can be imported using the format `{{realm_id}}/{{idp_alias}}`, where `idp_alias` is the identity provider alias. Examplebash\n\n```sh\n $ pulumi import keycloak:oidc/identityProvider:IdentityProvider realm_identity_provider my-realm/my-idp\n```\n\n ",
            "properties": {
                "acceptsPromptNoneForwardFromClient": {
                    "type": "boolean",
                    "description": "When `true`, the IDP will accept forwarded authentication requests that contain the `prompt=none` query parameter. Defaults to `false`.\n"
                },
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                },
                "alias": {
                    "type": "string",
                    "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "authorizationUrl": {
                    "type": "string",
                    "description": "The Authorization Url.\n"
                },
                "backchannelSupported": {
                    "type": "boolean",
                    "description": "Does the external IDP support backchannel logout? Defaults to `true`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client or client identifier registered within the identity provider.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use $${vault.ID} format.\n"
                },
                "defaultScopes": {
                    "type": "string",
                    "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to `openid`.\n"
                },
                "disableUserInfo": {
                    "type": "boolean",
                    "description": "When `true`, disables the usage of the user info service to obtain additional user information. Defaults to `false`.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "Display name for the identity provider in the GUI.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `true`, users will be able to log in to this realm using this identity provider. Defaults to `true`.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use when users log in for the first time through this identity provider. Defaults to `first broker login`.\n"
                },
                "guiOrder": {
                    "type": "string",
                    "description": "A number defining the order of this identity provider in the GUI.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "When `true`, this provider will be hidden on the login page, and is only accessible when requested explicitly. Defaults to `false`.\n"
                },
                "internalId": {
                    "type": "string",
                    "description": "(Computed) The unique ID that Keycloak assigns to the identity provider upon creation.\n"
                },
                "jwksUrl": {
                    "type": "string",
                    "description": "JSON Web Key Set URL.\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                },
                "loginHint": {
                    "type": "string",
                    "description": "Pass login hint to identity provider.\n"
                },
                "logoutUrl": {
                    "type": "string",
                    "description": "The Logout URL is the end session endpoint to use to logout user from external identity provider.\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use after users have successfully logged in, which can be used to perform additional user verification (such as OTP checking). Defaults to an empty string, which means no post login flow will be used.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The ID of the identity provider to use. Defaults to `oidc`, which should be used unless you have extended Keycloak and provided your own implementation.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak.\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                },
                "syncMode": {
                    "type": "string",
                    "description": "The default sync mode to use for all mappers attached to this identity provider. Can be once of `IMPORT`, `FORCE`, or `LEGACY`.\n"
                },
                "tokenUrl": {
                    "type": "string",
                    "description": "The Token URL.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                },
                "uiLocales": {
                    "type": "boolean",
                    "description": "Pass current locale to identity provider. Defaults to `false`.\n"
                },
                "userInfoUrl": {
                    "type": "string",
                    "description": "User Info URL.\n"
                },
                "validateSignature": {
                    "type": "boolean",
                    "description": "Enable/disable signature validation of external IDP signatures. Defaults to `false`.\n"
                }
            },
            "required": [
                "alias",
                "authorizationUrl",
                "clientId",
                "clientSecret",
                "internalId",
                "realm",
                "tokenUrl"
            ],
            "inputProperties": {
                "acceptsPromptNoneForwardFromClient": {
                    "type": "boolean",
                    "description": "When `true`, the IDP will accept forwarded authentication requests that contain the `prompt=none` query parameter. Defaults to `false`.\n"
                },
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                },
                "alias": {
                    "type": "string",
                    "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "authorizationUrl": {
                    "type": "string",
                    "description": "The Authorization Url.\n"
                },
                "backchannelSupported": {
                    "type": "boolean",
                    "description": "Does the external IDP support backchannel logout? Defaults to `true`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client or client identifier registered within the identity provider.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use $${vault.ID} format.\n"
                },
                "defaultScopes": {
                    "type": "string",
                    "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to `openid`.\n"
                },
                "disableUserInfo": {
                    "type": "boolean",
                    "description": "When `true`, disables the usage of the user info service to obtain additional user information. Defaults to `false`.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "Display name for the identity provider in the GUI.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `true`, users will be able to log in to this realm using this identity provider. Defaults to `true`.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use when users log in for the first time through this identity provider. Defaults to `first broker login`.\n"
                },
                "guiOrder": {
                    "type": "string",
                    "description": "A number defining the order of this identity provider in the GUI.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "When `true`, this provider will be hidden on the login page, and is only accessible when requested explicitly. Defaults to `false`.\n"
                },
                "jwksUrl": {
                    "type": "string",
                    "description": "JSON Web Key Set URL.\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                },
                "loginHint": {
                    "type": "string",
                    "description": "Pass login hint to identity provider.\n"
                },
                "logoutUrl": {
                    "type": "string",
                    "description": "The Logout URL is the end session endpoint to use to logout user from external identity provider.\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use after users have successfully logged in, which can be used to perform additional user verification (such as OTP checking). Defaults to an empty string, which means no post login flow will be used.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The ID of the identity provider to use. Defaults to `oidc`, which should be used unless you have extended Keycloak and provided your own implementation.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak.\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                },
                "syncMode": {
                    "type": "string",
                    "description": "The default sync mode to use for all mappers attached to this identity provider. Can be once of `IMPORT`, `FORCE`, or `LEGACY`.\n"
                },
                "tokenUrl": {
                    "type": "string",
                    "description": "The Token URL.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                },
                "uiLocales": {
                    "type": "boolean",
                    "description": "Pass current locale to identity provider. Defaults to `false`.\n"
                },
                "userInfoUrl": {
                    "type": "string",
                    "description": "User Info URL.\n"
                },
                "validateSignature": {
                    "type": "boolean",
                    "description": "Enable/disable signature validation of external IDP signatures. Defaults to `false`.\n"
                }
            },
            "requiredInputs": [
                "alias",
                "authorizationUrl",
                "clientId",
                "clientSecret",
                "realm",
                "tokenUrl"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IdentityProvider resources.\n",
                "properties": {
                    "acceptsPromptNoneForwardFromClient": {
                        "type": "boolean",
                        "description": "When `true`, the IDP will accept forwarded authentication requests that contain the `prompt=none` query parameter. Defaults to `false`.\n"
                    },
                    "addReadTokenRoleOnCreate": {
                        "type": "boolean",
                        "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                    },
                    "alias": {
                        "type": "string",
                        "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\n"
                    },
                    "authenticateByDefault": {
                        "type": "boolean",
                        "description": "Enable/disable authenticate users by default.\n"
                    },
                    "authorizationUrl": {
                        "type": "string",
                        "description": "The Authorization Url.\n"
                    },
                    "backchannelSupported": {
                        "type": "boolean",
                        "description": "Does the external IDP support backchannel logout? Defaults to `true`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client or client identifier registered within the identity provider.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use $${vault.ID} format.\n"
                    },
                    "defaultScopes": {
                        "type": "string",
                        "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to `openid`.\n"
                    },
                    "disableUserInfo": {
                        "type": "boolean",
                        "description": "When `true`, disables the usage of the user info service to obtain additional user information. Defaults to `false`.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "Display name for the identity provider in the GUI.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `true`, users will be able to log in to this realm using this identity provider. Defaults to `true`.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "firstBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "The authentication flow to use when users log in for the first time through this identity provider. Defaults to `first broker login`.\n"
                    },
                    "guiOrder": {
                        "type": "string",
                        "description": "A number defining the order of this identity provider in the GUI.\n"
                    },
                    "hideOnLoginPage": {
                        "type": "boolean",
                        "description": "When `true`, this provider will be hidden on the login page, and is only accessible when requested explicitly. Defaults to `false`.\n"
                    },
                    "internalId": {
                        "type": "string",
                        "description": "(Computed) The unique ID that Keycloak assigns to the identity provider upon creation.\n"
                    },
                    "jwksUrl": {
                        "type": "string",
                        "description": "JSON Web Key Set URL.\n"
                    },
                    "linkOnly": {
                        "type": "boolean",
                        "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                    },
                    "loginHint": {
                        "type": "string",
                        "description": "Pass login hint to identity provider.\n"
                    },
                    "logoutUrl": {
                        "type": "string",
                        "description": "The Logout URL is the end session endpoint to use to logout user from external identity provider.\n"
                    },
                    "postBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "The authentication flow to use after users have successfully logged in, which can be used to perform additional user verification (such as OTP checking). Defaults to an empty string, which means no post login flow will be used.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The ID of the identity provider to use. Defaults to `oidc`, which should be used unless you have extended Keycloak and provided your own implementation.\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "The name of the realm. This is unique across Keycloak.\n"
                    },
                    "storeToken": {
                        "type": "boolean",
                        "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                    },
                    "syncMode": {
                        "type": "string",
                        "description": "The default sync mode to use for all mappers attached to this identity provider. Can be once of `IMPORT`, `FORCE`, or `LEGACY`.\n"
                    },
                    "tokenUrl": {
                        "type": "string",
                        "description": "The Token URL.\n"
                    },
                    "trustEmail": {
                        "type": "boolean",
                        "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                    },
                    "uiLocales": {
                        "type": "boolean",
                        "description": "Pass current locale to identity provider. Defaults to `false`.\n"
                    },
                    "userInfoUrl": {
                        "type": "string",
                        "description": "User Info URL.\n"
                    },
                    "validateSignature": {
                        "type": "boolean",
                        "description": "Enable/disable signature validation of external IDP signatures. Defaults to `false`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/audienceProtocolMapper:AudienceProtocolMapper": {
            "description": "Allows for creating and managing audience protocol mappers within Keycloak.\n\nAudience protocol mappers allow you add audiences to the `aud` claim within issued tokens. The audience can be a custom\nstring, or it can be mapped to the ID of a pre-existing client.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst audienceMapper = new keycloak.openid.AudienceProtocolMapper(\"audienceMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    includedCustomAudience: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\naudience_mapper = keycloak.openid.AudienceProtocolMapper(\"audienceMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    included_custom_audience=\"foo\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var audienceMapper = new Keycloak.OpenId.AudienceProtocolMapper(\"audienceMapper\", new Keycloak.OpenId.AudienceProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n            IncludedCustomAudience = \"foo\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewAudienceProtocolMapper(ctx, \"audienceMapper\", \u0026openid.AudienceProtocolMapperArgs{\n\t\t\tRealmId:                realm.ID(),\n\t\t\tClientId:               openidClient.ID(),\n\t\t\tIncludedCustomAudience: pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst audienceMapper = new keycloak.openid.AudienceProtocolMapper(\"audienceMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    includedCustomAudience: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\naudience_mapper = keycloak.openid.AudienceProtocolMapper(\"audienceMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    included_custom_audience=\"foo\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var audienceMapper = new Keycloak.OpenId.AudienceProtocolMapper(\"audienceMapper\", new Keycloak.OpenId.AudienceProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            IncludedCustomAudience = \"foo\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewAudienceProtocolMapper(ctx, \"audienceMapper\", \u0026openid.AudienceProtocolMapperArgs{\n\t\t\tRealmId:                realm.ID(),\n\t\t\tClientScopeId:          clientScope.ID(),\n\t\t\tIncludedCustomAudience: pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nProtocol mappers can be imported using one of the following formats- Client`{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}` - Client Scope`{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}` Examplebash\n\n```sh\n $ pulumi import keycloak:openid/audienceProtocolMapper:AudienceProtocolMapper audience_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n\n\n```sh\n $ pulumi import keycloak:openid/audienceProtocolMapper:AudienceProtocolMapper audience_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n ",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "includedClientAudience": {
                    "type": "string",
                    "description": "A client ID to include within the token's `aud` claim. Conflicts with `included_custom_audience`. One of `included_client_audience` or `included_custom_audience` must be specified.\n"
                },
                "includedCustomAudience": {
                    "type": "string",
                    "description": "A custom audience to include within the token's `aud` claim. Conflicts with `included_client_audience`. One of `included_client_audience` or `included_custom_audience` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "includedClientAudience": {
                    "type": "string",
                    "description": "A client ID to include within the token's `aud` claim. Conflicts with `included_custom_audience`. One of `included_client_audience` or `included_custom_audience` must be specified.\n"
                },
                "includedCustomAudience": {
                    "type": "string",
                    "description": "A custom audience to include within the token's `aud` claim. Conflicts with `included_client_audience`. One of `included_client_audience` or `included_custom_audience` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AudienceProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "includedClientAudience": {
                        "type": "string",
                        "description": "A client ID to include within the token's `aud` claim. Conflicts with `included_custom_audience`. One of `included_client_audience` or `included_custom_audience` must be specified.\n"
                    },
                    "includedCustomAudience": {
                        "type": "string",
                        "description": "A custom audience to include within the token's `aud` claim. Conflicts with `included_client_audience`. One of `included_client_audience` or `included_custom_audience` must be specified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/audienceResolveProtocolMappter:AudienceResolveProtocolMappter": {
            "description": "Allows for creating the \"Audience Resolve\" OIDC protocol mapper within Keycloak.\n\nThis protocol mapper is useful to avoid manual management of audiences, instead relying on the presence of client roles\nto imply which audiences are appropriate for the token. See the\n[Keycloak docs](https://www.keycloak.org/docs/latest/server_admin/#_audience_resolve) for more details.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst audienceMapper = new keycloak.openid.AudienceResolveProtocolMappter(\"audienceMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\naudience_mapper = keycloak.openid.AudienceResolveProtocolMappter(\"audienceMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var audienceMapper = new Keycloak.OpenId.AudienceResolveProtocolMappter(\"audienceMapper\", new Keycloak.OpenId.AudienceResolveProtocolMappterArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewAudienceResolveProtocolMappter(ctx, \"audienceMapper\", \u0026openid.AudienceResolveProtocolMappterArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: openidClient.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst audienceMapper = new keycloak.openid.AudienceProtocolMapper(\"audienceMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\naudience_mapper = keycloak.openid.AudienceProtocolMapper(\"audienceMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var audienceMapper = new Keycloak.OpenId.AudienceProtocolMapper(\"audienceMapper\", new Keycloak.OpenId.AudienceProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewAudienceProtocolMapper(ctx, \"audienceMapper\", \u0026openid.AudienceProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nProtocol mappers can be imported using one of the following formats- Client`{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}` - Client Scope`{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}` Examplebash\n\n```sh\n $ pulumi import keycloak:openid/audienceResolveProtocolMappter:AudienceResolveProtocolMappter audience_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n\n\n```sh\n $ pulumi import keycloak:openid/audienceResolveProtocolMappter:AudienceResolveProtocolMappter audience_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n ",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI. Defaults to \"audience resolve\".\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI. Defaults to \"audience resolve\".\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AudienceResolveProtocolMappter resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI. Defaults to \"audience resolve\".\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/client:Client": {
            "description": "Allows for creating and managing Keycloak clients that use the OpenID Connect protocol.\n\nClients are entities that can use Keycloak for user authentication. Typically,\nclients are applications that redirect users to Keycloak for authentication\nin order to take advantage of Keycloak's user sessions for SSO.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"test-client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n    loginTheme: \"keycloak\",\n    extraConfig: {\n        key1: \"value1\",\n        key2: \"value2\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"test-client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"],\n    login_theme=\"keycloak\",\n    extra_config={\n        \"key1\": \"value1\",\n        \"key2\": \"value2\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"test-client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n            LoginTheme = \"keycloak\",\n            ExtraConfig = \n            {\n                { \"key1\", \"value1\" },\n                { \"key2\", \"value2\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t\tLoginTheme: pulumi.String(\"keycloak\"),\n\t\t\tExtraConfig: pulumi.AnyMap{\n\t\t\t\t\"key1\": pulumi.Any(\"value1\"),\n\t\t\t\t\"key2\": pulumi.Any(\"value2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nClients can be imported using the format `{{realm_id}}/{{client_keycloak_id}}`, where `client_keycloak_id` is the unique ID that Keycloak assigns to the client upon creation. This value can be found in the URI when editing this client in the GUI, and is typically a GUID. Examplebash\n\n```sh\n $ pulumi import keycloak:openid/client:Client openid_client my-realm/dcbc4c73-e478-4928-ae2e-d5e420223352\n```\n\n ",
            "properties": {
                "accessTokenLifespan": {
                    "type": "string",
                    "description": "The amount of time in seconds before an access token expires. This will override the default for the realm.\n"
                },
                "accessType": {
                    "type": "string",
                    "description": "Specifies the type of client, which can be one of the following:\n"
                },
                "adminUrl": {
                    "type": "string",
                    "description": "URL to the admin interface of the client.\n"
                },
                "authenticationFlowBindingOverrides": {
                    "$ref": "#/types/keycloak:openid/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides",
                    "description": "Override realm authentication flow bindings\n"
                },
                "authorization": {
                    "$ref": "#/types/keycloak:openid/ClientAuthorization:ClientAuthorization",
                    "description": "When this block is present, fine-grained authorization will be enabled for this client. The client's `access_type` must be `CONFIDENTIAL`, and `service_accounts_enabled` must be `true`. This block has the following arguments:\n"
                },
                "backchannelLogoutRevokeOfflineSessions": {
                    "type": "boolean",
                    "description": "Specifying whether a \"revoke_offline_access\" event is included in the Logout Token when the Backchannel Logout URL is used. Keycloak will revoke offline sessions when receiving a Logout Token with this event.\n"
                },
                "backchannelLogoutSessionRequired": {
                    "type": "boolean",
                    "description": "When `true`, a sid (session ID) claim will be included in the logout token when the backchannel logout URL is used. Defaults to `true`.\n"
                },
                "backchannelLogoutUrl": {
                    "type": "string",
                    "description": "The URL that will cause the client to log itself out when a logout request is sent to this realm. If omitted, no logout request will be sent to the client is this case.\n"
                },
                "baseUrl": {
                    "type": "string",
                    "description": "Default URL to use when the auth server needs to redirect or link back to the client.\n"
                },
                "clientAuthenticatorType": {
                    "type": "string",
                    "description": "Defaults to `client-secret` The authenticator type for clients with an `access_type` of `CONFIDENTIAL` or `BEARER-ONLY`. Can be one of the following:\n- `client-secret` (Default) Use client id and client secret to authenticate client.\n- `client-jwt` Use signed JWT to authenticate client. Set signing algorithm in `extra_config` with `attributes.token.endpoint.auth.signing.alg = \u003calg\u003e`\n- `client-x509` Use x509 certificate to authenticate client. Set Subject DN in `extra_config` with `attributes.x509.subjectdn = \u003csubjectDn\u003e`\n- `client-secret-jwt` Use signed JWT with client secret to authenticate client. Set signing algorithm in `extra_config` with `attributes.token.endpoint.auth.signing.alg = \u003calg\u003e`\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The Client ID for this client, referenced in the URI during authentication and in issued tokens.\n"
                },
                "clientOfflineSessionIdleTimeout": {
                    "type": "string",
                    "description": "Time a client session is allowed to be idle before it expires. Tokens are invalidated when a client session is expired. If not set it uses the standard SSO Session Idle value.\n"
                },
                "clientOfflineSessionMaxLifespan": {
                    "type": "string",
                    "description": "Max time before a client session is expired. Tokens are invalidated when a client session is expired. If not set, it uses the standard SSO Session Max value.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The secret for clients with an `access_type` of `CONFIDENTIAL` or `BEARER-ONLY`. This value is sensitive and should be treated with the same care as a password. If omitted, this will be generated by Keycloak.\n"
                },
                "clientSessionIdleTimeout": {
                    "type": "string",
                    "description": "Time a client offline session is allowed to be idle before it expires. Offline tokens are invalidated when a client offline session is expired. If not set it uses the Offline Session Idle value.\n"
                },
                "clientSessionMaxLifespan": {
                    "type": "string",
                    "description": "Max time before a client offline session is expired. Offline tokens are invalidated when a client offline session is expired. If not set, it uses the Offline Session Max value.\n"
                },
                "consentRequired": {
                    "type": "boolean",
                    "description": "When `true`, users have to consent to client access. Defaults to `false`.\n"
                },
                "consentScreenText": {
                    "type": "string",
                    "description": "The text to display on the consent screen about permissions specific to this client. This is applicable only when `display_on_consent_screen` is `true`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client in the GUI.\n"
                },
                "directAccessGrantsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, the OAuth2 Resource Owner Password Grant will be enabled for this client. Defaults to `false`.\n"
                },
                "displayOnConsentScreen": {
                    "type": "boolean",
                    "description": "When `true`, the consent screen will display information about the client itself. Defaults to `false`. This is applicable only when `consent_required` is `true`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.\n"
                },
                "excludeSessionStateFromAuthResponse": {
                    "type": "boolean",
                    "description": "When `true`, the parameter `session_state` will not be included in OpenID Connect Authentication Response.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "frontchannelLogoutEnabled": {
                    "type": "boolean",
                    "description": "When `true`, frontchannel logout will be enabled for this client. Specify the url with `frontchannel_logout_url`. Defaults to `false`.\n"
                },
                "frontchannelLogoutUrl": {
                    "type": "string",
                    "description": "The frontchannel logout url. This is applicable only when `frontchannel_logout_enabled` is `true`.\n"
                },
                "fullScopeAllowed": {
                    "type": "boolean",
                    "description": "Allow to include all roles mappings in the access token.\n"
                },
                "implicitFlowEnabled": {
                    "type": "boolean",
                    "description": "When `true`, the OAuth2 Implicit Grant will be enabled for this client. Defaults to `false`.\n"
                },
                "loginTheme": {
                    "type": "string",
                    "description": "The client login theme. This will override the default theme for the realm.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this client in the GUI.\n"
                },
                "oauth2DeviceAuthorizationGrantEnabled": {
                    "type": "boolean",
                    "description": "Enables support for OAuth 2.0 Device Authorization Grant, which means that client is an application on device that has limited input capabilities or lack a suitable browser.\n"
                },
                "oauth2DeviceCodeLifespan": {
                    "type": "string",
                    "description": "The maximum amount of time a client has to finish the device code flow before it expires.\n"
                },
                "oauth2DevicePollingInterval": {
                    "type": "string",
                    "description": "The minimum amount of time in seconds that the client should wait between polling requests to the token endpoint.\n"
                },
                "pkceCodeChallengeMethod": {
                    "type": "string",
                    "description": "The challenge method to use for Proof Key for Code Exchange. Can be either `plain` or `S256` or set to empty value ``.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client is attached to.\n"
                },
                "resourceServerId": {
                    "type": "string",
                    "description": "(Computed) When authorization is enabled for this client, this attribute is the unique ID for the client (the same value as the `.id` attribute).\n"
                },
                "rootUrl": {
                    "type": "string",
                    "description": "When specified, this URL is prepended to any relative URLs found within `valid_redirect_uris`, `web_origins`, and `admin_url`. NOTE: Due to limitations in the Keycloak API, when the `root_url` attribute is used, the `valid_redirect_uris`, `web_origins`, and `admin_url` attributes will be required.\n"
                },
                "serviceAccountUserId": {
                    "type": "string",
                    "description": "(Computed) When service accounts are enabled for this client, this attribute is the unique ID for the Keycloak user that represents this service account.\n"
                },
                "serviceAccountsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, the OAuth2 Client Credentials grant will be enabled for this client. Defaults to `false`.\n"
                },
                "standardFlowEnabled": {
                    "type": "boolean",
                    "description": "When `true`, the OAuth2 Authorization Code Grant will be enabled for this client. Defaults to `false`.\n"
                },
                "useRefreshTokens": {
                    "type": "boolean",
                    "description": "If this is `true`, a refresh_token will be created and added to the token response. If this is `false` then no refresh_token will be generated.  Defaults to `true`.\n"
                },
                "validRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of valid URIs a browser is permitted to redirect to after a successful login or logout. Simple\nwildcards in the form of an asterisk can be used here. This attribute must be set if either `standard_flow_enabled` or `implicit_flow_enabled`\nis set to `true`.\n"
                },
                "webOrigins": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of allowed CORS origins. `+` can be used to permit all valid redirect URIs, and `*` can be used to permit all origins.\n"
                }
            },
            "required": [
                "accessType",
                "clientId",
                "clientSecret",
                "name",
                "realmId",
                "resourceServerId",
                "serviceAccountUserId"
            ],
            "inputProperties": {
                "accessTokenLifespan": {
                    "type": "string",
                    "description": "The amount of time in seconds before an access token expires. This will override the default for the realm.\n"
                },
                "accessType": {
                    "type": "string",
                    "description": "Specifies the type of client, which can be one of the following:\n"
                },
                "adminUrl": {
                    "type": "string",
                    "description": "URL to the admin interface of the client.\n"
                },
                "authenticationFlowBindingOverrides": {
                    "$ref": "#/types/keycloak:openid/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides",
                    "description": "Override realm authentication flow bindings\n"
                },
                "authorization": {
                    "$ref": "#/types/keycloak:openid/ClientAuthorization:ClientAuthorization",
                    "description": "When this block is present, fine-grained authorization will be enabled for this client. The client's `access_type` must be `CONFIDENTIAL`, and `service_accounts_enabled` must be `true`. This block has the following arguments:\n"
                },
                "backchannelLogoutRevokeOfflineSessions": {
                    "type": "boolean",
                    "description": "Specifying whether a \"revoke_offline_access\" event is included in the Logout Token when the Backchannel Logout URL is used. Keycloak will revoke offline sessions when receiving a Logout Token with this event.\n"
                },
                "backchannelLogoutSessionRequired": {
                    "type": "boolean",
                    "description": "When `true`, a sid (session ID) claim will be included in the logout token when the backchannel logout URL is used. Defaults to `true`.\n"
                },
                "backchannelLogoutUrl": {
                    "type": "string",
                    "description": "The URL that will cause the client to log itself out when a logout request is sent to this realm. If omitted, no logout request will be sent to the client is this case.\n"
                },
                "baseUrl": {
                    "type": "string",
                    "description": "Default URL to use when the auth server needs to redirect or link back to the client.\n"
                },
                "clientAuthenticatorType": {
                    "type": "string",
                    "description": "Defaults to `client-secret` The authenticator type for clients with an `access_type` of `CONFIDENTIAL` or `BEARER-ONLY`. Can be one of the following:\n- `client-secret` (Default) Use client id and client secret to authenticate client.\n- `client-jwt` Use signed JWT to authenticate client. Set signing algorithm in `extra_config` with `attributes.token.endpoint.auth.signing.alg = \u003calg\u003e`\n- `client-x509` Use x509 certificate to authenticate client. Set Subject DN in `extra_config` with `attributes.x509.subjectdn = \u003csubjectDn\u003e`\n- `client-secret-jwt` Use signed JWT with client secret to authenticate client. Set signing algorithm in `extra_config` with `attributes.token.endpoint.auth.signing.alg = \u003calg\u003e`\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The Client ID for this client, referenced in the URI during authentication and in issued tokens.\n"
                },
                "clientOfflineSessionIdleTimeout": {
                    "type": "string",
                    "description": "Time a client session is allowed to be idle before it expires. Tokens are invalidated when a client session is expired. If not set it uses the standard SSO Session Idle value.\n"
                },
                "clientOfflineSessionMaxLifespan": {
                    "type": "string",
                    "description": "Max time before a client session is expired. Tokens are invalidated when a client session is expired. If not set, it uses the standard SSO Session Max value.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The secret for clients with an `access_type` of `CONFIDENTIAL` or `BEARER-ONLY`. This value is sensitive and should be treated with the same care as a password. If omitted, this will be generated by Keycloak.\n"
                },
                "clientSessionIdleTimeout": {
                    "type": "string",
                    "description": "Time a client offline session is allowed to be idle before it expires. Offline tokens are invalidated when a client offline session is expired. If not set it uses the Offline Session Idle value.\n"
                },
                "clientSessionMaxLifespan": {
                    "type": "string",
                    "description": "Max time before a client offline session is expired. Offline tokens are invalidated when a client offline session is expired. If not set, it uses the Offline Session Max value.\n"
                },
                "consentRequired": {
                    "type": "boolean",
                    "description": "When `true`, users have to consent to client access. Defaults to `false`.\n"
                },
                "consentScreenText": {
                    "type": "string",
                    "description": "The text to display on the consent screen about permissions specific to this client. This is applicable only when `display_on_consent_screen` is `true`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client in the GUI.\n"
                },
                "directAccessGrantsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, the OAuth2 Resource Owner Password Grant will be enabled for this client. Defaults to `false`.\n"
                },
                "displayOnConsentScreen": {
                    "type": "boolean",
                    "description": "When `true`, the consent screen will display information about the client itself. Defaults to `false`. This is applicable only when `consent_required` is `true`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.\n"
                },
                "excludeSessionStateFromAuthResponse": {
                    "type": "boolean",
                    "description": "When `true`, the parameter `session_state` will not be included in OpenID Connect Authentication Response.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "frontchannelLogoutEnabled": {
                    "type": "boolean",
                    "description": "When `true`, frontchannel logout will be enabled for this client. Specify the url with `frontchannel_logout_url`. Defaults to `false`.\n"
                },
                "frontchannelLogoutUrl": {
                    "type": "string",
                    "description": "The frontchannel logout url. This is applicable only when `frontchannel_logout_enabled` is `true`.\n"
                },
                "fullScopeAllowed": {
                    "type": "boolean",
                    "description": "Allow to include all roles mappings in the access token.\n"
                },
                "implicitFlowEnabled": {
                    "type": "boolean",
                    "description": "When `true`, the OAuth2 Implicit Grant will be enabled for this client. Defaults to `false`.\n"
                },
                "loginTheme": {
                    "type": "string",
                    "description": "The client login theme. This will override the default theme for the realm.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this client in the GUI.\n"
                },
                "oauth2DeviceAuthorizationGrantEnabled": {
                    "type": "boolean",
                    "description": "Enables support for OAuth 2.0 Device Authorization Grant, which means that client is an application on device that has limited input capabilities or lack a suitable browser.\n"
                },
                "oauth2DeviceCodeLifespan": {
                    "type": "string",
                    "description": "The maximum amount of time a client has to finish the device code flow before it expires.\n"
                },
                "oauth2DevicePollingInterval": {
                    "type": "string",
                    "description": "The minimum amount of time in seconds that the client should wait between polling requests to the token endpoint.\n"
                },
                "pkceCodeChallengeMethod": {
                    "type": "string",
                    "description": "The challenge method to use for Proof Key for Code Exchange. Can be either `plain` or `S256` or set to empty value ``.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client is attached to.\n"
                },
                "rootUrl": {
                    "type": "string",
                    "description": "When specified, this URL is prepended to any relative URLs found within `valid_redirect_uris`, `web_origins`, and `admin_url`. NOTE: Due to limitations in the Keycloak API, when the `root_url` attribute is used, the `valid_redirect_uris`, `web_origins`, and `admin_url` attributes will be required.\n"
                },
                "serviceAccountsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, the OAuth2 Client Credentials grant will be enabled for this client. Defaults to `false`.\n"
                },
                "standardFlowEnabled": {
                    "type": "boolean",
                    "description": "When `true`, the OAuth2 Authorization Code Grant will be enabled for this client. Defaults to `false`.\n"
                },
                "useRefreshTokens": {
                    "type": "boolean",
                    "description": "If this is `true`, a refresh_token will be created and added to the token response. If this is `false` then no refresh_token will be generated.  Defaults to `true`.\n"
                },
                "validRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of valid URIs a browser is permitted to redirect to after a successful login or logout. Simple\nwildcards in the form of an asterisk can be used here. This attribute must be set if either `standard_flow_enabled` or `implicit_flow_enabled`\nis set to `true`.\n"
                },
                "webOrigins": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of allowed CORS origins. `+` can be used to permit all valid redirect URIs, and `*` can be used to permit all origins.\n"
                }
            },
            "requiredInputs": [
                "accessType",
                "clientId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Client resources.\n",
                "properties": {
                    "accessTokenLifespan": {
                        "type": "string",
                        "description": "The amount of time in seconds before an access token expires. This will override the default for the realm.\n"
                    },
                    "accessType": {
                        "type": "string",
                        "description": "Specifies the type of client, which can be one of the following:\n"
                    },
                    "adminUrl": {
                        "type": "string",
                        "description": "URL to the admin interface of the client.\n"
                    },
                    "authenticationFlowBindingOverrides": {
                        "$ref": "#/types/keycloak:openid/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides",
                        "description": "Override realm authentication flow bindings\n"
                    },
                    "authorization": {
                        "$ref": "#/types/keycloak:openid/ClientAuthorization:ClientAuthorization",
                        "description": "When this block is present, fine-grained authorization will be enabled for this client. The client's `access_type` must be `CONFIDENTIAL`, and `service_accounts_enabled` must be `true`. This block has the following arguments:\n"
                    },
                    "backchannelLogoutRevokeOfflineSessions": {
                        "type": "boolean",
                        "description": "Specifying whether a \"revoke_offline_access\" event is included in the Logout Token when the Backchannel Logout URL is used. Keycloak will revoke offline sessions when receiving a Logout Token with this event.\n"
                    },
                    "backchannelLogoutSessionRequired": {
                        "type": "boolean",
                        "description": "When `true`, a sid (session ID) claim will be included in the logout token when the backchannel logout URL is used. Defaults to `true`.\n"
                    },
                    "backchannelLogoutUrl": {
                        "type": "string",
                        "description": "The URL that will cause the client to log itself out when a logout request is sent to this realm. If omitted, no logout request will be sent to the client is this case.\n"
                    },
                    "baseUrl": {
                        "type": "string",
                        "description": "Default URL to use when the auth server needs to redirect or link back to the client.\n"
                    },
                    "clientAuthenticatorType": {
                        "type": "string",
                        "description": "Defaults to `client-secret` The authenticator type for clients with an `access_type` of `CONFIDENTIAL` or `BEARER-ONLY`. Can be one of the following:\n- `client-secret` (Default) Use client id and client secret to authenticate client.\n- `client-jwt` Use signed JWT to authenticate client. Set signing algorithm in `extra_config` with `attributes.token.endpoint.auth.signing.alg = \u003calg\u003e`\n- `client-x509` Use x509 certificate to authenticate client. Set Subject DN in `extra_config` with `attributes.x509.subjectdn = \u003csubjectDn\u003e`\n- `client-secret-jwt` Use signed JWT with client secret to authenticate client. Set signing algorithm in `extra_config` with `attributes.token.endpoint.auth.signing.alg = \u003calg\u003e`\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The Client ID for this client, referenced in the URI during authentication and in issued tokens.\n"
                    },
                    "clientOfflineSessionIdleTimeout": {
                        "type": "string",
                        "description": "Time a client session is allowed to be idle before it expires. Tokens are invalidated when a client session is expired. If not set it uses the standard SSO Session Idle value.\n"
                    },
                    "clientOfflineSessionMaxLifespan": {
                        "type": "string",
                        "description": "Max time before a client session is expired. Tokens are invalidated when a client session is expired. If not set, it uses the standard SSO Session Max value.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The secret for clients with an `access_type` of `CONFIDENTIAL` or `BEARER-ONLY`. This value is sensitive and should be treated with the same care as a password. If omitted, this will be generated by Keycloak.\n"
                    },
                    "clientSessionIdleTimeout": {
                        "type": "string",
                        "description": "Time a client offline session is allowed to be idle before it expires. Offline tokens are invalidated when a client offline session is expired. If not set it uses the Offline Session Idle value.\n"
                    },
                    "clientSessionMaxLifespan": {
                        "type": "string",
                        "description": "Max time before a client offline session is expired. Offline tokens are invalidated when a client offline session is expired. If not set, it uses the Offline Session Max value.\n"
                    },
                    "consentRequired": {
                        "type": "boolean",
                        "description": "When `true`, users have to consent to client access. Defaults to `false`.\n"
                    },
                    "consentScreenText": {
                        "type": "string",
                        "description": "The text to display on the consent screen about permissions specific to this client. This is applicable only when `display_on_consent_screen` is `true`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of this client in the GUI.\n"
                    },
                    "directAccessGrantsEnabled": {
                        "type": "boolean",
                        "description": "When `true`, the OAuth2 Resource Owner Password Grant will be enabled for this client. Defaults to `false`.\n"
                    },
                    "displayOnConsentScreen": {
                        "type": "boolean",
                        "description": "When `true`, the consent screen will display information about the client itself. Defaults to `false`. This is applicable only when `consent_required` is `true`.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.\n"
                    },
                    "excludeSessionStateFromAuthResponse": {
                        "type": "boolean",
                        "description": "When `true`, the parameter `session_state` will not be included in OpenID Connect Authentication Response.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "frontchannelLogoutEnabled": {
                        "type": "boolean",
                        "description": "When `true`, frontchannel logout will be enabled for this client. Specify the url with `frontchannel_logout_url`. Defaults to `false`.\n"
                    },
                    "frontchannelLogoutUrl": {
                        "type": "string",
                        "description": "The frontchannel logout url. This is applicable only when `frontchannel_logout_enabled` is `true`.\n"
                    },
                    "fullScopeAllowed": {
                        "type": "boolean",
                        "description": "Allow to include all roles mappings in the access token.\n"
                    },
                    "implicitFlowEnabled": {
                        "type": "boolean",
                        "description": "When `true`, the OAuth2 Implicit Grant will be enabled for this client. Defaults to `false`.\n"
                    },
                    "loginTheme": {
                        "type": "string",
                        "description": "The client login theme. This will override the default theme for the realm.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this client in the GUI.\n"
                    },
                    "oauth2DeviceAuthorizationGrantEnabled": {
                        "type": "boolean",
                        "description": "Enables support for OAuth 2.0 Device Authorization Grant, which means that client is an application on device that has limited input capabilities or lack a suitable browser.\n"
                    },
                    "oauth2DeviceCodeLifespan": {
                        "type": "string",
                        "description": "The maximum amount of time a client has to finish the device code flow before it expires.\n"
                    },
                    "oauth2DevicePollingInterval": {
                        "type": "string",
                        "description": "The minimum amount of time in seconds that the client should wait between polling requests to the token endpoint.\n"
                    },
                    "pkceCodeChallengeMethod": {
                        "type": "string",
                        "description": "The challenge method to use for Proof Key for Code Exchange. Can be either `plain` or `S256` or set to empty value ``.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this client is attached to.\n"
                    },
                    "resourceServerId": {
                        "type": "string",
                        "description": "(Computed) When authorization is enabled for this client, this attribute is the unique ID for the client (the same value as the `.id` attribute).\n"
                    },
                    "rootUrl": {
                        "type": "string",
                        "description": "When specified, this URL is prepended to any relative URLs found within `valid_redirect_uris`, `web_origins`, and `admin_url`. NOTE: Due to limitations in the Keycloak API, when the `root_url` attribute is used, the `valid_redirect_uris`, `web_origins`, and `admin_url` attributes will be required.\n"
                    },
                    "serviceAccountUserId": {
                        "type": "string",
                        "description": "(Computed) When service accounts are enabled for this client, this attribute is the unique ID for the Keycloak user that represents this service account.\n"
                    },
                    "serviceAccountsEnabled": {
                        "type": "boolean",
                        "description": "When `true`, the OAuth2 Client Credentials grant will be enabled for this client. Defaults to `false`.\n"
                    },
                    "standardFlowEnabled": {
                        "type": "boolean",
                        "description": "When `true`, the OAuth2 Authorization Code Grant will be enabled for this client. Defaults to `false`.\n"
                    },
                    "useRefreshTokens": {
                        "type": "boolean",
                        "description": "If this is `true`, a refresh_token will be created and added to the token response. If this is `false` then no refresh_token will be generated.  Defaults to `true`.\n"
                    },
                    "validRedirectUris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of valid URIs a browser is permitted to redirect to after a successful login or logout. Simple\nwildcards in the form of an asterisk can be used here. This attribute must be set if either `standard_flow_enabled` or `implicit_flow_enabled`\nis set to `true`.\n"
                    },
                    "webOrigins": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of allowed CORS origins. `+` can be used to permit all valid redirect URIs, and `*` can be used to permit all origins.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientAggregatePolicy:ClientAggregatePolicy": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "required": [
                "decisionStrategy",
                "name",
                "policies",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "decisionStrategy",
                "policies",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientAggregatePolicy resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientAuthorizationPermission:ClientAuthorizationPermission": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "resources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "resources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "type": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientAuthorizationPermission resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "resources": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientAuthorizationResource:ClientAuthorizationResource": {
            "properties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "displayName": {
                    "type": "string"
                },
                "iconUri": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "ownerManagedAccess": {
                    "type": "boolean"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "type": {
                    "type": "string"
                },
                "uris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "displayName": {
                    "type": "string"
                },
                "iconUri": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "ownerManagedAccess": {
                    "type": "boolean"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "type": {
                    "type": "string"
                },
                "uris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "requiredInputs": [
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientAuthorizationResource resources.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "displayName": {
                        "type": "string"
                    },
                    "iconUri": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "ownerManagedAccess": {
                        "type": "boolean"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "type": {
                        "type": "string"
                    },
                    "uris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientAuthorizationScope:ClientAuthorizationScope": {
            "properties": {
                "displayName": {
                    "type": "string"
                },
                "iconUri": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "displayName": {
                    "type": "string"
                },
                "iconUri": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientAuthorizationScope resources.\n",
                "properties": {
                    "displayName": {
                        "type": "string"
                    },
                    "iconUri": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientDefaultScopes:ClientDefaultScopes": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"test-client\",\n    accessType: \"CONFIDENTIAL\",\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst clientDefaultScopes = new keycloak.openid.ClientDefaultScopes(\"clientDefaultScopes\", {\n    realmId: realm.id,\n    clientId: client.id,\n    defaultScopes: [\n        \"profile\",\n        \"email\",\n        \"roles\",\n        \"web-origins\",\n        clientScope.name,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"test-client\",\n    access_type=\"CONFIDENTIAL\")\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nclient_default_scopes = keycloak.openid.ClientDefaultScopes(\"clientDefaultScopes\",\n    realm_id=realm.id,\n    client_id=client.id,\n    default_scopes=[\n        \"profile\",\n        \"email\",\n        \"roles\",\n        \"web-origins\",\n        client_scope.name,\n    ])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var client = new Keycloak.OpenId.Client(\"client\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"test-client\",\n            AccessType = \"CONFIDENTIAL\",\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var clientDefaultScopes = new Keycloak.OpenId.ClientDefaultScopes(\"clientDefaultScopes\", new Keycloak.OpenId.ClientDefaultScopesArgs\n        {\n            RealmId = realm.Id,\n            ClientId = client.Id,\n            DefaultScopes = \n            {\n                \"profile\",\n                \"email\",\n                \"roles\",\n                \"web-origins\",\n                clientScope.Name,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientDefaultScopes(ctx, \"clientDefaultScopes\", \u0026openid.ClientDefaultScopesArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: client.ID(),\n\t\t\tDefaultScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"profile\"),\n\t\t\t\tpulumi.String(\"email\"),\n\t\t\t\tpulumi.String(\"roles\"),\n\t\t\t\tpulumi.String(\"web-origins\"),\n\t\t\t\tclientScope.Name,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThis resource does not support import. Instead of importing, feel free to create this resource as if it did not already exist on the server. ",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client to attach default scopes to. Note that this is the unique ID of the client generated by Keycloak.\n"
                },
                "defaultScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of client scope names to attach to this client.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client and scopes exists in.\n"
                }
            },
            "required": [
                "clientId",
                "defaultScopes",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client to attach default scopes to. Note that this is the unique ID of the client generated by Keycloak.\n"
                },
                "defaultScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of client scope names to attach to this client.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client and scopes exists in.\n"
                }
            },
            "requiredInputs": [
                "clientId",
                "defaultScopes",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientDefaultScopes resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The ID of the client to attach default scopes to. Note that this is the unique ID of the client generated by Keycloak.\n"
                    },
                    "defaultScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of client scope names to attach to this client.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this client and scopes exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientGroupPolicy:ClientGroupPolicy": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:openid/ClientGroupPolicyGroup:ClientGroupPolicyGroup"
                    }
                },
                "groupsClaim": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "required": [
                "decisionStrategy",
                "groups",
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:openid/ClientGroupPolicyGroup:ClientGroupPolicyGroup"
                    }
                },
                "groupsClaim": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "decisionStrategy",
                "groups",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientGroupPolicy resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "groups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:openid/ClientGroupPolicyGroup:ClientGroupPolicyGroup"
                        }
                    },
                    "groupsClaim": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientJsPolicy:ClientJsPolicy": {
            "properties": {
                "code": {
                    "type": "string"
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "code",
                "decisionStrategy",
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "code": {
                    "type": "string"
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "code",
                "decisionStrategy",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientJsPolicy resources.\n",
                "properties": {
                    "code": {
                        "type": "string"
                    },
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientOptionalScopes:ClientOptionalScopes": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"test-client\",\n    accessType: \"CONFIDENTIAL\",\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst clientOptionalScopes = new keycloak.openid.ClientOptionalScopes(\"clientOptionalScopes\", {\n    realmId: realm.id,\n    clientId: client.id,\n    optionalScopes: [\n        \"address\",\n        \"phone\",\n        \"offline_access\",\n        \"microprofile-jwt\",\n        clientScope.name,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"test-client\",\n    access_type=\"CONFIDENTIAL\")\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nclient_optional_scopes = keycloak.openid.ClientOptionalScopes(\"clientOptionalScopes\",\n    realm_id=realm.id,\n    client_id=client.id,\n    optional_scopes=[\n        \"address\",\n        \"phone\",\n        \"offline_access\",\n        \"microprofile-jwt\",\n        client_scope.name,\n    ])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var client = new Keycloak.OpenId.Client(\"client\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"test-client\",\n            AccessType = \"CONFIDENTIAL\",\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var clientOptionalScopes = new Keycloak.OpenId.ClientOptionalScopes(\"clientOptionalScopes\", new Keycloak.OpenId.ClientOptionalScopesArgs\n        {\n            RealmId = realm.Id,\n            ClientId = client.Id,\n            OptionalScopes = \n            {\n                \"address\",\n                \"phone\",\n                \"offline_access\",\n                \"microprofile-jwt\",\n                clientScope.Name,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientOptionalScopes(ctx, \"clientOptionalScopes\", \u0026openid.ClientOptionalScopesArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: client.ID(),\n\t\t\tOptionalScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"address\"),\n\t\t\t\tpulumi.String(\"phone\"),\n\t\t\t\tpulumi.String(\"offline_access\"),\n\t\t\t\tpulumi.String(\"microprofile-jwt\"),\n\t\t\t\tclientScope.Name,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThis resource does not support import. Instead of importing, feel free to create this resource as if it did not already exist on the server. ",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client to attach optional scopes to. Note that this is the unique ID of the client generated by Keycloak.\n"
                },
                "optionalScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of client scope names to attach to this client as optional scopes.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client and scopes exists in.\n"
                }
            },
            "required": [
                "clientId",
                "optionalScopes",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client to attach optional scopes to. Note that this is the unique ID of the client generated by Keycloak.\n"
                },
                "optionalScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of client scope names to attach to this client as optional scopes.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client and scopes exists in.\n"
                }
            },
            "requiredInputs": [
                "clientId",
                "optionalScopes",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientOptionalScopes resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The ID of the client to attach optional scopes to. Note that this is the unique ID of the client generated by Keycloak.\n"
                    },
                    "optionalScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of client scope names to attach to this client as optional scopes.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this client and scopes exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientPermissions:ClientPermissions": {
            "properties": {
                "authorizationResourceServerId": {
                    "type": "string",
                    "description": "Resource server id representing the realm management client on which this permission is managed\n"
                },
                "clientId": {
                    "type": "string"
                },
                "configureScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsConfigureScope:ClientPermissionsConfigureScope"
                },
                "enabled": {
                    "type": "boolean"
                },
                "manageScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsManageScope:ClientPermissionsManageScope"
                },
                "mapRolesClientScopeScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsMapRolesClientScopeScope:ClientPermissionsMapRolesClientScopeScope"
                },
                "mapRolesCompositeScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsMapRolesCompositeScope:ClientPermissionsMapRolesCompositeScope"
                },
                "mapRolesScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsMapRolesScope:ClientPermissionsMapRolesScope"
                },
                "realmId": {
                    "type": "string"
                },
                "tokenExchangeScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsTokenExchangeScope:ClientPermissionsTokenExchangeScope"
                },
                "viewScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsViewScope:ClientPermissionsViewScope"
                }
            },
            "required": [
                "authorizationResourceServerId",
                "clientId",
                "enabled",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string"
                },
                "configureScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsConfigureScope:ClientPermissionsConfigureScope"
                },
                "manageScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsManageScope:ClientPermissionsManageScope"
                },
                "mapRolesClientScopeScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsMapRolesClientScopeScope:ClientPermissionsMapRolesClientScopeScope"
                },
                "mapRolesCompositeScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsMapRolesCompositeScope:ClientPermissionsMapRolesCompositeScope"
                },
                "mapRolesScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsMapRolesScope:ClientPermissionsMapRolesScope"
                },
                "realmId": {
                    "type": "string"
                },
                "tokenExchangeScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsTokenExchangeScope:ClientPermissionsTokenExchangeScope"
                },
                "viewScope": {
                    "$ref": "#/types/keycloak:openid/ClientPermissionsViewScope:ClientPermissionsViewScope"
                }
            },
            "requiredInputs": [
                "clientId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientPermissions resources.\n",
                "properties": {
                    "authorizationResourceServerId": {
                        "type": "string",
                        "description": "Resource server id representing the realm management client on which this permission is managed\n"
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "configureScope": {
                        "$ref": "#/types/keycloak:openid/ClientPermissionsConfigureScope:ClientPermissionsConfigureScope"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "manageScope": {
                        "$ref": "#/types/keycloak:openid/ClientPermissionsManageScope:ClientPermissionsManageScope"
                    },
                    "mapRolesClientScopeScope": {
                        "$ref": "#/types/keycloak:openid/ClientPermissionsMapRolesClientScopeScope:ClientPermissionsMapRolesClientScopeScope"
                    },
                    "mapRolesCompositeScope": {
                        "$ref": "#/types/keycloak:openid/ClientPermissionsMapRolesCompositeScope:ClientPermissionsMapRolesCompositeScope"
                    },
                    "mapRolesScope": {
                        "$ref": "#/types/keycloak:openid/ClientPermissionsMapRolesScope:ClientPermissionsMapRolesScope"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "tokenExchangeScope": {
                        "$ref": "#/types/keycloak:openid/ClientPermissionsTokenExchangeScope:ClientPermissionsTokenExchangeScope"
                    },
                    "viewScope": {
                        "$ref": "#/types/keycloak:openid/ClientPermissionsViewScope:ClientPermissionsViewScope"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientPolicy:ClientPolicy": {
            "properties": {
                "clients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "required": [
                "clients",
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "clients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "clients",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientPolicy resources.\n",
                "properties": {
                    "clients": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientRolePolicy:ClientRolePolicy": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:openid/ClientRolePolicyRole:ClientRolePolicyRole"
                    }
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId",
                "resourceServerId",
                "roles",
                "type"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:openid/ClientRolePolicyRole:ClientRolePolicyRole"
                    }
                },
                "type": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "resourceServerId",
                "roles",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientRolePolicy resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:openid/ClientRolePolicyRole:ClientRolePolicyRole"
                        }
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientScope:ClientScope": {
            "description": "Allows for creating and managing Keycloak client scopes that can be attached to clients that use the OpenID Connect protocol.\n\nClient Scopes can be used to share common protocol and role mappings between multiple clients within a realm. They can also\nbe used by clients to conditionally request claims or roles for a user based on the OAuth 2.0 `scope` parameter.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClientScope = new keycloak.openid.ClientScope(\"openidClientScope\", {\n    realmId: realm.id,\n    description: \"When requested, this scope will map a user's group memberships to a claim\",\n    includeInTokenScope: true,\n    guiOrder: 1,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client_scope = keycloak.openid.ClientScope(\"openidClientScope\",\n    realm_id=realm.id,\n    description=\"When requested, this scope will map a user's group memberships to a claim\",\n    include_in_token_scope=True,\n    gui_order=1)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClientScope = new Keycloak.OpenId.ClientScope(\"openidClientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n            Description = \"When requested, this scope will map a user's group memberships to a claim\",\n            IncludeInTokenScope = true,\n            GuiOrder = 1,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientScope(ctx, \"openidClientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId:             realm.ID(),\n\t\t\tDescription:         pulumi.String(\"When requested, this scope will map a user's group memberships to a claim\"),\n\t\t\tIncludeInTokenScope: pulumi.Bool(true),\n\t\t\tGuiOrder:            pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nClient scopes can be imported using the format `{{realm_id}}/{{client_scope_id}}`, where `client_scope_id` is the unique ID that Keycloak assigns to the client scope upon creation. This value can be found in the URI when editing this client scope in the GUI, and is typically a GUID. Examplebash\n\n```sh\n $ pulumi import keycloak:openid/clientScope:ClientScope openid_client_scope my-realm/8e8f7fe1-df9b-40ed-bed3-4597aa0dac52\n```\n\n ",
            "properties": {
                "consentScreenText": {
                    "type": "string",
                    "description": "When set, a consent screen will be displayed to users authenticating to clients with this scope attached. The consent screen will display the string value of this attribute.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client scope in the GUI.\n"
                },
                "guiOrder": {
                    "type": "integer",
                    "description": "Specify order of the client scope in GUI (such as in Consent page) as integer.\n"
                },
                "includeInTokenScope": {
                    "type": "boolean",
                    "description": "When `true`, the name of this client scope will be added to the access token property 'scope' as well as to the Token Introspection Endpoint response.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this client scope in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client scope belongs to.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "consentScreenText": {
                    "type": "string",
                    "description": "When set, a consent screen will be displayed to users authenticating to clients with this scope attached. The consent screen will display the string value of this attribute.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client scope in the GUI.\n"
                },
                "guiOrder": {
                    "type": "integer",
                    "description": "Specify order of the client scope in GUI (such as in Consent page) as integer.\n"
                },
                "includeInTokenScope": {
                    "type": "boolean",
                    "description": "When `true`, the name of this client scope will be added to the access token property 'scope' as well as to the Token Introspection Endpoint response.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this client scope in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client scope belongs to.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientScope resources.\n",
                "properties": {
                    "consentScreenText": {
                        "type": "string",
                        "description": "When set, a consent screen will be displayed to users authenticating to clients with this scope attached. The consent screen will display the string value of this attribute.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of this client scope in the GUI.\n"
                    },
                    "guiOrder": {
                        "type": "integer",
                        "description": "Specify order of the client scope in GUI (such as in Consent page) as integer.\n"
                    },
                    "includeInTokenScope": {
                        "type": "boolean",
                        "description": "When `true`, the name of this client scope will be added to the access token property 'scope' as well as to the Token Introspection Endpoint response.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this client scope in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this client scope belongs to.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientServiceAccountRealmRole:ClientServiceAccountRealmRole": {
            "description": "Allows for assigning realm roles to the service account of an openid client.\nYou need to set `service_accounts_enabled` to `true` for the openid client that should be assigned the role.\n\nIf you'd like to attach client roles to a service account, please use the `keycloak.openid.ClientServiceAccountRole`\nresource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst realmRole = new keycloak.Role(\"realmRole\", {realmId: realm.id});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    serviceAccountsEnabled: true,\n});\nconst clientServiceAccountRole = new keycloak.openid.ClientServiceAccountRealmRole(\"clientServiceAccountRole\", {\n    realmId: realm.id,\n    serviceAccountUserId: client.serviceAccountUserId,\n    role: realmRole.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrealm_role = keycloak.Role(\"realmRole\", realm_id=realm.id)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    service_accounts_enabled=True)\nclient_service_account_role = keycloak.openid.ClientServiceAccountRealmRole(\"clientServiceAccountRole\",\n    realm_id=realm.id,\n    service_account_user_id=client.service_account_user_id,\n    role=realm_role.name)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var realmRole = new Keycloak.Role(\"realmRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n        });\n        var client = new Keycloak.OpenId.Client(\"client\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ServiceAccountsEnabled = true,\n        });\n        var clientServiceAccountRole = new Keycloak.OpenId.ClientServiceAccountRealmRole(\"clientServiceAccountRole\", new Keycloak.OpenId.ClientServiceAccountRealmRoleArgs\n        {\n            RealmId = realm.Id,\n            ServiceAccountUserId = client.ServiceAccountUserId,\n            Role = realmRole.Name,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmRole, err := keycloak.NewRole(ctx, \"realmRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:                realm.ID(),\n\t\t\tServiceAccountsEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientServiceAccountRealmRole(ctx, \"clientServiceAccountRole\", \u0026openid.ClientServiceAccountRealmRoleArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tServiceAccountUserId: client.ServiceAccountUserId,\n\t\t\tRole:                 realmRole.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThis resource can be imported using the format `{{realmId}}/{{serviceAccountUserId}}/{{roleId}}`. Examplebash\n\n```sh\n $ pulumi import keycloak:openid/clientServiceAccountRealmRole:ClientServiceAccountRealmRole client_service_account_role my-realm/489ba513-1ceb-49ba-ae0b-1ab1f5099ebf/c7230ab7-8e4e-4135-995d-e81b50696ad8\n```\n\n ",
            "properties": {
                "realmId": {
                    "type": "string",
                    "description": "The realm that the client and role belong to.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role that is assigned.\n"
                },
                "serviceAccountUserId": {
                    "type": "string",
                    "description": "The id of the service account that is assigned the role (the service account of the client that \"consumes\" the role).\n"
                }
            },
            "required": [
                "realmId",
                "role",
                "serviceAccountUserId"
            ],
            "inputProperties": {
                "realmId": {
                    "type": "string",
                    "description": "The realm that the client and role belong to.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role that is assigned.\n"
                },
                "serviceAccountUserId": {
                    "type": "string",
                    "description": "The id of the service account that is assigned the role (the service account of the client that \"consumes\" the role).\n"
                }
            },
            "requiredInputs": [
                "realmId",
                "role",
                "serviceAccountUserId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientServiceAccountRealmRole resources.\n",
                "properties": {
                    "realmId": {
                        "type": "string",
                        "description": "The realm that the client and role belong to.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the role that is assigned.\n"
                    },
                    "serviceAccountUserId": {
                        "type": "string",
                        "description": "The id of the service account that is assigned the role (the service account of the client that \"consumes\" the role).\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientServiceAccountRole:ClientServiceAccountRole": {
            "description": "Allows for assigning client roles to the service account of an openid client.\nYou need to set `service_accounts_enabled` to `true` for the openid client that should be assigned the role.\n\nIf you'd like to attach realm roles to a service account, please use the `keycloak.openid.ClientServiceAccountRealmRole`\nresource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\n// client1 provides a role to other clients\nconst client1 = new keycloak.openid.Client(\"client1\", {realmId: realm.id});\nconst client1Role = new keycloak.Role(\"client1Role\", {\n    realmId: realm.id,\n    clientId: client1.id,\n    description: \"A role that client1 provides\",\n});\n// client2 is assigned the role of client1\nconst client2 = new keycloak.openid.Client(\"client2\", {\n    realmId: realm.id,\n    serviceAccountsEnabled: true,\n});\nconst client2ServiceAccountRole = new keycloak.openid.ClientServiceAccountRole(\"client2ServiceAccountRole\", {\n    realmId: realm.id,\n    serviceAccountUserId: client2.serviceAccountUserId,\n    clientId: client1.id,\n    role: client1Role.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\n# client1 provides a role to other clients\nclient1 = keycloak.openid.Client(\"client1\", realm_id=realm.id)\nclient1_role = keycloak.Role(\"client1Role\",\n    realm_id=realm.id,\n    client_id=client1.id,\n    description=\"A role that client1 provides\")\n# client2 is assigned the role of client1\nclient2 = keycloak.openid.Client(\"client2\",\n    realm_id=realm.id,\n    service_accounts_enabled=True)\nclient2_service_account_role = keycloak.openid.ClientServiceAccountRole(\"client2ServiceAccountRole\",\n    realm_id=realm.id,\n    service_account_user_id=client2.service_account_user_id,\n    client_id=client1.id,\n    role=client1_role.name)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        // client1 provides a role to other clients\n        var client1 = new Keycloak.OpenId.Client(\"client1\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n        });\n        var client1Role = new Keycloak.Role(\"client1Role\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            ClientId = client1.Id,\n            Description = \"A role that client1 provides\",\n        });\n        // client2 is assigned the role of client1\n        var client2 = new Keycloak.OpenId.Client(\"client2\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ServiceAccountsEnabled = true,\n        });\n        var client2ServiceAccountRole = new Keycloak.OpenId.ClientServiceAccountRole(\"client2ServiceAccountRole\", new Keycloak.OpenId.ClientServiceAccountRoleArgs\n        {\n            RealmId = realm.Id,\n            ServiceAccountUserId = client2.ServiceAccountUserId,\n            ClientId = client1.Id,\n            Role = client1Role.Name,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient1, err := openid.NewClient(ctx, \"client1\", \u0026openid.ClientArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient1Role, err := keycloak.NewRole(ctx, \"client1Role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    client1.ID(),\n\t\t\tDescription: pulumi.String(\"A role that client1 provides\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient2, err := openid.NewClient(ctx, \"client2\", \u0026openid.ClientArgs{\n\t\t\tRealmId:                realm.ID(),\n\t\t\tServiceAccountsEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientServiceAccountRole(ctx, \"client2ServiceAccountRole\", \u0026openid.ClientServiceAccountRoleArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tServiceAccountUserId: client2.ServiceAccountUserId,\n\t\t\tClientId:             client1.ID(),\n\t\t\tRole:                 client1Role.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThis resource can be imported using the format `{{realmId}}/{{serviceAccountUserId}}/{{clientId}}/{{roleId}}`. Examplebash\n\n```sh\n $ pulumi import keycloak:openid/clientServiceAccountRole:ClientServiceAccountRole client2_service_account_role my-realm/489ba513-1ceb-49ba-ae0b-1ab1f5099ebf/baf01820-0f8b-4494-9be2-fb3bc8a397a4/c7230ab7-8e4e-4135-995d-e81b50696ad8\n```\n\n ",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The id of the client that provides the role.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the clients and roles belong to.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role that is assigned.\n"
                },
                "serviceAccountUserId": {
                    "type": "string",
                    "description": "The id of the service account that is assigned the role (the service account of the client that \"consumes\" the role).\n"
                }
            },
            "required": [
                "clientId",
                "realmId",
                "role",
                "serviceAccountUserId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The id of the client that provides the role.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the clients and roles belong to.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role that is assigned.\n"
                },
                "serviceAccountUserId": {
                    "type": "string",
                    "description": "The id of the service account that is assigned the role (the service account of the client that \"consumes\" the role).\n"
                }
            },
            "requiredInputs": [
                "clientId",
                "realmId",
                "role",
                "serviceAccountUserId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientServiceAccountRole resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The id of the client that provides the role.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm the clients and roles belong to.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the role that is assigned.\n"
                    },
                    "serviceAccountUserId": {
                        "type": "string",
                        "description": "The id of the service account that is assigned the role (the service account of the client that \"consumes\" the role).\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientTimePolicy:ClientTimePolicy": {
            "properties": {
                "dayMonth": {
                    "type": "string"
                },
                "dayMonthEnd": {
                    "type": "string"
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "hour": {
                    "type": "string"
                },
                "hourEnd": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "minute": {
                    "type": "string"
                },
                "minuteEnd": {
                    "type": "string"
                },
                "month": {
                    "type": "string"
                },
                "monthEnd": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "notBefore": {
                    "type": "string"
                },
                "notOnOrAfter": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "year": {
                    "type": "string"
                },
                "yearEnd": {
                    "type": "string"
                }
            },
            "required": [
                "decisionStrategy",
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "dayMonth": {
                    "type": "string"
                },
                "dayMonthEnd": {
                    "type": "string"
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "hour": {
                    "type": "string"
                },
                "hourEnd": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "minute": {
                    "type": "string"
                },
                "minuteEnd": {
                    "type": "string"
                },
                "month": {
                    "type": "string"
                },
                "monthEnd": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "notBefore": {
                    "type": "string"
                },
                "notOnOrAfter": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "year": {
                    "type": "string"
                },
                "yearEnd": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "decisionStrategy",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientTimePolicy resources.\n",
                "properties": {
                    "dayMonth": {
                        "type": "string"
                    },
                    "dayMonthEnd": {
                        "type": "string"
                    },
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "hour": {
                        "type": "string"
                    },
                    "hourEnd": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "minute": {
                        "type": "string"
                    },
                    "minuteEnd": {
                        "type": "string"
                    },
                    "month": {
                        "type": "string"
                    },
                    "monthEnd": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "notBefore": {
                        "type": "string"
                    },
                    "notOnOrAfter": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "year": {
                        "type": "string"
                    },
                    "yearEnd": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientUserPolicy:ClientUserPolicy": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "decisionStrategy",
                "name",
                "realmId",
                "resourceServerId",
                "users"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "requiredInputs": [
                "decisionStrategy",
                "realmId",
                "resourceServerId",
                "users"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientUserPolicy resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "users": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/fullNameProtocolMapper:FullNameProtocolMapper": {
            "description": "Allows for creating and managing full name protocol mappers within Keycloak.\n\nFull name protocol mappers allow you to map a user's first and last name to the OpenID Connect `name` claim in a token.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst fullNameMapper = new keycloak.openid.FullNameProtocolMapper(\"fullNameMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nfull_name_mapper = keycloak.openid.FullNameProtocolMapper(\"fullNameMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var fullNameMapper = new Keycloak.OpenId.FullNameProtocolMapper(\"fullNameMapper\", new Keycloak.OpenId.FullNameProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewFullNameProtocolMapper(ctx, \"fullNameMapper\", \u0026openid.FullNameProtocolMapperArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: openidClient.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst fullNameMapper = new keycloak.openid.FullNameProtocolMapper(\"fullNameMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nfull_name_mapper = keycloak.openid.FullNameProtocolMapper(\"fullNameMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var fullNameMapper = new Keycloak.OpenId.FullNameProtocolMapper(\"fullNameMapper\", new Keycloak.OpenId.FullNameProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewFullNameProtocolMapper(ctx, \"fullNameMapper\", \u0026openid.FullNameProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nProtocol mappers can be imported using one of the following formats- Client`{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}` - Client Scope`{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}` Examplebash\n\n```sh\n $ pulumi import keycloak:openid/fullNameProtocolMapper:FullNameProtocolMapper full_name_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n\n\n```sh\n $ pulumi import keycloak:openid/fullNameProtocolMapper:FullNameProtocolMapper full_name_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n ",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the user's full name should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the user's full name should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the user's full name should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the user's full name should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the user's full name should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the user's full name should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FullNameProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the user's full name should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the user's full name should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the user's full name should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/groupMembershipProtocolMapper:GroupMembershipProtocolMapper": {
            "description": "Allows for creating and managing group membership protocol mappers within Keycloak.\n\nGroup membership protocol mappers allow you to map a user's group memberships to a claim in a token.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst groupMembershipMapper = new keycloak.openid.GroupMembershipProtocolMapper(\"groupMembershipMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    claimName: \"groups\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\ngroup_membership_mapper = keycloak.openid.GroupMembershipProtocolMapper(\"groupMembershipMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    claim_name=\"groups\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var groupMembershipMapper = new Keycloak.OpenId.GroupMembershipProtocolMapper(\"groupMembershipMapper\", new Keycloak.OpenId.GroupMembershipProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n            ClaimName = \"groups\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewGroupMembershipProtocolMapper(ctx, \"groupMembershipMapper\", \u0026openid.GroupMembershipProtocolMapperArgs{\n\t\t\tRealmId:   realm.ID(),\n\t\t\tClientId:  openidClient.ID(),\n\t\t\tClaimName: pulumi.String(\"groups\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst groupMembershipMapper = new keycloak.openid.GroupMembershipProtocolMapper(\"groupMembershipMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    claimName: \"groups\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\ngroup_membership_mapper = keycloak.openid.GroupMembershipProtocolMapper(\"groupMembershipMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    claim_name=\"groups\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var groupMembershipMapper = new Keycloak.OpenId.GroupMembershipProtocolMapper(\"groupMembershipMapper\", new Keycloak.OpenId.GroupMembershipProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            ClaimName = \"groups\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewGroupMembershipProtocolMapper(ctx, \"groupMembershipMapper\", \u0026openid.GroupMembershipProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tClaimName:     pulumi.String(\"groups\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nProtocol mappers can be imported using one of the following formats- Client`{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}` - Client Scope`{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}` Examplebash\n\n```sh\n $ pulumi import keycloak:openid/groupMembershipProtocolMapper:GroupMembershipProtocolMapper group_membership_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n\n\n```sh\n $ pulumi import keycloak:openid/groupMembershipProtocolMapper:GroupMembershipProtocolMapper group_membership_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n ",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "fullPath": {
                    "type": "boolean",
                    "description": "Indicates whether the full path of the group including its parents will be used. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "fullPath": {
                    "type": "boolean",
                    "description": "Indicates whether the full path of the group including its parents will be used. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupMembershipProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "The name of the claim to insert into a token.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "fullPath": {
                        "type": "boolean",
                        "description": "Indicates whether the full path of the group including its parents will be used. Defaults to `true`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/hardcodedClaimProtocolMapper:HardcodedClaimProtocolMapper": {
            "description": "Allows for creating and managing hardcoded claim protocol mappers within Keycloak.\n\nHardcoded claim protocol mappers allow you to define a claim with a hardcoded value.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst hardcodedClaimMapper = new keycloak.openid.HardcodedClaimProtocolMapper(\"hardcodedClaimMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    claimName: \"foo\",\n    claimValue: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nhardcoded_claim_mapper = keycloak.openid.HardcodedClaimProtocolMapper(\"hardcodedClaimMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    claim_name=\"foo\",\n    claim_value=\"bar\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var hardcodedClaimMapper = new Keycloak.OpenId.HardcodedClaimProtocolMapper(\"hardcodedClaimMapper\", new Keycloak.OpenId.HardcodedClaimProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n            ClaimName = \"foo\",\n            ClaimValue = \"bar\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewHardcodedClaimProtocolMapper(ctx, \"hardcodedClaimMapper\", \u0026openid.HardcodedClaimProtocolMapperArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   openidClient.ID(),\n\t\t\tClaimName:  pulumi.String(\"foo\"),\n\t\t\tClaimValue: pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst hardcodedClaimMapper = new keycloak.openid.HardcodedClaimProtocolMapper(\"hardcodedClaimMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    claimName: \"foo\",\n    claimValue: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nhardcoded_claim_mapper = keycloak.openid.HardcodedClaimProtocolMapper(\"hardcodedClaimMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    claim_name=\"foo\",\n    claim_value=\"bar\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var hardcodedClaimMapper = new Keycloak.OpenId.HardcodedClaimProtocolMapper(\"hardcodedClaimMapper\", new Keycloak.OpenId.HardcodedClaimProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            ClaimName = \"foo\",\n            ClaimValue = \"bar\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewHardcodedClaimProtocolMapper(ctx, \"hardcodedClaimMapper\", \u0026openid.HardcodedClaimProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tClaimName:     pulumi.String(\"foo\"),\n\t\t\tClaimValue:    pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nProtocol mappers can be imported using one of the following formats- Client`{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}` - Client Scope`{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}` Examplebash\n\n```sh\n $ pulumi import keycloak:openid/hardcodedClaimProtocolMapper:HardcodedClaimProtocolMapper hardcoded_claim_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n\n\n```sh\n $ pulumi import keycloak:openid/hardcodedClaimProtocolMapper:HardcodedClaimProtocolMapper hardcoded_claim_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n ",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValue": {
                    "type": "string",
                    "description": "The hardcoded value of the claim.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "required": [
                "claimName",
                "claimValue",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValue": {
                    "type": "string",
                    "description": "The hardcoded value of the claim.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "claimValue",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedClaimProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "The name of the claim to insert into a token.\n"
                    },
                    "claimValue": {
                        "type": "string",
                        "description": "The hardcoded value of the claim.\n"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/hardcodedRoleProtocolMapper:HardcodedRoleProtocolMapper": {
            "description": "Allows for creating and managing hardcoded role protocol mappers within Keycloak.\n\nHardcoded role protocol mappers allow you to specify a single role to always map to an access token for a client.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst role = new keycloak.Role(\"role\", {realmId: realm.id});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst hardcodedRoleMapper = new keycloak.openid.HardcodedRoleProtocolMapper(\"hardcodedRoleMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    roleId: role.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrole = keycloak.Role(\"role\", realm_id=realm.id)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nhardcoded_role_mapper = keycloak.openid.HardcodedRoleProtocolMapper(\"hardcodedRoleMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    role_id=role.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var role = new Keycloak.Role(\"role\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var hardcodedRoleMapper = new Keycloak.OpenId.HardcodedRoleProtocolMapper(\"hardcodedRoleMapper\", new Keycloak.OpenId.HardcodedRoleProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n            RoleId = role.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trole, err := keycloak.NewRole(ctx, \"role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewHardcodedRoleProtocolMapper(ctx, \"hardcodedRoleMapper\", \u0026openid.HardcodedRoleProtocolMapperArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: openidClient.ID(),\n\t\t\tRoleId:   role.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst role = new keycloak.Role(\"role\", {realmId: realm.id});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst hardcodedRoleMapper = new keycloak.openid.HardcodedRoleProtocolMapper(\"hardcodedRoleMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    roleId: role.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrole = keycloak.Role(\"role\", realm_id=realm.id)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nhardcoded_role_mapper = keycloak.openid.HardcodedRoleProtocolMapper(\"hardcodedRoleMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    role_id=role.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var role = new Keycloak.Role(\"role\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var hardcodedRoleMapper = new Keycloak.OpenId.HardcodedRoleProtocolMapper(\"hardcodedRoleMapper\", new Keycloak.OpenId.HardcodedRoleProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            RoleId = role.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trole, err := keycloak.NewRole(ctx, \"role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewHardcodedRoleProtocolMapper(ctx, \"hardcodedRoleMapper\", \u0026openid.HardcodedRoleProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tRoleId:        role.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nProtocol mappers can be imported using one of the following formats- Client`{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}` - Client Scope`{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}` Examplebash\n\n```sh\n $ pulumi import keycloak:openid/hardcodedRoleProtocolMapper:HardcodedRoleProtocolMapper hardcoded_role_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n\n\n```sh\n $ pulumi import keycloak:openid/hardcodedRoleProtocolMapper:HardcodedRoleProtocolMapper hardcoded_role_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n ",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to map to an access token.\n"
                }
            },
            "required": [
                "name",
                "realmId",
                "roleId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to map to an access token.\n"
                }
            },
            "requiredInputs": [
                "realmId",
                "roleId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedRoleProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The ID of the role to map to an access token.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/scriptProtocolMapper:ScriptProtocolMapper": {
            "description": "Allows for creating and managing script protocol mappers within Keycloak.\n\nScript protocol mappers evaluate a JavaScript function to produce a token claim based on context information.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst scriptMapper = new keycloak.openid.ScriptProtocolMapper(\"scriptMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    claimName: \"foo\",\n    script: \"exports = 'foo';\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nscript_mapper = keycloak.openid.ScriptProtocolMapper(\"scriptMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    claim_name=\"foo\",\n    script=\"exports = 'foo';\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var scriptMapper = new Keycloak.OpenId.ScriptProtocolMapper(\"scriptMapper\", new Keycloak.OpenId.ScriptProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n            ClaimName = \"foo\",\n            Script = \"exports = 'foo';\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewScriptProtocolMapper(ctx, \"scriptMapper\", \u0026openid.ScriptProtocolMapperArgs{\n\t\t\tRealmId:   realm.ID(),\n\t\t\tClientId:  openidClient.ID(),\n\t\t\tClaimName: pulumi.String(\"foo\"),\n\t\t\tScript:    pulumi.String(\"exports = 'foo';\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst scriptMapper = new keycloak.openid.ScriptProtocolMapper(\"scriptMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    claimName: \"foo\",\n    script: \"exports = 'foo';\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nscript_mapper = keycloak.openid.ScriptProtocolMapper(\"scriptMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    claim_name=\"foo\",\n    script=\"exports = 'foo';\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var scriptMapper = new Keycloak.OpenId.ScriptProtocolMapper(\"scriptMapper\", new Keycloak.OpenId.ScriptProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            ClaimName = \"foo\",\n            Script = \"exports = 'foo';\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewScriptProtocolMapper(ctx, \"scriptMapper\", \u0026openid.ScriptProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tClaimName:     pulumi.String(\"foo\"),\n\t\t\tScript:        pulumi.String(\"exports = 'foo';\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nProtocol mappers can be imported using one of the following formats- Client`{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}` - Client Scope`{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}` Examplebash\n\n```sh\n $ pulumi import keycloak:openid/scriptProtocolMapper:ScriptProtocolMapper script_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n\n\n```sh\n $ pulumi import keycloak:openid/scriptProtocolMapper:ScriptProtocolMapper script_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n ",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "script": {
                    "type": "string",
                    "description": "JavaScript code to compute the claim value.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId",
                "script"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "script": {
                    "type": "string",
                    "description": "JavaScript code to compute the claim value.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId",
                "script"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ScriptProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "The name of the claim to insert into a token.\n"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "multivalued": {
                        "type": "boolean",
                        "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    },
                    "script": {
                        "type": "string",
                        "description": "JavaScript code to compute the claim value.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userAttributeProtocolMapper:UserAttributeProtocolMapper": {
            "description": "Allows for creating and managing user attribute protocol mappers within Keycloak.\n\nUser attribute protocol mappers allow you to map custom attributes defined for a user within Keycloak to a claim in a token.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userAttributeMapper = new keycloak.openid.UserAttributeProtocolMapper(\"userAttributeMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    userAttribute: \"foo\",\n    claimName: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_attribute_mapper = keycloak.openid.UserAttributeProtocolMapper(\"userAttributeMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    user_attribute=\"foo\",\n    claim_name=\"bar\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var userAttributeMapper = new Keycloak.OpenId.UserAttributeProtocolMapper(\"userAttributeMapper\", new Keycloak.OpenId.UserAttributeProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n            UserAttribute = \"foo\",\n            ClaimName = \"bar\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserAttributeProtocolMapper(ctx, \"userAttributeMapper\", \u0026openid.UserAttributeProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientId:      openidClient.ID(),\n\t\t\tUserAttribute: pulumi.String(\"foo\"),\n\t\t\tClaimName:     pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst userAttributeMapper = new keycloak.openid.UserAttributeProtocolMapper(\"userAttributeMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    userAttribute: \"foo\",\n    claimName: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nuser_attribute_mapper = keycloak.openid.UserAttributeProtocolMapper(\"userAttributeMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    user_attribute=\"foo\",\n    claim_name=\"bar\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var userAttributeMapper = new Keycloak.OpenId.UserAttributeProtocolMapper(\"userAttributeMapper\", new Keycloak.OpenId.UserAttributeProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            UserAttribute = \"foo\",\n            ClaimName = \"bar\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserAttributeProtocolMapper(ctx, \"userAttributeMapper\", \u0026openid.UserAttributeProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tUserAttribute: pulumi.String(\"foo\"),\n\t\t\tClaimName:     pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nProtocol mappers can be imported using one of the following formats- Client`{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}` - Client Scope`{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}` Examplebash\n\n```sh\n $ pulumi import keycloak:openid/userAttributeProtocolMapper:UserAttributeProtocolMapper user_attribute_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n\n\n```sh\n $ pulumi import keycloak:openid/userAttributeProtocolMapper:UserAttributeProtocolMapper user_attribute_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n ",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "aggregateAttributes": {
                    "type": "boolean",
                    "description": "Indicates whether this attribute is a single value or an array of values. Defaults to `false`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates whether this attribute is a single value or an array of values. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "userAttribute": {
                    "type": "string",
                    "description": "The custom user attribute to map a claim for.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId",
                "userAttribute"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "aggregateAttributes": {
                    "type": "boolean",
                    "description": "Indicates whether this attribute is a single value or an array of values. Defaults to `false`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates whether this attribute is a single value or an array of values. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "userAttribute": {
                    "type": "string",
                    "description": "The custom user attribute to map a claim for.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId",
                "userAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserAttributeProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                    },
                    "aggregateAttributes": {
                        "type": "boolean",
                        "description": "Indicates whether this attribute is a single value or an array of values. Defaults to `false`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "The name of the claim to insert into a token.\n"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "multivalued": {
                        "type": "boolean",
                        "description": "Indicates whether this attribute is a single value or an array of values. Defaults to `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    },
                    "userAttribute": {
                        "type": "string",
                        "description": "The custom user attribute to map a claim for.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userClientRoleProtocolMapper:UserClientRoleProtocolMapper": {
            "description": "Allows for creating and managing user client role protocol mappers within Keycloak.\n\nUser client role protocol mappers allow you to define a claim containing the list of a client roles.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userClientRoleMapper = new keycloak.openid.UserClientRoleProtocolMapper(\"userClientRoleMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    claimName: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_client_role_mapper = keycloak.openid.UserClientRoleProtocolMapper(\"userClientRoleMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    claim_name=\"foo\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var userClientRoleMapper = new Keycloak.OpenId.UserClientRoleProtocolMapper(\"userClientRoleMapper\", new Keycloak.OpenId.UserClientRoleProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n            ClaimName = \"foo\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserClientRoleProtocolMapper(ctx, \"userClientRoleMapper\", \u0026openid.UserClientRoleProtocolMapperArgs{\n\t\t\tRealmId:   realm.ID(),\n\t\t\tClientId:  openidClient.ID(),\n\t\t\tClaimName: pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst userClientRoleMapper = new keycloak.openid.UserClientRoleProtocolMapper(\"userClientRoleMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    claimName: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nuser_client_role_mapper = keycloak.openid.UserClientRoleProtocolMapper(\"userClientRoleMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    claim_name=\"foo\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var userClientRoleMapper = new Keycloak.OpenId.UserClientRoleProtocolMapper(\"userClientRoleMapper\", new Keycloak.OpenId.UserClientRoleProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            ClaimName = \"foo\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserClientRoleProtocolMapper(ctx, \"userClientRoleMapper\", \u0026openid.UserClientRoleProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tClaimName:     pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nProtocol mappers can be imported using one of the following formats- Client`{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}` - Client Scope`{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}` Examplebash\n\n```sh\n $ pulumi import keycloak:openid/userClientRoleProtocolMapper:UserClientRoleProtocolMapper user_client_role_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n\n\n```sh\n $ pulumi import keycloak:openid/userClientRoleProtocolMapper:UserClientRoleProtocolMapper user_client_role_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n ",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientIdForRoleMappings": {
                    "type": "string",
                    "description": "The Client ID for role mappings. Just client roles of this client will be added to the token. If this is unset, client roles of all clients will be added to the token.\n"
                },
                "clientRolePrefix": {
                    "type": "string",
                    "description": "A prefix for each Client Role.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientIdForRoleMappings": {
                    "type": "string",
                    "description": "The Client ID for role mappings. Just client roles of this client will be added to the token. If this is unset, client roles of all clients will be added to the token.\n"
                },
                "clientRolePrefix": {
                    "type": "string",
                    "description": "A prefix for each Client Role.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserClientRoleProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "The name of the claim to insert into a token.\n"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientIdForRoleMappings": {
                        "type": "string",
                        "description": "The Client ID for role mappings. Just client roles of this client will be added to the token. If this is unset, client roles of all clients will be added to the token.\n"
                    },
                    "clientRolePrefix": {
                        "type": "string",
                        "description": "A prefix for each Client Role.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "multivalued": {
                        "type": "boolean",
                        "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userPropertyProtocolMapper:UserPropertyProtocolMapper": {
            "description": "Allows for creating and managing user property protocol mappers within Keycloak.\n\nUser property protocol mappers allow you to map built in properties defined on the Keycloak user interface to a claim in\na token.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userPropertyMapper = new keycloak.openid.UserPropertyProtocolMapper(\"userPropertyMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    userProperty: \"email\",\n    claimName: \"email\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_property_mapper = keycloak.openid.UserPropertyProtocolMapper(\"userPropertyMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    user_property=\"email\",\n    claim_name=\"email\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var userPropertyMapper = new Keycloak.OpenId.UserPropertyProtocolMapper(\"userPropertyMapper\", new Keycloak.OpenId.UserPropertyProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n            UserProperty = \"email\",\n            ClaimName = \"email\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserPropertyProtocolMapper(ctx, \"userPropertyMapper\", \u0026openid.UserPropertyProtocolMapperArgs{\n\t\t\tRealmId:      realm.ID(),\n\t\t\tClientId:     openidClient.ID(),\n\t\t\tUserProperty: pulumi.String(\"email\"),\n\t\t\tClaimName:    pulumi.String(\"email\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst userPropertyMapper = new keycloak.openid.UserPropertyProtocolMapper(\"userPropertyMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    userProperty: \"email\",\n    claimName: \"email\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nuser_property_mapper = keycloak.openid.UserPropertyProtocolMapper(\"userPropertyMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    user_property=\"email\",\n    claim_name=\"email\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var userPropertyMapper = new Keycloak.OpenId.UserPropertyProtocolMapper(\"userPropertyMapper\", new Keycloak.OpenId.UserPropertyProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            UserProperty = \"email\",\n            ClaimName = \"email\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserPropertyProtocolMapper(ctx, \"userPropertyMapper\", \u0026openid.UserPropertyProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tUserProperty:  pulumi.String(\"email\"),\n\t\t\tClaimName:     pulumi.String(\"email\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nProtocol mappers can be imported using one of the following formats- Client`{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}` - Client Scope`{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}` Examplebash\n\n```sh\n $ pulumi import keycloak:openid/userPropertyProtocolMapper:UserPropertyProtocolMapper user_property_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n\n\n```sh\n $ pulumi import keycloak:openid/userPropertyProtocolMapper:UserPropertyProtocolMapper user_property_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n ",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified. `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "userProperty": {
                    "type": "string",
                    "description": "The built in user property (such as email) to map a claim for.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId",
                "userProperty"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified. `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "userProperty": {
                    "type": "string",
                    "description": "The built in user property (such as email) to map a claim for.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId",
                "userProperty"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserPropertyProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "The name of the claim to insert into a token.\n"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified. `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    },
                    "userProperty": {
                        "type": "string",
                        "description": "The built in user property (such as email) to map a claim for.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userRealmRoleProtocolMapper:UserRealmRoleProtocolMapper": {
            "description": "Allows for creating and managing user realm role protocol mappers within Keycloak.\n\nUser realm role protocol mappers allow you to define a claim containing the list of the realm roles.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userRealmRoleMapper = new keycloak.openid.UserRealmRoleProtocolMapper(\"userRealmRoleMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    claimName: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_realm_role_mapper = keycloak.openid.UserRealmRoleProtocolMapper(\"userRealmRoleMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    claim_name=\"foo\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var userRealmRoleMapper = new Keycloak.OpenId.UserRealmRoleProtocolMapper(\"userRealmRoleMapper\", new Keycloak.OpenId.UserRealmRoleProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n            ClaimName = \"foo\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserRealmRoleProtocolMapper(ctx, \"userRealmRoleMapper\", \u0026openid.UserRealmRoleProtocolMapperArgs{\n\t\t\tRealmId:   realm.ID(),\n\t\t\tClientId:  openidClient.ID(),\n\t\t\tClaimName: pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst userRealmRoleMapper = new keycloak.openid.UserRealmRoleProtocolMapper(\"userRealmRoleMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    claimName: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nuser_realm_role_mapper = keycloak.openid.UserRealmRoleProtocolMapper(\"userRealmRoleMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    claim_name=\"foo\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var userRealmRoleMapper = new Keycloak.OpenId.UserRealmRoleProtocolMapper(\"userRealmRoleMapper\", new Keycloak.OpenId.UserRealmRoleProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            ClaimName = \"foo\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserRealmRoleProtocolMapper(ctx, \"userRealmRoleMapper\", \u0026openid.UserRealmRoleProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tClaimName:     pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nProtocol mappers can be imported using one of the following formats- Client`{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}` - Client Scope`{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}` Examplebash\n\n```sh\n $ pulumi import keycloak:openid/userRealmRoleProtocolMapper:UserRealmRoleProtocolMapper user_realm_role_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n\n\n```sh\n $ pulumi import keycloak:openid/userRealmRoleProtocolMapper:UserRealmRoleProtocolMapper user_realm_role_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n ",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "realmRolePrefix": {
                    "type": "string",
                    "description": "A prefix for each Realm Role.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "realmRolePrefix": {
                    "type": "string",
                    "description": "A prefix for each Realm Role.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserRealmRoleProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "The name of the claim to insert into a token.\n"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "multivalued": {
                        "type": "boolean",
                        "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    },
                    "realmRolePrefix": {
                        "type": "string",
                        "description": "A prefix for each Realm Role.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userSessionNoteProtocolMapper:UserSessionNoteProtocolMapper": {
            "description": "Allows for creating and managing user session note protocol mappers within Keycloak.\n\nUser session note protocol mappers map a custom user session note to a token claim.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userSessionNoteMapper = new keycloak.openid.UserSessionNoteProtocolMapper(\"userSessionNoteMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    claimName: \"foo\",\n    claimValueType: \"String\",\n    sessionNote: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_session_note_mapper = keycloak.openid.UserSessionNoteProtocolMapper(\"userSessionNoteMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    claim_name=\"foo\",\n    claim_value_type=\"String\",\n    session_note=\"bar\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var userSessionNoteMapper = new Keycloak.OpenId.UserSessionNoteProtocolMapper(\"userSessionNoteMapper\", new Keycloak.OpenId.UserSessionNoteProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n            ClaimName = \"foo\",\n            ClaimValueType = \"String\",\n            SessionNote = \"bar\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserSessionNoteProtocolMapper(ctx, \"userSessionNoteMapper\", \u0026openid.UserSessionNoteProtocolMapperArgs{\n\t\t\tRealmId:        realm.ID(),\n\t\t\tClientId:       openidClient.ID(),\n\t\t\tClaimName:      pulumi.String(\"foo\"),\n\t\t\tClaimValueType: pulumi.String(\"String\"),\n\t\t\tSessionNote:    pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst userSessionNoteMapper = new keycloak.openid.UserSessionNoteProtocolMapper(\"userSessionNoteMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    claimName: \"foo\",\n    claimValueType: \"String\",\n    sessionNote: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nuser_session_note_mapper = keycloak.openid.UserSessionNoteProtocolMapper(\"userSessionNoteMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    claim_name=\"foo\",\n    claim_value_type=\"String\",\n    session_note=\"bar\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var userSessionNoteMapper = new Keycloak.OpenId.UserSessionNoteProtocolMapper(\"userSessionNoteMapper\", new Keycloak.OpenId.UserSessionNoteProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            ClaimName = \"foo\",\n            ClaimValueType = \"String\",\n            SessionNote = \"bar\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserSessionNoteProtocolMapper(ctx, \"userSessionNoteMapper\", \u0026openid.UserSessionNoteProtocolMapperArgs{\n\t\t\tRealmId:        realm.ID(),\n\t\t\tClientScopeId:  clientScope.ID(),\n\t\t\tClaimName:      pulumi.String(\"foo\"),\n\t\t\tClaimValueType: pulumi.String(\"String\"),\n\t\t\tSessionNote:    pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nProtocol mappers can be imported using one of the following formats- Client`{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}` - Client Scope`{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}` Examplebash\n\n```sh\n $ pulumi import keycloak:openid/userSessionNoteProtocolMapper:UserSessionNoteProtocolMapper user_session_note_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n\n\n```sh\n $ pulumi import keycloak:openid/userSessionNoteProtocolMapper:UserSessionNoteProtocolMapper user_session_note_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n ",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "sessionNote": {
                    "type": "string",
                    "description": "String value being the name of stored user session note within the UserSessionModel.note map.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "sessionNote": {
                    "type": "string",
                    "description": "String value being the name of stored user session note within the UserSessionModel.note map.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserSessionNoteProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "The name of the claim to insert into a token.\n"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    },
                    "sessionNote": {
                        "type": "string",
                        "description": "String value being the name of stored user session note within the UserSessionModel.note map.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/client:Client": {
            "description": "Allows for creating and managing Keycloak clients that use the SAML protocol.\n\nClients are entities that can use Keycloak for user authentication. Typically, clients are applications that redirect users\nto Keycloak for authentication in order to take advantage of Keycloak's user sessions for SSO.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\nimport * from \"fs\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClient = new keycloak.saml.Client(\"samlClient\", {\n    realmId: realm.id,\n    clientId: \"saml-client\",\n    signDocuments: false,\n    signAssertions: true,\n    includeAuthnStatement: true,\n    signingCertificate: fs.readFileSync(\"saml-cert.pem\"),\n    signingPrivateKey: fs.readFileSync(\"saml-key.pem\"),\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client = keycloak.saml.Client(\"samlClient\",\n    realm_id=realm.id,\n    client_id=\"saml-client\",\n    sign_documents=False,\n    sign_assertions=True,\n    include_authn_statement=True,\n    signing_certificate=(lambda path: open(path).read())(\"saml-cert.pem\"),\n    signing_private_key=(lambda path: open(path).read())(\"saml-key.pem\"))\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var samlClient = new Keycloak.Saml.Client(\"samlClient\", new Keycloak.Saml.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"saml-client\",\n            SignDocuments = false,\n            SignAssertions = true,\n            IncludeAuthnStatement = true,\n            SigningCertificate = File.ReadAllText(\"saml-cert.pem\"),\n            SigningPrivateKey = File.ReadAllText(\"saml-key.pem\"),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = saml.NewClient(ctx, \"samlClient\", \u0026saml.ClientArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tClientId:              pulumi.String(\"saml-client\"),\n\t\t\tSignDocuments:         pulumi.Bool(false),\n\t\t\tSignAssertions:        pulumi.Bool(true),\n\t\t\tIncludeAuthnStatement: pulumi.Bool(true),\n\t\t\tSigningCertificate:    readFileOrPanic(\"saml-cert.pem\"),\n\t\t\tSigningPrivateKey:     readFileOrPanic(\"saml-key.pem\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nClients can be imported using the format `{{realm_id}}/{{client_keycloak_id}}`, where `client_keycloak_id` is the unique ID that Keycloak assigns to the client upon creation. This value can be found in the URI when editing this client in the GUI, and is typically a GUID. Examplebash\n\n```sh\n $ pulumi import keycloak:saml/client:Client saml_client my-realm/dcbc4c73-e478-4928-ae2e-d5e420223352\n```\n\n ",
            "properties": {
                "assertionConsumerPostUrl": {
                    "type": "string",
                    "description": "SAML POST Binding URL for the client's assertion consumer service (login responses).\n"
                },
                "assertionConsumerRedirectUrl": {
                    "type": "string",
                    "description": "SAML Redirect Binding URL for the client's assertion consumer service (login responses).\n"
                },
                "authenticationFlowBindingOverrides": {
                    "$ref": "#/types/keycloak:saml/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides",
                    "description": "Override realm authentication flow bindings\n"
                },
                "baseUrl": {
                    "type": "string",
                    "description": "When specified, this URL will be used whenever Keycloak needs to link to this client.\n"
                },
                "canonicalizationMethod": {
                    "type": "string",
                    "description": "The Canonicalization Method for XML signatures. Should be one of \"EXCLUSIVE\", \"EXCLUSIVE_WITH_COMMENTS\", \"INCLUSIVE\", or \"INCLUSIVE_WITH_COMMENTS\". Defaults to \"EXCLUSIVE\".\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The unique ID of this client, referenced in the URI during authentication and in issued tokens.\n"
                },
                "clientSignatureRequired": {
                    "type": "boolean",
                    "description": "When `true`, Keycloak will expect that documents originating from a client will be signed using the certificate and/or key configured via `signing_certificate` and `signing_private_key`. Defaults to `true`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client in the GUI.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When false, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.\n"
                },
                "encryptAssertions": {
                    "type": "boolean",
                    "description": "When `true`, the SAML assertions will be encrypted by Keycloak using the client's public key. Defaults to `false`.\n"
                },
                "encryptionCertificate": {
                    "type": "string",
                    "description": "If assertions for the client are encrypted, this certificate will be used for encryption.\n"
                },
                "encryptionCertificateSha1": {
                    "type": "string",
                    "description": "(Computed) The sha1sum fingerprint of the encryption certificate. If the encryption certificate is not in correct base64 format, this will be left empty.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "forceNameIdFormat": {
                    "type": "boolean",
                    "description": "Ignore requested NameID subject format and use the one defined in `name_id_format` instead. Defaults to `false`.\n"
                },
                "forcePostBinding": {
                    "type": "boolean",
                    "description": "When `true`, Keycloak will always respond to an authentication request via the SAML POST Binding. Defaults to `true`.\n"
                },
                "frontChannelLogout": {
                    "type": "boolean",
                    "description": "When `true`, this client will require a browser redirect in order to perform a logout. Defaults to `true`.\n"
                },
                "fullScopeAllowed": {
                    "type": "boolean",
                    "description": "- Allow to include all roles mappings in the access token\n"
                },
                "idpInitiatedSsoRelayState": {
                    "type": "string",
                    "description": "Relay state you want to send with SAML request when you want to do IDP Initiated SSO.\n"
                },
                "idpInitiatedSsoUrlName": {
                    "type": "string",
                    "description": "URL fragment name to reference client when you want to do IDP Initiated SSO.\n"
                },
                "includeAuthnStatement": {
                    "type": "boolean",
                    "description": "When `true`, an `AuthnStatement` will be included in the SAML response. Defaults to `true`.\n"
                },
                "loginTheme": {
                    "type": "string",
                    "description": "The login theme of this client.\n"
                },
                "logoutServicePostBindingUrl": {
                    "type": "string",
                    "description": "SAML POST Binding URL for the client's single logout service.\n"
                },
                "logoutServiceRedirectBindingUrl": {
                    "type": "string",
                    "description": "SAML Redirect Binding URL for the client's single logout service.\n"
                },
                "masterSamlProcessingUrl": {
                    "type": "string",
                    "description": "When specified, this URL will be used for all SAML requests.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this client in the GUI.\n"
                },
                "nameIdFormat": {
                    "type": "string",
                    "description": "Sets the Name ID format for the subject.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client is attached to.\n"
                },
                "rootUrl": {
                    "type": "string",
                    "description": "When specified, this value is prepended to all relative URLs.\n"
                },
                "signAssertions": {
                    "type": "boolean",
                    "description": "When `true`, the SAML assertions will be signed by Keycloak using the realm's private key, and embedded within the SAML XML Auth response. Defaults to `false`.\n"
                },
                "signDocuments": {
                    "type": "boolean",
                    "description": "When `true`, the SAML document will be signed by Keycloak using the realm's private key. Defaults to `true`.\n"
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "description": "The signature algorithm used to sign documents. Should be one of \"RSA_SHA1\", \"RSA_SHA256\", \"RSA_SHA512\", or \"DSA_SHA1\".\n"
                },
                "signatureKeyName": {
                    "type": "string",
                    "description": "The value of the `KeyName` element within the signed SAML document. Should be one of \"NONE\", \"KEY_ID\", or \"CERT_SUBJECT\". Defaults to \"KEY_ID\".\n"
                },
                "signingCertificate": {
                    "type": "string",
                    "description": "If documents or assertions from the client are signed, this certificate will be used to verify the signature.\n"
                },
                "signingCertificateSha1": {
                    "type": "string",
                    "description": "(Computed) The sha1sum fingerprint of the signing certificate. If the signing certificate is not in correct base64 format, this will be left empty.\n"
                },
                "signingPrivateKey": {
                    "type": "string",
                    "description": "If documents or assertions from the client are signed, this private key will be used to verify the signature.\n"
                },
                "signingPrivateKeySha1": {
                    "type": "string",
                    "description": "(Computed) The sha1sum fingerprint of the signing private key. If the signing private key is not in correct base64 format, this will be left empty.\n"
                },
                "validRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "When specified, Keycloak will use this list to validate given Assertion Consumer URLs specified in the authentication request.\n"
                }
            },
            "required": [
                "clientId",
                "encryptionCertificate",
                "encryptionCertificateSha1",
                "name",
                "nameIdFormat",
                "realmId",
                "signingCertificate",
                "signingCertificateSha1",
                "signingPrivateKey",
                "signingPrivateKeySha1"
            ],
            "inputProperties": {
                "assertionConsumerPostUrl": {
                    "type": "string",
                    "description": "SAML POST Binding URL for the client's assertion consumer service (login responses).\n"
                },
                "assertionConsumerRedirectUrl": {
                    "type": "string",
                    "description": "SAML Redirect Binding URL for the client's assertion consumer service (login responses).\n"
                },
                "authenticationFlowBindingOverrides": {
                    "$ref": "#/types/keycloak:saml/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides",
                    "description": "Override realm authentication flow bindings\n"
                },
                "baseUrl": {
                    "type": "string",
                    "description": "When specified, this URL will be used whenever Keycloak needs to link to this client.\n"
                },
                "canonicalizationMethod": {
                    "type": "string",
                    "description": "The Canonicalization Method for XML signatures. Should be one of \"EXCLUSIVE\", \"EXCLUSIVE_WITH_COMMENTS\", \"INCLUSIVE\", or \"INCLUSIVE_WITH_COMMENTS\". Defaults to \"EXCLUSIVE\".\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The unique ID of this client, referenced in the URI during authentication and in issued tokens.\n"
                },
                "clientSignatureRequired": {
                    "type": "boolean",
                    "description": "When `true`, Keycloak will expect that documents originating from a client will be signed using the certificate and/or key configured via `signing_certificate` and `signing_private_key`. Defaults to `true`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client in the GUI.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When false, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.\n"
                },
                "encryptAssertions": {
                    "type": "boolean",
                    "description": "When `true`, the SAML assertions will be encrypted by Keycloak using the client's public key. Defaults to `false`.\n"
                },
                "encryptionCertificate": {
                    "type": "string",
                    "description": "If assertions for the client are encrypted, this certificate will be used for encryption.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "forceNameIdFormat": {
                    "type": "boolean",
                    "description": "Ignore requested NameID subject format and use the one defined in `name_id_format` instead. Defaults to `false`.\n"
                },
                "forcePostBinding": {
                    "type": "boolean",
                    "description": "When `true`, Keycloak will always respond to an authentication request via the SAML POST Binding. Defaults to `true`.\n"
                },
                "frontChannelLogout": {
                    "type": "boolean",
                    "description": "When `true`, this client will require a browser redirect in order to perform a logout. Defaults to `true`.\n"
                },
                "fullScopeAllowed": {
                    "type": "boolean",
                    "description": "- Allow to include all roles mappings in the access token\n"
                },
                "idpInitiatedSsoRelayState": {
                    "type": "string",
                    "description": "Relay state you want to send with SAML request when you want to do IDP Initiated SSO.\n"
                },
                "idpInitiatedSsoUrlName": {
                    "type": "string",
                    "description": "URL fragment name to reference client when you want to do IDP Initiated SSO.\n"
                },
                "includeAuthnStatement": {
                    "type": "boolean",
                    "description": "When `true`, an `AuthnStatement` will be included in the SAML response. Defaults to `true`.\n"
                },
                "loginTheme": {
                    "type": "string",
                    "description": "The login theme of this client.\n"
                },
                "logoutServicePostBindingUrl": {
                    "type": "string",
                    "description": "SAML POST Binding URL for the client's single logout service.\n"
                },
                "logoutServiceRedirectBindingUrl": {
                    "type": "string",
                    "description": "SAML Redirect Binding URL for the client's single logout service.\n"
                },
                "masterSamlProcessingUrl": {
                    "type": "string",
                    "description": "When specified, this URL will be used for all SAML requests.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this client in the GUI.\n"
                },
                "nameIdFormat": {
                    "type": "string",
                    "description": "Sets the Name ID format for the subject.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client is attached to.\n"
                },
                "rootUrl": {
                    "type": "string",
                    "description": "When specified, this value is prepended to all relative URLs.\n"
                },
                "signAssertions": {
                    "type": "boolean",
                    "description": "When `true`, the SAML assertions will be signed by Keycloak using the realm's private key, and embedded within the SAML XML Auth response. Defaults to `false`.\n"
                },
                "signDocuments": {
                    "type": "boolean",
                    "description": "When `true`, the SAML document will be signed by Keycloak using the realm's private key. Defaults to `true`.\n"
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "description": "The signature algorithm used to sign documents. Should be one of \"RSA_SHA1\", \"RSA_SHA256\", \"RSA_SHA512\", or \"DSA_SHA1\".\n"
                },
                "signatureKeyName": {
                    "type": "string",
                    "description": "The value of the `KeyName` element within the signed SAML document. Should be one of \"NONE\", \"KEY_ID\", or \"CERT_SUBJECT\". Defaults to \"KEY_ID\".\n"
                },
                "signingCertificate": {
                    "type": "string",
                    "description": "If documents or assertions from the client are signed, this certificate will be used to verify the signature.\n"
                },
                "signingPrivateKey": {
                    "type": "string",
                    "description": "If documents or assertions from the client are signed, this private key will be used to verify the signature.\n"
                },
                "validRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "When specified, Keycloak will use this list to validate given Assertion Consumer URLs specified in the authentication request.\n"
                }
            },
            "requiredInputs": [
                "clientId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Client resources.\n",
                "properties": {
                    "assertionConsumerPostUrl": {
                        "type": "string",
                        "description": "SAML POST Binding URL for the client's assertion consumer service (login responses).\n"
                    },
                    "assertionConsumerRedirectUrl": {
                        "type": "string",
                        "description": "SAML Redirect Binding URL for the client's assertion consumer service (login responses).\n"
                    },
                    "authenticationFlowBindingOverrides": {
                        "$ref": "#/types/keycloak:saml/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides",
                        "description": "Override realm authentication flow bindings\n"
                    },
                    "baseUrl": {
                        "type": "string",
                        "description": "When specified, this URL will be used whenever Keycloak needs to link to this client.\n"
                    },
                    "canonicalizationMethod": {
                        "type": "string",
                        "description": "The Canonicalization Method for XML signatures. Should be one of \"EXCLUSIVE\", \"EXCLUSIVE_WITH_COMMENTS\", \"INCLUSIVE\", or \"INCLUSIVE_WITH_COMMENTS\". Defaults to \"EXCLUSIVE\".\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The unique ID of this client, referenced in the URI during authentication and in issued tokens.\n"
                    },
                    "clientSignatureRequired": {
                        "type": "boolean",
                        "description": "When `true`, Keycloak will expect that documents originating from a client will be signed using the certificate and/or key configured via `signing_certificate` and `signing_private_key`. Defaults to `true`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of this client in the GUI.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When false, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.\n"
                    },
                    "encryptAssertions": {
                        "type": "boolean",
                        "description": "When `true`, the SAML assertions will be encrypted by Keycloak using the client's public key. Defaults to `false`.\n"
                    },
                    "encryptionCertificate": {
                        "type": "string",
                        "description": "If assertions for the client are encrypted, this certificate will be used for encryption.\n"
                    },
                    "encryptionCertificateSha1": {
                        "type": "string",
                        "description": "(Computed) The sha1sum fingerprint of the encryption certificate. If the encryption certificate is not in correct base64 format, this will be left empty.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "forceNameIdFormat": {
                        "type": "boolean",
                        "description": "Ignore requested NameID subject format and use the one defined in `name_id_format` instead. Defaults to `false`.\n"
                    },
                    "forcePostBinding": {
                        "type": "boolean",
                        "description": "When `true`, Keycloak will always respond to an authentication request via the SAML POST Binding. Defaults to `true`.\n"
                    },
                    "frontChannelLogout": {
                        "type": "boolean",
                        "description": "When `true`, this client will require a browser redirect in order to perform a logout. Defaults to `true`.\n"
                    },
                    "fullScopeAllowed": {
                        "type": "boolean",
                        "description": "- Allow to include all roles mappings in the access token\n"
                    },
                    "idpInitiatedSsoRelayState": {
                        "type": "string",
                        "description": "Relay state you want to send with SAML request when you want to do IDP Initiated SSO.\n"
                    },
                    "idpInitiatedSsoUrlName": {
                        "type": "string",
                        "description": "URL fragment name to reference client when you want to do IDP Initiated SSO.\n"
                    },
                    "includeAuthnStatement": {
                        "type": "boolean",
                        "description": "When `true`, an `AuthnStatement` will be included in the SAML response. Defaults to `true`.\n"
                    },
                    "loginTheme": {
                        "type": "string",
                        "description": "The login theme of this client.\n"
                    },
                    "logoutServicePostBindingUrl": {
                        "type": "string",
                        "description": "SAML POST Binding URL for the client's single logout service.\n"
                    },
                    "logoutServiceRedirectBindingUrl": {
                        "type": "string",
                        "description": "SAML Redirect Binding URL for the client's single logout service.\n"
                    },
                    "masterSamlProcessingUrl": {
                        "type": "string",
                        "description": "When specified, this URL will be used for all SAML requests.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this client in the GUI.\n"
                    },
                    "nameIdFormat": {
                        "type": "string",
                        "description": "Sets the Name ID format for the subject.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this client is attached to.\n"
                    },
                    "rootUrl": {
                        "type": "string",
                        "description": "When specified, this value is prepended to all relative URLs.\n"
                    },
                    "signAssertions": {
                        "type": "boolean",
                        "description": "When `true`, the SAML assertions will be signed by Keycloak using the realm's private key, and embedded within the SAML XML Auth response. Defaults to `false`.\n"
                    },
                    "signDocuments": {
                        "type": "boolean",
                        "description": "When `true`, the SAML document will be signed by Keycloak using the realm's private key. Defaults to `true`.\n"
                    },
                    "signatureAlgorithm": {
                        "type": "string",
                        "description": "The signature algorithm used to sign documents. Should be one of \"RSA_SHA1\", \"RSA_SHA256\", \"RSA_SHA512\", or \"DSA_SHA1\".\n"
                    },
                    "signatureKeyName": {
                        "type": "string",
                        "description": "The value of the `KeyName` element within the signed SAML document. Should be one of \"NONE\", \"KEY_ID\", or \"CERT_SUBJECT\". Defaults to \"KEY_ID\".\n"
                    },
                    "signingCertificate": {
                        "type": "string",
                        "description": "If documents or assertions from the client are signed, this certificate will be used to verify the signature.\n"
                    },
                    "signingCertificateSha1": {
                        "type": "string",
                        "description": "(Computed) The sha1sum fingerprint of the signing certificate. If the signing certificate is not in correct base64 format, this will be left empty.\n"
                    },
                    "signingPrivateKey": {
                        "type": "string",
                        "description": "If documents or assertions from the client are signed, this private key will be used to verify the signature.\n"
                    },
                    "signingPrivateKeySha1": {
                        "type": "string",
                        "description": "(Computed) The sha1sum fingerprint of the signing private key. If the signing private key is not in correct base64 format, this will be left empty.\n"
                    },
                    "validRedirectUris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "When specified, Keycloak will use this list to validate given Assertion Consumer URLs specified in the authentication request.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/clientDefaultScope:ClientDefaultScope": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\nimport * from \"fs\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClient = new keycloak.saml.Client(\"samlClient\", {\n    realmId: realm.id,\n    clientId: \"saml-client\",\n    signDocuments: false,\n    signAssertions: true,\n    includeAuthnStatement: true,\n    signingCertificate: fs.readFileSync(\"saml-cert.pem\"),\n    signingPrivateKey: fs.readFileSync(\"saml-key.pem\"),\n});\nconst clientScope = new keycloak.saml.ClientScope(\"clientScope\", {realmId: realm.id});\nconst clientDefaultScopes = new keycloak.saml.ClientDefaultScope(\"clientDefaultScopes\", {\n    realmId: realm.id,\n    clientId: keycloak_saml_client.client.id,\n    defaultScopes: [\n        \"role_list\",\n        clientScope.name,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client = keycloak.saml.Client(\"samlClient\",\n    realm_id=realm.id,\n    client_id=\"saml-client\",\n    sign_documents=False,\n    sign_assertions=True,\n    include_authn_statement=True,\n    signing_certificate=(lambda path: open(path).read())(\"saml-cert.pem\"),\n    signing_private_key=(lambda path: open(path).read())(\"saml-key.pem\"))\nclient_scope = keycloak.saml.ClientScope(\"clientScope\", realm_id=realm.id)\nclient_default_scopes = keycloak.saml.ClientDefaultScope(\"clientDefaultScopes\",\n    realm_id=realm.id,\n    client_id=keycloak_saml_client[\"client\"][\"id\"],\n    default_scopes=[\n        \"role_list\",\n        client_scope.name,\n    ])\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var samlClient = new Keycloak.Saml.Client(\"samlClient\", new Keycloak.Saml.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"saml-client\",\n            SignDocuments = false,\n            SignAssertions = true,\n            IncludeAuthnStatement = true,\n            SigningCertificate = File.ReadAllText(\"saml-cert.pem\"),\n            SigningPrivateKey = File.ReadAllText(\"saml-key.pem\"),\n        });\n        var clientScope = new Keycloak.Saml.ClientScope(\"clientScope\", new Keycloak.Saml.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var clientDefaultScopes = new Keycloak.Saml.ClientDefaultScope(\"clientDefaultScopes\", new Keycloak.Saml.ClientDefaultScopeArgs\n        {\n            RealmId = realm.Id,\n            ClientId = keycloak_saml_client.Client.Id,\n            DefaultScopes = \n            {\n                \"role_list\",\n                clientScope.Name,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = saml.NewClient(ctx, \"samlClient\", \u0026saml.ClientArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tClientId:              pulumi.String(\"saml-client\"),\n\t\t\tSignDocuments:         pulumi.Bool(false),\n\t\t\tSignAssertions:        pulumi.Bool(true),\n\t\t\tIncludeAuthnStatement: pulumi.Bool(true),\n\t\t\tSigningCertificate:    readFileOrPanic(\"saml-cert.pem\"),\n\t\t\tSigningPrivateKey:     readFileOrPanic(\"saml-key.pem\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := saml.NewClientScope(ctx, \"clientScope\", \u0026saml.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = saml.NewClientDefaultScope(ctx, \"clientDefaultScopes\", \u0026saml.ClientDefaultScopeArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: pulumi.Any(keycloak_saml_client.Client.Id),\n\t\t\tDefaultScopes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"role_list\"),\n\t\t\t\tclientScope.Name,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThis resource does not support import. Instead of importing, feel free to create this resource as if it did not already exist on the server. ",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client to attach default scopes to. Note that this is the unique ID of the client generated by Keycloak.\n"
                },
                "defaultScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of client scope names to attach to this client.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client and scopes exists in.\n"
                }
            },
            "required": [
                "clientId",
                "defaultScopes",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client to attach default scopes to. Note that this is the unique ID of the client generated by Keycloak.\n"
                },
                "defaultScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of client scope names to attach to this client.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client and scopes exists in.\n"
                }
            },
            "requiredInputs": [
                "clientId",
                "defaultScopes",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientDefaultScope resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The ID of the client to attach default scopes to. Note that this is the unique ID of the client generated by Keycloak.\n"
                    },
                    "defaultScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of client scope names to attach to this client.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this client and scopes exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/clientScope:ClientScope": {
            "description": "Allows for creating and managing Keycloak client scopes that can be attached to clients that use the SAML protocol.\n\nClient Scopes can be used to share common protocol and role mappings between multiple clients within a realm.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClientScope = new keycloak.saml.ClientScope(\"samlClientScope\", {\n    realmId: realm.id,\n    description: \"This scope will map a user's group memberships to SAML assertion\",\n    guiOrder: 1,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client_scope = keycloak.saml.ClientScope(\"samlClientScope\",\n    realm_id=realm.id,\n    description=\"This scope will map a user's group memberships to SAML assertion\",\n    gui_order=1)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var samlClientScope = new Keycloak.Saml.ClientScope(\"samlClientScope\", new Keycloak.Saml.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n            Description = \"This scope will map a user's group memberships to SAML assertion\",\n            GuiOrder = 1,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = saml.NewClientScope(ctx, \"samlClientScope\", \u0026saml.ClientScopeArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tDescription: pulumi.String(\"This scope will map a user's group memberships to SAML assertion\"),\n\t\t\tGuiOrder:    pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nClient scopes can be imported using the format `{{realm_id}}/{{client_scope_id}}`, where `client_scope_id` is the unique ID that Keycloak assigns to the client scope upon creation. This value can be found in the URI when editing this client scope in the GUI, and is typically a GUID. Examplebash\n\n```sh\n $ pulumi import keycloak:saml/clientScope:ClientScope saml_client_scope my-realm/e8a5d115-6985-4de3-a0f5-732e1be4525e\n```\n\n ",
            "properties": {
                "consentScreenText": {
                    "type": "string",
                    "description": "When set, a consent screen will be displayed to users authenticating to clients with this scope attached. The consent screen will display the string value of this attribute.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client scope in the GUI.\n"
                },
                "guiOrder": {
                    "type": "integer",
                    "description": "Specify order of the client scope in GUI (such as in Consent page) as integer.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this client scope in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client scope belongs to.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "consentScreenText": {
                    "type": "string",
                    "description": "When set, a consent screen will be displayed to users authenticating to clients with this scope attached. The consent screen will display the string value of this attribute.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client scope in the GUI.\n"
                },
                "guiOrder": {
                    "type": "integer",
                    "description": "Specify order of the client scope in GUI (such as in Consent page) as integer.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this client scope in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client scope belongs to.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientScope resources.\n",
                "properties": {
                    "consentScreenText": {
                        "type": "string",
                        "description": "When set, a consent screen will be displayed to users authenticating to clients with this scope attached. The consent screen will display the string value of this attribute.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of this client scope in the GUI.\n"
                    },
                    "guiOrder": {
                        "type": "integer",
                        "description": "Specify order of the client scope in GUI (such as in Consent page) as integer.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this client scope in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this client scope belongs to.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/identityProvider:IdentityProvider": {
            "description": "Allows for creating and managing SAML Identity Providers within Keycloak.\n\nSAML (Security Assertion Markup Language) identity providers allows users to authenticate through a third-party system using the SAML protocol.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst realmSamlIdentityProvider = new keycloak.saml.IdentityProvider(\"realmSamlIdentityProvider\", {\n    realm: realm.id,\n    alias: \"my-saml-idp\",\n    entityId: \"https://domain.com/entity_id\",\n    singleSignOnServiceUrl: \"https://domain.com/adfs/ls/\",\n    singleLogoutServiceUrl: \"https://domain.com/adfs/ls/?wa=wsignout1.0\",\n    backchannelSupported: true,\n    postBindingResponse: true,\n    postBindingLogout: true,\n    postBindingAuthnRequest: true,\n    storeToken: false,\n    trustEmail: true,\n    forceAuthn: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrealm_saml_identity_provider = keycloak.saml.IdentityProvider(\"realmSamlIdentityProvider\",\n    realm=realm.id,\n    alias=\"my-saml-idp\",\n    entity_id=\"https://domain.com/entity_id\",\n    single_sign_on_service_url=\"https://domain.com/adfs/ls/\",\n    single_logout_service_url=\"https://domain.com/adfs/ls/?wa=wsignout1.0\",\n    backchannel_supported=True,\n    post_binding_response=True,\n    post_binding_logout=True,\n    post_binding_authn_request=True,\n    store_token=False,\n    trust_email=True,\n    force_authn=True)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var realmSamlIdentityProvider = new Keycloak.Saml.IdentityProvider(\"realmSamlIdentityProvider\", new Keycloak.Saml.IdentityProviderArgs\n        {\n            Realm = realm.Id,\n            Alias = \"my-saml-idp\",\n            EntityId = \"https://domain.com/entity_id\",\n            SingleSignOnServiceUrl = \"https://domain.com/adfs/ls/\",\n            SingleLogoutServiceUrl = \"https://domain.com/adfs/ls/?wa=wsignout1.0\",\n            BackchannelSupported = true,\n            PostBindingResponse = true,\n            PostBindingLogout = true,\n            PostBindingAuthnRequest = true,\n            StoreToken = false,\n            TrustEmail = true,\n            ForceAuthn = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = saml.NewIdentityProvider(ctx, \"realmSamlIdentityProvider\", \u0026saml.IdentityProviderArgs{\n\t\t\tRealm:                   realm.ID(),\n\t\t\tAlias:                   pulumi.String(\"my-saml-idp\"),\n\t\t\tEntityId:                pulumi.String(\"https://domain.com/entity_id\"),\n\t\t\tSingleSignOnServiceUrl:  pulumi.String(\"https://domain.com/adfs/ls/\"),\n\t\t\tSingleLogoutServiceUrl:  pulumi.String(\"https://domain.com/adfs/ls/?wa=wsignout1.0\"),\n\t\t\tBackchannelSupported:    pulumi.Bool(true),\n\t\t\tPostBindingResponse:     pulumi.Bool(true),\n\t\t\tPostBindingLogout:       pulumi.Bool(true),\n\t\t\tPostBindingAuthnRequest: pulumi.Bool(true),\n\t\t\tStoreToken:              pulumi.Bool(false),\n\t\t\tTrustEmail:              pulumi.Bool(true),\n\t\t\tForceAuthn:              pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nIdentity providers can be imported using the format `{{realm_id}}/{{idp_alias}}`, where `idp_alias` is the identity provider alias. Examplebash\n\n```sh\n $ pulumi import keycloak:saml/identityProvider:IdentityProvider realm_saml_identity_provider my-realm/my-saml-idp\n```\n\n ",
            "properties": {
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                },
                "alias": {
                    "type": "string",
                    "description": "The unique name of identity provider.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Authenticate users by default. Defaults to `false`.\n"
                },
                "backchannelSupported": {
                    "type": "boolean",
                    "description": "Does the external IDP support back-channel logout ?.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "The display name for the realm that is shown when logging in to the admin console.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, users and clients will not be able to access this realm. Defaults to `true`.\n"
                },
                "entityId": {
                    "type": "string",
                    "description": "The Entity ID that will be used to uniquely identify this SAML Service Provider.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that there is not yet existing Keycloak account linked with the authenticated identity provider account. Defaults to `first broker login`.\n"
                },
                "forceAuthn": {
                    "type": "boolean",
                    "description": "Indicates whether the identity provider must authenticate the presenter directly rather than rely on a previous security context.\n"
                },
                "guiOrder": {
                    "type": "string",
                    "description": "A number defining the order of this identity provider in the GUI.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "If hidden, then login with this provider is possible only if requested explicitly, e.g. using the 'kc_idp_hint' parameter.\n"
                },
                "internalId": {
                    "type": "string",
                    "description": "Internal Identity Provider Id\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                },
                "nameIdPolicyFormat": {
                    "type": "string",
                    "description": "Specifies the URI reference corresponding to a name identifier format. Defaults to empty.\n"
                },
                "postBindingAuthnRequest": {
                    "type": "boolean",
                    "description": "Indicates whether the AuthnRequest must be sent using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\n"
                },
                "postBindingLogout": {
                    "type": "boolean",
                    "description": "Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\n"
                },
                "postBindingResponse": {
                    "type": "boolean",
                    "description": "Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used..\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it. Defaults to empty.\n"
                },
                "principalAttribute": {
                    "type": "string",
                    "description": "Principal Attribute\n"
                },
                "principalType": {
                    "type": "string",
                    "description": "Principal Type\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak.\n"
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "description": "Signing Algorithm. Defaults to empty.\n"
                },
                "signingCertificate": {
                    "type": "string",
                    "description": "Signing Certificate.\n"
                },
                "singleLogoutServiceUrl": {
                    "type": "string",
                    "description": "The Url that must be used to send logout requests.\n"
                },
                "singleSignOnServiceUrl": {
                    "type": "string",
                    "description": "The Url that must be used to send authentication requests (SAML AuthnRequest).\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                },
                "syncMode": {
                    "type": "string",
                    "description": "The default sync mode to use for all mappers attached to this identity provider. Can be once of `IMPORT`, `FORCE`, or `LEGACY`.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                },
                "validateSignature": {
                    "type": "boolean",
                    "description": "Enable/disable signature validation of SAML responses.\n"
                },
                "wantAssertionsEncrypted": {
                    "type": "boolean",
                    "description": "Indicates whether this service provider expects an encrypted Assertion.\n"
                },
                "wantAssertionsSigned": {
                    "type": "boolean",
                    "description": "Indicates whether this service provider expects a signed Assertion.\n"
                },
                "xmlSignKeyInfoKeyNameTransformer": {
                    "type": "string",
                    "description": "Sign Key Transformer. Defaults to empty.\n"
                }
            },
            "required": [
                "alias",
                "entityId",
                "internalId",
                "realm",
                "singleSignOnServiceUrl"
            ],
            "inputProperties": {
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                },
                "alias": {
                    "type": "string",
                    "description": "The unique name of identity provider.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Authenticate users by default. Defaults to `false`.\n"
                },
                "backchannelSupported": {
                    "type": "boolean",
                    "description": "Does the external IDP support back-channel logout ?.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "The display name for the realm that is shown when logging in to the admin console.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, users and clients will not be able to access this realm. Defaults to `true`.\n"
                },
                "entityId": {
                    "type": "string",
                    "description": "The Entity ID that will be used to uniquely identify this SAML Service Provider.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that there is not yet existing Keycloak account linked with the authenticated identity provider account. Defaults to `first broker login`.\n"
                },
                "forceAuthn": {
                    "type": "boolean",
                    "description": "Indicates whether the identity provider must authenticate the presenter directly rather than rely on a previous security context.\n"
                },
                "guiOrder": {
                    "type": "string",
                    "description": "A number defining the order of this identity provider in the GUI.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "If hidden, then login with this provider is possible only if requested explicitly, e.g. using the 'kc_idp_hint' parameter.\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                },
                "nameIdPolicyFormat": {
                    "type": "string",
                    "description": "Specifies the URI reference corresponding to a name identifier format. Defaults to empty.\n"
                },
                "postBindingAuthnRequest": {
                    "type": "boolean",
                    "description": "Indicates whether the AuthnRequest must be sent using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\n"
                },
                "postBindingLogout": {
                    "type": "boolean",
                    "description": "Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\n"
                },
                "postBindingResponse": {
                    "type": "boolean",
                    "description": "Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used..\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it. Defaults to empty.\n"
                },
                "principalAttribute": {
                    "type": "string",
                    "description": "Principal Attribute\n"
                },
                "principalType": {
                    "type": "string",
                    "description": "Principal Type\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak.\n"
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "description": "Signing Algorithm. Defaults to empty.\n"
                },
                "signingCertificate": {
                    "type": "string",
                    "description": "Signing Certificate.\n"
                },
                "singleLogoutServiceUrl": {
                    "type": "string",
                    "description": "The Url that must be used to send logout requests.\n"
                },
                "singleSignOnServiceUrl": {
                    "type": "string",
                    "description": "The Url that must be used to send authentication requests (SAML AuthnRequest).\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                },
                "syncMode": {
                    "type": "string",
                    "description": "The default sync mode to use for all mappers attached to this identity provider. Can be once of `IMPORT`, `FORCE`, or `LEGACY`.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                },
                "validateSignature": {
                    "type": "boolean",
                    "description": "Enable/disable signature validation of SAML responses.\n"
                },
                "wantAssertionsEncrypted": {
                    "type": "boolean",
                    "description": "Indicates whether this service provider expects an encrypted Assertion.\n"
                },
                "wantAssertionsSigned": {
                    "type": "boolean",
                    "description": "Indicates whether this service provider expects a signed Assertion.\n"
                },
                "xmlSignKeyInfoKeyNameTransformer": {
                    "type": "string",
                    "description": "Sign Key Transformer. Defaults to empty.\n"
                }
            },
            "requiredInputs": [
                "alias",
                "entityId",
                "realm",
                "singleSignOnServiceUrl"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IdentityProvider resources.\n",
                "properties": {
                    "addReadTokenRoleOnCreate": {
                        "type": "boolean",
                        "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                    },
                    "alias": {
                        "type": "string",
                        "description": "The unique name of identity provider.\n"
                    },
                    "authenticateByDefault": {
                        "type": "boolean",
                        "description": "Authenticate users by default. Defaults to `false`.\n"
                    },
                    "backchannelSupported": {
                        "type": "boolean",
                        "description": "Does the external IDP support back-channel logout ?.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "The display name for the realm that is shown when logging in to the admin console.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, users and clients will not be able to access this realm. Defaults to `true`.\n"
                    },
                    "entityId": {
                        "type": "string",
                        "description": "The Entity ID that will be used to uniquely identify this SAML Service Provider.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "firstBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that there is not yet existing Keycloak account linked with the authenticated identity provider account. Defaults to `first broker login`.\n"
                    },
                    "forceAuthn": {
                        "type": "boolean",
                        "description": "Indicates whether the identity provider must authenticate the presenter directly rather than rely on a previous security context.\n"
                    },
                    "guiOrder": {
                        "type": "string",
                        "description": "A number defining the order of this identity provider in the GUI.\n"
                    },
                    "hideOnLoginPage": {
                        "type": "boolean",
                        "description": "If hidden, then login with this provider is possible only if requested explicitly, e.g. using the 'kc_idp_hint' parameter.\n"
                    },
                    "internalId": {
                        "type": "string",
                        "description": "Internal Identity Provider Id\n"
                    },
                    "linkOnly": {
                        "type": "boolean",
                        "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                    },
                    "nameIdPolicyFormat": {
                        "type": "string",
                        "description": "Specifies the URI reference corresponding to a name identifier format. Defaults to empty.\n"
                    },
                    "postBindingAuthnRequest": {
                        "type": "boolean",
                        "description": "Indicates whether the AuthnRequest must be sent using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\n"
                    },
                    "postBindingLogout": {
                        "type": "boolean",
                        "description": "Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\n"
                    },
                    "postBindingResponse": {
                        "type": "boolean",
                        "description": "Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used..\n"
                    },
                    "postBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it. Defaults to empty.\n"
                    },
                    "principalAttribute": {
                        "type": "string",
                        "description": "Principal Attribute\n"
                    },
                    "principalType": {
                        "type": "string",
                        "description": "Principal Type\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "The name of the realm. This is unique across Keycloak.\n"
                    },
                    "signatureAlgorithm": {
                        "type": "string",
                        "description": "Signing Algorithm. Defaults to empty.\n"
                    },
                    "signingCertificate": {
                        "type": "string",
                        "description": "Signing Certificate.\n"
                    },
                    "singleLogoutServiceUrl": {
                        "type": "string",
                        "description": "The Url that must be used to send logout requests.\n"
                    },
                    "singleSignOnServiceUrl": {
                        "type": "string",
                        "description": "The Url that must be used to send authentication requests (SAML AuthnRequest).\n"
                    },
                    "storeToken": {
                        "type": "boolean",
                        "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                    },
                    "syncMode": {
                        "type": "string",
                        "description": "The default sync mode to use for all mappers attached to this identity provider. Can be once of `IMPORT`, `FORCE`, or `LEGACY`.\n"
                    },
                    "trustEmail": {
                        "type": "boolean",
                        "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                    },
                    "validateSignature": {
                        "type": "boolean",
                        "description": "Enable/disable signature validation of SAML responses.\n"
                    },
                    "wantAssertionsEncrypted": {
                        "type": "boolean",
                        "description": "Indicates whether this service provider expects an encrypted Assertion.\n"
                    },
                    "wantAssertionsSigned": {
                        "type": "boolean",
                        "description": "Indicates whether this service provider expects a signed Assertion.\n"
                    },
                    "xmlSignKeyInfoKeyNameTransformer": {
                        "type": "string",
                        "description": "Sign Key Transformer. Defaults to empty.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/scriptProtocolMapper:ScriptProtocolMapper": {
            "description": "Allows for creating and managing script protocol mappers for SAML clients within Keycloak.\n\nScript protocol mappers evaluate a JavaScript function to produce an attribute value based on context information.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClient = new keycloak.saml.Client(\"samlClient\", {\n    realmId: realm.id,\n    clientId: \"saml-client\",\n});\nconst samlScriptMapper = new keycloak.saml.ScriptProtocolMapper(\"samlScriptMapper\", {\n    realmId: realm.id,\n    clientId: samlClient.id,\n    script: \"exports = 'foo';\",\n    samlAttributeName: \"displayName\",\n    samlAttributeNameFormat: \"Unspecified\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client = keycloak.saml.Client(\"samlClient\",\n    realm_id=realm.id,\n    client_id=\"saml-client\")\nsaml_script_mapper = keycloak.saml.ScriptProtocolMapper(\"samlScriptMapper\",\n    realm_id=realm.id,\n    client_id=saml_client.id,\n    script=\"exports = 'foo';\",\n    saml_attribute_name=\"displayName\",\n    saml_attribute_name_format=\"Unspecified\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var samlClient = new Keycloak.Saml.Client(\"samlClient\", new Keycloak.Saml.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"saml-client\",\n        });\n        var samlScriptMapper = new Keycloak.Saml.ScriptProtocolMapper(\"samlScriptMapper\", new Keycloak.Saml.ScriptProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = samlClient.Id,\n            Script = \"exports = 'foo';\",\n            SamlAttributeName = \"displayName\",\n            SamlAttributeNameFormat = \"Unspecified\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsamlClient, err := saml.NewClient(ctx, \"samlClient\", \u0026saml.ClientArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: pulumi.String(\"saml-client\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = saml.NewScriptProtocolMapper(ctx, \"samlScriptMapper\", \u0026saml.ScriptProtocolMapperArgs{\n\t\t\tRealmId:                 realm.ID(),\n\t\t\tClientId:                samlClient.ID(),\n\t\t\tScript:                  pulumi.String(\"exports = 'foo';\"),\n\t\t\tSamlAttributeName:       pulumi.String(\"displayName\"),\n\t\t\tSamlAttributeNameFormat: pulumi.String(\"Unspecified\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nProtocol mappers can be imported using one of the following formats- Client`{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}` - Client Scope`{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}` Examplebash\n\n```sh\n $ pulumi import keycloak:saml/scriptProtocolMapper:ScriptProtocolMapper saml_script_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n\n\n```sh\n $ pulumi import keycloak:saml/scriptProtocolMapper:ScriptProtocolMapper saml_script_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n ",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "friendlyName": {
                    "type": "string",
                    "description": "An optional human-friendly name for this attribute.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "samlAttributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "samlAttributeNameFormat": {
                    "type": "string",
                    "description": "The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n"
                },
                "script": {
                    "type": "string",
                    "description": "JavaScript code to compute the attribute value.\n"
                },
                "singleValueAttribute": {
                    "type": "boolean",
                    "description": "When `true`, all values will be stored under one attribute with multiple attribute values. Defaults to `true`.\n"
                }
            },
            "required": [
                "name",
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "script"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "friendlyName": {
                    "type": "string",
                    "description": "An optional human-friendly name for this attribute.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "samlAttributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "samlAttributeNameFormat": {
                    "type": "string",
                    "description": "The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n"
                },
                "script": {
                    "type": "string",
                    "description": "JavaScript code to compute the attribute value.\n"
                },
                "singleValueAttribute": {
                    "type": "boolean",
                    "description": "When `true`, all values will be stored under one attribute with multiple attribute values. Defaults to `true`.\n"
                }
            },
            "requiredInputs": [
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "script"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ScriptProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "friendlyName": {
                        "type": "string",
                        "description": "An optional human-friendly name for this attribute.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    },
                    "samlAttributeName": {
                        "type": "string",
                        "description": "The name of the SAML attribute.\n"
                    },
                    "samlAttributeNameFormat": {
                        "type": "string",
                        "description": "The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n"
                    },
                    "script": {
                        "type": "string",
                        "description": "JavaScript code to compute the attribute value.\n"
                    },
                    "singleValueAttribute": {
                        "type": "boolean",
                        "description": "When `true`, all values will be stored under one attribute with multiple attribute values. Defaults to `true`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/userAttributeProtocolMapper:UserAttributeProtocolMapper": {
            "description": "Allows for creating and managing user attribute protocol mappers for SAML clients within Keycloak.\n\nSAML user attribute protocol mappers allow you to map custom attributes defined for a user within Keycloak to an attribute\nin a SAML assertion.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClient = new keycloak.saml.Client(\"samlClient\", {\n    realmId: realm.id,\n    clientId: \"saml-client\",\n});\nconst samlUserAttributeMapper = new keycloak.saml.UserAttributeProtocolMapper(\"samlUserAttributeMapper\", {\n    realmId: realm.id,\n    clientId: samlClient.id,\n    userAttribute: \"displayName\",\n    samlAttributeName: \"displayName\",\n    samlAttributeNameFormat: \"Unspecified\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client = keycloak.saml.Client(\"samlClient\",\n    realm_id=realm.id,\n    client_id=\"saml-client\")\nsaml_user_attribute_mapper = keycloak.saml.UserAttributeProtocolMapper(\"samlUserAttributeMapper\",\n    realm_id=realm.id,\n    client_id=saml_client.id,\n    user_attribute=\"displayName\",\n    saml_attribute_name=\"displayName\",\n    saml_attribute_name_format=\"Unspecified\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var samlClient = new Keycloak.Saml.Client(\"samlClient\", new Keycloak.Saml.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"saml-client\",\n        });\n        var samlUserAttributeMapper = new Keycloak.Saml.UserAttributeProtocolMapper(\"samlUserAttributeMapper\", new Keycloak.Saml.UserAttributeProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = samlClient.Id,\n            UserAttribute = \"displayName\",\n            SamlAttributeName = \"displayName\",\n            SamlAttributeNameFormat = \"Unspecified\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsamlClient, err := saml.NewClient(ctx, \"samlClient\", \u0026saml.ClientArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: pulumi.String(\"saml-client\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = saml.NewUserAttributeProtocolMapper(ctx, \"samlUserAttributeMapper\", \u0026saml.UserAttributeProtocolMapperArgs{\n\t\t\tRealmId:                 realm.ID(),\n\t\t\tClientId:                samlClient.ID(),\n\t\t\tUserAttribute:           pulumi.String(\"displayName\"),\n\t\t\tSamlAttributeName:       pulumi.String(\"displayName\"),\n\t\t\tSamlAttributeNameFormat: pulumi.String(\"Unspecified\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nProtocol mappers can be imported using one of the following formats- Client`{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}` - Client Scope`{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}` Examplebash\n\n```sh\n $ pulumi import keycloak:saml/userAttributeProtocolMapper:UserAttributeProtocolMapper saml_user_attribute_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n\n\n```sh\n $ pulumi import keycloak:saml/userAttributeProtocolMapper:UserAttributeProtocolMapper saml_user_attribute_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n ",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "friendlyName": {
                    "type": "string",
                    "description": "An optional human-friendly name for this attribute.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "samlAttributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "samlAttributeNameFormat": {
                    "type": "string",
                    "description": "The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n"
                },
                "userAttribute": {
                    "type": "string",
                    "description": "The custom user attribute to map.\n"
                }
            },
            "required": [
                "name",
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "userAttribute"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "friendlyName": {
                    "type": "string",
                    "description": "An optional human-friendly name for this attribute.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "samlAttributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "samlAttributeNameFormat": {
                    "type": "string",
                    "description": "The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n"
                },
                "userAttribute": {
                    "type": "string",
                    "description": "The custom user attribute to map.\n"
                }
            },
            "requiredInputs": [
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "userAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserAttributeProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "friendlyName": {
                        "type": "string",
                        "description": "An optional human-friendly name for this attribute.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    },
                    "samlAttributeName": {
                        "type": "string",
                        "description": "The name of the SAML attribute.\n"
                    },
                    "samlAttributeNameFormat": {
                        "type": "string",
                        "description": "The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n"
                    },
                    "userAttribute": {
                        "type": "string",
                        "description": "The custom user attribute to map.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/userPropertyProtocolMapper:UserPropertyProtocolMapper": {
            "description": "Allows for creating and managing user property protocol mappers for SAML clients within Keycloak.\n\nSAML user property protocol mappers allow you to map properties of the Keycloak\nuser model to an attribute in a SAML assertion.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClient = new keycloak.saml.Client(\"samlClient\", {\n    realmId: realm.id,\n    clientId: \"saml-client\",\n});\nconst samlUserPropertyMapper = new keycloak.saml.UserPropertyProtocolMapper(\"samlUserPropertyMapper\", {\n    realmId: realm.id,\n    clientId: samlClient.id,\n    userProperty: \"email\",\n    samlAttributeName: \"email\",\n    samlAttributeNameFormat: \"Unspecified\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client = keycloak.saml.Client(\"samlClient\",\n    realm_id=realm.id,\n    client_id=\"saml-client\")\nsaml_user_property_mapper = keycloak.saml.UserPropertyProtocolMapper(\"samlUserPropertyMapper\",\n    realm_id=realm.id,\n    client_id=saml_client.id,\n    user_property=\"email\",\n    saml_attribute_name=\"email\",\n    saml_attribute_name_format=\"Unspecified\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var samlClient = new Keycloak.Saml.Client(\"samlClient\", new Keycloak.Saml.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"saml-client\",\n        });\n        var samlUserPropertyMapper = new Keycloak.Saml.UserPropertyProtocolMapper(\"samlUserPropertyMapper\", new Keycloak.Saml.UserPropertyProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = samlClient.Id,\n            UserProperty = \"email\",\n            SamlAttributeName = \"email\",\n            SamlAttributeNameFormat = \"Unspecified\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsamlClient, err := saml.NewClient(ctx, \"samlClient\", \u0026saml.ClientArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: pulumi.String(\"saml-client\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = saml.NewUserPropertyProtocolMapper(ctx, \"samlUserPropertyMapper\", \u0026saml.UserPropertyProtocolMapperArgs{\n\t\t\tRealmId:                 realm.ID(),\n\t\t\tClientId:                samlClient.ID(),\n\t\t\tUserProperty:            pulumi.String(\"email\"),\n\t\t\tSamlAttributeName:       pulumi.String(\"email\"),\n\t\t\tSamlAttributeNameFormat: pulumi.String(\"Unspecified\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nProtocol mappers can be imported using one of the following formats- Client`{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}` - Client Scope`{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}` Examplebash\n\n```sh\n $ pulumi import keycloak:saml/userPropertyProtocolMapper:UserPropertyProtocolMapper saml_user_property_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n\n\n```sh\n $ pulumi import keycloak:saml/userPropertyProtocolMapper:UserPropertyProtocolMapper saml_user_property_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4\n```\n\n ",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "friendlyName": {
                    "type": "string",
                    "description": "An optional human-friendly name for this attribute.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "samlAttributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "samlAttributeNameFormat": {
                    "type": "string",
                    "description": "The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n"
                },
                "userProperty": {
                    "type": "string",
                    "description": "The property of the Keycloak user model to map.\n"
                }
            },
            "required": [
                "name",
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "userProperty"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "friendlyName": {
                    "type": "string",
                    "description": "An optional human-friendly name for this attribute.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "samlAttributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "samlAttributeNameFormat": {
                    "type": "string",
                    "description": "The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n"
                },
                "userProperty": {
                    "type": "string",
                    "description": "The property of the Keycloak user model to map.\n"
                }
            },
            "requiredInputs": [
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "userProperty"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserPropertyProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "friendlyName": {
                        "type": "string",
                        "description": "An optional human-friendly name for this attribute.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    },
                    "samlAttributeName": {
                        "type": "string",
                        "description": "The name of the SAML attribute.\n"
                    },
                    "samlAttributeNameFormat": {
                        "type": "string",
                        "description": "The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n"
                    },
                    "userProperty": {
                        "type": "string",
                        "description": "The property of the Keycloak user model to map.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "keycloak:index/getAuthenticationExecution:getAuthenticationExecution": {
            "description": "This data source can be used to fetch the ID of an authentication execution within Keycloak.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst browserAuthCookie = keycloak.getAuthenticationExecutionOutput({\n    realmId: realm.id,\n    parentFlowAlias: \"browser\",\n    providerId: \"auth-cookie\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nbrowser_auth_cookie = keycloak.get_authentication_execution_output(realm_id=realm.id,\n    parent_flow_alias=\"browser\",\n    provider_id=\"auth-cookie\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var browserAuthCookie = Keycloak.GetAuthenticationExecution.Invoke(new Keycloak.GetAuthenticationExecutionInvokeArgs\n        {\n            RealmId = realm.Id,\n            ParentFlowAlias = \"browser\",\n            ProviderId = \"auth-cookie\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = keycloak.GetAuthenticationExecutionOutput(ctx, GetAuthenticationExecutionOutputArgs{\n\t\t\tRealmId:         realm.ID(),\n\t\t\tParentFlowAlias: pulumi.String(\"browser\"),\n\t\t\tProviderId:      pulumi.String(\"auth-cookie\"),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthenticationExecution.\n",
                "properties": {
                    "parentFlowAlias": {
                        "type": "string",
                        "description": "The alias of the flow this execution is attached to.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The name of the provider. This can be found by experimenting with the GUI and looking at HTTP requests within the network tab of your browser's development tools. This was previously known as the \"authenticator\".\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm the authentication execution exists in.\n"
                    }
                },
                "type": "object",
                "required": [
                    "parentFlowAlias",
                    "providerId",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthenticationExecution.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "parentFlowAlias": {
                        "type": "string"
                    },
                    "providerId": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "parentFlowAlias",
                    "providerId",
                    "realmId",
                    "id"
                ]
            }
        },
        "keycloak:index/getAuthenticationFlow:getAuthenticationFlow": {
            "description": "This data source can be used to fetch the ID of an authentication flow within Keycloak.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst browserAuthCookie = keycloak.getAuthenticationFlowOutput({\n    realmId: realm.id,\n    alias: \"browser\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nbrowser_auth_cookie = keycloak.get_authentication_flow_output(realm_id=realm.id,\n    alias=\"browser\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var browserAuthCookie = Keycloak.GetAuthenticationFlow.Invoke(new Keycloak.GetAuthenticationFlowInvokeArgs\n        {\n            RealmId = realm.Id,\n            Alias = \"browser\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = keycloak.GetAuthenticationFlowOutput(ctx, GetAuthenticationFlowOutputArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tAlias:   pulumi.String(\"browser\"),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAuthenticationFlow.\n",
                "properties": {
                    "alias": {
                        "type": "string",
                        "description": "The alias of the flow.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm the authentication flow exists in.\n"
                    }
                },
                "type": "object",
                "required": [
                    "alias",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuthenticationFlow.\n",
                "properties": {
                    "alias": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "alias",
                    "realmId",
                    "id"
                ]
            }
        },
        "keycloak:index/getClientDescriptionConverter:getClientDescriptionConverter": {
            "description": "This data source uses the [ClientDescriptionConverter](https://www.keycloak.org/docs-api/6.0/javadocs/org/keycloak/exportimport/ClientDescriptionConverter.html) API to convert a generic client description into a Keycloak\nclient. This data can then be used to manage the client within Keycloak.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClientClientDescriptionConverter = keycloak.getClientDescriptionConverterOutput({\n    realmId: realm.id,\n    body: `\t\u003cmd:EntityDescriptor xmlns:md=\"urn:oasis:names:tc:SAML:2.0:metadata\" validUntil=\"2021-04-17T12:41:46Z\" cacheDuration=\"PT604800S\" entityID=\"FakeEntityId\"\u003e\n    \u003cmd:SPSSODescriptor AuthnRequestsSigned=\"false\" WantAssertionsSigned=\"false\" protocolSupportEnumeration=\"urn:oasis:names:tc:SAML:2.0:protocol\"\u003e\n        \u003cmd:KeyDescriptor use=\"signing\"\u003e\n\t\t\t\u003cds:KeyInfo xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\u003e\n\t\t\t\t\u003cds:X509Data\u003e\n\t\t\t\t\t\u003cds:X509Certificate\u003eMIICyDCCAjGgAwIBAgIBADANBgkqhkiG9w0BAQ0FADCBgDELMAkGA1UEBhMCdXMx\n\t\t\t\t\tCzAJBgNVBAgMAklBMSQwIgYDVQQKDBt0ZXJyYWZvcm0tcHJvdmlkZXIta2V5Y2xv\n\t\t\t\t\tYWsxHDAaBgNVBAMME21ycGFya2Vycy5naXRodWIuaW8xIDAeBgkqhkiG9w0BCQEW\n\t\t\t\t\tEW1pY2hhZWxAcGFya2VyLmdnMB4XDTE5MDEwODE0NDYzNloXDTI5MDEwNTE0NDYz\n\t\t\t\t\tNlowgYAxCzAJBgNVBAYTAnVzMQswCQYDVQQIDAJJQTEkMCIGA1UECgwbdGVycmFm\n\t\t\t\t\tb3JtLXByb3ZpZGVyLWtleWNsb2FrMRwwGgYDVQQDDBNtcnBhcmtlcnMuZ2l0aHVi\n\t\t\t\t\tLmlvMSAwHgYJKoZIhvcNAQkBFhFtaWNoYWVsQHBhcmtlci5nZzCBnzANBgkqhkiG\n\t\t\t\t\t9w0BAQEFAAOBjQAwgYkCgYEAxuZny7uyYxGVPtpie14gNQC4tT9sAvO2sVNDhuoe\n\t\t\t\t\tqIKLRpNwkHnwQmwe5OxSh9K0BPHp/DNuuVWUqvo4tniEYn3jBr7FwLYLTKojQIxj\n\t\t\t\t\t53S1UTT9EXq3eP5HsHMD0QnTuca2nlNYUDBm6ud2fQj0Jt5qLx86EbEC28N56IRv\n\t\t\t\t\tGX8CAwEAAaNQME4wHQYDVR0OBBYEFMLnbQh77j7vhGTpAhKpDhCrBsPZMB8GA1Ud\n\t\t\t\t\tIwQYMBaAFMLnbQh77j7vhGTpAhKpDhCrBsPZMAwGA1UdEwQFMAMBAf8wDQYJKoZI\n\t\t\t\t\thvcNAQENBQADgYEAB8wGrAQY0pAfwbnYSyBt4STbebeRTu1/q1ucfrtc3qsegcd5\n\t\t\t\t\tn01xTR+T2uZJwqHFPpFjr4IPORiHx3+4BWCweslPD53qBjKUPXcbMO1Revjef6Tj\n\t\t\t\t\tK3K0AuJ94fxgXVoT61Nzu/a6Lj6RhzU/Dao9mlSbJY+YSbm+ZBpsuRUQ84s=\u003c/ds:X509Certificate\u003e\n\t\t\t\t\u003c/ds:X509Data\u003e\n\t\t\t\u003c/ds:KeyInfo\u003e\n\t\t\u003c/md:KeyDescriptor\u003e\n\t\t\u003cmd:NameIDFormat\u003eurn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\u003c/md:NameIDFormat\u003e\n        \u003cmd:AssertionConsumerService Binding=\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\" Location=\"https://localhost/acs/saml/\" index=\"1\"/\u003e\n    \u003c/md:SPSSODescriptor\u003e\n\u003c/md:EntityDescriptor\u003e\n`,\n});\nconst samlClientClient = new keycloak.saml.Client(\"samlClientClient\", {\n    realmId: realm.id,\n    clientId: samlClientClientDescriptionConverter.apply(samlClientClientDescriptionConverter =\u003e samlClientClientDescriptionConverter.clientId),\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client_client_description_converter = keycloak.get_client_description_converter_output(realm_id=realm.id,\n    body=\"\"\"\t\u003cmd:EntityDescriptor xmlns:md=\"urn:oasis:names:tc:SAML:2.0:metadata\" validUntil=\"2021-04-17T12:41:46Z\" cacheDuration=\"PT604800S\" entityID=\"FakeEntityId\"\u003e\n    \u003cmd:SPSSODescriptor AuthnRequestsSigned=\"false\" WantAssertionsSigned=\"false\" protocolSupportEnumeration=\"urn:oasis:names:tc:SAML:2.0:protocol\"\u003e\n        \u003cmd:KeyDescriptor use=\"signing\"\u003e\n\t\t\t\u003cds:KeyInfo xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\u003e\n\t\t\t\t\u003cds:X509Data\u003e\n\t\t\t\t\t\u003cds:X509Certificate\u003eMIICyDCCAjGgAwIBAgIBADANBgkqhkiG9w0BAQ0FADCBgDELMAkGA1UEBhMCdXMx\n\t\t\t\t\tCzAJBgNVBAgMAklBMSQwIgYDVQQKDBt0ZXJyYWZvcm0tcHJvdmlkZXIta2V5Y2xv\n\t\t\t\t\tYWsxHDAaBgNVBAMME21ycGFya2Vycy5naXRodWIuaW8xIDAeBgkqhkiG9w0BCQEW\n\t\t\t\t\tEW1pY2hhZWxAcGFya2VyLmdnMB4XDTE5MDEwODE0NDYzNloXDTI5MDEwNTE0NDYz\n\t\t\t\t\tNlowgYAxCzAJBgNVBAYTAnVzMQswCQYDVQQIDAJJQTEkMCIGA1UECgwbdGVycmFm\n\t\t\t\t\tb3JtLXByb3ZpZGVyLWtleWNsb2FrMRwwGgYDVQQDDBNtcnBhcmtlcnMuZ2l0aHVi\n\t\t\t\t\tLmlvMSAwHgYJKoZIhvcNAQkBFhFtaWNoYWVsQHBhcmtlci5nZzCBnzANBgkqhkiG\n\t\t\t\t\t9w0BAQEFAAOBjQAwgYkCgYEAxuZny7uyYxGVPtpie14gNQC4tT9sAvO2sVNDhuoe\n\t\t\t\t\tqIKLRpNwkHnwQmwe5OxSh9K0BPHp/DNuuVWUqvo4tniEYn3jBr7FwLYLTKojQIxj\n\t\t\t\t\t53S1UTT9EXq3eP5HsHMD0QnTuca2nlNYUDBm6ud2fQj0Jt5qLx86EbEC28N56IRv\n\t\t\t\t\tGX8CAwEAAaNQME4wHQYDVR0OBBYEFMLnbQh77j7vhGTpAhKpDhCrBsPZMB8GA1Ud\n\t\t\t\t\tIwQYMBaAFMLnbQh77j7vhGTpAhKpDhCrBsPZMAwGA1UdEwQFMAMBAf8wDQYJKoZI\n\t\t\t\t\thvcNAQENBQADgYEAB8wGrAQY0pAfwbnYSyBt4STbebeRTu1/q1ucfrtc3qsegcd5\n\t\t\t\t\tn01xTR+T2uZJwqHFPpFjr4IPORiHx3+4BWCweslPD53qBjKUPXcbMO1Revjef6Tj\n\t\t\t\t\tK3K0AuJ94fxgXVoT61Nzu/a6Lj6RhzU/Dao9mlSbJY+YSbm+ZBpsuRUQ84s=\u003c/ds:X509Certificate\u003e\n\t\t\t\t\u003c/ds:X509Data\u003e\n\t\t\t\u003c/ds:KeyInfo\u003e\n\t\t\u003c/md:KeyDescriptor\u003e\n\t\t\u003cmd:NameIDFormat\u003eurn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\u003c/md:NameIDFormat\u003e\n        \u003cmd:AssertionConsumerService Binding=\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\" Location=\"https://localhost/acs/saml/\" index=\"1\"/\u003e\n    \u003c/md:SPSSODescriptor\u003e\n\u003c/md:EntityDescriptor\u003e\n\"\"\")\nsaml_client_client = keycloak.saml.Client(\"samlClientClient\",\n    realm_id=realm.id,\n    client_id=saml_client_client_description_converter.client_id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var samlClientClientDescriptionConverter = Keycloak.GetClientDescriptionConverter.Invoke(new Keycloak.GetClientDescriptionConverterInvokeArgs\n        {\n            RealmId = realm.Id,\n            Body = @\"\t\u003cmd:EntityDescriptor xmlns:md=\"\"urn:oasis:names:tc:SAML:2.0:metadata\"\" validUntil=\"\"2021-04-17T12:41:46Z\"\" cacheDuration=\"\"PT604800S\"\" entityID=\"\"FakeEntityId\"\"\u003e\n    \u003cmd:SPSSODescriptor AuthnRequestsSigned=\"\"false\"\" WantAssertionsSigned=\"\"false\"\" protocolSupportEnumeration=\"\"urn:oasis:names:tc:SAML:2.0:protocol\"\"\u003e\n        \u003cmd:KeyDescriptor use=\"\"signing\"\"\u003e\n\t\t\t\u003cds:KeyInfo xmlns:ds=\"\"http://www.w3.org/2000/09/xmldsig#\"\"\u003e\n\t\t\t\t\u003cds:X509Data\u003e\n\t\t\t\t\t\u003cds:X509Certificate\u003eMIICyDCCAjGgAwIBAgIBADANBgkqhkiG9w0BAQ0FADCBgDELMAkGA1UEBhMCdXMx\n\t\t\t\t\tCzAJBgNVBAgMAklBMSQwIgYDVQQKDBt0ZXJyYWZvcm0tcHJvdmlkZXIta2V5Y2xv\n\t\t\t\t\tYWsxHDAaBgNVBAMME21ycGFya2Vycy5naXRodWIuaW8xIDAeBgkqhkiG9w0BCQEW\n\t\t\t\t\tEW1pY2hhZWxAcGFya2VyLmdnMB4XDTE5MDEwODE0NDYzNloXDTI5MDEwNTE0NDYz\n\t\t\t\t\tNlowgYAxCzAJBgNVBAYTAnVzMQswCQYDVQQIDAJJQTEkMCIGA1UECgwbdGVycmFm\n\t\t\t\t\tb3JtLXByb3ZpZGVyLWtleWNsb2FrMRwwGgYDVQQDDBNtcnBhcmtlcnMuZ2l0aHVi\n\t\t\t\t\tLmlvMSAwHgYJKoZIhvcNAQkBFhFtaWNoYWVsQHBhcmtlci5nZzCBnzANBgkqhkiG\n\t\t\t\t\t9w0BAQEFAAOBjQAwgYkCgYEAxuZny7uyYxGVPtpie14gNQC4tT9sAvO2sVNDhuoe\n\t\t\t\t\tqIKLRpNwkHnwQmwe5OxSh9K0BPHp/DNuuVWUqvo4tniEYn3jBr7FwLYLTKojQIxj\n\t\t\t\t\t53S1UTT9EXq3eP5HsHMD0QnTuca2nlNYUDBm6ud2fQj0Jt5qLx86EbEC28N56IRv\n\t\t\t\t\tGX8CAwEAAaNQME4wHQYDVR0OBBYEFMLnbQh77j7vhGTpAhKpDhCrBsPZMB8GA1Ud\n\t\t\t\t\tIwQYMBaAFMLnbQh77j7vhGTpAhKpDhCrBsPZMAwGA1UdEwQFMAMBAf8wDQYJKoZI\n\t\t\t\t\thvcNAQENBQADgYEAB8wGrAQY0pAfwbnYSyBt4STbebeRTu1/q1ucfrtc3qsegcd5\n\t\t\t\t\tn01xTR+T2uZJwqHFPpFjr4IPORiHx3+4BWCweslPD53qBjKUPXcbMO1Revjef6Tj\n\t\t\t\t\tK3K0AuJ94fxgXVoT61Nzu/a6Lj6RhzU/Dao9mlSbJY+YSbm+ZBpsuRUQ84s=\u003c/ds:X509Certificate\u003e\n\t\t\t\t\u003c/ds:X509Data\u003e\n\t\t\t\u003c/ds:KeyInfo\u003e\n\t\t\u003c/md:KeyDescriptor\u003e\n\t\t\u003cmd:NameIDFormat\u003eurn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\u003c/md:NameIDFormat\u003e\n        \u003cmd:AssertionConsumerService Binding=\"\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\"\" Location=\"\"https://localhost/acs/saml/\"\" index=\"\"1\"\"/\u003e\n    \u003c/md:SPSSODescriptor\u003e\n\u003c/md:EntityDescriptor\u003e\n\",\n        });\n        var samlClientClient = new Keycloak.Saml.Client(\"samlClientClient\", new Keycloak.Saml.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = samlClientClientDescriptionConverter.Apply(samlClientClientDescriptionConverter =\u003e samlClientClientDescriptionConverter.ClientId),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsamlClientClientDescriptionConverter := keycloak.GetClientDescriptionConverterOutput(ctx, GetClientDescriptionConverterOutputArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tBody: pulumi.String(fmt.Sprintf(\"%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v\", \"\t\u003cmd:EntityDescriptor xmlns:md=\\\"urn:oasis:names:tc:SAML:2.0:metadata\\\" validUntil=\\\"2021-04-17T12:41:46Z\\\" cacheDuration=\\\"PT604800S\\\" entityID=\\\"FakeEntityId\\\"\u003e\\n\", \"    \u003cmd:SPSSODescriptor AuthnRequestsSigned=\\\"false\\\" WantAssertionsSigned=\\\"false\\\" protocolSupportEnumeration=\\\"urn:oasis:names:tc:SAML:2.0:protocol\\\"\u003e\\n\", \"        \u003cmd:KeyDescriptor use=\\\"signing\\\"\u003e\\n\", \"\t\t\t\u003cds:KeyInfo xmlns:ds=\\\"http://www.w3.org/2000/09/xmldsig#\\\"\u003e\\n\", \"\t\t\t\t\u003cds:X509Data\u003e\\n\", \"\t\t\t\t\t\u003cds:X509Certificate\u003eMIICyDCCAjGgAwIBAgIBADANBgkqhkiG9w0BAQ0FADCBgDELMAkGA1UEBhMCdXMx\\n\", \"\t\t\t\t\tCzAJBgNVBAgMAklBMSQwIgYDVQQKDBt0ZXJyYWZvcm0tcHJvdmlkZXIta2V5Y2xv\\n\", \"\t\t\t\t\tYWsxHDAaBgNVBAMME21ycGFya2Vycy5naXRodWIuaW8xIDAeBgkqhkiG9w0BCQEW\\n\", \"\t\t\t\t\tEW1pY2hhZWxAcGFya2VyLmdnMB4XDTE5MDEwODE0NDYzNloXDTI5MDEwNTE0NDYz\\n\", \"\t\t\t\t\tNlowgYAxCzAJBgNVBAYTAnVzMQswCQYDVQQIDAJJQTEkMCIGA1UECgwbdGVycmFm\\n\", \"\t\t\t\t\tb3JtLXByb3ZpZGVyLWtleWNsb2FrMRwwGgYDVQQDDBNtcnBhcmtlcnMuZ2l0aHVi\\n\", \"\t\t\t\t\tLmlvMSAwHgYJKoZIhvcNAQkBFhFtaWNoYWVsQHBhcmtlci5nZzCBnzANBgkqhkiG\\n\", \"\t\t\t\t\t9w0BAQEFAAOBjQAwgYkCgYEAxuZny7uyYxGVPtpie14gNQC4tT9sAvO2sVNDhuoe\\n\", \"\t\t\t\t\tqIKLRpNwkHnwQmwe5OxSh9K0BPHp/DNuuVWUqvo4tniEYn3jBr7FwLYLTKojQIxj\\n\", \"\t\t\t\t\t53S1UTT9EXq3eP5HsHMD0QnTuca2nlNYUDBm6ud2fQj0Jt5qLx86EbEC28N56IRv\\n\", \"\t\t\t\t\tGX8CAwEAAaNQME4wHQYDVR0OBBYEFMLnbQh77j7vhGTpAhKpDhCrBsPZMB8GA1Ud\\n\", \"\t\t\t\t\tIwQYMBaAFMLnbQh77j7vhGTpAhKpDhCrBsPZMAwGA1UdEwQFMAMBAf8wDQYJKoZI\\n\", \"\t\t\t\t\thvcNAQENBQADgYEAB8wGrAQY0pAfwbnYSyBt4STbebeRTu1/q1ucfrtc3qsegcd5\\n\", \"\t\t\t\t\tn01xTR+T2uZJwqHFPpFjr4IPORiHx3+4BWCweslPD53qBjKUPXcbMO1Revjef6Tj\\n\", \"\t\t\t\t\tK3K0AuJ94fxgXVoT61Nzu/a6Lj6RhzU/Dao9mlSbJY+YSbm+ZBpsuRUQ84s=\u003c/ds:X509Certificate\u003e\\n\", \"\t\t\t\t\u003c/ds:X509Data\u003e\\n\", \"\t\t\t\u003c/ds:KeyInfo\u003e\\n\", \"\t\t\u003c/md:KeyDescriptor\u003e\\n\", \"\t\t\u003cmd:NameIDFormat\u003eurn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\u003c/md:NameIDFormat\u003e\\n\", \"        \u003cmd:AssertionConsumerService Binding=\\\"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\\\" Location=\\\"https://localhost/acs/saml/\\\" index=\\\"1\\\"/\u003e\\n\", \"    \u003c/md:SPSSODescriptor\u003e\\n\", \"\u003c/md:EntityDescriptor\u003e\\n\")),\n\t\t}, nil)\n\t\t_, err = saml.NewClient(ctx, \"samlClientClient\", \u0026saml.ClientArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tClientId: samlClientClientDescriptionConverter.ApplyT(func(samlClientClientDescriptionConverter GetClientDescriptionConverterResult) (string, error) {\n\t\t\t\treturn samlClientClientDescriptionConverter.ClientId, nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getClientDescriptionConverter.\n",
                "properties": {
                    "body": {
                        "type": "string",
                        "description": "The body of the request to convert.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm to use for the client description converter API call.\n"
                    }
                },
                "type": "object",
                "required": [
                    "body",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClientDescriptionConverter.\n",
                "properties": {
                    "access": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "adminUrl": {
                        "type": "string"
                    },
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "authenticationFlowBindingOverrides": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "authorizationServicesEnabled": {
                        "type": "boolean"
                    },
                    "authorizationSettings": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "baseUrl": {
                        "type": "string"
                    },
                    "bearerOnly": {
                        "type": "boolean"
                    },
                    "body": {
                        "type": "string"
                    },
                    "clientAuthenticatorType": {
                        "type": "string"
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "consentRequired": {
                        "type": "string"
                    },
                    "defaultClientScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "defaultRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "description": {
                        "type": "string"
                    },
                    "directAccessGrantsEnabled": {
                        "type": "boolean"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "frontchannelLogout": {
                        "type": "boolean"
                    },
                    "fullScopeAllowed": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "implicitFlowEnabled": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "notBefore": {
                        "type": "integer"
                    },
                    "optionalClientScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "origin": {
                        "type": "string"
                    },
                    "protocol": {
                        "type": "string"
                    },
                    "protocolMappers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/getClientDescriptionConverterProtocolMapper:getClientDescriptionConverterProtocolMapper"
                        }
                    },
                    "publicClient": {
                        "type": "boolean"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "redirectUris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "registeredNodes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "registrationAccessToken": {
                        "type": "string"
                    },
                    "rootUrl": {
                        "type": "string"
                    },
                    "secret": {
                        "type": "string"
                    },
                    "serviceAccountsEnabled": {
                        "type": "boolean"
                    },
                    "standardFlowEnabled": {
                        "type": "boolean"
                    },
                    "surrogateAuthRequired": {
                        "type": "boolean"
                    },
                    "webOrigins": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "access",
                    "adminUrl",
                    "attributes",
                    "authenticationFlowBindingOverrides",
                    "authorizationServicesEnabled",
                    "authorizationSettings",
                    "baseUrl",
                    "bearerOnly",
                    "body",
                    "clientAuthenticatorType",
                    "clientId",
                    "consentRequired",
                    "defaultClientScopes",
                    "defaultRoles",
                    "description",
                    "directAccessGrantsEnabled",
                    "enabled",
                    "frontchannelLogout",
                    "fullScopeAllowed",
                    "implicitFlowEnabled",
                    "name",
                    "notBefore",
                    "optionalClientScopes",
                    "origin",
                    "protocol",
                    "protocolMappers",
                    "publicClient",
                    "realmId",
                    "redirectUris",
                    "registeredNodes",
                    "registrationAccessToken",
                    "rootUrl",
                    "secret",
                    "serviceAccountsEnabled",
                    "standardFlowEnabled",
                    "surrogateAuthRequired",
                    "webOrigins",
                    "id"
                ]
            }
        },
        "keycloak:index/getGroup:getGroup": {
            "description": "This data source can be used to fetch properties of a Keycloak group for\nusage with other resources, such as `keycloak.GroupRoles`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst offlineAccess = keycloak.getRoleOutput({\n    realmId: realm.id,\n    name: \"offline_access\",\n});\nconst group = keycloak.getGroupOutput({\n    realmId: realm.id,\n    name: \"group\",\n});\nconst groupRoles = new keycloak.GroupRoles(\"groupRoles\", {\n    realmId: realm.id,\n    groupId: group.apply(group =\u003e group.id),\n    roleIds: [offlineAccess.apply(offlineAccess =\u003e offlineAccess.id)],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\noffline_access = keycloak.get_role_output(realm_id=realm.id,\n    name=\"offline_access\")\ngroup = keycloak.get_group_output(realm_id=realm.id,\n    name=\"group\")\ngroup_roles = keycloak.GroupRoles(\"groupRoles\",\n    realm_id=realm.id,\n    group_id=group.id,\n    role_ids=[offline_access.id])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var offlineAccess = Keycloak.GetRole.Invoke(new Keycloak.GetRoleInvokeArgs\n        {\n            RealmId = realm.Id,\n            Name = \"offline_access\",\n        });\n        var @group = Keycloak.GetGroup.Invoke(new Keycloak.GetGroupInvokeArgs\n        {\n            RealmId = realm.Id,\n            Name = \"group\",\n        });\n        var groupRoles = new Keycloak.GroupRoles(\"groupRoles\", new Keycloak.GroupRolesArgs\n        {\n            RealmId = realm.Id,\n            GroupId = @group.Apply(@group =\u003e @group.Id),\n            RoleIds = \n            {\n                offlineAccess.Apply(offlineAccess =\u003e offlineAccess.Id),\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tofflineAccess := keycloak.LookupRoleOutput(ctx, GetRoleOutputArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"offline_access\"),\n\t\t}, nil)\n\t\tgroup := keycloak.LookupGroupOutput(ctx, GetGroupOutputArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"group\"),\n\t\t}, nil)\n\t\t_, err = keycloak.NewGroupRoles(ctx, \"groupRoles\", \u0026keycloak.GroupRolesArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tGroupId: group.ApplyT(func(group GetGroupResult) (string, error) {\n\t\t\t\treturn group.Id, nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tRoleIds: pulumi.StringArray{\n\t\t\t\tofflineAccess.ApplyT(func(offlineAccess GetRoleResult) (string, error) {\n\t\t\t\t\treturn offlineAccess.Id, nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getGroup.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the group. If there are multiple groups match `name`, the first result will be returned.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this group exists within.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroup.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "parentId": {
                        "type": "string"
                    },
                    "path": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "attributes",
                    "name",
                    "parentId",
                    "path",
                    "realmId",
                    "id"
                ]
            }
        },
        "keycloak:index/getRealm:getRealm": {
            "description": "This data source can be used to fetch properties of a Keycloak realm for\nusage with other resources.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = keycloak.getRealm({\n    realm: \"my-realm\",\n});\nconst group = new keycloak.Role(\"group\", {realmId: realm.then(realm =\u003e realm.id)});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.get_realm(realm=\"my-realm\")\ngroup = keycloak.Role(\"group\", realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = Output.Create(Keycloak.GetRealm.InvokeAsync(new Keycloak.GetRealmArgs\n        {\n            Realm = \"my-realm\",\n        }));\n        var @group = new Keycloak.Role(\"group\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Apply(realm =\u003e realm.Id),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.LookupRealm(ctx, \u0026GetRealmArgs{\n\t\t\tRealm: \"my-realm\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"group\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: pulumi.String(realm.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getRealm.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "defaultDefaultClientScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "defaultOptionalClientScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "displayNameHtml": {
                        "type": "string"
                    },
                    "internationalizations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmInternationalization:getRealmInternationalization"
                        }
                    },
                    "otpPolicy": {
                        "$ref": "#/types/keycloak:index/getRealmOtpPolicy:getRealmOtpPolicy"
                    },
                    "realm": {
                        "type": "string",
                        "description": "The realm name.\n"
                    },
                    "securityDefenses": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmSecurityDefense:getRealmSecurityDefense"
                        }
                    },
                    "smtpServers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmSmtpServer:getRealmSmtpServer"
                        }
                    },
                    "webAuthnPasswordlessPolicy": {
                        "$ref": "#/types/keycloak:index/getRealmWebAuthnPasswordlessPolicy:getRealmWebAuthnPasswordlessPolicy"
                    },
                    "webAuthnPolicy": {
                        "$ref": "#/types/keycloak:index/getRealmWebAuthnPolicy:getRealmWebAuthnPolicy"
                    }
                },
                "type": "object",
                "required": [
                    "realm"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRealm.\n",
                "properties": {
                    "accessCodeLifespan": {
                        "type": "string"
                    },
                    "accessCodeLifespanLogin": {
                        "type": "string"
                    },
                    "accessCodeLifespanUserAction": {
                        "type": "string"
                    },
                    "accessTokenLifespan": {
                        "type": "string"
                    },
                    "accessTokenLifespanForImplicitFlow": {
                        "type": "string"
                    },
                    "accountTheme": {
                        "type": "string"
                    },
                    "actionTokenGeneratedByAdminLifespan": {
                        "type": "string"
                    },
                    "actionTokenGeneratedByUserLifespan": {
                        "type": "string"
                    },
                    "adminTheme": {
                        "type": "string"
                    },
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "browserFlow": {
                        "type": "string"
                    },
                    "clientAuthenticationFlow": {
                        "type": "string"
                    },
                    "defaultDefaultClientScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "defaultOptionalClientScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "defaultSignatureAlgorithm": {
                        "type": "string"
                    },
                    "directGrantFlow": {
                        "type": "string"
                    },
                    "displayName": {
                        "type": "string"
                    },
                    "displayNameHtml": {
                        "type": "string"
                    },
                    "dockerAuthenticationFlow": {
                        "type": "string"
                    },
                    "duplicateEmailsAllowed": {
                        "type": "boolean"
                    },
                    "editUsernameAllowed": {
                        "type": "boolean"
                    },
                    "emailTheme": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "internalId": {
                        "type": "string"
                    },
                    "internationalizations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmInternationalization:getRealmInternationalization"
                        }
                    },
                    "loginTheme": {
                        "type": "string"
                    },
                    "loginWithEmailAllowed": {
                        "type": "boolean"
                    },
                    "oauth2DeviceCodeLifespan": {
                        "type": "string"
                    },
                    "oauth2DevicePollingInterval": {
                        "type": "integer"
                    },
                    "offlineSessionIdleTimeout": {
                        "type": "string"
                    },
                    "offlineSessionMaxLifespan": {
                        "type": "string"
                    },
                    "offlineSessionMaxLifespanEnabled": {
                        "type": "boolean"
                    },
                    "otpPolicy": {
                        "$ref": "#/types/keycloak:index/getRealmOtpPolicy:getRealmOtpPolicy"
                    },
                    "passwordPolicy": {
                        "type": "string"
                    },
                    "realm": {
                        "type": "string"
                    },
                    "refreshTokenMaxReuse": {
                        "type": "integer"
                    },
                    "registrationAllowed": {
                        "type": "boolean"
                    },
                    "registrationEmailAsUsername": {
                        "type": "boolean"
                    },
                    "registrationFlow": {
                        "type": "string"
                    },
                    "rememberMe": {
                        "type": "boolean"
                    },
                    "resetCredentialsFlow": {
                        "type": "string"
                    },
                    "resetPasswordAllowed": {
                        "type": "boolean"
                    },
                    "revokeRefreshToken": {
                        "type": "boolean"
                    },
                    "securityDefenses": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmSecurityDefense:getRealmSecurityDefense"
                        }
                    },
                    "smtpServers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmSmtpServer:getRealmSmtpServer"
                        }
                    },
                    "sslRequired": {
                        "type": "string"
                    },
                    "ssoSessionIdleTimeout": {
                        "type": "string"
                    },
                    "ssoSessionIdleTimeoutRememberMe": {
                        "type": "string"
                    },
                    "ssoSessionMaxLifespan": {
                        "type": "string"
                    },
                    "ssoSessionMaxLifespanRememberMe": {
                        "type": "string"
                    },
                    "userManagedAccess": {
                        "type": "boolean"
                    },
                    "verifyEmail": {
                        "type": "boolean"
                    },
                    "webAuthnPasswordlessPolicy": {
                        "$ref": "#/types/keycloak:index/getRealmWebAuthnPasswordlessPolicy:getRealmWebAuthnPasswordlessPolicy"
                    },
                    "webAuthnPolicy": {
                        "$ref": "#/types/keycloak:index/getRealmWebAuthnPolicy:getRealmWebAuthnPolicy"
                    }
                },
                "type": "object",
                "required": [
                    "accessCodeLifespan",
                    "accessCodeLifespanLogin",
                    "accessCodeLifespanUserAction",
                    "accessTokenLifespan",
                    "accessTokenLifespanForImplicitFlow",
                    "accountTheme",
                    "actionTokenGeneratedByAdminLifespan",
                    "actionTokenGeneratedByUserLifespan",
                    "adminTheme",
                    "attributes",
                    "browserFlow",
                    "clientAuthenticationFlow",
                    "defaultDefaultClientScopes",
                    "defaultOptionalClientScopes",
                    "defaultSignatureAlgorithm",
                    "directGrantFlow",
                    "displayName",
                    "dockerAuthenticationFlow",
                    "duplicateEmailsAllowed",
                    "editUsernameAllowed",
                    "emailTheme",
                    "enabled",
                    "internalId",
                    "internationalizations",
                    "loginTheme",
                    "loginWithEmailAllowed",
                    "oauth2DeviceCodeLifespan",
                    "oauth2DevicePollingInterval",
                    "offlineSessionIdleTimeout",
                    "offlineSessionMaxLifespan",
                    "offlineSessionMaxLifespanEnabled",
                    "otpPolicy",
                    "passwordPolicy",
                    "realm",
                    "refreshTokenMaxReuse",
                    "registrationAllowed",
                    "registrationEmailAsUsername",
                    "registrationFlow",
                    "rememberMe",
                    "resetCredentialsFlow",
                    "resetPasswordAllowed",
                    "revokeRefreshToken",
                    "securityDefenses",
                    "smtpServers",
                    "sslRequired",
                    "ssoSessionIdleTimeout",
                    "ssoSessionIdleTimeoutRememberMe",
                    "ssoSessionMaxLifespan",
                    "ssoSessionMaxLifespanRememberMe",
                    "userManagedAccess",
                    "verifyEmail",
                    "webAuthnPasswordlessPolicy",
                    "webAuthnPolicy",
                    "id"
                ]
            }
        },
        "keycloak:index/getRealmKeys:getRealmKeys": {
            "description": "Use this data source to get the keys of a realm. Keys can be filtered by algorithm and status.\n\nRemarks:\n\n- A key must meet all filter criteria\n- This data source may return more than one value.\n- If no key matches the filter criteria, then an error will be returned.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRealmKeys.\n",
                "properties": {
                    "algorithms": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "When specified, keys will be filtered by algorithm. The algorithms can be any of `HS256`, `RS256`,`AES`, etc.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm from which the keys will be retrieved.\n"
                    },
                    "statuses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "When specified, keys will be filtered by status. The statuses can be any of `ACTIVE`, `DISABLED` and `PASSIVE`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRealmKeys.\n",
                "properties": {
                    "algorithms": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "keys": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmKeysKey:getRealmKeysKey"
                        },
                        "description": "(Computed) A list of keys that match the filter criteria. Each key has the following attributes:\n"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "statuses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Key status (string)\n"
                    }
                },
                "type": "object",
                "required": [
                    "keys",
                    "realmId",
                    "id"
                ]
            }
        },
        "keycloak:index/getRole:getRole": {
            "description": "This data source can be used to fetch properties of a Keycloak role for\nusage with other resources, such as `keycloak.GroupRoles`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst offlineAccess = keycloak.getRoleOutput({\n    realmId: realm.id,\n    name: \"offline_access\",\n});\nconst group = new keycloak.Group(\"group\", {realmId: realm.id});\nconst groupRoles = new keycloak.GroupRoles(\"groupRoles\", {\n    realmId: realm.id,\n    groupId: group.id,\n    roleIds: [offlineAccess.apply(offlineAccess =\u003e offlineAccess.id)],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\noffline_access = keycloak.get_role_output(realm_id=realm.id,\n    name=\"offline_access\")\ngroup = keycloak.Group(\"group\", realm_id=realm.id)\ngroup_roles = keycloak.GroupRoles(\"groupRoles\",\n    realm_id=realm.id,\n    group_id=group.id,\n    role_ids=[offline_access.id])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var offlineAccess = Keycloak.GetRole.Invoke(new Keycloak.GetRoleInvokeArgs\n        {\n            RealmId = realm.Id,\n            Name = \"offline_access\",\n        });\n        var @group = new Keycloak.Group(\"group\", new Keycloak.GroupArgs\n        {\n            RealmId = realm.Id,\n        });\n        var groupRoles = new Keycloak.GroupRoles(\"groupRoles\", new Keycloak.GroupRolesArgs\n        {\n            RealmId = realm.Id,\n            GroupId = @group.Id,\n            RoleIds = \n            {\n                offlineAccess.Apply(offlineAccess =\u003e offlineAccess.Id),\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tofflineAccess := keycloak.LookupRoleOutput(ctx, GetRoleOutputArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"offline_access\"),\n\t\t}, nil)\n\t\tgroup, err := keycloak.NewGroup(ctx, \"group\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGroupRoles(ctx, \"groupRoles\", \u0026keycloak.GroupRolesArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tGroupId: group.ID(),\n\t\t\tRoleIds: pulumi.StringArray{\n\t\t\t\tofflineAccess.ApplyT(func(offlineAccess GetRoleResult) (string, error) {\n\t\t\t\t\treturn offlineAccess.Id, nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getRole.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "When specified, this role is assumed to be a client role belonging to the client with the provided ID. The `id` attribute of a `keycloak_client` resource should be used here.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this role exists within.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRole.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "compositeRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "description": {
                        "type": "string",
                        "description": "(Computed) The description of the role.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "attributes",
                    "compositeRoles",
                    "description",
                    "name",
                    "realmId",
                    "id"
                ]
            }
        },
        "keycloak:index/getUser:getUser": {
            "description": "This data source can be used to fetch properties of a user within Keycloak.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst masterRealm = keycloak.getRealm({\n    realm: \"master\",\n});\nconst defaultAdminUser = masterRealm.then(masterRealm =\u003e keycloak.getUser({\n    realmId: masterRealm.id,\n    username: \"keycloak\",\n}));\nexport const keycloakUserId = defaultAdminUser.then(defaultAdminUser =\u003e defaultAdminUser.id);\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nmaster_realm = keycloak.get_realm(realm=\"master\")\ndefault_admin_user = keycloak.get_user(realm_id=master_realm.id,\n    username=\"keycloak\")\npulumi.export(\"keycloakUserId\", default_admin_user.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var masterRealm = Output.Create(Keycloak.GetRealm.InvokeAsync(new Keycloak.GetRealmArgs\n        {\n            Realm = \"master\",\n        }));\n        var defaultAdminUser = masterRealm.Apply(masterRealm =\u003e Output.Create(Keycloak.GetUser.InvokeAsync(new Keycloak.GetUserArgs\n        {\n            RealmId = masterRealm.Id,\n            Username = \"keycloak\",\n        })));\n        this.KeycloakUserId = defaultAdminUser.Apply(defaultAdminUser =\u003e defaultAdminUser.Id);\n    }\n\n    [Output(\"keycloakUserId\")]\n    public Output\u003cstring\u003e KeycloakUserId { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmasterRealm, err := keycloak.LookupRealm(ctx, \u0026GetRealmArgs{\n\t\t\tRealm: \"master\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefaultAdminUser, err := keycloak.LookupUser(ctx, \u0026GetUserArgs{\n\t\t\tRealmId:  masterRealm.Id,\n\t\t\tUsername: \"keycloak\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"keycloakUserId\", defaultAdminUser.Id)\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getUser.\n",
                "properties": {
                    "realmId": {
                        "type": "string",
                        "description": "The realm this user belongs to.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The unique username of this user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "realmId",
                    "username"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getUser.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "(Computed) A map representing attributes for the user\n"
                    },
                    "email": {
                        "type": "string",
                        "description": "(Computed) The user's email.\n"
                    },
                    "emailVerified": {
                        "type": "boolean",
                        "description": "(Computed) Whether the email address was validated or not. Default to `false`.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "(Computed) When false, this user cannot log in. Defaults to `true`.\n"
                    },
                    "federatedIdentities": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(Computed) The user's federated identities, if applicable. This block has the following schema:\n"
                    },
                    "firstName": {
                        "type": "string",
                        "description": "(Computed) The user's first name.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "lastName": {
                        "type": "string",
                        "description": "(Computed) The user's last name.\n"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "attributes",
                    "email",
                    "emailVerified",
                    "enabled",
                    "federatedIdentities",
                    "firstName",
                    "lastName",
                    "realmId",
                    "username",
                    "id"
                ]
            }
        },
        "keycloak:index/getUserRealmRoles:getUserRealmRoles": {
            "description": "This data source can be used to fetch the realm roles of a user within Keycloak.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst masterRealm = keycloak.getRealm({\n    realm: \"master\",\n});\nconst defaultAdminUser = masterRealm.then(masterRealm =\u003e keycloak.getUser({\n    realmId: masterRealm.id,\n    username: \"keycloak\",\n}));\nconst userRealmRoles = Promise.all([masterRealm, defaultAdminUser]).then(([masterRealm, defaultAdminUser]) =\u003e keycloak.getUserRealmRoles({\n    realmId: masterRealm.id,\n    userId: defaultAdminUser.id,\n}));\nexport const keycloakUserRoleNames = userRealmRoles.then(userRealmRoles =\u003e userRealmRoles.roleNames);\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nmaster_realm = keycloak.get_realm(realm=\"master\")\ndefault_admin_user = keycloak.get_user(realm_id=master_realm.id,\n    username=\"keycloak\")\nuser_realm_roles = keycloak.get_user_realm_roles(realm_id=master_realm.id,\n    user_id=default_admin_user.id)\npulumi.export(\"keycloakUserRoleNames\", user_realm_roles.role_names)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var masterRealm = Output.Create(Keycloak.GetRealm.InvokeAsync(new Keycloak.GetRealmArgs\n        {\n            Realm = \"master\",\n        }));\n        var defaultAdminUser = masterRealm.Apply(masterRealm =\u003e Output.Create(Keycloak.GetUser.InvokeAsync(new Keycloak.GetUserArgs\n        {\n            RealmId = masterRealm.Id,\n            Username = \"keycloak\",\n        })));\n        var userRealmRoles = Output.Tuple(masterRealm, defaultAdminUser).Apply(values =\u003e\n        {\n            var masterRealm = values.Item1;\n            var defaultAdminUser = values.Item2;\n            return Output.Create(Keycloak.GetUserRealmRoles.InvokeAsync(new Keycloak.GetUserRealmRolesArgs\n            {\n                RealmId = masterRealm.Id,\n                UserId = defaultAdminUser.Id,\n            }));\n        });\n        this.KeycloakUserRoleNames = userRealmRoles.Apply(userRealmRoles =\u003e userRealmRoles.RoleNames);\n    }\n\n    [Output(\"keycloakUserRoleNames\")]\n    public Output\u003cstring\u003e KeycloakUserRoleNames { get; set; }\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmasterRealm, err := keycloak.LookupRealm(ctx, \u0026GetRealmArgs{\n\t\t\tRealm: \"master\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefaultAdminUser, err := keycloak.LookupUser(ctx, \u0026GetUserArgs{\n\t\t\tRealmId:  masterRealm.Id,\n\t\t\tUsername: \"keycloak\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tuserRealmRoles, err := keycloak.GetUserRealmRoles(ctx, \u0026GetUserRealmRolesArgs{\n\t\t\tRealmId: masterRealm.Id,\n\t\t\tUserId:  defaultAdminUser.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"keycloakUserRoleNames\", userRealmRoles.RoleNames)\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getUserRealmRoles.\n",
                "properties": {
                    "realmId": {
                        "type": "string",
                        "description": "The realm this user belongs to.\n"
                    },
                    "userId": {
                        "type": "string",
                        "description": "The ID of the user to query realm roles for.\n"
                    }
                },
                "type": "object",
                "required": [
                    "realmId",
                    "userId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getUserRealmRoles.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "roleNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(Computed) A list of realm roles that belong to this user.\n"
                    },
                    "userId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "realmId",
                    "roleNames",
                    "userId",
                    "id"
                ]
            }
        },
        "keycloak:openid/getClient:getClient": {
            "description": "This data source can be used to fetch properties of a Keycloak OpenID client for usage with other resources.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realmManagement = keycloak.openid.getClient({\n    realmId: \"my-realm\",\n    clientId: \"realm-management\",\n});\nconst admin = realmManagement.then(realmManagement =\u003e keycloak.getRole({\n    realmId: \"my-realm\",\n    clientId: realmManagement.id,\n    name: \"realm-admin\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm_management = keycloak.openid.get_client(realm_id=\"my-realm\",\n    client_id=\"realm-management\")\nadmin = keycloak.get_role(realm_id=\"my-realm\",\n    client_id=realm_management.id,\n    name=\"realm-admin\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realmManagement = Output.Create(Keycloak.OpenId.GetClient.InvokeAsync(new Keycloak.OpenId.GetClientArgs\n        {\n            RealmId = \"my-realm\",\n            ClientId = \"realm-management\",\n        }));\n        var admin = realmManagement.Apply(realmManagement =\u003e Output.Create(Keycloak.GetRole.InvokeAsync(new Keycloak.GetRoleArgs\n        {\n            RealmId = \"my-realm\",\n            ClientId = realmManagement.Id,\n            Name = \"realm-admin\",\n        })));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealmManagement, err := openid.LookupClient(ctx, \u0026openid.LookupClientArgs{\n\t\t\tRealmId:  \"my-realm\",\n\t\t\tClientId: \"realm-management\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.LookupRole(ctx, \u0026GetRoleArgs{\n\t\t\tRealmId:  \"my-realm\",\n\t\t\tClientId: pulumi.StringRef(realmManagement.Id),\n\t\t\tName:     \"realm-admin\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getClient.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The client id (not its unique ID).\n"
                    },
                    "consentScreenText": {
                        "type": "string"
                    },
                    "displayOnConsentScreen": {
                        "type": "boolean"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "oauth2DeviceAuthorizationGrantEnabled": {
                        "type": "boolean"
                    },
                    "oauth2DeviceCodeLifespan": {
                        "type": "string"
                    },
                    "oauth2DevicePollingInterval": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clientId",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClient.\n",
                "properties": {
                    "accessTokenLifespan": {
                        "type": "string"
                    },
                    "accessType": {
                        "type": "string"
                    },
                    "adminUrl": {
                        "type": "string"
                    },
                    "authenticationFlowBindingOverrides": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:openid/getClientAuthenticationFlowBindingOverride:getClientAuthenticationFlowBindingOverride"
                        }
                    },
                    "authorizations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:openid/getClientAuthorization:getClientAuthorization"
                        }
                    },
                    "backchannelLogoutRevokeOfflineSessions": {
                        "type": "boolean"
                    },
                    "backchannelLogoutSessionRequired": {
                        "type": "boolean"
                    },
                    "backchannelLogoutUrl": {
                        "type": "string"
                    },
                    "baseUrl": {
                        "type": "string"
                    },
                    "clientAuthenticatorType": {
                        "type": "string"
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "clientOfflineSessionIdleTimeout": {
                        "type": "string"
                    },
                    "clientOfflineSessionMaxLifespan": {
                        "type": "string"
                    },
                    "clientSecret": {
                        "type": "string"
                    },
                    "clientSessionIdleTimeout": {
                        "type": "string"
                    },
                    "clientSessionMaxLifespan": {
                        "type": "string"
                    },
                    "consentRequired": {
                        "type": "boolean"
                    },
                    "consentScreenText": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "directAccessGrantsEnabled": {
                        "type": "boolean"
                    },
                    "displayOnConsentScreen": {
                        "type": "boolean"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "excludeSessionStateFromAuthResponse": {
                        "type": "boolean"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "frontchannelLogoutEnabled": {
                        "type": "boolean"
                    },
                    "frontchannelLogoutUrl": {
                        "type": "string"
                    },
                    "fullScopeAllowed": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "implicitFlowEnabled": {
                        "type": "boolean"
                    },
                    "loginTheme": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "oauth2DeviceAuthorizationGrantEnabled": {
                        "type": "boolean"
                    },
                    "oauth2DeviceCodeLifespan": {
                        "type": "string"
                    },
                    "oauth2DevicePollingInterval": {
                        "type": "string"
                    },
                    "pkceCodeChallengeMethod": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "rootUrl": {
                        "type": "string"
                    },
                    "serviceAccountUserId": {
                        "type": "string"
                    },
                    "serviceAccountsEnabled": {
                        "type": "boolean"
                    },
                    "standardFlowEnabled": {
                        "type": "boolean"
                    },
                    "useRefreshTokens": {
                        "type": "boolean"
                    },
                    "validRedirectUris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "webOrigins": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "accessTokenLifespan",
                    "accessType",
                    "adminUrl",
                    "authenticationFlowBindingOverrides",
                    "authorizations",
                    "backchannelLogoutRevokeOfflineSessions",
                    "backchannelLogoutSessionRequired",
                    "backchannelLogoutUrl",
                    "baseUrl",
                    "clientAuthenticatorType",
                    "clientId",
                    "clientOfflineSessionIdleTimeout",
                    "clientOfflineSessionMaxLifespan",
                    "clientSecret",
                    "clientSessionIdleTimeout",
                    "clientSessionMaxLifespan",
                    "consentRequired",
                    "description",
                    "directAccessGrantsEnabled",
                    "enabled",
                    "excludeSessionStateFromAuthResponse",
                    "extraConfig",
                    "frontchannelLogoutEnabled",
                    "frontchannelLogoutUrl",
                    "fullScopeAllowed",
                    "implicitFlowEnabled",
                    "loginTheme",
                    "name",
                    "pkceCodeChallengeMethod",
                    "realmId",
                    "resourceServerId",
                    "rootUrl",
                    "serviceAccountUserId",
                    "serviceAccountsEnabled",
                    "standardFlowEnabled",
                    "useRefreshTokens",
                    "validRedirectUris",
                    "webOrigins",
                    "id"
                ]
            }
        },
        "keycloak:openid/getClientAuthorizationPolicy:getClientAuthorizationPolicy": {
            "description": "This data source can be used to fetch policy and permission information for an OpenID client that has authorization enabled.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nIn this example, we'll create a new OpenID client with authorization enabled. This will cause Keycloak to create a default\npermission for this client called \"Default Permission\". We'll use the `keycloak.openid.getClientAuthorizationPolicy` data\nsource to fetch information about this permission, so we can use it to create a new resource-based authorization permission.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientWithAuthz = new keycloak.openid.Client(\"clientWithAuthz\", {\n    clientId: \"client-with-authz\",\n    realmId: realm.id,\n    accessType: \"CONFIDENTIAL\",\n    serviceAccountsEnabled: true,\n    authorization: {\n        policyEnforcementMode: \"ENFORCING\",\n    },\n});\nconst defaultPermission = keycloak.openid.getClientAuthorizationPolicyOutput({\n    realmId: realm.id,\n    resourceServerId: clientWithAuthz.resourceServerId,\n    name: \"Default Permission\",\n});\nconst resource = new keycloak.openid.ClientAuthorizationResource(\"resource\", {\n    resourceServerId: clientWithAuthz.resourceServerId,\n    realmId: realm.id,\n    uris: [\"/endpoint/*\"],\n    attributes: {\n        foo: \"bar\",\n    },\n});\nconst permission = new keycloak.openid.ClientAuthorizationPermission(\"permission\", {\n    resourceServerId: clientWithAuthz.resourceServerId,\n    realmId: realm.id,\n    policies: [defaultPermission.apply(defaultPermission =\u003e defaultPermission.id)],\n    resources: [resource.id],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_with_authz = keycloak.openid.Client(\"clientWithAuthz\",\n    client_id=\"client-with-authz\",\n    realm_id=realm.id,\n    access_type=\"CONFIDENTIAL\",\n    service_accounts_enabled=True,\n    authorization=keycloak.openid.ClientAuthorizationArgs(\n        policy_enforcement_mode=\"ENFORCING\",\n    ))\ndefault_permission = keycloak.openid.get_client_authorization_policy_output(realm_id=realm.id,\n    resource_server_id=client_with_authz.resource_server_id,\n    name=\"Default Permission\")\nresource = keycloak.openid.ClientAuthorizationResource(\"resource\",\n    resource_server_id=client_with_authz.resource_server_id,\n    realm_id=realm.id,\n    uris=[\"/endpoint/*\"],\n    attributes={\n        \"foo\": \"bar\",\n    })\npermission = keycloak.openid.ClientAuthorizationPermission(\"permission\",\n    resource_server_id=client_with_authz.resource_server_id,\n    realm_id=realm.id,\n    policies=[default_permission.id],\n    resources=[resource.id])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientWithAuthz = new Keycloak.OpenId.Client(\"clientWithAuthz\", new Keycloak.OpenId.ClientArgs\n        {\n            ClientId = \"client-with-authz\",\n            RealmId = realm.Id,\n            AccessType = \"CONFIDENTIAL\",\n            ServiceAccountsEnabled = true,\n            Authorization = new Keycloak.OpenId.Inputs.ClientAuthorizationArgs\n            {\n                PolicyEnforcementMode = \"ENFORCING\",\n            },\n        });\n        var defaultPermission = Keycloak.OpenId.GetClientAuthorizationPolicy.Invoke(new Keycloak.OpenId.GetClientAuthorizationPolicyInvokeArgs\n        {\n            RealmId = realm.Id,\n            ResourceServerId = clientWithAuthz.ResourceServerId,\n            Name = \"Default Permission\",\n        });\n        var resource = new Keycloak.OpenId.ClientAuthorizationResource(\"resource\", new Keycloak.OpenId.ClientAuthorizationResourceArgs\n        {\n            ResourceServerId = clientWithAuthz.ResourceServerId,\n            RealmId = realm.Id,\n            Uris = \n            {\n                \"/endpoint/*\",\n            },\n            Attributes = \n            {\n                { \"foo\", \"bar\" },\n            },\n        });\n        var permission = new Keycloak.OpenId.ClientAuthorizationPermission(\"permission\", new Keycloak.OpenId.ClientAuthorizationPermissionArgs\n        {\n            ResourceServerId = clientWithAuthz.ResourceServerId,\n            RealmId = realm.Id,\n            Policies = \n            {\n                defaultPermission.Apply(defaultPermission =\u003e defaultPermission.Id),\n            },\n            Resources = \n            {\n                resource.Id,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientWithAuthz, err := openid.NewClient(ctx, \"clientWithAuthz\", \u0026openid.ClientArgs{\n\t\t\tClientId:               pulumi.String(\"client-with-authz\"),\n\t\t\tRealmId:                realm.ID(),\n\t\t\tAccessType:             pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tServiceAccountsEnabled: pulumi.Bool(true),\n\t\t\tAuthorization: \u0026openid.ClientAuthorizationArgs{\n\t\t\t\tPolicyEnforcementMode: pulumi.String(\"ENFORCING\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefaultPermission := openid.GetClientAuthorizationPolicyOutput(ctx, openid.GetClientAuthorizationPolicyOutputArgs{\n\t\t\tRealmId:          realm.ID(),\n\t\t\tResourceServerId: clientWithAuthz.ResourceServerId,\n\t\t\tName:             pulumi.String(\"Default Permission\"),\n\t\t}, nil)\n\t\tresource, err := openid.NewClientAuthorizationResource(ctx, \"resource\", \u0026openid.ClientAuthorizationResourceArgs{\n\t\t\tResourceServerId: clientWithAuthz.ResourceServerId,\n\t\t\tRealmId:          realm.ID(),\n\t\t\tUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"/endpoint/*\"),\n\t\t\t},\n\t\t\tAttributes: pulumi.AnyMap{\n\t\t\t\t\"foo\": pulumi.Any(\"bar\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientAuthorizationPermission(ctx, \"permission\", \u0026openid.ClientAuthorizationPermissionArgs{\n\t\t\tResourceServerId: clientWithAuthz.ResourceServerId,\n\t\t\tRealmId:          realm.ID(),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tdefaultPermission.ApplyT(func(defaultPermission openid.GetClientAuthorizationPolicyResult) (string, error) {\n\t\t\t\t\treturn defaultPermission.Id, nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t},\n\t\t\tResources: pulumi.StringArray{\n\t\t\t\tresource.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getClientAuthorizationPolicy.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the authorization policy.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this authorization policy exists within.\n"
                    },
                    "resourceServerId": {
                        "type": "string",
                        "description": "The ID of the resource server this authorization policy is attached to.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "realmId",
                    "resourceServerId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClientAuthorizationPolicy.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string",
                        "description": "(Computed) Dictates how the policies associated with a given permission are evaluated and how a final decision is obtained. Could be one of `AFFIRMATIVE`, `CONSENSUS`, or `UNANIMOUS`. Applies to permissions.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "logic": {
                        "type": "string",
                        "description": "(Computed) Dictates how the policy decision should be made. Can be either `POSITIVE` or `NEGATIVE`. Applies to policies.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "owner": {
                        "type": "string",
                        "description": "(Computed) The ID of the owning resource. Applies to resources.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(Computed) The IDs of the policies that must be applied to scopes/resources for this policy/permission. Applies to policies and permissions.\n"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "resources": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(Computed) The IDs of the resources that this permission applies to. Applies to resource-based permissions.\n"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(Computed) The IDs of the scopes that this permission applies to. Applies to scope-based permissions.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "(Computed) The type of this policy / permission. For permissions, this could be `resource` or `scope`. For policies, this could be any type of authorization policy, such as `js`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "decisionStrategy",
                    "logic",
                    "name",
                    "owner",
                    "policies",
                    "realmId",
                    "resourceServerId",
                    "resources",
                    "scopes",
                    "type",
                    "id"
                ]
            }
        },
        "keycloak:openid/getClientServiceAccountUser:getClientServiceAccountUser": {
            "description": "This data source can be used to fetch information about the service account user that is associated with an OpenID client\nthat has service accounts enabled.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nIn this example, we'll create an OpenID client with service accounts enabled. This causes Keycloak to create a special user\nthat represents the service account. We'll use this data source to grab this user's ID in order to assign some roles to this\nuser, using the `keycloak.UserRoles` resource.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    accessType: \"CONFIDENTIAL\",\n    serviceAccountsEnabled: true,\n});\nconst serviceAccountUser = keycloak.openid.getClientServiceAccountUserOutput({\n    realmId: realm.id,\n    clientId: client.id,\n});\nconst offlineAccess = keycloak.getRoleOutput({\n    realmId: realm.id,\n    name: \"offline_access\",\n});\nconst serviceAccountUserRoles = new keycloak.UserRoles(\"serviceAccountUserRoles\", {\n    realmId: realm.id,\n    userId: serviceAccountUser.apply(serviceAccountUser =\u003e serviceAccountUser.id),\n    roleIds: [offlineAccess.apply(offlineAccess =\u003e offlineAccess.id)],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    access_type=\"CONFIDENTIAL\",\n    service_accounts_enabled=True)\nservice_account_user = keycloak.openid.get_client_service_account_user_output(realm_id=realm.id,\n    client_id=client.id)\noffline_access = keycloak.get_role_output(realm_id=realm.id,\n    name=\"offline_access\")\nservice_account_user_roles = keycloak.UserRoles(\"serviceAccountUserRoles\",\n    realm_id=realm.id,\n    user_id=service_account_user.id,\n    role_ids=[offline_access.id])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var client = new Keycloak.OpenId.Client(\"client\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            AccessType = \"CONFIDENTIAL\",\n            ServiceAccountsEnabled = true,\n        });\n        var serviceAccountUser = Keycloak.OpenId.GetClientServiceAccountUser.Invoke(new Keycloak.OpenId.GetClientServiceAccountUserInvokeArgs\n        {\n            RealmId = realm.Id,\n            ClientId = client.Id,\n        });\n        var offlineAccess = Keycloak.GetRole.Invoke(new Keycloak.GetRoleInvokeArgs\n        {\n            RealmId = realm.Id,\n            Name = \"offline_access\",\n        });\n        var serviceAccountUserRoles = new Keycloak.UserRoles(\"serviceAccountUserRoles\", new Keycloak.UserRolesArgs\n        {\n            RealmId = realm.Id,\n            UserId = serviceAccountUser.Apply(serviceAccountUser =\u003e serviceAccountUser.Id),\n            RoleIds = \n            {\n                offlineAccess.Apply(offlineAccess =\u003e offlineAccess.Id),\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:                realm.ID(),\n\t\t\tClientId:               pulumi.String(\"client\"),\n\t\t\tAccessType:             pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tServiceAccountsEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tserviceAccountUser := openid.GetClientServiceAccountUserOutput(ctx, openid.GetClientServiceAccountUserOutputArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: client.ID(),\n\t\t}, nil)\n\t\tofflineAccess := keycloak.LookupRoleOutput(ctx, GetRoleOutputArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tName:    pulumi.String(\"offline_access\"),\n\t\t}, nil)\n\t\t_, err = keycloak.NewUserRoles(ctx, \"serviceAccountUserRoles\", \u0026keycloak.UserRolesArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tUserId: serviceAccountUser.ApplyT(func(serviceAccountUser openid.GetClientServiceAccountUserResult) (string, error) {\n\t\t\t\treturn serviceAccountUser.Id, nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tRoleIds: pulumi.StringArray{\n\t\t\t\tofflineAccess.ApplyT(func(offlineAccess GetRoleResult) (string, error) {\n\t\t\t\t\treturn offlineAccess.Id, nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getClientServiceAccountUser.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The ID of the OpenID client with service accounts enabled.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that the OpenID client exists within.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clientId",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClientServiceAccountUser.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "email": {
                        "type": "string"
                    },
                    "emailVerified": {
                        "type": "boolean"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "federatedIdentities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:openid/getClientServiceAccountUserFederatedIdentity:getClientServiceAccountUserFederatedIdentity"
                        }
                    },
                    "firstName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "lastName": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "attributes",
                    "clientId",
                    "email",
                    "emailVerified",
                    "enabled",
                    "federatedIdentities",
                    "firstName",
                    "lastName",
                    "realmId",
                    "username",
                    "id"
                ]
            }
        },
        "keycloak:saml/getClient:getClient": {
            "description": "This data source can be used to fetch properties of a Keycloak client that uses the SAML protocol.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realmManagement = keycloak.saml.getClient({\n    realmId: \"my-realm\",\n    clientId: \"realm-management\",\n});\nconst admin = realmManagement.then(realmManagement =\u003e keycloak.getRole({\n    realmId: \"my-realm\",\n    clientId: realmManagement.id,\n    name: \"realm-admin\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm_management = keycloak.saml.get_client(realm_id=\"my-realm\",\n    client_id=\"realm-management\")\nadmin = keycloak.get_role(realm_id=\"my-realm\",\n    client_id=realm_management.id,\n    name=\"realm-admin\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realmManagement = Output.Create(Keycloak.Saml.GetClient.InvokeAsync(new Keycloak.Saml.GetClientArgs\n        {\n            RealmId = \"my-realm\",\n            ClientId = \"realm-management\",\n        }));\n        var admin = realmManagement.Apply(realmManagement =\u003e Output.Create(Keycloak.GetRole.InvokeAsync(new Keycloak.GetRoleArgs\n        {\n            RealmId = \"my-realm\",\n            ClientId = realmManagement.Id,\n            Name = \"realm-admin\",\n        })));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealmManagement, err := saml.LookupClient(ctx, \u0026saml.LookupClientArgs{\n\t\t\tRealmId:  \"my-realm\",\n\t\t\tClientId: \"realm-management\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.LookupRole(ctx, \u0026GetRoleArgs{\n\t\t\tRealmId:  \"my-realm\",\n\t\t\tClientId: pulumi.StringRef(realmManagement.Id),\n\t\t\tName:     \"realm-admin\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getClient.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The client id (not its unique ID).\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clientId",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClient.\n",
                "properties": {
                    "assertionConsumerPostUrl": {
                        "type": "string"
                    },
                    "assertionConsumerRedirectUrl": {
                        "type": "string"
                    },
                    "authenticationFlowBindingOverrides": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:saml/getClientAuthenticationFlowBindingOverride:getClientAuthenticationFlowBindingOverride"
                        }
                    },
                    "baseUrl": {
                        "type": "string"
                    },
                    "canonicalizationMethod": {
                        "type": "string"
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "clientSignatureRequired": {
                        "type": "boolean"
                    },
                    "description": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "encryptAssertions": {
                        "type": "boolean"
                    },
                    "encryptionCertificate": {
                        "type": "string"
                    },
                    "encryptionCertificateSha1": {
                        "type": "string"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "forceNameIdFormat": {
                        "type": "boolean"
                    },
                    "forcePostBinding": {
                        "type": "boolean"
                    },
                    "frontChannelLogout": {
                        "type": "boolean"
                    },
                    "fullScopeAllowed": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "idpInitiatedSsoRelayState": {
                        "type": "string"
                    },
                    "idpInitiatedSsoUrlName": {
                        "type": "string"
                    },
                    "includeAuthnStatement": {
                        "type": "boolean"
                    },
                    "loginTheme": {
                        "type": "string"
                    },
                    "logoutServicePostBindingUrl": {
                        "type": "string"
                    },
                    "logoutServiceRedirectBindingUrl": {
                        "type": "string"
                    },
                    "masterSamlProcessingUrl": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nameIdFormat": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "rootUrl": {
                        "type": "string"
                    },
                    "samlSignatureKeyName": {
                        "type": "string"
                    },
                    "signAssertions": {
                        "type": "boolean"
                    },
                    "signDocuments": {
                        "type": "boolean"
                    },
                    "signatureAlgorithm": {
                        "type": "string"
                    },
                    "signatureKeyName": {
                        "type": "string"
                    },
                    "signingCertificate": {
                        "type": "string"
                    },
                    "signingCertificateSha1": {
                        "type": "string"
                    },
                    "signingPrivateKey": {
                        "type": "string"
                    },
                    "signingPrivateKeySha1": {
                        "type": "string"
                    },
                    "validRedirectUris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "assertionConsumerPostUrl",
                    "assertionConsumerRedirectUrl",
                    "authenticationFlowBindingOverrides",
                    "baseUrl",
                    "canonicalizationMethod",
                    "clientId",
                    "clientSignatureRequired",
                    "description",
                    "enabled",
                    "encryptAssertions",
                    "encryptionCertificate",
                    "encryptionCertificateSha1",
                    "extraConfig",
                    "forceNameIdFormat",
                    "forcePostBinding",
                    "frontChannelLogout",
                    "fullScopeAllowed",
                    "idpInitiatedSsoRelayState",
                    "idpInitiatedSsoUrlName",
                    "includeAuthnStatement",
                    "loginTheme",
                    "logoutServicePostBindingUrl",
                    "logoutServiceRedirectBindingUrl",
                    "masterSamlProcessingUrl",
                    "name",
                    "nameIdFormat",
                    "realmId",
                    "rootUrl",
                    "samlSignatureKeyName",
                    "signAssertions",
                    "signDocuments",
                    "signatureAlgorithm",
                    "signatureKeyName",
                    "signingCertificate",
                    "signingCertificateSha1",
                    "signingPrivateKey",
                    "signingPrivateKeySha1",
                    "validRedirectUris",
                    "id"
                ]
            }
        },
        "keycloak:saml/getClientInstallationProvider:getClientInstallationProvider": {
            "description": "This data source can be used to retrieve Installation Provider of a SAML Client.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nIn the example below, we extract the SAML metadata IDPSSODescriptor to pass it to the AWS IAM SAML Provider.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\nimport * as keycloak from \"@pulumi/keycloak\";\nimport * from \"fs\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClient = new keycloak.saml.Client(\"samlClient\", {\n    realmId: realm.id,\n    clientId: \"test-saml-client\",\n    signDocuments: false,\n    signAssertions: true,\n    includeAuthnStatement: true,\n    signingCertificate: fs.readFileSync(\"saml-cert.pem\"),\n    signingPrivateKey: fs.readFileSync(\"saml-key.pem\"),\n});\nconst samlIdpDescriptor = keycloak.saml.getClientInstallationProviderOutput({\n    realmId: realm.id,\n    clientId: samlClient.id,\n    providerId: \"saml-idp-descriptor\",\n});\nconst _default = new aws.iam.SamlProvider(\"default\", {samlMetadataDocument: samlIdpDescriptor.apply(samlIdpDescriptor =\u003e samlIdpDescriptor.value)});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client = keycloak.saml.Client(\"samlClient\",\n    realm_id=realm.id,\n    client_id=\"test-saml-client\",\n    sign_documents=False,\n    sign_assertions=True,\n    include_authn_statement=True,\n    signing_certificate=(lambda path: open(path).read())(\"saml-cert.pem\"),\n    signing_private_key=(lambda path: open(path).read())(\"saml-key.pem\"))\nsaml_idp_descriptor = keycloak.saml.get_client_installation_provider_output(realm_id=realm.id,\n    client_id=saml_client.id,\n    provider_id=\"saml-idp-descriptor\")\ndefault = aws.iam.SamlProvider(\"default\", saml_metadata_document=saml_idp_descriptor.value)\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var samlClient = new Keycloak.Saml.Client(\"samlClient\", new Keycloak.Saml.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"test-saml-client\",\n            SignDocuments = false,\n            SignAssertions = true,\n            IncludeAuthnStatement = true,\n            SigningCertificate = File.ReadAllText(\"saml-cert.pem\"),\n            SigningPrivateKey = File.ReadAllText(\"saml-key.pem\"),\n        });\n        var samlIdpDescriptor = Keycloak.Saml.GetClientInstallationProvider.Invoke(new Keycloak.Saml.GetClientInstallationProviderInvokeArgs\n        {\n            RealmId = realm.Id,\n            ClientId = samlClient.Id,\n            ProviderId = \"saml-idp-descriptor\",\n        });\n        var @default = new Aws.Iam.SamlProvider(\"default\", new Aws.Iam.SamlProviderArgs\n        {\n            SamlMetadataDocument = samlIdpDescriptor.Apply(samlIdpDescriptor =\u003e samlIdpDescriptor.Value),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\n\t\"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/iam\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsamlClient, err := saml.NewClient(ctx, \"samlClient\", \u0026saml.ClientArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tClientId:              pulumi.String(\"test-saml-client\"),\n\t\t\tSignDocuments:         pulumi.Bool(false),\n\t\t\tSignAssertions:        pulumi.Bool(true),\n\t\t\tIncludeAuthnStatement: pulumi.Bool(true),\n\t\t\tSigningCertificate:    readFileOrPanic(\"saml-cert.pem\"),\n\t\t\tSigningPrivateKey:     readFileOrPanic(\"saml-key.pem\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsamlIdpDescriptor := saml.GetClientInstallationProviderOutput(ctx, saml.GetClientInstallationProviderOutputArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   samlClient.ID(),\n\t\t\tProviderId: pulumi.String(\"saml-idp-descriptor\"),\n\t\t}, nil)\n\t\t_, err = iam.NewSamlProvider(ctx, \"default\", \u0026iam.SamlProviderArgs{\n\t\t\tSamlMetadataDocument: samlIdpDescriptor.ApplyT(func(samlIdpDescriptor saml.GetClientInstallationProviderResult) (string, error) {\n\t\t\t\treturn samlIdpDescriptor.Value, nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getClientInstallationProvider.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The ID of the SAML client. The `id` attribute of a `keycloak_client` resource should be used here.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The ID of the SAML installation provider. Could be one of `saml-idp-descriptor`, `keycloak-saml`, `saml-sp-descriptor`, `keycloak-saml-subsystem`, `mod-auth-mellon`, etc.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that the SAML client exists within.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clientId",
                    "providerId",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClientInstallationProvider.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "providerId": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "value": {
                        "type": "string",
                        "description": "(Computed) The returned document needed for SAML installation.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clientId",
                    "providerId",
                    "realmId",
                    "value",
                    "id"
                ]
            }
        }
    },
    "language": {
        "csharp": {
            "compatibility": "tfbridge20",
            "namespaces": {
                "authentication": "Authentication",
                "index": "index",
                "keycloak": "Keycloak",
                "ldap": "Ldap",
                "oidc": "Oidc",
                "openid": "OpenId",
                "saml": "Saml"
            },
            "packageReferences": {
                "Pulumi": "3.*"
            }
        },
        "go": {
            "generateExtraInputTypes": true,
            "generateResourceContainerTypes": true,
            "importBasePath": "github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak"
        },
        "nodejs": {
            "compatibility": "tfbridge20",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing keycloak cloud resources.",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/mrparkers/terraform-provider-keycloak)\n\u003e distributed under [MIT](https://mit-license.org/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-keycloak` repo](https://github.com/pulumi/pulumi-keycloak/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`mrparkers/terraform-provider-keycloak` repo](https://github.com/mrparkers/terraform-provider-keycloak/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "compatibility": "tfbridge20",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/mrparkers/terraform-provider-keycloak)\n\u003e distributed under [MIT](https://mit-license.org/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-keycloak` repo](https://github.com/pulumi/pulumi-keycloak/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`mrparkers/terraform-provider-keycloak` repo](https://github.com/mrparkers/terraform-provider-keycloak/issues).",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            }
        }
    }
}