{
    "name": "keycloak",
    "description": "A Pulumi package for creating and managing keycloak cloud resources.",
    "keywords": [
        "pulumi",
        "keycloak"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`keycloak` Terraform Provider](https://github.com/mrparkers/terraform-provider-keycloak).",
    "repository": "https://github.com/pulumi/pulumi-keycloak",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "config": {
        "variables": {
            "basePath": {
                "type": "string"
            },
            "clientId": {
                "type": "string",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_CLIENT_ID"
                    ]
                }
            },
            "clientSecret": {
                "type": "string",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_CLIENT_SECRET"
                    ]
                }
            },
            "clientTimeout": {
                "type": "integer",
                "description": "Timeout (in seconds) of the Keycloak client\n",
                "default": 5,
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_CLIENT_TIMEOUT"
                    ]
                }
            },
            "initialLogin": {
                "type": "boolean",
                "description": "Whether or not to login to Keycloak instance on provider initialization\n"
            },
            "password": {
                "type": "string",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_PASSWORD"
                    ]
                }
            },
            "realm": {
                "type": "string",
                "default": "master",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_REALM"
                    ]
                }
            },
            "rootCaCertificate": {
                "type": "string",
                "description": "Allows x509 calls using an unknown CA certificate (for development purposes)\n"
            },
            "tlsInsecureSkipVerify": {
                "type": "boolean",
                "description": "Allows ignoring insecure certificates when set to true. Defaults to false. Disabling security check is dangerous and\nshould be avoided.\n"
            },
            "url": {
                "type": "string",
                "description": "The base URL of the Keycloak instance, before `/auth`\n",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_URL"
                    ]
                }
            },
            "username": {
                "type": "string",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_USER"
                    ]
                }
            }
        },
        "defaults": [
            "clientId",
            "url"
        ]
    },
    "types": {
        "keycloak:index/RealmInternationalization:RealmInternationalization": {
            "properties": {
                "defaultLocale": {
                    "type": "string",
                    "description": "The locale to use by default. This locale code must be present within the `supported_locales` list.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "supportedLocales": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) locale codes that the realm should support.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "defaultLocale",
                "supportedLocales"
            ]
        },
        "keycloak:index/RealmSecurityDefenses:RealmSecurityDefenses": {
            "properties": {
                "bruteForceDetection": {
                    "$ref": "#/types/keycloak:index/RealmSecurityDefensesBruteForceDetection:RealmSecurityDefensesBruteForceDetection",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "headers": {
                    "$ref": "#/types/keycloak:index/RealmSecurityDefensesHeaders:RealmSecurityDefensesHeaders",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/RealmSecurityDefensesBruteForceDetection:RealmSecurityDefensesBruteForceDetection": {
            "properties": {
                "failureResetTimeSeconds": {
                    "type": "integer",
                    "description": "When will failure count be reset?\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxFailureWaitSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLoginFailures": {
                    "type": "integer",
                    "description": "How many failures before wait is triggered.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minimumQuickLoginWaitSeconds": {
                    "type": "integer",
                    "description": "How long to wait after a quick login failure.\n- `max_failure_wait_seconds ` - (Optional) Max. time a user will be locked out.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "permanentLockout": {
                    "type": "boolean",
                    "description": "When `true`, this will lock the user permanently when the user exceeds the maximum login failures.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "quickLoginCheckMilliSeconds": {
                    "type": "integer",
                    "description": "Configures the amount of time, in milliseconds, for consecutive failures to lock a user out.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "waitIncrementSeconds": {
                    "type": "integer",
                    "description": "This represents the amount of time a user should be locked out when the login failure threshold has been met.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/RealmSecurityDefensesHeaders:RealmSecurityDefensesHeaders": {
            "properties": {
                "contentSecurityPolicy": {
                    "type": "string",
                    "description": "Sets the Content Security Policy, which can be used for prevent pages from being included by non-origin iframes. More information can be found in the [W3C-CSP](https://www.w3.org/TR/CSP/) Abstract.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contentSecurityPolicyReportOnly": {
                    "type": "string",
                    "description": "Used for testing Content Security Policies.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "strictTransportSecurity": {
                    "type": "string",
                    "description": "The Script-Transport-Security HTTP header tells browsers to always use HTTPS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xContentTypeOptions": {
                    "type": "string",
                    "description": "Sets the X-Content-Type-Options, which can be used for prevent MIME-sniffing a response away from the declared content-type\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xFrameOptions": {
                    "type": "string",
                    "description": "Sets the x-frame-option, which can be used to prevent pages from being included by non-origin iframes. More information can be found in the [RFC7034](https://tools.ietf.org/html/rfc7034)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xRobotsTag": {
                    "type": "string",
                    "description": "Prevent pages from appearing in search engines.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xXssProtection": {
                    "type": "string",
                    "description": "This header configures the Cross-site scripting (XSS) filter in your browser.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:index/RealmSmtpServer:RealmSmtpServer": {
            "properties": {
                "auth": {
                    "$ref": "#/types/keycloak:index/RealmSmtpServerAuth:RealmSmtpServerAuth",
                    "description": "Enables authentication to the SMTP server.  This block supports the following arguments:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "envelopeFrom": {
                    "type": "string",
                    "description": "The email address uses for bounces.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "from": {
                    "type": "string",
                    "description": "The email address for the sender.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fromDisplayName": {
                    "type": "string",
                    "description": "The display name of the sender email address.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "description": "The host of the SMTP server.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "string",
                    "description": "The port of the SMTP server (defaults to 25).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replyTo": {
                    "type": "string",
                    "description": "The \"reply to\" email address.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replyToDisplayName": {
                    "type": "string",
                    "description": "The display name of the \"reply to\" email address.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssl": {
                    "type": "boolean",
                    "description": "When `true`, enables SSL. Defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "starttls": {
                    "type": "boolean",
                    "description": "When `true`, enables StartTLS. Defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "from",
                "host"
            ]
        },
        "keycloak:index/RealmSmtpServerAuth:RealmSmtpServerAuth": {
            "properties": {
                "password": {
                    "type": "string",
                    "description": "The SMTP server password.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "The SMTP server username.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "password",
                "username"
            ]
        },
        "keycloak:index/RealmWebAuthnPasswordlessPolicy:RealmWebAuthnPasswordlessPolicy": {
            "properties": {
                "acceptableAaguids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of AAGUIDs for which an authenticator can be registered.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attestationConveyancePreference": {
                    "type": "string",
                    "description": "The preference of how to generate a WebAuthn attestation statement. Valid options are `not specified`, `none`, `indirect`, `direct`, or `enterprise`. Defaults to `not specified`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authenticatorAttachment": {
                    "type": "string",
                    "description": "The acceptable attachment pattern for the WebAuthn authenticator. Valid options are `not specified`, `platform`, or `cross-platform`. Defaults to `not specified`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "avoidSameAuthenticatorRegister": {
                    "type": "boolean",
                    "description": "When `true`, Keycloak will avoid registering the authenticator for WebAuthn if it has already been registered. Defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createTimeout": {
                    "type": "integer",
                    "description": "The timeout value for creating a user's public key credential in seconds. When set to `0`, this timeout option is not adapted. Defaults to `0`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "relyingPartyEntityName": {
                    "type": "string",
                    "description": "A human readable server name for the WebAuthn Relying Party. Defaults to `keycloak`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "relyingPartyId": {
                    "type": "string",
                    "description": "The WebAuthn relying party ID.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requireResidentKey": {
                    "type": "string",
                    "description": "Specifies whether or not a public key should be created to represent the resident key. Valid options are `not specified`, `Yes`, or `No`. Defaults to `not specified`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "signatureAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of signature algorithms that should be used for the authentication assertion. Valid options at the time these docs were written are `ES256`, `ES384`, `ES512`, `RS256`, `RS384`, `RS512`, and `RS1`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userVerificationRequirement": {
                    "type": "string",
                    "description": "Specifies the policy for verifying a user logging in via WebAuthn. Valid options are `not specified`, `required`, `preferred`, or `discouraged`. Defaults to `not specified`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "signatureAlgorithms"
                    ]
                }
            }
        },
        "keycloak:index/RealmWebAuthnPolicy:RealmWebAuthnPolicy": {
            "properties": {
                "acceptableAaguids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of AAGUIDs for which an authenticator can be registered.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attestationConveyancePreference": {
                    "type": "string",
                    "description": "The preference of how to generate a WebAuthn attestation statement. Valid options are `not specified`, `none`, `indirect`, `direct`, or `enterprise`. Defaults to `not specified`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authenticatorAttachment": {
                    "type": "string",
                    "description": "The acceptable attachment pattern for the WebAuthn authenticator. Valid options are `not specified`, `platform`, or `cross-platform`. Defaults to `not specified`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "avoidSameAuthenticatorRegister": {
                    "type": "boolean",
                    "description": "When `true`, Keycloak will avoid registering the authenticator for WebAuthn if it has already been registered. Defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createTimeout": {
                    "type": "integer",
                    "description": "The timeout value for creating a user's public key credential in seconds. When set to `0`, this timeout option is not adapted. Defaults to `0`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "relyingPartyEntityName": {
                    "type": "string",
                    "description": "A human readable server name for the WebAuthn Relying Party. Defaults to `keycloak`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "relyingPartyId": {
                    "type": "string",
                    "description": "The WebAuthn relying party ID.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requireResidentKey": {
                    "type": "string",
                    "description": "Specifies whether or not a public key should be created to represent the resident key. Valid options are `not specified`, `Yes`, or `No`. Defaults to `not specified`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "signatureAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of signature algorithms that should be used for the authentication assertion. Valid options at the time these docs were written are `ES256`, `ES384`, `ES512`, `RS256`, `RS384`, `RS512`, and `RS1`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userVerificationRequirement": {
                    "type": "string",
                    "description": "Specifies the policy for verifying a user logging in via WebAuthn. Valid options are `not specified`, `required`, `preferred`, or `discouraged`. Defaults to `not specified`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "signatureAlgorithms"
                    ]
                }
            }
        },
        "keycloak:index/UserFederatedIdentity:UserFederatedIdentity": {
            "properties": {
                "identityProvider": {
                    "type": "string",
                    "description": "The name of the identity provider\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userId": {
                    "type": "string",
                    "description": "The ID of the user defined in the identity provider\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userName": {
                    "type": "string",
                    "description": "The user name of the user defined in the identity provider\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "identityProvider",
                "userId",
                "userName"
            ]
        },
        "keycloak:index/UserInitialPassword:UserInitialPassword": {
            "properties": {
                "temporary": {
                    "type": "boolean",
                    "description": "If set to `true`, the initial password is set up for renewal on first use. Default to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The initial password.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "value"
            ]
        },
        "keycloak:index/getRealmInternationalization:getRealmInternationalization": {
            "properties": {
                "defaultLocale": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "supportedLocales": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "defaultLocale",
                "supportedLocales"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmKeysKey:getRealmKeysKey": {
            "properties": {
                "algorithm": {
                    "type": "string",
                    "description": "Key algorithm (string)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "certificate": {
                    "type": "string",
                    "description": "Key certificate (string)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "kid": {
                    "type": "string",
                    "description": "Key ID (string)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerId": {
                    "type": "string",
                    "description": "Key provider ID (string)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerPriority": {
                    "type": "integer",
                    "description": "Key provider priority (int64)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "publicKey": {
                    "type": "string",
                    "description": "Key public key (string)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "description": "When specified, keys will be filtered by status. The statuses can be any of `ACTIVE`, `DISABLED` and `PASSIVE`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "Key type (string)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "algorithm",
                "certificate",
                "kid",
                "providerId",
                "providerPriority",
                "publicKey",
                "status",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmSecurityDefense:getRealmSecurityDefense": {
            "properties": {
                "bruteForceDetections": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/getRealmSecurityDefenseBruteForceDetection:getRealmSecurityDefenseBruteForceDetection"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/getRealmSecurityDefenseHeader:getRealmSecurityDefenseHeader"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "bruteForceDetections",
                "headers"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmSecurityDefenseBruteForceDetection:getRealmSecurityDefenseBruteForceDetection": {
            "properties": {
                "failureResetTimeSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxFailureWaitSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLoginFailures": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minimumQuickLoginWaitSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "permanentLockout": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "quickLoginCheckMilliSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "waitIncrementSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "failureResetTimeSeconds",
                "maxFailureWaitSeconds",
                "maxLoginFailures",
                "minimumQuickLoginWaitSeconds",
                "permanentLockout",
                "quickLoginCheckMilliSeconds",
                "waitIncrementSeconds"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmSecurityDefenseHeader:getRealmSecurityDefenseHeader": {
            "properties": {
                "contentSecurityPolicy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "contentSecurityPolicyReportOnly": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "strictTransportSecurity": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xContentTypeOptions": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xFrameOptions": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xRobotsTag": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "xXssProtection": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "contentSecurityPolicy",
                "contentSecurityPolicyReportOnly",
                "strictTransportSecurity",
                "xContentTypeOptions",
                "xFrameOptions",
                "xRobotsTag",
                "xXssProtection"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmSmtpServer:getRealmSmtpServer": {
            "properties": {
                "auths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/getRealmSmtpServerAuth:getRealmSmtpServerAuth"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "envelopeFrom": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "from": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fromDisplayName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "host": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "port": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replyTo": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replyToDisplayName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssl": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "starttls": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "auths",
                "envelopeFrom",
                "from",
                "fromDisplayName",
                "host",
                "port",
                "replyTo",
                "replyToDisplayName",
                "ssl",
                "starttls"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmSmtpServerAuth:getRealmSmtpServerAuth": {
            "properties": {
                "password": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "password",
                "username"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmWebAuthnPasswordlessPolicy:getRealmWebAuthnPasswordlessPolicy": {
            "properties": {
                "acceptableAaguids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attestationConveyancePreference": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authenticatorAttachment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "avoidSameAuthenticatorRegister": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createTimeout": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "relyingPartyEntityName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "relyingPartyId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requireResidentKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "signatureAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userVerificationRequirement": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "acceptableAaguids",
                "attestationConveyancePreference",
                "authenticatorAttachment",
                "avoidSameAuthenticatorRegister",
                "createTimeout",
                "relyingPartyEntityName",
                "relyingPartyId",
                "requireResidentKey",
                "signatureAlgorithms",
                "userVerificationRequirement"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:index/getRealmWebAuthnPolicy:getRealmWebAuthnPolicy": {
            "properties": {
                "acceptableAaguids": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "attestationConveyancePreference": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authenticatorAttachment": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "avoidSameAuthenticatorRegister": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createTimeout": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "relyingPartyEntityName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "relyingPartyId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requireResidentKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "signatureAlgorithms": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userVerificationRequirement": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "acceptableAaguids",
                "attestationConveyancePreference",
                "authenticatorAttachment",
                "avoidSameAuthenticatorRegister",
                "createTimeout",
                "relyingPartyEntityName",
                "relyingPartyId",
                "requireResidentKey",
                "signatureAlgorithms",
                "userVerificationRequirement"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:ldap/UserFederationCache:UserFederationCache": {
            "properties": {
                "evictionDay": {
                    "type": "integer",
                    "description": "Minute of day the entry will become invalid on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "evictionHour": {
                    "type": "integer",
                    "description": "Hour of day the entry will become invalid on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "evictionMinute": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxLifespan": {
                    "type": "string",
                    "description": "Max lifespan of cache entry (duration string).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policy": {
                    "type": "string",
                    "description": "Can be one of `DEFAULT`, `EVICT_DAILY`, `EVICT_WEEKLY`, `MAX_LIFESPAN`, or `NO_CACHE`. Defaults to `DEFAULT`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:ldap/UserFederationKerberos:UserFederationKerberos": {
            "properties": {
                "kerberosRealm": {
                    "type": "string",
                    "description": "The name of the kerberos realm, e.g. FOO.LOCAL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyTab": {
                    "type": "string",
                    "description": "Path to the kerberos keytab file on the server with credentials of the service principal.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serverPrincipal": {
                    "type": "string",
                    "description": "The kerberos server principal, e.g. 'HTTP/host.foo.com@FOO.LOCAL'.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "useKerberosForPasswordAuthentication": {
                    "type": "boolean",
                    "description": "Use kerberos login module instead of ldap service api. Defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "kerberosRealm",
                "keyTab",
                "serverPrincipal"
            ]
        },
        "keycloak:openid/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides": {
            "properties": {
                "browserId": {
                    "type": "string",
                    "description": "Browser flow id, (flow needs to exist)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "directGrantId": {
                    "type": "string",
                    "description": "Direct grant flow id (flow needs to exist)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "keycloak:openid/ClientAuthorization:ClientAuthorization": {
            "properties": {
                "allowRemoteResourceManagement": {
                    "type": "boolean",
                    "description": "When `true`, resources can be managed remotely by the resource server. Defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keepDefaults": {
                    "type": "boolean",
                    "description": "When `true`, defaults set by Keycloak will be respected. Defaults to `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policyEnforcementMode": {
                    "type": "string",
                    "description": "Dictates how policies are enforced when evaluating authorization requests. Can be one of `ENFORCING`, `PERMISSIVE`, or `DISABLED`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "policyEnforcementMode"
            ]
        },
        "keycloak:openid/ClientGroupPolicyGroup:ClientGroupPolicyGroup": {
            "properties": {
                "extendChildren": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "extendChildren",
                "id",
                "path"
            ]
        },
        "keycloak:openid/ClientRolePolicyRole:ClientRolePolicyRole": {
            "properties": {
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "required": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "id",
                "required"
            ]
        },
        "keycloak:openid/getClientAuthenticationFlowBindingOverride:getClientAuthenticationFlowBindingOverride": {
            "properties": {
                "browserId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "directGrantId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "browserId",
                "directGrantId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:openid/getClientAuthorization:getClientAuthorization": {
            "properties": {
                "allowRemoteResourceManagement": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keepDefaults": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policyEnforcementMode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "allowRemoteResourceManagement",
                "keepDefaults",
                "policyEnforcementMode"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "keycloak:openid/getClientServiceAccountUserFederatedIdentity:getClientServiceAccountUserFederatedIdentity": {
            "properties": {
                "identityProvider": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "identityProvider",
                "userId",
                "userName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the keycloak package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "inputProperties": {
            "basePath": {
                "type": "string"
            },
            "clientId": {
                "type": "string",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_CLIENT_ID"
                    ]
                }
            },
            "clientSecret": {
                "type": "string",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_CLIENT_SECRET"
                    ]
                }
            },
            "clientTimeout": {
                "type": "integer",
                "description": "Timeout (in seconds) of the Keycloak client\n",
                "default": 5,
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_CLIENT_TIMEOUT"
                    ]
                }
            },
            "initialLogin": {
                "type": "boolean",
                "description": "Whether or not to login to Keycloak instance on provider initialization\n"
            },
            "password": {
                "type": "string",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_PASSWORD"
                    ]
                }
            },
            "realm": {
                "type": "string",
                "default": "master",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_REALM"
                    ]
                }
            },
            "rootCaCertificate": {
                "type": "string",
                "description": "Allows x509 calls using an unknown CA certificate (for development purposes)\n"
            },
            "tlsInsecureSkipVerify": {
                "type": "boolean",
                "description": "Allows ignoring insecure certificates when set to true. Defaults to false. Disabling security check is dangerous and\nshould be avoided.\n"
            },
            "url": {
                "type": "string",
                "description": "The base URL of the Keycloak instance, before `/auth`\n",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_URL"
                    ]
                }
            },
            "username": {
                "type": "string",
                "defaultInfo": {
                    "environment": [
                        "KEYCLOAK_USER"
                    ]
                }
            }
        }
    },
    "resources": {
        "keycloak:authentication/execution:Execution": {
            "description": "Allows for creating and managing an authentication execution within Keycloak.\n\nAn authentication execution is an action that the user or service may or may not take when authenticating through an authentication\nflow.\n\n\u003e Due to limitations in the Keycloak API, the ordering of authentication executions within a flow must be specified using `depends_on`. Authentication executions that are created first will appear first within the flow.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst flow = new keycloak.authentication.Flow(\"flow\", {\n    realmId: realm.id,\n    alias: \"my-flow-alias\",\n});\n// first execution\nconst executionOne = new keycloak.authentication.Execution(\"executionOne\", {\n    realmId: realm.id,\n    parentFlowAlias: flow.alias,\n    authenticator: \"auth-cookie\",\n    requirement: \"ALTERNATIVE\",\n});\n// second execution\nconst executionTwo = new keycloak.authentication.Execution(\"executionTwo\", {\n    realmId: realm.id,\n    parentFlowAlias: flow.alias,\n    authenticator: \"identity-provider-redirector\",\n    requirement: \"ALTERNATIVE\",\n}, {\n    dependsOn: [executionOne],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nflow = keycloak.authentication.Flow(\"flow\",\n    realm_id=realm.id,\n    alias=\"my-flow-alias\")\n# first execution\nexecution_one = keycloak.authentication.Execution(\"executionOne\",\n    realm_id=realm.id,\n    parent_flow_alias=flow.alias,\n    authenticator=\"auth-cookie\",\n    requirement=\"ALTERNATIVE\")\n# second execution\nexecution_two = keycloak.authentication.Execution(\"executionTwo\",\n    realm_id=realm.id,\n    parent_flow_alias=flow.alias,\n    authenticator=\"identity-provider-redirector\",\n    requirement=\"ALTERNATIVE\",\n    opts=ResourceOptions(depends_on=[execution_one]))\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var flow = new Keycloak.Authentication.Flow(\"flow\", new Keycloak.Authentication.FlowArgs\n        {\n            RealmId = realm.Id,\n            Alias = \"my-flow-alias\",\n        });\n        // first execution\n        var executionOne = new Keycloak.Authentication.Execution(\"executionOne\", new Keycloak.Authentication.ExecutionArgs\n        {\n            RealmId = realm.Id,\n            ParentFlowAlias = flow.Alias,\n            Authenticator = \"auth-cookie\",\n            Requirement = \"ALTERNATIVE\",\n        });\n        // second execution\n        var executionTwo = new Keycloak.Authentication.Execution(\"executionTwo\", new Keycloak.Authentication.ExecutionArgs\n        {\n            RealmId = realm.Id,\n            ParentFlowAlias = flow.Alias,\n            Authenticator = \"identity-provider-redirector\",\n            Requirement = \"ALTERNATIVE\",\n        }, new CustomResourceOptions\n        {\n            DependsOn = \n            {\n                executionOne,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/authentication\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tflow, err := authentication.NewFlow(ctx, \"flow\", \u0026authentication.FlowArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tAlias:   pulumi.String(\"my-flow-alias\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texecutionOne, err := authentication.NewExecution(ctx, \"executionOne\", \u0026authentication.ExecutionArgs{\n\t\t\tRealmId:         realm.ID(),\n\t\t\tParentFlowAlias: flow.Alias,\n\t\t\tAuthenticator:   pulumi.String(\"auth-cookie\"),\n\t\t\tRequirement:     pulumi.String(\"ALTERNATIVE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = authentication.NewExecution(ctx, \"executionTwo\", \u0026authentication.ExecutionArgs{\n\t\t\tRealmId:         realm.ID(),\n\t\t\tParentFlowAlias: flow.Alias,\n\t\t\tAuthenticator:   pulumi.String(\"identity-provider-redirector\"),\n\t\t\tRequirement:     pulumi.String(\"ALTERNATIVE\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\texecutionOne,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "authenticator": {
                    "type": "string",
                    "description": "The name of the authenticator. This can be found by experimenting with the GUI and looking at HTTP requests within the network tab of your browser's development tools.\n"
                },
                "parentFlowAlias": {
                    "type": "string",
                    "description": "The alias of the flow this execution is attached to.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the authentication execution exists in.\n"
                },
                "requirement": {
                    "type": "string",
                    "description": "The requirement setting, which can be one of `REQUIRED`, `ALTERNATIVE`, `OPTIONAL`, `CONDITIONAL`, or `DISABLED`. Defaults to `DISABLED`.\n"
                }
            },
            "required": [
                "authenticator",
                "parentFlowAlias",
                "realmId"
            ],
            "inputProperties": {
                "authenticator": {
                    "type": "string",
                    "description": "The name of the authenticator. This can be found by experimenting with the GUI and looking at HTTP requests within the network tab of your browser's development tools.\n"
                },
                "parentFlowAlias": {
                    "type": "string",
                    "description": "The alias of the flow this execution is attached to.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the authentication execution exists in.\n"
                },
                "requirement": {
                    "type": "string",
                    "description": "The requirement setting, which can be one of `REQUIRED`, `ALTERNATIVE`, `OPTIONAL`, `CONDITIONAL`, or `DISABLED`. Defaults to `DISABLED`.\n"
                }
            },
            "requiredInputs": [
                "authenticator",
                "parentFlowAlias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Execution resources.\n",
                "properties": {
                    "authenticator": {
                        "type": "string",
                        "description": "The name of the authenticator. This can be found by experimenting with the GUI and looking at HTTP requests within the network tab of your browser's development tools.\n"
                    },
                    "parentFlowAlias": {
                        "type": "string",
                        "description": "The alias of the flow this execution is attached to.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm the authentication execution exists in.\n"
                    },
                    "requirement": {
                        "type": "string",
                        "description": "The requirement setting, which can be one of `REQUIRED`, `ALTERNATIVE`, `OPTIONAL`, `CONDITIONAL`, or `DISABLED`. Defaults to `DISABLED`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:authentication/executionConfig:ExecutionConfig": {
            "description": "Allows for managing an authentication execution's configuration. If a particular authentication execution supports additional\nconfiguration (such as with the `identity-provider-redirector` execution), this can be managed with this resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst flow = new keycloak.authentication.Flow(\"flow\", {\n    realmId: realm.id,\n    alias: \"my-flow-alias\",\n});\nconst execution = new keycloak.authentication.Execution(\"execution\", {\n    realmId: realm.id,\n    parentFlowAlias: flow.alias,\n    authenticator: \"identity-provider-redirector\",\n});\nconst config = new keycloak.authentication.ExecutionConfig(\"config\", {\n    realmId: realm.id,\n    executionId: execution.id,\n    alias: \"my-config-alias\",\n    config: {\n        defaultProvider: \"my-config-default-idp\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nflow = keycloak.authentication.Flow(\"flow\",\n    realm_id=realm.id,\n    alias=\"my-flow-alias\")\nexecution = keycloak.authentication.Execution(\"execution\",\n    realm_id=realm.id,\n    parent_flow_alias=flow.alias,\n    authenticator=\"identity-provider-redirector\")\nconfig = keycloak.authentication.ExecutionConfig(\"config\",\n    realm_id=realm.id,\n    execution_id=execution.id,\n    alias=\"my-config-alias\",\n    config={\n        \"defaultProvider\": \"my-config-default-idp\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var flow = new Keycloak.Authentication.Flow(\"flow\", new Keycloak.Authentication.FlowArgs\n        {\n            RealmId = realm.Id,\n            Alias = \"my-flow-alias\",\n        });\n        var execution = new Keycloak.Authentication.Execution(\"execution\", new Keycloak.Authentication.ExecutionArgs\n        {\n            RealmId = realm.Id,\n            ParentFlowAlias = flow.Alias,\n            Authenticator = \"identity-provider-redirector\",\n        });\n        var config = new Keycloak.Authentication.ExecutionConfig(\"config\", new Keycloak.Authentication.ExecutionConfigArgs\n        {\n            RealmId = realm.Id,\n            ExecutionId = execution.Id,\n            Alias = \"my-config-alias\",\n            Config = \n            {\n                { \"defaultProvider\", \"my-config-default-idp\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/authentication\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tflow, err := authentication.NewFlow(ctx, \"flow\", \u0026authentication.FlowArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tAlias:   pulumi.String(\"my-flow-alias\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texecution, err := authentication.NewExecution(ctx, \"execution\", \u0026authentication.ExecutionArgs{\n\t\t\tRealmId:         realm.ID(),\n\t\t\tParentFlowAlias: flow.Alias,\n\t\t\tAuthenticator:   pulumi.String(\"identity-provider-redirector\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = authentication.NewExecutionConfig(ctx, \"config\", \u0026authentication.ExecutionConfigArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tExecutionId: execution.ID(),\n\t\t\tAlias:       pulumi.String(\"my-config-alias\"),\n\t\t\tConfig: pulumi.StringMap{\n\t\t\t\t\"defaultProvider\": pulumi.String(\"my-config-default-idp\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "alias": {
                    "type": "string",
                    "description": "The name of the configuration.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The configuration. Keys are specific to each configurable authentication execution and not checked when applying.\n"
                },
                "executionId": {
                    "type": "string",
                    "description": "The authentication execution this configuration is attached to.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the authentication execution exists in.\n"
                }
            },
            "required": [
                "alias",
                "config",
                "executionId",
                "realmId"
            ],
            "inputProperties": {
                "alias": {
                    "type": "string",
                    "description": "The name of the configuration.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The configuration. Keys are specific to each configurable authentication execution and not checked when applying.\n"
                },
                "executionId": {
                    "type": "string",
                    "description": "The authentication execution this configuration is attached to.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the authentication execution exists in.\n"
                }
            },
            "requiredInputs": [
                "alias",
                "config",
                "executionId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ExecutionConfig resources.\n",
                "properties": {
                    "alias": {
                        "type": "string",
                        "description": "The name of the configuration.\n"
                    },
                    "config": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The configuration. Keys are specific to each configurable authentication execution and not checked when applying.\n"
                    },
                    "executionId": {
                        "type": "string",
                        "description": "The authentication execution this configuration is attached to.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm the authentication execution exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:authentication/flow:Flow": {
            "description": "Allows for creating and managing an authentication flow within Keycloak.\n\n[Authentication flows](https://www.keycloak.org/docs/11.0/server_admin/index.html#_authentication-flows) describe a sequence\nof actions that a user or service must perform in order to be authenticated to Keycloak. The authentication flow itself\nis a container for these actions, which are otherwise known as executions.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst flow = new keycloak.authentication.Flow(\"flow\", {\n    realmId: realm.id,\n    alias: \"my-flow-alias\",\n});\nconst execution = new keycloak.authentication.Execution(\"execution\", {\n    realmId: realm.id,\n    parentFlowAlias: flow.alias,\n    authenticator: \"identity-provider-redirector\",\n    requirement: \"REQUIRED\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nflow = keycloak.authentication.Flow(\"flow\",\n    realm_id=realm.id,\n    alias=\"my-flow-alias\")\nexecution = keycloak.authentication.Execution(\"execution\",\n    realm_id=realm.id,\n    parent_flow_alias=flow.alias,\n    authenticator=\"identity-provider-redirector\",\n    requirement=\"REQUIRED\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var flow = new Keycloak.Authentication.Flow(\"flow\", new Keycloak.Authentication.FlowArgs\n        {\n            RealmId = realm.Id,\n            Alias = \"my-flow-alias\",\n        });\n        var execution = new Keycloak.Authentication.Execution(\"execution\", new Keycloak.Authentication.ExecutionArgs\n        {\n            RealmId = realm.Id,\n            ParentFlowAlias = flow.Alias,\n            Authenticator = \"identity-provider-redirector\",\n            Requirement = \"REQUIRED\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/authentication\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tflow, err := authentication.NewFlow(ctx, \"flow\", \u0026authentication.FlowArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tAlias:   pulumi.String(\"my-flow-alias\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = authentication.NewExecution(ctx, \"execution\", \u0026authentication.ExecutionArgs{\n\t\t\tRealmId:         realm.ID(),\n\t\t\tParentFlowAlias: flow.Alias,\n\t\t\tAuthenticator:   pulumi.String(\"identity-provider-redirector\"),\n\t\t\tRequirement:     pulumi.String(\"REQUIRED\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "alias": {
                    "type": "string",
                    "description": "The alias for this authentication flow.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the authentication flow.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The type of authentication flow to create. Valid choices include `basic-flow` and `client-flow`. Defaults to `basic-flow`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that the authentication flow exists in.\n"
                }
            },
            "required": [
                "alias",
                "realmId"
            ],
            "inputProperties": {
                "alias": {
                    "type": "string",
                    "description": "The alias for this authentication flow.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the authentication flow.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The type of authentication flow to create. Valid choices include `basic-flow` and `client-flow`. Defaults to `basic-flow`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that the authentication flow exists in.\n"
                }
            },
            "requiredInputs": [
                "alias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Flow resources.\n",
                "properties": {
                    "alias": {
                        "type": "string",
                        "description": "The alias for this authentication flow.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description for the authentication flow.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The type of authentication flow to create. Valid choices include `basic-flow` and `client-flow`. Defaults to `basic-flow`.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that the authentication flow exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:authentication/subflow:Subflow": {
            "properties": {
                "alias": {
                    "type": "string"
                },
                "authenticator": {
                    "type": "string",
                    "description": "Might be needed to be set with certain custom subflow with specific authenticator, in general this will remain empty\n"
                },
                "description": {
                    "type": "string"
                },
                "parentFlowAlias": {
                    "type": "string"
                },
                "providerId": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "requirement": {
                    "type": "string"
                }
            },
            "required": [
                "alias",
                "parentFlowAlias",
                "realmId"
            ],
            "inputProperties": {
                "alias": {
                    "type": "string"
                },
                "authenticator": {
                    "type": "string",
                    "description": "Might be needed to be set with certain custom subflow with specific authenticator, in general this will remain empty\n"
                },
                "description": {
                    "type": "string"
                },
                "parentFlowAlias": {
                    "type": "string"
                },
                "providerId": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "requirement": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "alias",
                "parentFlowAlias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Subflow resources.\n",
                "properties": {
                    "alias": {
                        "type": "string"
                    },
                    "authenticator": {
                        "type": "string",
                        "description": "Might be needed to be set with certain custom subflow with specific authenticator, in general this will remain empty\n"
                    },
                    "description": {
                        "type": "string"
                    },
                    "parentFlowAlias": {
                        "type": "string"
                    },
                    "providerId": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "requirement": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/attributeImporterIdentityProviderMapper:AttributeImporterIdentityProviderMapper": {
            "description": "Allows for creating and managing an attribute importer identity provider mapper within Keycloak.\n\nThe attribute importer mapper can be used to map attributes from externally defined users to attributes or properties of the imported Keycloak user:\n- For the OIDC identity provider, this will map a claim on the ID or access token to an attribute for the imported Keycloak user.\n- For the SAML identity provider, this will map a SAML attribute found within the assertion to an attribute for the imported Keycloak user.\n- For social identity providers, this will map a JSON field from the user profile to an attribute for the imported Keycloak user.\n\n\u003e If you are using Keycloak 10 or higher, you will need to specify the `extra_config` argument in order to define a `syncMode` for the mapper.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst oidcIdentityProvider = new keycloak.oidc.IdentityProvider(\"oidcIdentityProvider\", {\n    realm: realm.id,\n    alias: \"oidc\",\n    authorizationUrl: \"https://example.com/auth\",\n    tokenUrl: \"https://example.com/token\",\n    clientId: \"example_id\",\n    clientSecret: \"example_token\",\n    defaultScopes: \"openid random profile\",\n});\nconst oidcAttributeImporterIdentityProviderMapper = new keycloak.AttributeImporterIdentityProviderMapper(\"oidcAttributeImporterIdentityProviderMapper\", {\n    realm: realm.id,\n    claimName: \"my-email-claim\",\n    identityProviderAlias: oidcIdentityProvider.alias,\n    userAttribute: \"email\",\n    extraConfig: {\n        syncMode: \"INHERIT\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\noidc_identity_provider = keycloak.oidc.IdentityProvider(\"oidcIdentityProvider\",\n    realm=realm.id,\n    alias=\"oidc\",\n    authorization_url=\"https://example.com/auth\",\n    token_url=\"https://example.com/token\",\n    client_id=\"example_id\",\n    client_secret=\"example_token\",\n    default_scopes=\"openid random profile\")\noidc_attribute_importer_identity_provider_mapper = keycloak.AttributeImporterIdentityProviderMapper(\"oidcAttributeImporterIdentityProviderMapper\",\n    realm=realm.id,\n    claim_name=\"my-email-claim\",\n    identity_provider_alias=oidc_identity_provider.alias,\n    user_attribute=\"email\",\n    extra_config={\n        \"syncMode\": \"INHERIT\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var oidcIdentityProvider = new Keycloak.Oidc.IdentityProvider(\"oidcIdentityProvider\", new Keycloak.Oidc.IdentityProviderArgs\n        {\n            Realm = realm.Id,\n            Alias = \"oidc\",\n            AuthorizationUrl = \"https://example.com/auth\",\n            TokenUrl = \"https://example.com/token\",\n            ClientId = \"example_id\",\n            ClientSecret = \"example_token\",\n            DefaultScopes = \"openid random profile\",\n        });\n        var oidcAttributeImporterIdentityProviderMapper = new Keycloak.AttributeImporterIdentityProviderMapper(\"oidcAttributeImporterIdentityProviderMapper\", new Keycloak.AttributeImporterIdentityProviderMapperArgs\n        {\n            Realm = realm.Id,\n            ClaimName = \"my-email-claim\",\n            IdentityProviderAlias = oidcIdentityProvider.Alias,\n            UserAttribute = \"email\",\n            ExtraConfig = \n            {\n                { \"syncMode\", \"INHERIT\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/oidc\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\toidcIdentityProvider, err := oidc.NewIdentityProvider(ctx, \"oidcIdentityProvider\", \u0026oidc.IdentityProviderArgs{\n\t\t\tRealm:            realm.ID(),\n\t\t\tAlias:            pulumi.String(\"oidc\"),\n\t\t\tAuthorizationUrl: pulumi.String(\"https://example.com/auth\"),\n\t\t\tTokenUrl:         pulumi.String(\"https://example.com/token\"),\n\t\t\tClientId:         pulumi.String(\"example_id\"),\n\t\t\tClientSecret:     pulumi.String(\"example_token\"),\n\t\t\tDefaultScopes:    pulumi.String(\"openid random profile\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewAttributeImporterIdentityProviderMapper(ctx, \"oidcAttributeImporterIdentityProviderMapper\", \u0026keycloak.AttributeImporterIdentityProviderMapperArgs{\n\t\t\tRealm:                 realm.ID(),\n\t\t\tClaimName:             pulumi.String(\"my-email-claim\"),\n\t\t\tIdentityProviderAlias: oidcIdentityProvider.Alias,\n\t\t\tUserAttribute:         pulumi.String(\"email\"),\n\t\t\tExtraConfig: pulumi.StringMap{\n\t\t\t\t\"syncMode\": pulumi.String(\"INHERIT\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "attributeFriendlyName": {
                    "type": "string",
                    "description": "For SAML based providers, this is the friendly name of the attribute to search for in the assertion. Conflicts with `attribute_name`.\n"
                },
                "attributeName": {
                    "type": "string",
                    "description": "For SAML based providers, this is the name of the attribute to search for in the assertion. Conflicts with `attribute_friendly_name`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "For OIDC based providers, this is the name of the claim to use.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "The alias of the associated identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the mapper.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm.\n"
                },
                "userAttribute": {
                    "type": "string",
                    "description": "The user attribute or property name to store the mapped result.\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm",
                "userAttribute"
            ],
            "inputProperties": {
                "attributeFriendlyName": {
                    "type": "string",
                    "description": "For SAML based providers, this is the friendly name of the attribute to search for in the assertion. Conflicts with `attribute_name`.\n"
                },
                "attributeName": {
                    "type": "string",
                    "description": "For SAML based providers, this is the name of the attribute to search for in the assertion. Conflicts with `attribute_friendly_name`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "For OIDC based providers, this is the name of the claim to use.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "The alias of the associated identity provider.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the mapper.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm.\n"
                },
                "userAttribute": {
                    "type": "string",
                    "description": "The user attribute or property name to store the mapped result.\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm",
                "userAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AttributeImporterIdentityProviderMapper resources.\n",
                "properties": {
                    "attributeFriendlyName": {
                        "type": "string",
                        "description": "For SAML based providers, this is the friendly name of the attribute to search for in the assertion. Conflicts with `attribute_name`.\n"
                    },
                    "attributeName": {
                        "type": "string",
                        "description": "For SAML based providers, this is the name of the attribute to search for in the assertion. Conflicts with `attribute_friendly_name`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "For OIDC based providers, this is the name of the claim to use.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Key/value attributes to add to the identity provider mapper model that is persisted to Keycloak. This can be used to extend the base model with new Keycloak features.\n"
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "The alias of the associated identity provider.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the mapper.\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "The name of the realm.\n"
                    },
                    "userAttribute": {
                        "type": "string",
                        "description": "The user attribute or property name to store the mapped result.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/attributeToRoleIdentityMapper:AttributeToRoleIdentityMapper": {
            "properties": {
                "attributeFriendlyName": {
                    "type": "string",
                    "description": "Attribute Friendly Name\n"
                },
                "attributeName": {
                    "type": "string",
                    "description": "Attribute Name\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "Attribute Value\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "OIDC Claim Name\n"
                },
                "claimValue": {
                    "type": "string",
                    "description": "OIDC Claim Value\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role Name\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm",
                "role"
            ],
            "inputProperties": {
                "attributeFriendlyName": {
                    "type": "string",
                    "description": "Attribute Friendly Name\n"
                },
                "attributeName": {
                    "type": "string",
                    "description": "Attribute Name\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "Attribute Value\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "OIDC Claim Name\n"
                },
                "claimValue": {
                    "type": "string",
                    "description": "OIDC Claim Value\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role Name\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm",
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AttributeToRoleIdentityMapper resources.\n",
                "properties": {
                    "attributeFriendlyName": {
                        "type": "string",
                        "description": "Attribute Friendly Name\n"
                    },
                    "attributeName": {
                        "type": "string",
                        "description": "Attribute Name\n"
                    },
                    "attributeValue": {
                        "type": "string",
                        "description": "Attribute Value\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "OIDC Claim Name\n"
                    },
                    "claimValue": {
                        "type": "string",
                        "description": "OIDC Claim Value\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "IDP Alias\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "IDP Mapper Name\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "Realm Name\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Role Name\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/customUserFederation:CustomUserFederation": {
            "properties": {
                "cachePolicy": {
                    "type": "string",
                    "description": "Can be one of `DEFAULT`, `EVICT_DAILY`, `EVICT_WEEKLY`, `MAX_LIFESPAN`, or `NO_CACHE`. Defaults to `DEFAULT`.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "The provider configuration handed over to your custom user federation provider.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, this provider will not be used when performing queries for users. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the provider when displayed in the console.\n"
                },
                "parentId": {
                    "type": "string",
                    "description": "Must be set to the realms' `internal_id`  when it differs from the realm. This can happen when existing resources are imported into the state.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of this provider when looking up users. Lower values are first. Defaults to `0`.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The unique ID of the custom provider, specified in the `getId` implementation for the `UserStorageProviderFactory` interface.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this provider will provide user federation for.\n"
                }
            },
            "required": [
                "name",
                "providerId",
                "realmId"
            ],
            "inputProperties": {
                "cachePolicy": {
                    "type": "string",
                    "description": "Can be one of `DEFAULT`, `EVICT_DAILY`, `EVICT_WEEKLY`, `MAX_LIFESPAN`, or `NO_CACHE`. Defaults to `DEFAULT`.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "The provider configuration handed over to your custom user federation provider.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, this provider will not be used when performing queries for users. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the provider when displayed in the console.\n"
                },
                "parentId": {
                    "type": "string",
                    "description": "Must be set to the realms' `internal_id`  when it differs from the realm. This can happen when existing resources are imported into the state.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of this provider when looking up users. Lower values are first. Defaults to `0`.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The unique ID of the custom provider, specified in the `getId` implementation for the `UserStorageProviderFactory` interface.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this provider will provide user federation for.\n"
                }
            },
            "requiredInputs": [
                "providerId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomUserFederation resources.\n",
                "properties": {
                    "cachePolicy": {
                        "type": "string",
                        "description": "Can be one of `DEFAULT`, `EVICT_DAILY`, `EVICT_WEEKLY`, `MAX_LIFESPAN`, or `NO_CACHE`. Defaults to `DEFAULT`.\n"
                    },
                    "config": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "The provider configuration handed over to your custom user federation provider.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, this provider will not be used when performing queries for users. Defaults to `true`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the provider when displayed in the console.\n"
                    },
                    "parentId": {
                        "type": "string",
                        "description": "Must be set to the realms' `internal_id`  when it differs from the realm. This can happen when existing resources are imported into the state.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority of this provider when looking up users. Lower values are first. Defaults to `0`.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The unique ID of the custom provider, specified in the `getId` implementation for the `UserStorageProviderFactory` interface.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this provider will provide user federation for.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/defaultGroups:DefaultGroups": {
            "description": "Allows for managing a realm's default groups.\n\n\u003e You should not use `keycloak.DefaultGroups` with a group whose members are managed by `keycloak.GroupMemberships`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst group = new keycloak.Group(\"group\", {realmId: realm.id});\nconst _default = new keycloak.DefaultGroups(\"default\", {\n    realmId: realm.id,\n    groupIds: [group.id],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\ngroup = keycloak.Group(\"group\", realm_id=realm.id)\ndefault = keycloak.DefaultGroups(\"default\",\n    realm_id=realm.id,\n    group_ids=[group.id])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var @group = new Keycloak.Group(\"group\", new Keycloak.GroupArgs\n        {\n            RealmId = realm.Id,\n        });\n        var @default = new Keycloak.DefaultGroups(\"default\", new Keycloak.DefaultGroupsArgs\n        {\n            RealmId = realm.Id,\n            GroupIds = \n            {\n                @group.Id,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgroup, err := keycloak.NewGroup(ctx, \"group\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewDefaultGroups(ctx, \"_default\", \u0026keycloak.DefaultGroupsArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tGroupIds: pulumi.StringArray{\n\t\t\t\tgroup.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of group ids that should be default groups on the realm referenced by `realm_id`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n"
                }
            },
            "required": [
                "groupIds",
                "realmId"
            ],
            "inputProperties": {
                "groupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A set of group ids that should be default groups on the realm referenced by `realm_id`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n"
                }
            },
            "requiredInputs": [
                "groupIds",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DefaultGroups resources.\n",
                "properties": {
                    "groupIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A set of group ids that should be default groups on the realm referenced by `realm_id`.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this group exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/genericClientProtocolMapper:GenericClientProtocolMapper": {
            "description": "Allows for creating and managing protocol mappers for both types of clients (openid-connect and saml) within Keycloak.\n\nThere are two uses cases for using this resource:\n* If you implemented a custom protocol mapper, this resource can be used to configure it\n* If the provider doesn't support a particular protocol mapper, this resource can be used instead.\n\nDue to the generic nature of this mapper, it is less user-friendly and more prone to configuration errors.\nTherefore, if possible, a specific mapper should be used.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClient = new keycloak.saml.Client(\"samlClient\", {\n    realmId: realm.id,\n    clientId: \"test-client\",\n});\nconst samlHardcodeAttributeMapper = new keycloak.GenericClientProtocolMapper(\"samlHardcodeAttributeMapper\", {\n    realmId: realm.id,\n    clientId: samlClient.id,\n    protocol: \"saml\",\n    protocolMapper: \"saml-hardcode-attribute-mapper\",\n    config: {\n        \"attribute.name\": \"name\",\n        \"attribute.nameformat\": \"Basic\",\n        \"attribute.value\": \"value\",\n        \"friendly.name\": \"display name\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client = keycloak.saml.Client(\"samlClient\",\n    realm_id=realm.id,\n    client_id=\"test-client\")\nsaml_hardcode_attribute_mapper = keycloak.GenericClientProtocolMapper(\"samlHardcodeAttributeMapper\",\n    realm_id=realm.id,\n    client_id=saml_client.id,\n    protocol=\"saml\",\n    protocol_mapper=\"saml-hardcode-attribute-mapper\",\n    config={\n        \"attribute.name\": \"name\",\n        \"attribute.nameformat\": \"Basic\",\n        \"attribute.value\": \"value\",\n        \"friendly.name\": \"display name\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var samlClient = new Keycloak.Saml.Client(\"samlClient\", new Keycloak.Saml.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"test-client\",\n        });\n        var samlHardcodeAttributeMapper = new Keycloak.GenericClientProtocolMapper(\"samlHardcodeAttributeMapper\", new Keycloak.GenericClientProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = samlClient.Id,\n            Protocol = \"saml\",\n            ProtocolMapper = \"saml-hardcode-attribute-mapper\",\n            Config = \n            {\n                { \"attribute.name\", \"name\" },\n                { \"attribute.nameformat\", \"Basic\" },\n                { \"attribute.value\", \"value\" },\n                { \"friendly.name\", \"display name\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsamlClient, err := saml.NewClient(ctx, \"samlClient\", \u0026saml.ClientArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: pulumi.String(\"test-client\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientProtocolMapper(ctx, \"samlHardcodeAttributeMapper\", \u0026keycloak.GenericClientProtocolMapperArgs{\n\t\t\tRealmId:        realm.ID(),\n\t\t\tClientId:       samlClient.ID(),\n\t\t\tProtocol:       pulumi.String(\"saml\"),\n\t\t\tProtocolMapper: pulumi.String(\"saml-hardcode-attribute-mapper\"),\n\t\t\tConfig: pulumi.StringMap{\n\t\t\t\t\"attribute.name\":       pulumi.String(\"name\"),\n\t\t\t\t\"attribute.nameformat\": pulumi.String(\"Basic\"),\n\t\t\t\t\"attribute.value\":      pulumi.String(\"value\"),\n\t\t\t\t\"friendly.name\":        pulumi.String(\"display name\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper is attached to.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map with key / value pairs for configuring the protocol mapper. The supported keys depends on the protocol mapper.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The type of client (either `openid-connect` or `saml`). The type must match the type of the client.\n"
                },
                "protocolMapper": {
                    "type": "string",
                    "description": "The name of the protocol mapper. The protocol mapper must be compatible with the specified client.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "required": [
                "config",
                "name",
                "protocol",
                "protocolMapper",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper is attached to.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map with key / value pairs for configuring the protocol mapper. The supported keys depends on the protocol mapper.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The type of client (either `openid-connect` or `saml`). The type must match the type of the client.\n"
                },
                "protocolMapper": {
                    "type": "string",
                    "description": "The name of the protocol mapper. The protocol mapper must be compatible with the specified client.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "requiredInputs": [
                "config",
                "protocol",
                "protocolMapper",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GenericClientProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper is attached to.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The mapper's associated client scope. Cannot be used at the same time as client_id.\n"
                    },
                    "config": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map with key / value pairs for configuring the protocol mapper. The supported keys depends on the protocol mapper.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "The type of client (either `openid-connect` or `saml`). The type must match the type of the client.\n"
                    },
                    "protocolMapper": {
                        "type": "string",
                        "description": "The name of the protocol mapper. The protocol mapper must be compatible with the specified client.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/genericClientRoleMapper:GenericClientRoleMapper": {
            "description": "Allow for creating and managing a client's scope mappings within Keycloak.\n\nBy default, all the user role mappings of the user are added as claims within the token (OIDC) or assertion (SAML). When\n`full_scope_allowed` is set to `false` for a client, role scope mapping allows you to limit the roles that get declared\ninside an access token for a client.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Realm Role To Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst realmRole = new keycloak.Role(\"realmRole\", {\n    realmId: realm.id,\n    description: \"My Realm Role\",\n});\nconst clientRoleMapper = new keycloak.GenericClientRoleMapper(\"clientRoleMapper\", {\n    realmId: realm.id,\n    clientId: client.id,\n    roleId: realmRole.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nrealm_role = keycloak.Role(\"realmRole\",\n    realm_id=realm.id,\n    description=\"My Realm Role\")\nclient_role_mapper = keycloak.GenericClientRoleMapper(\"clientRoleMapper\",\n    realm_id=realm.id,\n    client_id=client.id,\n    role_id=realm_role.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var client = new Keycloak.OpenId.Client(\"client\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"BEARER-ONLY\",\n        });\n        var realmRole = new Keycloak.Role(\"realmRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            Description = \"My Realm Role\",\n        });\n        var clientRoleMapper = new Keycloak.GenericClientRoleMapper(\"clientRoleMapper\", new Keycloak.GenericClientRoleMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = client.Id,\n            RoleId = realmRole.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmRole, err := keycloak.NewRole(ctx, \"realmRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientRoleMapper(ctx, \"clientRoleMapper\", \u0026keycloak.GenericClientRoleMapperArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: client.ID(),\n\t\t\tRoleId:   realmRole.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Role To Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientA = new keycloak.openid.Client(\"clientA\", {\n    realmId: realm.id,\n    clientId: \"client-a\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n    fullScopeAllowed: false,\n});\nconst clientRoleA = new keycloak.Role(\"clientRoleA\", {\n    realmId: realm.id,\n    clientId: clientA.id,\n    description: \"My Client Role\",\n});\nconst clientB = new keycloak.openid.Client(\"clientB\", {\n    realmId: realm.id,\n    clientId: \"client-b\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst clientRoleB = new keycloak.Role(\"clientRoleB\", {\n    realmId: realm.id,\n    clientId: clientB.id,\n    description: \"My Client Role\",\n});\nconst clientBRoleMapper = new keycloak.GenericClientRoleMapper(\"clientBRoleMapper\", {\n    realmId: realm.id,\n    clientId: keycloak_client.client_b.id,\n    roleId: clientRoleA.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_a = keycloak.openid.Client(\"clientA\",\n    realm_id=realm.id,\n    client_id=\"client-a\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\",\n    full_scope_allowed=False)\nclient_role_a = keycloak.Role(\"clientRoleA\",\n    realm_id=realm.id,\n    client_id=client_a.id,\n    description=\"My Client Role\")\nclient_b = keycloak.openid.Client(\"clientB\",\n    realm_id=realm.id,\n    client_id=\"client-b\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nclient_role_b = keycloak.Role(\"clientRoleB\",\n    realm_id=realm.id,\n    client_id=client_b.id,\n    description=\"My Client Role\")\nclient_b_role_mapper = keycloak.GenericClientRoleMapper(\"clientBRoleMapper\",\n    realm_id=realm.id,\n    client_id=keycloak_client[\"client_b\"][\"id\"],\n    role_id=client_role_a.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientA = new Keycloak.OpenId.Client(\"clientA\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client-a\",\n            Enabled = true,\n            AccessType = \"BEARER-ONLY\",\n            FullScopeAllowed = false,\n        });\n        var clientRoleA = new Keycloak.Role(\"clientRoleA\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            ClientId = clientA.Id,\n            Description = \"My Client Role\",\n        });\n        var clientB = new Keycloak.OpenId.Client(\"clientB\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client-b\",\n            Enabled = true,\n            AccessType = \"BEARER-ONLY\",\n        });\n        var clientRoleB = new Keycloak.Role(\"clientRoleB\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            ClientId = clientB.Id,\n            Description = \"My Client Role\",\n        });\n        var clientBRoleMapper = new Keycloak.GenericClientRoleMapper(\"clientBRoleMapper\", new Keycloak.GenericClientRoleMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = keycloak_client.Client_b.Id,\n            RoleId = clientRoleA.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientA, err := openid.NewClient(ctx, \"clientA\", \u0026openid.ClientArgs{\n\t\t\tRealmId:          realm.ID(),\n\t\t\tClientId:         pulumi.String(\"client-a\"),\n\t\t\tEnabled:          pulumi.Bool(true),\n\t\t\tAccessType:       pulumi.String(\"BEARER-ONLY\"),\n\t\t\tFullScopeAllowed: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientRoleA, err := keycloak.NewRole(ctx, \"clientRoleA\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    clientA.ID(),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientB, err := openid.NewClient(ctx, \"clientB\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client-b\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"clientRoleB\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    clientB.ID(),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientRoleMapper(ctx, \"clientBRoleMapper\", \u0026keycloak.GenericClientRoleMapperArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: pulumi.Any(keycloak_client.Client_b.Id),\n\t\t\tRoleId:   clientRoleA.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Realm Role To Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst realmRole = new keycloak.Role(\"realmRole\", {\n    realmId: realm.id,\n    description: \"My Realm Role\",\n});\nconst clientRoleMapper = new keycloak.GenericClientRoleMapper(\"clientRoleMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    roleId: realmRole.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nrealm_role = keycloak.Role(\"realmRole\",\n    realm_id=realm.id,\n    description=\"My Realm Role\")\nclient_role_mapper = keycloak.GenericClientRoleMapper(\"clientRoleMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    role_id=realm_role.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var realmRole = new Keycloak.Role(\"realmRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            Description = \"My Realm Role\",\n        });\n        var clientRoleMapper = new Keycloak.GenericClientRoleMapper(\"clientRoleMapper\", new Keycloak.GenericClientRoleMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            RoleId = realmRole.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmRole, err := keycloak.NewRole(ctx, \"realmRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientRoleMapper(ctx, \"clientRoleMapper\", \u0026keycloak.GenericClientRoleMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tRoleId:        realmRole.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Role To Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"BEARER-ONLY\",\n});\nconst clientRole = new keycloak.Role(\"clientRole\", {\n    realmId: realm.id,\n    clientId: client.id,\n    description: \"My Client Role\",\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst clientBRoleMapper = new keycloak.GenericClientRoleMapper(\"clientBRoleMapper\", {\n    realmId: realm.id,\n    clientScopeId: keycloak_client_scope.client_scope.id,\n    roleId: clientRole.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"BEARER-ONLY\")\nclient_role = keycloak.Role(\"clientRole\",\n    realm_id=realm.id,\n    client_id=client.id,\n    description=\"My Client Role\")\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nclient_b_role_mapper = keycloak.GenericClientRoleMapper(\"clientBRoleMapper\",\n    realm_id=realm.id,\n    client_scope_id=keycloak_client_scope[\"client_scope\"][\"id\"],\n    role_id=client_role.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var client = new Keycloak.OpenId.Client(\"client\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"BEARER-ONLY\",\n        });\n        var clientRole = new Keycloak.Role(\"clientRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            ClientId = client.Id,\n            Description = \"My Client Role\",\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var clientBRoleMapper = new Keycloak.GenericClientRoleMapper(\"clientBRoleMapper\", new Keycloak.GenericClientRoleMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = keycloak_client_scope.Client_scope.Id,\n            RoleId = clientRole.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"BEARER-ONLY\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientRole, err := keycloak.NewRole(ctx, \"clientRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    client.ID(),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGenericClientRoleMapper(ctx, \"clientBRoleMapper\", \u0026keycloak.GenericClientRoleMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: pulumi.Any(keycloak_client_scope.Client_scope.Id),\n\t\t\tRoleId:        clientRole.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client this role mapper should be added to. Conflicts with `client_scope_id`. This argument is required if `client_scope_id` is not set.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The ID of the client scope this role mapper should be added to. Conflicts with `client_id`. This argument is required if `client_id` is not set.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this role mapper exists within.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to be added to this role mapper.\n"
                }
            },
            "required": [
                "realmId",
                "roleId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client this role mapper should be added to. Conflicts with `client_scope_id`. This argument is required if `client_scope_id` is not set.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The ID of the client scope this role mapper should be added to. Conflicts with `client_id`. This argument is required if `client_id` is not set.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this role mapper exists within.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to be added to this role mapper.\n"
                }
            },
            "requiredInputs": [
                "realmId",
                "roleId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GenericClientRoleMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The ID of the client this role mapper should be added to. Conflicts with `client_scope_id`. This argument is required if `client_scope_id` is not set.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The ID of the client scope this role mapper should be added to. Conflicts with `client_id`. This argument is required if `client_id` is not set.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this role mapper exists within.\n"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The ID of the role to be added to this role mapper.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/group:Group": {
            "description": "Allows for creating and managing Groups within Keycloak.\n\nGroups provide a logical wrapping for users within Keycloak. Users within a group can share attributes and roles, and\ngroup membership can be mapped to a claim.\n\nAttributes can also be defined on Groups.\n\nGroups can also be federated from external data sources, such as LDAP or Active Directory. This resource **should not**\nbe used to manage groups that were created this way.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst parentGroup = new keycloak.Group(\"parentGroup\", {realmId: realm.id});\nconst childGroup = new keycloak.Group(\"childGroup\", {\n    realmId: realm.id,\n    parentId: parentGroup.id,\n});\nconst childGroupWithOptionalAttributes = new keycloak.Group(\"childGroupWithOptionalAttributes\", {\n    realmId: realm.id,\n    parentId: parentGroup.id,\n    attributes: {\n        key1: \"value1\",\n        key2: \"value2\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nparent_group = keycloak.Group(\"parentGroup\", realm_id=realm.id)\nchild_group = keycloak.Group(\"childGroup\",\n    realm_id=realm.id,\n    parent_id=parent_group.id)\nchild_group_with_optional_attributes = keycloak.Group(\"childGroupWithOptionalAttributes\",\n    realm_id=realm.id,\n    parent_id=parent_group.id,\n    attributes={\n        \"key1\": \"value1\",\n        \"key2\": \"value2\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var parentGroup = new Keycloak.Group(\"parentGroup\", new Keycloak.GroupArgs\n        {\n            RealmId = realm.Id,\n        });\n        var childGroup = new Keycloak.Group(\"childGroup\", new Keycloak.GroupArgs\n        {\n            RealmId = realm.Id,\n            ParentId = parentGroup.Id,\n        });\n        var childGroupWithOptionalAttributes = new Keycloak.Group(\"childGroupWithOptionalAttributes\", new Keycloak.GroupArgs\n        {\n            RealmId = realm.Id,\n            ParentId = parentGroup.Id,\n            Attributes = \n            {\n                { \"key1\", \"value1\" },\n                { \"key2\", \"value2\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tparentGroup, err := keycloak.NewGroup(ctx, \"parentGroup\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGroup(ctx, \"childGroup\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tParentId: parentGroup.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGroup(ctx, \"childGroupWithOptionalAttributes\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tParentId: parentGroup.ID(),\n\t\t\tAttributes: pulumi.StringMap{\n\t\t\t\t\"key1\": pulumi.String(\"value1\"),\n\t\t\t\t\"key2\": pulumi.String(\"value2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of key/value pairs to set as custom attributes for the group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the group.\n"
                },
                "parentId": {
                    "type": "string",
                    "description": "The ID of this group's parent. If omitted, this group will be defined at the root level.\n"
                },
                "path": {
                    "type": "string",
                    "description": "(Computed) The complete path of the group. For example, the child group's path in the example configuration would be `/parent-group/child-group`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n"
                }
            },
            "required": [
                "name",
                "path",
                "realmId"
            ],
            "inputProperties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of key/value pairs to set as custom attributes for the group.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the group.\n"
                },
                "parentId": {
                    "type": "string",
                    "description": "The ID of this group's parent. If omitted, this group will be defined at the root level.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Group resources.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map of key/value pairs to set as custom attributes for the group.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the group.\n"
                    },
                    "parentId": {
                        "type": "string",
                        "description": "The ID of this group's parent. If omitted, this group will be defined at the root level.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "(Computed) The complete path of the group. For example, the child group's path in the example configuration would be `/parent-group/child-group`.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this group exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/groupMemberships:GroupMemberships": {
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "The ID of the group this resource should manage memberships for.\n"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of usernames that belong to this group.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n"
                }
            },
            "required": [
                "members",
                "realmId"
            ],
            "inputProperties": {
                "groupId": {
                    "type": "string",
                    "description": "The ID of the group this resource should manage memberships for.\n"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of usernames that belong to this group.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n"
                }
            },
            "requiredInputs": [
                "members",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupMemberships resources.\n",
                "properties": {
                    "groupId": {
                        "type": "string",
                        "description": "The ID of the group this resource should manage memberships for.\n"
                    },
                    "members": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of usernames that belong to this group.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this group exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/groupRoles:GroupRoles": {
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "The ID of the group this resource should manage roles for.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of role IDs to map to the group\n"
                }
            },
            "required": [
                "groupId",
                "realmId",
                "roleIds"
            ],
            "inputProperties": {
                "groupId": {
                    "type": "string",
                    "description": "The ID of the group this resource should manage roles for.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this group exists in.\n"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of role IDs to map to the group\n"
                }
            },
            "requiredInputs": [
                "groupId",
                "realmId",
                "roleIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupRoles resources.\n",
                "properties": {
                    "groupId": {
                        "type": "string",
                        "description": "The ID of the group this resource should manage roles for.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this group exists in.\n"
                    },
                    "roleIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of role IDs to map to the group\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/hardcodedAttributeIdentityProviderMapper:HardcodedAttributeIdentityProviderMapper": {
            "properties": {
                "attributeName": {
                    "type": "string",
                    "description": "OIDC Claim\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "User Attribute\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "userSession": {
                    "type": "boolean",
                    "description": "Is Attribute Related To a User Session\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm",
                "userSession"
            ],
            "inputProperties": {
                "attributeName": {
                    "type": "string",
                    "description": "OIDC Claim\n"
                },
                "attributeValue": {
                    "type": "string",
                    "description": "User Attribute\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "userSession": {
                    "type": "boolean",
                    "description": "Is Attribute Related To a User Session\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm",
                "userSession"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedAttributeIdentityProviderMapper resources.\n",
                "properties": {
                    "attributeName": {
                        "type": "string",
                        "description": "OIDC Claim\n"
                    },
                    "attributeValue": {
                        "type": "string",
                        "description": "User Attribute\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "IDP Alias\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "IDP Mapper Name\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "Realm Name\n"
                    },
                    "userSession": {
                        "type": "boolean",
                        "description": "Is Attribute Related To a User Session\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/hardcodedRoleIdentityMapper:HardcodedRoleIdentityMapper": {
            "properties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role Name\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm"
            ],
            "inputProperties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role Name\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedRoleIdentityMapper resources.\n",
                "properties": {
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "IDP Alias\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "IDP Mapper Name\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "Realm Name\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "Role Name\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/identityProviderTokenExchangeScopePermission:IdentityProviderTokenExchangeScopePermission": {
            "properties": {
                "authorizationIdpResourceId": {
                    "type": "string",
                    "description": "(Computed) Resource ID representing the identity provider, this automatically created by keycloak.\n"
                },
                "authorizationResourceServerId": {
                    "type": "string",
                    "description": "(Computed) Resource server ID representing the realm management client on which this permission is managed.\n"
                },
                "authorizationTokenExchangeScopePermissionId": {
                    "type": "string",
                    "description": "(Computed) Permission ID representing the Permission with scope 'Token Exchange' and the resource 'authorization_idp_resource_id', this automatically created by keycloak, the policy ID will be set on this permission.\n"
                },
                "clients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IDs of the clients for which a policy will be created and set on scope based token exchange permission.\n"
                },
                "policyId": {
                    "type": "string",
                    "description": "(Computed) Policy ID that will be set on the scope based token exchange permission automatically created by enabling permissions on the reference identity provider.\n"
                },
                "policyType": {
                    "type": "string",
                    "description": "Defaults to \"client\" This is also the only value policy type supported by this provider.\n"
                },
                "providerAlias": {
                    "type": "string",
                    "description": "Alias of the identity provider.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that the identity provider exists in.\n"
                }
            },
            "required": [
                "authorizationIdpResourceId",
                "authorizationResourceServerId",
                "authorizationTokenExchangeScopePermissionId",
                "clients",
                "policyId",
                "providerAlias",
                "realmId"
            ],
            "inputProperties": {
                "clients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of IDs of the clients for which a policy will be created and set on scope based token exchange permission.\n"
                },
                "policyType": {
                    "type": "string",
                    "description": "Defaults to \"client\" This is also the only value policy type supported by this provider.\n"
                },
                "providerAlias": {
                    "type": "string",
                    "description": "Alias of the identity provider.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that the identity provider exists in.\n"
                }
            },
            "requiredInputs": [
                "clients",
                "providerAlias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IdentityProviderTokenExchangeScopePermission resources.\n",
                "properties": {
                    "authorizationIdpResourceId": {
                        "type": "string",
                        "description": "(Computed) Resource ID representing the identity provider, this automatically created by keycloak.\n"
                    },
                    "authorizationResourceServerId": {
                        "type": "string",
                        "description": "(Computed) Resource server ID representing the realm management client on which this permission is managed.\n"
                    },
                    "authorizationTokenExchangeScopePermissionId": {
                        "type": "string",
                        "description": "(Computed) Permission ID representing the Permission with scope 'Token Exchange' and the resource 'authorization_idp_resource_id', this automatically created by keycloak, the policy ID will be set on this permission.\n"
                    },
                    "clients": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of IDs of the clients for which a policy will be created and set on scope based token exchange permission.\n"
                    },
                    "policyId": {
                        "type": "string",
                        "description": "(Computed) Policy ID that will be set on the scope based token exchange permission automatically created by enabling permissions on the reference identity provider.\n"
                    },
                    "policyType": {
                        "type": "string",
                        "description": "Defaults to \"client\" This is also the only value policy type supported by this provider.\n"
                    },
                    "providerAlias": {
                        "type": "string",
                        "description": "Alias of the identity provider.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that the identity provider exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realm:Realm": {
            "description": "Allows for creating and managing Realms within Keycloak.\n\nA realm manages a logical collection of users, credentials, roles, and groups. Users log in to realms and can be federated\nfrom multiple sources.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    accessCodeLifespan: \"1h\",\n    attributes: {\n        mycustomAttribute: \"myCustomValue\",\n    },\n    displayName: \"my realm\",\n    displayNameHtml: \"\u003cb\u003emy realm\u003c/b\u003e\",\n    enabled: true,\n    internationalization: {\n        defaultLocale: \"en\",\n        supportedLocales: [\n            \"en\",\n            \"de\",\n            \"es\",\n        ],\n    },\n    loginTheme: \"base\",\n    passwordPolicy: \"upperCase(1) and length(8) and forceExpiredPasswordChange(365) and notUsername\",\n    realm: \"my-realm\",\n    securityDefenses: {\n        bruteForceDetection: {\n            failureResetTimeSeconds: 43200,\n            maxFailureWaitSeconds: 900,\n            maxLoginFailures: 30,\n            minimumQuickLoginWaitSeconds: 60,\n            permanentLockout: false,\n            quickLoginCheckMilliSeconds: 1000,\n            waitIncrementSeconds: 60,\n        },\n        headers: {\n            contentSecurityPolicy: \"frame-src 'self'; frame-ancestors 'self'; object-src 'none';\",\n            contentSecurityPolicyReportOnly: \"\",\n            strictTransportSecurity: \"max-age=31536000; includeSubDomains\",\n            xContentTypeOptions: \"nosniff\",\n            xFrameOptions: \"DENY\",\n            xRobotsTag: \"none\",\n            xXssProtection: \"1; mode=block\",\n        },\n    },\n    smtpServer: {\n        auth: {\n            password: \"password\",\n            username: \"tom\",\n        },\n        from: \"example@example.com\",\n        host: \"smtp.example.com\",\n    },\n    sslRequired: \"external\",\n    webAuthnPolicy: {\n        relyingPartyEntityName: \"Example\",\n        relyingPartyId: \"keycloak.example.com\",\n        signatureAlgorithms: [\n            \"ES256\",\n            \"RS256\",\n        ],\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    access_code_lifespan=\"1h\",\n    attributes={\n        \"mycustomAttribute\": \"myCustomValue\",\n    },\n    display_name=\"my realm\",\n    display_name_html=\"\u003cb\u003emy realm\u003c/b\u003e\",\n    enabled=True,\n    internationalization=keycloak.RealmInternationalizationArgs(\n        default_locale=\"en\",\n        supported_locales=[\n            \"en\",\n            \"de\",\n            \"es\",\n        ],\n    ),\n    login_theme=\"base\",\n    password_policy=\"upperCase(1) and length(8) and forceExpiredPasswordChange(365) and notUsername\",\n    realm=\"my-realm\",\n    security_defenses=keycloak.RealmSecurityDefensesArgs(\n        brute_force_detection=keycloak.RealmSecurityDefensesBruteForceDetectionArgs(\n            failure_reset_time_seconds=43200,\n            max_failure_wait_seconds=900,\n            max_login_failures=30,\n            minimum_quick_login_wait_seconds=60,\n            permanent_lockout=False,\n            quick_login_check_milli_seconds=1000,\n            wait_increment_seconds=60,\n        ),\n        headers=keycloak.RealmSecurityDefensesHeadersArgs(\n            content_security_policy=\"frame-src 'self'; frame-ancestors 'self'; object-src 'none';\",\n            content_security_policy_report_only=\"\",\n            strict_transport_security=\"max-age=31536000; includeSubDomains\",\n            x_content_type_options=\"nosniff\",\n            x_frame_options=\"DENY\",\n            x_robots_tag=\"none\",\n            x_xss_protection=\"1; mode=block\",\n        ),\n    ),\n    smtp_server=keycloak.RealmSmtpServerArgs(\n        auth=keycloak.RealmSmtpServerAuthArgs(\n            password=\"password\",\n            username=\"tom\",\n        ),\n        from_=\"example@example.com\",\n        host=\"smtp.example.com\",\n    ),\n    ssl_required=\"external\",\n    web_authn_policy=keycloak.RealmWebAuthnPolicyArgs(\n        relying_party_entity_name=\"Example\",\n        relying_party_id=\"keycloak.example.com\",\n        signature_algorithms=[\n            \"ES256\",\n            \"RS256\",\n        ],\n    ))\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            AccessCodeLifespan = \"1h\",\n            Attributes = \n            {\n                { \"mycustomAttribute\", \"myCustomValue\" },\n            },\n            DisplayName = \"my realm\",\n            DisplayNameHtml = \"\u003cb\u003emy realm\u003c/b\u003e\",\n            Enabled = true,\n            Internationalization = new Keycloak.Inputs.RealmInternationalizationArgs\n            {\n                DefaultLocale = \"en\",\n                SupportedLocales = \n                {\n                    \"en\",\n                    \"de\",\n                    \"es\",\n                },\n            },\n            LoginTheme = \"base\",\n            PasswordPolicy = \"upperCase(1) and length(8) and forceExpiredPasswordChange(365) and notUsername\",\n            Realm = \"my-realm\",\n            SecurityDefenses = new Keycloak.Inputs.RealmSecurityDefensesArgs\n            {\n                BruteForceDetection = new Keycloak.Inputs.RealmSecurityDefensesBruteForceDetectionArgs\n                {\n                    FailureResetTimeSeconds = 43200,\n                    MaxFailureWaitSeconds = 900,\n                    MaxLoginFailures = 30,\n                    MinimumQuickLoginWaitSeconds = 60,\n                    PermanentLockout = false,\n                    QuickLoginCheckMilliSeconds = 1000,\n                    WaitIncrementSeconds = 60,\n                },\n                Headers = new Keycloak.Inputs.RealmSecurityDefensesHeadersArgs\n                {\n                    ContentSecurityPolicy = \"frame-src 'self'; frame-ancestors 'self'; object-src 'none';\",\n                    ContentSecurityPolicyReportOnly = \"\",\n                    StrictTransportSecurity = \"max-age=31536000; includeSubDomains\",\n                    XContentTypeOptions = \"nosniff\",\n                    XFrameOptions = \"DENY\",\n                    XRobotsTag = \"none\",\n                    XXssProtection = \"1; mode=block\",\n                },\n            },\n            SmtpServer = new Keycloak.Inputs.RealmSmtpServerArgs\n            {\n                Auth = new Keycloak.Inputs.RealmSmtpServerAuthArgs\n                {\n                    Password = \"password\",\n                    Username = \"tom\",\n                },\n                From = \"example@example.com\",\n                Host = \"smtp.example.com\",\n            },\n            SslRequired = \"external\",\n            WebAuthnPolicy = new Keycloak.Inputs.RealmWebAuthnPolicyArgs\n            {\n                RelyingPartyEntityName = \"Example\",\n                RelyingPartyId = \"keycloak.example.com\",\n                SignatureAlgorithms = \n                {\n                    \"ES256\",\n                    \"RS256\",\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tAccessCodeLifespan: pulumi.String(\"1h\"),\n\t\t\tAttributes: pulumi.StringMap{\n\t\t\t\t\"mycustomAttribute\": pulumi.String(\"myCustomValue\"),\n\t\t\t},\n\t\t\tDisplayName:     pulumi.String(\"my realm\"),\n\t\t\tDisplayNameHtml: pulumi.String(\"\u003cb\u003emy realm\u003c/b\u003e\"),\n\t\t\tEnabled:         pulumi.Bool(true),\n\t\t\tInternationalization: \u0026keycloak.RealmInternationalizationArgs{\n\t\t\t\tDefaultLocale: pulumi.String(\"en\"),\n\t\t\t\tSupportedLocales: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"en\"),\n\t\t\t\t\tpulumi.String(\"de\"),\n\t\t\t\t\tpulumi.String(\"es\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLoginTheme:     pulumi.String(\"base\"),\n\t\t\tPasswordPolicy: pulumi.String(\"upperCase(1) and length(8) and forceExpiredPasswordChange(365) and notUsername\"),\n\t\t\tRealm:          pulumi.String(\"my-realm\"),\n\t\t\tSecurityDefenses: \u0026keycloak.RealmSecurityDefensesArgs{\n\t\t\t\tBruteForceDetection: \u0026keycloak.RealmSecurityDefensesBruteForceDetectionArgs{\n\t\t\t\t\tFailureResetTimeSeconds:      pulumi.Int(43200),\n\t\t\t\t\tMaxFailureWaitSeconds:        pulumi.Int(900),\n\t\t\t\t\tMaxLoginFailures:             pulumi.Int(30),\n\t\t\t\t\tMinimumQuickLoginWaitSeconds: pulumi.Int(60),\n\t\t\t\t\tPermanentLockout:             pulumi.Bool(false),\n\t\t\t\t\tQuickLoginCheckMilliSeconds:  pulumi.Int(1000),\n\t\t\t\t\tWaitIncrementSeconds:         pulumi.Int(60),\n\t\t\t\t},\n\t\t\t\tHeaders: \u0026keycloak.RealmSecurityDefensesHeadersArgs{\n\t\t\t\t\tContentSecurityPolicy:           pulumi.String(\"frame-src 'self'; frame-ancestors 'self'; object-src 'none';\"),\n\t\t\t\t\tContentSecurityPolicyReportOnly: pulumi.String(\"\"),\n\t\t\t\t\tStrictTransportSecurity:         pulumi.String(\"max-age=31536000; includeSubDomains\"),\n\t\t\t\t\tXContentTypeOptions:             pulumi.String(\"nosniff\"),\n\t\t\t\t\tXFrameOptions:                   pulumi.String(\"DENY\"),\n\t\t\t\t\tXRobotsTag:                      pulumi.String(\"none\"),\n\t\t\t\t\tXXssProtection:                  pulumi.String(\"1; mode=block\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tSmtpServer: \u0026keycloak.RealmSmtpServerArgs{\n\t\t\t\tAuth: \u0026keycloak.RealmSmtpServerAuthArgs{\n\t\t\t\t\tPassword: pulumi.String(\"password\"),\n\t\t\t\t\tUsername: pulumi.String(\"tom\"),\n\t\t\t\t},\n\t\t\t\tFrom: pulumi.String(\"example@example.com\"),\n\t\t\t\tHost: pulumi.String(\"smtp.example.com\"),\n\t\t\t},\n\t\t\tSslRequired: pulumi.String(\"external\"),\n\t\t\tWebAuthnPolicy: \u0026keycloak.RealmWebAuthnPolicyArgs{\n\t\t\t\tRelyingPartyEntityName: pulumi.String(\"Example\"),\n\t\t\t\tRelyingPartyId:         pulumi.String(\"keycloak.example.com\"),\n\t\t\t\tSignatureAlgorithms: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"ES256\"),\n\t\t\t\t\tpulumi.String(\"RS256\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessCodeLifespan": {
                    "type": "string",
                    "description": "The maximum amount of time a client has to finish the authorization code flow.\n"
                },
                "accessCodeLifespanLogin": {
                    "type": "string",
                    "description": "The maximum amount of time a user is permitted to stay on the login page before the authentication process must be restarted.\n"
                },
                "accessCodeLifespanUserAction": {
                    "type": "string",
                    "description": "The maximum amount of time a user has to complete login related actions, such as updating a password.\n"
                },
                "accessTokenLifespan": {
                    "type": "string",
                    "description": "The amount of time an access token can be used before it expires.\n"
                },
                "accessTokenLifespanForImplicitFlow": {
                    "type": "string",
                    "description": "The amount of time an access token issued with the OpenID Connect Implicit Flow can be used before it expires.\n"
                },
                "accountTheme": {
                    "type": "string",
                    "description": "Used for account management pages.\n"
                },
                "actionTokenGeneratedByAdminLifespan": {
                    "type": "string",
                    "description": "The maximum time a user has to use an admin-generated permit before it expires.\n"
                },
                "actionTokenGeneratedByUserLifespan": {
                    "type": "string",
                    "description": "The maximum time a user has to use a user-generated permit before it expires.\n"
                },
                "adminTheme": {
                    "type": "string",
                    "description": "Used for the admin console.\n"
                },
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of custom attributes to add to the realm.\n"
                },
                "browserFlow": {
                    "type": "string",
                    "description": "The desired flow for browser authentication. Defaults to `browser`.\n"
                },
                "clientAuthenticationFlow": {
                    "type": "string",
                    "description": "The desired flow for client authentication. Defaults to `clients`.\n"
                },
                "defaultSignatureAlgorithm": {
                    "type": "string",
                    "description": "Default algorithm used to sign tokens for the realm.\n"
                },
                "directGrantFlow": {
                    "type": "string",
                    "description": "The desired flow for direct access authentication. Defaults to `direct grant`.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "The display name for the realm that is shown when logging in to the admin console.\n"
                },
                "displayNameHtml": {
                    "type": "string",
                    "description": "The display name for the realm that is rendered as HTML on the screen when logging in to the admin console.\n"
                },
                "dockerAuthenticationFlow": {
                    "type": "string",
                    "description": "The desired flow for Docker authentication. Defaults to `docker auth`.\n"
                },
                "duplicateEmailsAllowed": {
                    "type": "boolean",
                    "description": "When true, multiple users will be allowed to have the same email address. This argument must be set to `false` if `login_with_email_allowed` is set to `true`.\n"
                },
                "editUsernameAllowed": {
                    "type": "boolean",
                    "description": "When true, the username field is editable.\n"
                },
                "emailTheme": {
                    "type": "string",
                    "description": "Used for emails that are sent by Keycloak.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, users and clients will not be able to access this realm. Defaults to `true`.\n"
                },
                "internalId": {
                    "type": "string"
                },
                "internationalization": {
                    "$ref": "#/types/keycloak:index/RealmInternationalization:RealmInternationalization"
                },
                "loginTheme": {
                    "type": "string",
                    "description": "Used for the login, forgot password, and registration pages.\n"
                },
                "loginWithEmailAllowed": {
                    "type": "boolean",
                    "description": "When true, users may log in with their email address.\n"
                },
                "offlineSessionIdleTimeout": {
                    "type": "string",
                    "description": "The amount of time an offline session can be idle before it expires.\n"
                },
                "offlineSessionMaxLifespan": {
                    "type": "string",
                    "description": "The maximum amount of time before an offline session expires regardless of activity.\n"
                },
                "offlineSessionMaxLifespanEnabled": {
                    "type": "boolean",
                    "description": "Enable `offline_session_max_lifespan`.\n"
                },
                "passwordPolicy": {
                    "type": "string",
                    "description": "The password policy for users within the realm.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak. This will also be used as the realm's internal ID within Keycloak.\n",
                    "language": {
                        "csharp": {
                            "name": "RealmName"
                        }
                    }
                },
                "refreshTokenMaxReuse": {
                    "type": "integer",
                    "description": "Maximum number of times a refresh token can be reused before they are revoked. If unspecified and 'revoke_refresh_token' is enabled the default value is 0 and refresh tokens can not be reused.\n"
                },
                "registrationAllowed": {
                    "type": "boolean",
                    "description": "When true, user registration will be enabled, and a link for registration will be displayed on the login page.\n"
                },
                "registrationEmailAsUsername": {
                    "type": "boolean",
                    "description": "When true, the user's email will be used as their username during registration.\n"
                },
                "registrationFlow": {
                    "type": "string",
                    "description": "The desired flow for user registration. Defaults to `registration`.\n"
                },
                "rememberMe": {
                    "type": "boolean",
                    "description": "When true, a \"remember me\" checkbox will be displayed on the login page, and the user's session will not expire between browser restarts.\n"
                },
                "resetCredentialsFlow": {
                    "type": "string",
                    "description": "The desired flow to use when a user attempts to reset their credentials. Defaults to `reset credentials`.\n"
                },
                "resetPasswordAllowed": {
                    "type": "boolean",
                    "description": "When true, a \"forgot password\" link will be displayed on the login page.\n"
                },
                "revokeRefreshToken": {
                    "type": "boolean",
                    "description": "If enabled a refresh token can only be used number of times specified in 'refresh_token_max_reuse' before they are revoked. If unspecified, refresh tokens can be reused.\n"
                },
                "securityDefenses": {
                    "$ref": "#/types/keycloak:index/RealmSecurityDefenses:RealmSecurityDefenses"
                },
                "smtpServer": {
                    "$ref": "#/types/keycloak:index/RealmSmtpServer:RealmSmtpServer"
                },
                "sslRequired": {
                    "type": "string",
                    "description": "Can be one of following values: 'none, 'external' or 'all'\n"
                },
                "ssoSessionIdleTimeout": {
                    "type": "string",
                    "description": "The amount of time a session can be idle before it expires.\n"
                },
                "ssoSessionIdleTimeoutRememberMe": {
                    "type": "string"
                },
                "ssoSessionMaxLifespan": {
                    "type": "string",
                    "description": "The maximum amount of time before a session expires regardless of activity.\n"
                },
                "ssoSessionMaxLifespanRememberMe": {
                    "type": "string"
                },
                "userManagedAccess": {
                    "type": "boolean",
                    "description": "When `true`, users are allowed to manage their own resources. Defaults to `false`.\n"
                },
                "verifyEmail": {
                    "type": "boolean",
                    "description": "When true, users are required to verify their email address after registration and after email address changes.\n"
                },
                "webAuthnPasswordlessPolicy": {
                    "$ref": "#/types/keycloak:index/RealmWebAuthnPasswordlessPolicy:RealmWebAuthnPasswordlessPolicy",
                    "description": "Configuration for WebAuthn Passwordless Policy authentication.\n"
                },
                "webAuthnPolicy": {
                    "$ref": "#/types/keycloak:index/RealmWebAuthnPolicy:RealmWebAuthnPolicy",
                    "description": "Configuration for WebAuthn Policy authentication.\n"
                }
            },
            "required": [
                "accessCodeLifespan",
                "accessCodeLifespanLogin",
                "accessCodeLifespanUserAction",
                "accessTokenLifespan",
                "accessTokenLifespanForImplicitFlow",
                "actionTokenGeneratedByAdminLifespan",
                "actionTokenGeneratedByUserLifespan",
                "duplicateEmailsAllowed",
                "editUsernameAllowed",
                "internalId",
                "loginWithEmailAllowed",
                "offlineSessionIdleTimeout",
                "offlineSessionMaxLifespan",
                "realm",
                "registrationAllowed",
                "registrationEmailAsUsername",
                "rememberMe",
                "resetPasswordAllowed",
                "ssoSessionIdleTimeout",
                "ssoSessionIdleTimeoutRememberMe",
                "ssoSessionMaxLifespan",
                "ssoSessionMaxLifespanRememberMe",
                "verifyEmail",
                "webAuthnPasswordlessPolicy",
                "webAuthnPolicy"
            ],
            "inputProperties": {
                "accessCodeLifespan": {
                    "type": "string",
                    "description": "The maximum amount of time a client has to finish the authorization code flow.\n"
                },
                "accessCodeLifespanLogin": {
                    "type": "string",
                    "description": "The maximum amount of time a user is permitted to stay on the login page before the authentication process must be restarted.\n"
                },
                "accessCodeLifespanUserAction": {
                    "type": "string",
                    "description": "The maximum amount of time a user has to complete login related actions, such as updating a password.\n"
                },
                "accessTokenLifespan": {
                    "type": "string",
                    "description": "The amount of time an access token can be used before it expires.\n"
                },
                "accessTokenLifespanForImplicitFlow": {
                    "type": "string",
                    "description": "The amount of time an access token issued with the OpenID Connect Implicit Flow can be used before it expires.\n"
                },
                "accountTheme": {
                    "type": "string",
                    "description": "Used for account management pages.\n"
                },
                "actionTokenGeneratedByAdminLifespan": {
                    "type": "string",
                    "description": "The maximum time a user has to use an admin-generated permit before it expires.\n"
                },
                "actionTokenGeneratedByUserLifespan": {
                    "type": "string",
                    "description": "The maximum time a user has to use a user-generated permit before it expires.\n"
                },
                "adminTheme": {
                    "type": "string",
                    "description": "Used for the admin console.\n"
                },
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of custom attributes to add to the realm.\n"
                },
                "browserFlow": {
                    "type": "string",
                    "description": "The desired flow for browser authentication. Defaults to `browser`.\n"
                },
                "clientAuthenticationFlow": {
                    "type": "string",
                    "description": "The desired flow for client authentication. Defaults to `clients`.\n"
                },
                "defaultSignatureAlgorithm": {
                    "type": "string",
                    "description": "Default algorithm used to sign tokens for the realm.\n"
                },
                "directGrantFlow": {
                    "type": "string",
                    "description": "The desired flow for direct access authentication. Defaults to `direct grant`.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "The display name for the realm that is shown when logging in to the admin console.\n"
                },
                "displayNameHtml": {
                    "type": "string",
                    "description": "The display name for the realm that is rendered as HTML on the screen when logging in to the admin console.\n"
                },
                "dockerAuthenticationFlow": {
                    "type": "string",
                    "description": "The desired flow for Docker authentication. Defaults to `docker auth`.\n"
                },
                "duplicateEmailsAllowed": {
                    "type": "boolean",
                    "description": "When true, multiple users will be allowed to have the same email address. This argument must be set to `false` if `login_with_email_allowed` is set to `true`.\n"
                },
                "editUsernameAllowed": {
                    "type": "boolean",
                    "description": "When true, the username field is editable.\n"
                },
                "emailTheme": {
                    "type": "string",
                    "description": "Used for emails that are sent by Keycloak.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, users and clients will not be able to access this realm. Defaults to `true`.\n"
                },
                "internationalization": {
                    "$ref": "#/types/keycloak:index/RealmInternationalization:RealmInternationalization"
                },
                "loginTheme": {
                    "type": "string",
                    "description": "Used for the login, forgot password, and registration pages.\n"
                },
                "loginWithEmailAllowed": {
                    "type": "boolean",
                    "description": "When true, users may log in with their email address.\n"
                },
                "offlineSessionIdleTimeout": {
                    "type": "string",
                    "description": "The amount of time an offline session can be idle before it expires.\n"
                },
                "offlineSessionMaxLifespan": {
                    "type": "string",
                    "description": "The maximum amount of time before an offline session expires regardless of activity.\n"
                },
                "offlineSessionMaxLifespanEnabled": {
                    "type": "boolean",
                    "description": "Enable `offline_session_max_lifespan`.\n"
                },
                "passwordPolicy": {
                    "type": "string",
                    "description": "The password policy for users within the realm.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak. This will also be used as the realm's internal ID within Keycloak.\n",
                    "language": {
                        "csharp": {
                            "name": "RealmName"
                        }
                    }
                },
                "refreshTokenMaxReuse": {
                    "type": "integer",
                    "description": "Maximum number of times a refresh token can be reused before they are revoked. If unspecified and 'revoke_refresh_token' is enabled the default value is 0 and refresh tokens can not be reused.\n"
                },
                "registrationAllowed": {
                    "type": "boolean",
                    "description": "When true, user registration will be enabled, and a link for registration will be displayed on the login page.\n"
                },
                "registrationEmailAsUsername": {
                    "type": "boolean",
                    "description": "When true, the user's email will be used as their username during registration.\n"
                },
                "registrationFlow": {
                    "type": "string",
                    "description": "The desired flow for user registration. Defaults to `registration`.\n"
                },
                "rememberMe": {
                    "type": "boolean",
                    "description": "When true, a \"remember me\" checkbox will be displayed on the login page, and the user's session will not expire between browser restarts.\n"
                },
                "resetCredentialsFlow": {
                    "type": "string",
                    "description": "The desired flow to use when a user attempts to reset their credentials. Defaults to `reset credentials`.\n"
                },
                "resetPasswordAllowed": {
                    "type": "boolean",
                    "description": "When true, a \"forgot password\" link will be displayed on the login page.\n"
                },
                "revokeRefreshToken": {
                    "type": "boolean",
                    "description": "If enabled a refresh token can only be used number of times specified in 'refresh_token_max_reuse' before they are revoked. If unspecified, refresh tokens can be reused.\n"
                },
                "securityDefenses": {
                    "$ref": "#/types/keycloak:index/RealmSecurityDefenses:RealmSecurityDefenses"
                },
                "smtpServer": {
                    "$ref": "#/types/keycloak:index/RealmSmtpServer:RealmSmtpServer"
                },
                "sslRequired": {
                    "type": "string",
                    "description": "Can be one of following values: 'none, 'external' or 'all'\n"
                },
                "ssoSessionIdleTimeout": {
                    "type": "string",
                    "description": "The amount of time a session can be idle before it expires.\n"
                },
                "ssoSessionIdleTimeoutRememberMe": {
                    "type": "string"
                },
                "ssoSessionMaxLifespan": {
                    "type": "string",
                    "description": "The maximum amount of time before a session expires regardless of activity.\n"
                },
                "ssoSessionMaxLifespanRememberMe": {
                    "type": "string"
                },
                "userManagedAccess": {
                    "type": "boolean",
                    "description": "When `true`, users are allowed to manage their own resources. Defaults to `false`.\n"
                },
                "verifyEmail": {
                    "type": "boolean",
                    "description": "When true, users are required to verify their email address after registration and after email address changes.\n"
                },
                "webAuthnPasswordlessPolicy": {
                    "$ref": "#/types/keycloak:index/RealmWebAuthnPasswordlessPolicy:RealmWebAuthnPasswordlessPolicy",
                    "description": "Configuration for WebAuthn Passwordless Policy authentication.\n"
                },
                "webAuthnPolicy": {
                    "$ref": "#/types/keycloak:index/RealmWebAuthnPolicy:RealmWebAuthnPolicy",
                    "description": "Configuration for WebAuthn Policy authentication.\n"
                }
            },
            "requiredInputs": [
                "realm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Realm resources.\n",
                "properties": {
                    "accessCodeLifespan": {
                        "type": "string",
                        "description": "The maximum amount of time a client has to finish the authorization code flow.\n"
                    },
                    "accessCodeLifespanLogin": {
                        "type": "string",
                        "description": "The maximum amount of time a user is permitted to stay on the login page before the authentication process must be restarted.\n"
                    },
                    "accessCodeLifespanUserAction": {
                        "type": "string",
                        "description": "The maximum amount of time a user has to complete login related actions, such as updating a password.\n"
                    },
                    "accessTokenLifespan": {
                        "type": "string",
                        "description": "The amount of time an access token can be used before it expires.\n"
                    },
                    "accessTokenLifespanForImplicitFlow": {
                        "type": "string",
                        "description": "The amount of time an access token issued with the OpenID Connect Implicit Flow can be used before it expires.\n"
                    },
                    "accountTheme": {
                        "type": "string",
                        "description": "Used for account management pages.\n"
                    },
                    "actionTokenGeneratedByAdminLifespan": {
                        "type": "string",
                        "description": "The maximum time a user has to use an admin-generated permit before it expires.\n"
                    },
                    "actionTokenGeneratedByUserLifespan": {
                        "type": "string",
                        "description": "The maximum time a user has to use a user-generated permit before it expires.\n"
                    },
                    "adminTheme": {
                        "type": "string",
                        "description": "Used for the admin console.\n"
                    },
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map of custom attributes to add to the realm.\n"
                    },
                    "browserFlow": {
                        "type": "string",
                        "description": "The desired flow for browser authentication. Defaults to `browser`.\n"
                    },
                    "clientAuthenticationFlow": {
                        "type": "string",
                        "description": "The desired flow for client authentication. Defaults to `clients`.\n"
                    },
                    "defaultSignatureAlgorithm": {
                        "type": "string",
                        "description": "Default algorithm used to sign tokens for the realm.\n"
                    },
                    "directGrantFlow": {
                        "type": "string",
                        "description": "The desired flow for direct access authentication. Defaults to `direct grant`.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "The display name for the realm that is shown when logging in to the admin console.\n"
                    },
                    "displayNameHtml": {
                        "type": "string",
                        "description": "The display name for the realm that is rendered as HTML on the screen when logging in to the admin console.\n"
                    },
                    "dockerAuthenticationFlow": {
                        "type": "string",
                        "description": "The desired flow for Docker authentication. Defaults to `docker auth`.\n"
                    },
                    "duplicateEmailsAllowed": {
                        "type": "boolean",
                        "description": "When true, multiple users will be allowed to have the same email address. This argument must be set to `false` if `login_with_email_allowed` is set to `true`.\n"
                    },
                    "editUsernameAllowed": {
                        "type": "boolean",
                        "description": "When true, the username field is editable.\n"
                    },
                    "emailTheme": {
                        "type": "string",
                        "description": "Used for emails that are sent by Keycloak.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, users and clients will not be able to access this realm. Defaults to `true`.\n"
                    },
                    "internalId": {
                        "type": "string"
                    },
                    "internationalization": {
                        "$ref": "#/types/keycloak:index/RealmInternationalization:RealmInternationalization"
                    },
                    "loginTheme": {
                        "type": "string",
                        "description": "Used for the login, forgot password, and registration pages.\n"
                    },
                    "loginWithEmailAllowed": {
                        "type": "boolean",
                        "description": "When true, users may log in with their email address.\n"
                    },
                    "offlineSessionIdleTimeout": {
                        "type": "string",
                        "description": "The amount of time an offline session can be idle before it expires.\n"
                    },
                    "offlineSessionMaxLifespan": {
                        "type": "string",
                        "description": "The maximum amount of time before an offline session expires regardless of activity.\n"
                    },
                    "offlineSessionMaxLifespanEnabled": {
                        "type": "boolean",
                        "description": "Enable `offline_session_max_lifespan`.\n"
                    },
                    "passwordPolicy": {
                        "type": "string",
                        "description": "The password policy for users within the realm.\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "The name of the realm. This is unique across Keycloak. This will also be used as the realm's internal ID within Keycloak.\n",
                        "language": {
                            "csharp": {
                                "name": "RealmName"
                            }
                        }
                    },
                    "refreshTokenMaxReuse": {
                        "type": "integer",
                        "description": "Maximum number of times a refresh token can be reused before they are revoked. If unspecified and 'revoke_refresh_token' is enabled the default value is 0 and refresh tokens can not be reused.\n"
                    },
                    "registrationAllowed": {
                        "type": "boolean",
                        "description": "When true, user registration will be enabled, and a link for registration will be displayed on the login page.\n"
                    },
                    "registrationEmailAsUsername": {
                        "type": "boolean",
                        "description": "When true, the user's email will be used as their username during registration.\n"
                    },
                    "registrationFlow": {
                        "type": "string",
                        "description": "The desired flow for user registration. Defaults to `registration`.\n"
                    },
                    "rememberMe": {
                        "type": "boolean",
                        "description": "When true, a \"remember me\" checkbox will be displayed on the login page, and the user's session will not expire between browser restarts.\n"
                    },
                    "resetCredentialsFlow": {
                        "type": "string",
                        "description": "The desired flow to use when a user attempts to reset their credentials. Defaults to `reset credentials`.\n"
                    },
                    "resetPasswordAllowed": {
                        "type": "boolean",
                        "description": "When true, a \"forgot password\" link will be displayed on the login page.\n"
                    },
                    "revokeRefreshToken": {
                        "type": "boolean",
                        "description": "If enabled a refresh token can only be used number of times specified in 'refresh_token_max_reuse' before they are revoked. If unspecified, refresh tokens can be reused.\n"
                    },
                    "securityDefenses": {
                        "$ref": "#/types/keycloak:index/RealmSecurityDefenses:RealmSecurityDefenses"
                    },
                    "smtpServer": {
                        "$ref": "#/types/keycloak:index/RealmSmtpServer:RealmSmtpServer"
                    },
                    "sslRequired": {
                        "type": "string",
                        "description": "Can be one of following values: 'none, 'external' or 'all'\n"
                    },
                    "ssoSessionIdleTimeout": {
                        "type": "string",
                        "description": "The amount of time a session can be idle before it expires.\n"
                    },
                    "ssoSessionIdleTimeoutRememberMe": {
                        "type": "string"
                    },
                    "ssoSessionMaxLifespan": {
                        "type": "string",
                        "description": "The maximum amount of time before a session expires regardless of activity.\n"
                    },
                    "ssoSessionMaxLifespanRememberMe": {
                        "type": "string"
                    },
                    "userManagedAccess": {
                        "type": "boolean",
                        "description": "When `true`, users are allowed to manage their own resources. Defaults to `false`.\n"
                    },
                    "verifyEmail": {
                        "type": "boolean",
                        "description": "When true, users are required to verify their email address after registration and after email address changes.\n"
                    },
                    "webAuthnPasswordlessPolicy": {
                        "$ref": "#/types/keycloak:index/RealmWebAuthnPasswordlessPolicy:RealmWebAuthnPasswordlessPolicy",
                        "description": "Configuration for WebAuthn Passwordless Policy authentication.\n"
                    },
                    "webAuthnPolicy": {
                        "$ref": "#/types/keycloak:index/RealmWebAuthnPolicy:RealmWebAuthnPolicy",
                        "description": "Configuration for WebAuthn Policy authentication.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/realmEvents:RealmEvents": {
            "description": "Allows for managing Realm Events settings within Keycloak.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst realmEvents = new keycloak.RealmEvents(\"realmEvents\", {\n    realmId: realm.id,\n    eventsEnabled: true,\n    eventsExpiration: 3600,\n    adminEventsEnabled: true,\n    adminEventsDetailsEnabled: true,\n    enabledEventTypes: [\n        \"LOGIN\",\n        \"LOGOUT\",\n    ],\n    eventsListeners: [\"jboss-logging\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrealm_events = keycloak.RealmEvents(\"realmEvents\",\n    realm_id=realm.id,\n    events_enabled=True,\n    events_expiration=3600,\n    admin_events_enabled=True,\n    admin_events_details_enabled=True,\n    enabled_event_types=[\n        \"LOGIN\",\n        \"LOGOUT\",\n    ],\n    events_listeners=[\"jboss-logging\"])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var realmEvents = new Keycloak.RealmEvents(\"realmEvents\", new Keycloak.RealmEventsArgs\n        {\n            RealmId = realm.Id,\n            EventsEnabled = true,\n            EventsExpiration = 3600,\n            AdminEventsEnabled = true,\n            AdminEventsDetailsEnabled = true,\n            EnabledEventTypes = \n            {\n                \"LOGIN\",\n                \"LOGOUT\",\n            },\n            EventsListeners = \n            {\n                \"jboss-logging\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRealmEvents(ctx, \"realmEvents\", \u0026keycloak.RealmEventsArgs{\n\t\t\tRealmId:                   realm.ID(),\n\t\t\tEventsEnabled:             pulumi.Bool(true),\n\t\t\tEventsExpiration:          pulumi.Int(3600),\n\t\t\tAdminEventsEnabled:        pulumi.Bool(true),\n\t\t\tAdminEventsDetailsEnabled: pulumi.Bool(true),\n\t\t\tEnabledEventTypes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"LOGIN\"),\n\t\t\t\tpulumi.String(\"LOGOUT\"),\n\t\t\t},\n\t\t\tEventsListeners: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"jboss-logging\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "adminEventsDetailsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, saved admin events will included detailed information for create/update requests. Defaults to `false`.\n"
                },
                "adminEventsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, admin events are saved to the database, making them available through the admin console. Defaults to `false`.\n"
                },
                "enabledEventTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The event types that will be saved to the database. Omitting this field enables all event types. Defaults to `[]` or all event types.\n"
                },
                "eventsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, events from `enabled_event_types` are saved to the database, making them available through the admin console. Defaults to `false`.\n"
                },
                "eventsExpiration": {
                    "type": "integer",
                    "description": "The amount of time in seconds events will be saved in the database. Defaults to `0` or never.\n"
                },
                "eventsListeners": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The event listeners that events should be sent to. Defaults to `[]` or none. Note that new realms enable the `jboss-logging` listener by default, and this resource will remove that unless it is specified.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The name of the realm the event settings apply to.\n"
                }
            },
            "required": [
                "realmId"
            ],
            "inputProperties": {
                "adminEventsDetailsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, saved admin events will included detailed information for create/update requests. Defaults to `false`.\n"
                },
                "adminEventsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, admin events are saved to the database, making them available through the admin console. Defaults to `false`.\n"
                },
                "enabledEventTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The event types that will be saved to the database. Omitting this field enables all event types. Defaults to `[]` or all event types.\n"
                },
                "eventsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, events from `enabled_event_types` are saved to the database, making them available through the admin console. Defaults to `false`.\n"
                },
                "eventsExpiration": {
                    "type": "integer",
                    "description": "The amount of time in seconds events will be saved in the database. Defaults to `0` or never.\n"
                },
                "eventsListeners": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The event listeners that events should be sent to. Defaults to `[]` or none. Note that new realms enable the `jboss-logging` listener by default, and this resource will remove that unless it is specified.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The name of the realm the event settings apply to.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RealmEvents resources.\n",
                "properties": {
                    "adminEventsDetailsEnabled": {
                        "type": "boolean",
                        "description": "When `true`, saved admin events will included detailed information for create/update requests. Defaults to `false`.\n"
                    },
                    "adminEventsEnabled": {
                        "type": "boolean",
                        "description": "When `true`, admin events are saved to the database, making them available through the admin console. Defaults to `false`.\n"
                    },
                    "enabledEventTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The event types that will be saved to the database. Omitting this field enables all event types. Defaults to `[]` or all event types.\n"
                    },
                    "eventsEnabled": {
                        "type": "boolean",
                        "description": "When `true`, events from `enabled_event_types` are saved to the database, making them available through the admin console. Defaults to `false`.\n"
                    },
                    "eventsExpiration": {
                        "type": "integer",
                        "description": "The amount of time in seconds events will be saved in the database. Defaults to `0` or never.\n"
                    },
                    "eventsListeners": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The event listeners that events should be sent to. Defaults to `[]` or none. Note that new realms enable the `jboss-logging` listener by default, and this resource will remove that unless it is specified.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The name of the realm the event settings apply to.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/requiredAction:RequiredAction": {
            "properties": {
                "alias": {
                    "type": "string"
                },
                "defaultAction": {
                    "type": "boolean"
                },
                "enabled": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "priority": {
                    "type": "integer"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "required": [
                "alias",
                "name",
                "priority",
                "realmId"
            ],
            "inputProperties": {
                "alias": {
                    "type": "string"
                },
                "defaultAction": {
                    "type": "boolean"
                },
                "enabled": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "priority": {
                    "type": "integer"
                },
                "realmId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "alias",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RequiredAction resources.\n",
                "properties": {
                    "alias": {
                        "type": "string"
                    },
                    "defaultAction": {
                        "type": "boolean"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "priority": {
                        "type": "integer"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/role:Role": {
            "description": "Allows for creating and managing roles within Keycloak.\n\nRoles allow you define privileges within Keycloak and map them to users and groups.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Realm Role)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst realmRole = new keycloak.Role(\"realmRole\", {\n    realmId: realm.id,\n    description: \"My Realm Role\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrealm_role = keycloak.Role(\"realmRole\",\n    realm_id=realm.id,\n    description=\"My Realm Role\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var realmRole = new Keycloak.Role(\"realmRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            Description = \"My Realm Role\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"realmRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Role)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst clientRole = new keycloak.Role(\"clientRole\", {\n    realmId: realm.id,\n    clientId: keycloak_client.openid_client.id,\n    description: \"My Client Role\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nclient_role = keycloak.Role(\"clientRole\",\n    realm_id=realm.id,\n    client_id=keycloak_client[\"openid_client\"][\"id\"],\n    description=\"My Client Role\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var clientRole = new Keycloak.Role(\"clientRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            ClientId = keycloak_client.Openid_client.Id,\n            Description = \"My Client Role\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"clientRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    pulumi.Any(keycloak_client.Openid_client.Id),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Composite Role)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\n// realm roles\nconst createRole = new keycloak.Role(\"createRole\", {realmId: realm.id});\nconst readRole = new keycloak.Role(\"readRole\", {realmId: realm.id});\nconst updateRole = new keycloak.Role(\"updateRole\", {realmId: realm.id});\nconst deleteRole = new keycloak.Role(\"deleteRole\", {realmId: realm.id});\n// client role\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst clientRole = new keycloak.Role(\"clientRole\", {\n    realmId: realm.id,\n    clientId: keycloak_client.openid_client.id,\n    description: \"My Client Role\",\n});\nconst adminRole = new keycloak.Role(\"adminRole\", {\n    realmId: realm.id,\n    compositeRoles: [\n        createRole.id,\n        readRole.id,\n        updateRole.id,\n        deleteRole.id,\n        clientRole.id,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\n# realm roles\ncreate_role = keycloak.Role(\"createRole\", realm_id=realm.id)\nread_role = keycloak.Role(\"readRole\", realm_id=realm.id)\nupdate_role = keycloak.Role(\"updateRole\", realm_id=realm.id)\ndelete_role = keycloak.Role(\"deleteRole\", realm_id=realm.id)\n# client role\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nclient_role = keycloak.Role(\"clientRole\",\n    realm_id=realm.id,\n    client_id=keycloak_client[\"openid_client\"][\"id\"],\n    description=\"My Client Role\")\nadmin_role = keycloak.Role(\"adminRole\",\n    realm_id=realm.id,\n    composite_roles=[\n        create_role.id,\n        read_role.id,\n        update_role.id,\n        delete_role.id,\n        client_role.id,\n    ])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        // realm roles\n        var createRole = new Keycloak.Role(\"createRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n        });\n        var readRole = new Keycloak.Role(\"readRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n        });\n        var updateRole = new Keycloak.Role(\"updateRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n        });\n        var deleteRole = new Keycloak.Role(\"deleteRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n        });\n        // client role\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var clientRole = new Keycloak.Role(\"clientRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            ClientId = keycloak_client.Openid_client.Id,\n            Description = \"My Client Role\",\n        });\n        var adminRole = new Keycloak.Role(\"adminRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            CompositeRoles = \n            {\n                createRole.Id,\n                readRole.Id,\n                updateRole.Id,\n                deleteRole.Id,\n                clientRole.Id,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcreateRole, err := keycloak.NewRole(ctx, \"createRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treadRole, err := keycloak.NewRole(ctx, \"readRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tupdateRole, err := keycloak.NewRole(ctx, \"updateRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdeleteRole, err := keycloak.NewRole(ctx, \"deleteRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientRole, err := keycloak.NewRole(ctx, \"clientRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    pulumi.Any(keycloak_client.Openid_client.Id),\n\t\t\tDescription: pulumi.String(\"My Client Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"adminRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tCompositeRoles: pulumi.StringArray{\n\t\t\t\tcreateRole.ID(),\n\t\t\t\treadRole.ID(),\n\t\t\t\tupdateRole.ID(),\n\t\t\t\tdeleteRole.ID(),\n\t\t\t\tclientRole.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "When specified, this role will be created as a client role attached to the client with the provided ID\n"
                },
                "compositeRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "When specified, this role will be a composite role, composed of all roles that have an ID present within this list.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the role\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the role\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this role exists within.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "When specified, this role will be created as a client role attached to the client with the provided ID\n"
                },
                "compositeRoles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "When specified, this role will be a composite role, composed of all roles that have an ID present within this list.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the role\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the role\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this role exists within.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Role resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "When specified, this role will be created as a client role attached to the client with the provided ID\n"
                    },
                    "compositeRoles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "When specified, this role will be a composite role, composed of all roles that have an ID present within this list.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the role\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the role\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this role exists within.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/user:User": {
            "description": "Allows for creating and managing Users within Keycloak.\n\nThis resource was created primarily to enable the acceptance tests for the `keycloak.Group` resource. Creating users within\nKeycloak is not recommended. Instead, users should be federated from external sources by configuring user federation providers\nor identity providers.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst user = new keycloak.User(\"user\", {\n    realmId: realm.id,\n    username: \"bob\",\n    enabled: true,\n    email: \"bob@domain.com\",\n    firstName: \"Bob\",\n    lastName: \"Bobson\",\n});\nconst userWithInitialPassword = new keycloak.User(\"userWithInitialPassword\", {\n    realmId: realm.id,\n    username: \"alice\",\n    enabled: true,\n    email: \"alice@domain.com\",\n    firstName: \"Alice\",\n    lastName: \"Aliceberg\",\n    attributes: {\n        foo: \"bar\",\n    },\n    initialPassword: {\n        value: \"some password\",\n        temporary: true,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nuser = keycloak.User(\"user\",\n    realm_id=realm.id,\n    username=\"bob\",\n    enabled=True,\n    email=\"bob@domain.com\",\n    first_name=\"Bob\",\n    last_name=\"Bobson\")\nuser_with_initial_password = keycloak.User(\"userWithInitialPassword\",\n    realm_id=realm.id,\n    username=\"alice\",\n    enabled=True,\n    email=\"alice@domain.com\",\n    first_name=\"Alice\",\n    last_name=\"Aliceberg\",\n    attributes={\n        \"foo\": \"bar\",\n    },\n    initial_password=keycloak.UserInitialPasswordArgs(\n        value=\"some password\",\n        temporary=True,\n    ))\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var user = new Keycloak.User(\"user\", new Keycloak.UserArgs\n        {\n            RealmId = realm.Id,\n            Username = \"bob\",\n            Enabled = true,\n            Email = \"bob@domain.com\",\n            FirstName = \"Bob\",\n            LastName = \"Bobson\",\n        });\n        var userWithInitialPassword = new Keycloak.User(\"userWithInitialPassword\", new Keycloak.UserArgs\n        {\n            RealmId = realm.Id,\n            Username = \"alice\",\n            Enabled = true,\n            Email = \"alice@domain.com\",\n            FirstName = \"Alice\",\n            LastName = \"Aliceberg\",\n            Attributes = \n            {\n                { \"foo\", \"bar\" },\n            },\n            InitialPassword = new Keycloak.Inputs.UserInitialPasswordArgs\n            {\n                Value = \"some password\",\n                Temporary = true,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewUser(ctx, \"user\", \u0026keycloak.UserArgs{\n\t\t\tRealmId:   realm.ID(),\n\t\t\tUsername:  pulumi.String(\"bob\"),\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tEmail:     pulumi.String(\"bob@domain.com\"),\n\t\t\tFirstName: pulumi.String(\"Bob\"),\n\t\t\tLastName:  pulumi.String(\"Bobson\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewUser(ctx, \"userWithInitialPassword\", \u0026keycloak.UserArgs{\n\t\t\tRealmId:   realm.ID(),\n\t\t\tUsername:  pulumi.String(\"alice\"),\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tEmail:     pulumi.String(\"alice@domain.com\"),\n\t\t\tFirstName: pulumi.String(\"Alice\"),\n\t\t\tLastName:  pulumi.String(\"Aliceberg\"),\n\t\t\tAttributes: pulumi.StringMap{\n\t\t\t\t\"foo\": pulumi.String(\"bar\"),\n\t\t\t},\n\t\t\tInitialPassword: \u0026keycloak.UserInitialPasswordArgs{\n\t\t\t\tValue:     pulumi.String(\"some password\"),\n\t\t\t\tTemporary: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map representing attributes for the user\n"
                },
                "email": {
                    "type": "string",
                    "description": "The user's email.\n"
                },
                "emailVerified": {
                    "type": "boolean",
                    "description": "Whether the email address was validated or not. Default to `false`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When false, this user cannot log in. Defaults to `true`.\n"
                },
                "federatedIdentities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/UserFederatedIdentity:UserFederatedIdentity"
                    }
                },
                "firstName": {
                    "type": "string",
                    "description": "The user's first name.\n"
                },
                "initialPassword": {
                    "$ref": "#/types/keycloak:index/UserInitialPassword:UserInitialPassword",
                    "description": "When given, the user's initial password will be set. This attribute is only respected during initial user creation.\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "The user's last name.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this user belongs to.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The unique username of this user.\n"
                }
            },
            "required": [
                "realmId",
                "username"
            ],
            "inputProperties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map representing attributes for the user\n"
                },
                "email": {
                    "type": "string",
                    "description": "The user's email.\n"
                },
                "emailVerified": {
                    "type": "boolean",
                    "description": "Whether the email address was validated or not. Default to `false`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When false, this user cannot log in. Defaults to `true`.\n"
                },
                "federatedIdentities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:index/UserFederatedIdentity:UserFederatedIdentity"
                    }
                },
                "firstName": {
                    "type": "string",
                    "description": "The user's first name.\n"
                },
                "initialPassword": {
                    "$ref": "#/types/keycloak:index/UserInitialPassword:UserInitialPassword",
                    "description": "When given, the user's initial password will be set. This attribute is only respected during initial user creation.\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "The user's last name.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this user belongs to.\n"
                },
                "username": {
                    "type": "string",
                    "description": "The unique username of this user.\n"
                }
            },
            "requiredInputs": [
                "realmId",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering User resources.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map representing attributes for the user\n"
                    },
                    "email": {
                        "type": "string",
                        "description": "The user's email.\n"
                    },
                    "emailVerified": {
                        "type": "boolean",
                        "description": "Whether the email address was validated or not. Default to `false`.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When false, this user cannot log in. Defaults to `true`.\n"
                    },
                    "federatedIdentities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/UserFederatedIdentity:UserFederatedIdentity"
                        }
                    },
                    "firstName": {
                        "type": "string",
                        "description": "The user's first name.\n"
                    },
                    "initialPassword": {
                        "$ref": "#/types/keycloak:index/UserInitialPassword:UserInitialPassword",
                        "description": "When given, the user's initial password will be set. This attribute is only respected during initial user creation.\n"
                    },
                    "lastName": {
                        "type": "string",
                        "description": "The user's last name.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this user belongs to.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "The unique username of this user.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/userRoles:UserRoles": {
            "properties": {
                "realmId": {
                    "type": "string",
                    "description": "The realm this user exists in.\n"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of role IDs to map to the user\n"
                },
                "userId": {
                    "type": "string",
                    "description": "The ID of the user this resource should manage roles for.\n"
                }
            },
            "required": [
                "realmId",
                "roleIds",
                "userId"
            ],
            "inputProperties": {
                "realmId": {
                    "type": "string",
                    "description": "The realm this user exists in.\n"
                },
                "roleIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of role IDs to map to the user\n"
                },
                "userId": {
                    "type": "string",
                    "description": "The ID of the user this resource should manage roles for.\n"
                }
            },
            "requiredInputs": [
                "realmId",
                "roleIds",
                "userId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserRoles resources.\n",
                "properties": {
                    "realmId": {
                        "type": "string",
                        "description": "The realm this user exists in.\n"
                    },
                    "roleIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of role IDs to map to the user\n"
                    },
                    "userId": {
                        "type": "string",
                        "description": "The ID of the user this resource should manage roles for.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:index/userTemplateImporterIdentityProviderMapper:UserTemplateImporterIdentityProviderMapper": {
            "properties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "template": {
                    "type": "string",
                    "description": "Username For Template Import\n"
                }
            },
            "required": [
                "identityProviderAlias",
                "name",
                "realm"
            ],
            "inputProperties": {
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "identityProviderAlias": {
                    "type": "string",
                    "description": "IDP Alias\n"
                },
                "name": {
                    "type": "string",
                    "description": "IDP Mapper Name\n"
                },
                "realm": {
                    "type": "string",
                    "description": "Realm Name\n"
                },
                "template": {
                    "type": "string",
                    "description": "Username For Template Import\n"
                }
            },
            "requiredInputs": [
                "identityProviderAlias",
                "realm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserTemplateImporterIdentityProviderMapper resources.\n",
                "properties": {
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "identityProviderAlias": {
                        "type": "string",
                        "description": "IDP Alias\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "IDP Mapper Name\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "Realm Name\n"
                    },
                    "template": {
                        "type": "string",
                        "description": "Username For Template Import\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/fullNameMapper:FullNameMapper": {
            "description": "Allows for creating and managing full name mappers for Keycloak users federated via LDAP.\n\nThe LDAP full name mapper can map a user's full name from an LDAP attribute to the first and last name attributes of a\nKeycloak user.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldapUserFederation\", {\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst ldapFullNameMapper = new keycloak.ldap.FullNameMapper(\"ldapFullNameMapper\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    ldapFullNameAttribute: \"cn\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nldap_full_name_mapper = keycloak.ldap.FullNameMapper(\"ldapFullNameMapper\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    ldap_full_name_attribute=\"cn\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            RealmId = realm.Id,\n            UsernameLdapAttribute = \"cn\",\n            RdnLdapAttribute = \"cn\",\n            UuidLdapAttribute = \"entryDN\",\n            UserObjectClasses = \n            {\n                \"simpleSecurityObject\",\n                \"organizationalRole\",\n            },\n            ConnectionUrl = \"ldap://openldap\",\n            UsersDn = \"dc=example,dc=org\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            BindCredential = \"admin\",\n        });\n        var ldapFullNameMapper = new Keycloak.Ldap.FullNameMapper(\"ldapFullNameMapper\", new Keycloak.Ldap.FullNameMapperArgs\n        {\n            RealmId = realm.Id,\n            LdapUserFederationId = ldapUserFederation.Id,\n            LdapFullNameAttribute = \"cn\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewFullNameMapper(ctx, \"ldapFullNameMapper\", \u0026ldap.FullNameMapperArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tLdapUserFederationId:  ldapUserFederation.ID(),\n\t\t\tLdapFullNameAttribute: pulumi.String(\"cn\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "ldapFullNameAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute containing the user's full name.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "When `true`, updates to a user within Keycloak will not be written back to LDAP. Defaults to `false`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                },
                "writeOnly": {
                    "type": "boolean",
                    "description": "When `true`, this mapper will only be used to write updates to LDAP. Defaults to `false`.\n"
                }
            },
            "required": [
                "ldapFullNameAttribute",
                "ldapUserFederationId",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "ldapFullNameAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute containing the user's full name.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "When `true`, updates to a user within Keycloak will not be written back to LDAP. Defaults to `false`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                },
                "writeOnly": {
                    "type": "boolean",
                    "description": "When `true`, this mapper will only be used to write updates to LDAP. Defaults to `false`.\n"
                }
            },
            "requiredInputs": [
                "ldapFullNameAttribute",
                "ldapUserFederationId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FullNameMapper resources.\n",
                "properties": {
                    "ldapFullNameAttribute": {
                        "type": "string",
                        "description": "The name of the LDAP attribute containing the user's full name.\n"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n"
                    },
                    "readOnly": {
                        "type": "boolean",
                        "description": "When `true`, updates to a user within Keycloak will not be written back to LDAP. Defaults to `false`.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this LDAP mapper will exist in.\n"
                    },
                    "writeOnly": {
                        "type": "boolean",
                        "description": "When `true`, this mapper will only be used to write updates to LDAP. Defaults to `false`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/groupMapper:GroupMapper": {
            "description": "Allows for creating and managing group mappers for Keycloak users federated via LDAP.\n\nThe LDAP group mapper can be used to map an LDAP user's groups from some DN to Keycloak groups. This group mapper will also\ncreate the groups within Keycloak if they do not already exist.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldapUserFederation\", {\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst ldapGroupMapper = new keycloak.ldap.GroupMapper(\"ldapGroupMapper\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    ldapGroupsDn: \"dc=example,dc=org\",\n    groupNameLdapAttribute: \"cn\",\n    groupObjectClasses: [\"groupOfNames\"],\n    membershipAttributeType: \"DN\",\n    membershipLdapAttribute: \"member\",\n    membershipUserLdapAttribute: \"cn\",\n    memberofLdapAttribute: \"memberOf\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nldap_group_mapper = keycloak.ldap.GroupMapper(\"ldapGroupMapper\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    ldap_groups_dn=\"dc=example,dc=org\",\n    group_name_ldap_attribute=\"cn\",\n    group_object_classes=[\"groupOfNames\"],\n    membership_attribute_type=\"DN\",\n    membership_ldap_attribute=\"member\",\n    membership_user_ldap_attribute=\"cn\",\n    memberof_ldap_attribute=\"memberOf\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            RealmId = realm.Id,\n            UsernameLdapAttribute = \"cn\",\n            RdnLdapAttribute = \"cn\",\n            UuidLdapAttribute = \"entryDN\",\n            UserObjectClasses = \n            {\n                \"simpleSecurityObject\",\n                \"organizationalRole\",\n            },\n            ConnectionUrl = \"ldap://openldap\",\n            UsersDn = \"dc=example,dc=org\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            BindCredential = \"admin\",\n        });\n        var ldapGroupMapper = new Keycloak.Ldap.GroupMapper(\"ldapGroupMapper\", new Keycloak.Ldap.GroupMapperArgs\n        {\n            RealmId = realm.Id,\n            LdapUserFederationId = ldapUserFederation.Id,\n            LdapGroupsDn = \"dc=example,dc=org\",\n            GroupNameLdapAttribute = \"cn\",\n            GroupObjectClasses = \n            {\n                \"groupOfNames\",\n            },\n            MembershipAttributeType = \"DN\",\n            MembershipLdapAttribute = \"member\",\n            MembershipUserLdapAttribute = \"cn\",\n            MemberofLdapAttribute = \"memberOf\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewGroupMapper(ctx, \"ldapGroupMapper\", \u0026ldap.GroupMapperArgs{\n\t\t\tRealmId:                realm.ID(),\n\t\t\tLdapUserFederationId:   ldapUserFederation.ID(),\n\t\t\tLdapGroupsDn:           pulumi.String(\"dc=example,dc=org\"),\n\t\t\tGroupNameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tGroupObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"groupOfNames\"),\n\t\t\t},\n\t\t\tMembershipAttributeType:     pulumi.String(\"DN\"),\n\t\t\tMembershipLdapAttribute:     pulumi.String(\"member\"),\n\t\t\tMembershipUserLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tMemberofLdapAttribute:       pulumi.String(\"memberOf\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "dropNonExistingGroupsDuringSync": {
                    "type": "boolean",
                    "description": "When `true`, groups that no longer exist within LDAP will be dropped in Keycloak during sync. Defaults to `false`.\n"
                },
                "groupNameLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute that is used in group objects for the name and RDN of the group. Typically `cn`.\n"
                },
                "groupObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings representing the object classes for the group. Must contain at least one.\n"
                },
                "groupsLdapFilter": {
                    "type": "string",
                    "description": "When specified, adds an additional custom filter to be used when querying for groups. Must start with `(` and end with `)`.\n"
                },
                "ignoreMissingGroups": {
                    "type": "boolean",
                    "description": "When `true`, missing groups in the hierarchy will be ignored.\n"
                },
                "ldapGroupsDn": {
                    "type": "string",
                    "description": "The LDAP DN where groups can be found.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "mappedGroupAttributes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of strings representing attributes on the LDAP group which will be mapped to attributes on the Keycloak group.\n"
                },
                "memberofLdapAttribute": {
                    "type": "string",
                    "description": "Specifies the name of the LDAP attribute on the LDAP user that contains the groups the user is a member of. Defaults to `memberOf`.\n"
                },
                "membershipAttributeType": {
                    "type": "string",
                    "description": "Can be one of `DN` or `UID`. Defaults to `DN`.\n"
                },
                "membershipLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute that is used for membership mappings.\n"
                },
                "membershipUserLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute on a user that is used for membership mappings.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Can be one of `READ_ONLY` or `LDAP_ONLY`. Defaults to `READ_ONLY`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "preserveGroupInheritance": {
                    "type": "boolean",
                    "description": "When `true`, group inheritance will be propagated from LDAP to Keycloak. When `false`, all LDAP groups will be propagated as top level groups within Keycloak.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                },
                "userRolesRetrieveStrategy": {
                    "type": "string",
                    "description": "Can be one of `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE`, `GET_GROUPS_FROM_USER_MEMBEROF_ATTRIBUTE`, or `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE_RECURSIVELY`. Defaults to `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE`.\n"
                }
            },
            "required": [
                "groupNameLdapAttribute",
                "groupObjectClasses",
                "ldapGroupsDn",
                "ldapUserFederationId",
                "membershipLdapAttribute",
                "membershipUserLdapAttribute",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "dropNonExistingGroupsDuringSync": {
                    "type": "boolean",
                    "description": "When `true`, groups that no longer exist within LDAP will be dropped in Keycloak during sync. Defaults to `false`.\n"
                },
                "groupNameLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute that is used in group objects for the name and RDN of the group. Typically `cn`.\n"
                },
                "groupObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of strings representing the object classes for the group. Must contain at least one.\n"
                },
                "groupsLdapFilter": {
                    "type": "string",
                    "description": "When specified, adds an additional custom filter to be used when querying for groups. Must start with `(` and end with `)`.\n"
                },
                "ignoreMissingGroups": {
                    "type": "boolean",
                    "description": "When `true`, missing groups in the hierarchy will be ignored.\n"
                },
                "ldapGroupsDn": {
                    "type": "string",
                    "description": "The LDAP DN where groups can be found.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "mappedGroupAttributes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of strings representing attributes on the LDAP group which will be mapped to attributes on the Keycloak group.\n"
                },
                "memberofLdapAttribute": {
                    "type": "string",
                    "description": "Specifies the name of the LDAP attribute on the LDAP user that contains the groups the user is a member of. Defaults to `memberOf`.\n"
                },
                "membershipAttributeType": {
                    "type": "string",
                    "description": "Can be one of `DN` or `UID`. Defaults to `DN`.\n"
                },
                "membershipLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute that is used for membership mappings.\n"
                },
                "membershipUserLdapAttribute": {
                    "type": "string",
                    "description": "The name of the LDAP attribute on a user that is used for membership mappings.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Can be one of `READ_ONLY` or `LDAP_ONLY`. Defaults to `READ_ONLY`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "preserveGroupInheritance": {
                    "type": "boolean",
                    "description": "When `true`, group inheritance will be propagated from LDAP to Keycloak. When `false`, all LDAP groups will be propagated as top level groups within Keycloak.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                },
                "userRolesRetrieveStrategy": {
                    "type": "string",
                    "description": "Can be one of `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE`, `GET_GROUPS_FROM_USER_MEMBEROF_ATTRIBUTE`, or `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE_RECURSIVELY`. Defaults to `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE`.\n"
                }
            },
            "requiredInputs": [
                "groupNameLdapAttribute",
                "groupObjectClasses",
                "ldapGroupsDn",
                "ldapUserFederationId",
                "membershipLdapAttribute",
                "membershipUserLdapAttribute",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupMapper resources.\n",
                "properties": {
                    "dropNonExistingGroupsDuringSync": {
                        "type": "boolean",
                        "description": "When `true`, groups that no longer exist within LDAP will be dropped in Keycloak during sync. Defaults to `false`.\n"
                    },
                    "groupNameLdapAttribute": {
                        "type": "string",
                        "description": "The name of the LDAP attribute that is used in group objects for the name and RDN of the group. Typically `cn`.\n"
                    },
                    "groupObjectClasses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of strings representing the object classes for the group. Must contain at least one.\n"
                    },
                    "groupsLdapFilter": {
                        "type": "string",
                        "description": "When specified, adds an additional custom filter to be used when querying for groups. Must start with `(` and end with `)`.\n"
                    },
                    "ignoreMissingGroups": {
                        "type": "boolean",
                        "description": "When `true`, missing groups in the hierarchy will be ignored.\n"
                    },
                    "ldapGroupsDn": {
                        "type": "string",
                        "description": "The LDAP DN where groups can be found.\n"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                    },
                    "mappedGroupAttributes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Array of strings representing attributes on the LDAP group which will be mapped to attributes on the Keycloak group.\n"
                    },
                    "memberofLdapAttribute": {
                        "type": "string",
                        "description": "Specifies the name of the LDAP attribute on the LDAP user that contains the groups the user is a member of. Defaults to `memberOf`.\n"
                    },
                    "membershipAttributeType": {
                        "type": "string",
                        "description": "Can be one of `DN` or `UID`. Defaults to `DN`.\n"
                    },
                    "membershipLdapAttribute": {
                        "type": "string",
                        "description": "The name of the LDAP attribute that is used for membership mappings.\n"
                    },
                    "membershipUserLdapAttribute": {
                        "type": "string",
                        "description": "The name of the LDAP attribute on a user that is used for membership mappings.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "Can be one of `READ_ONLY` or `LDAP_ONLY`. Defaults to `READ_ONLY`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n"
                    },
                    "preserveGroupInheritance": {
                        "type": "boolean",
                        "description": "When `true`, group inheritance will be propagated from LDAP to Keycloak. When `false`, all LDAP groups will be propagated as top level groups within Keycloak.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this LDAP mapper will exist in.\n"
                    },
                    "userRolesRetrieveStrategy": {
                        "type": "string",
                        "description": "Can be one of `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE`, `GET_GROUPS_FROM_USER_MEMBEROF_ATTRIBUTE`, or `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE_RECURSIVELY`. Defaults to `LOAD_GROUPS_BY_MEMBER_ATTRIBUTE`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/hardcodedGroupMapper:HardcodedGroupMapper": {
            "properties": {
                "group": {
                    "type": "string",
                    "description": "Group to grant to user.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                }
            },
            "required": [
                "group",
                "ldapUserFederationId",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "group": {
                    "type": "string",
                    "description": "Group to grant to user.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                }
            },
            "requiredInputs": [
                "group",
                "ldapUserFederationId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedGroupMapper resources.\n",
                "properties": {
                    "group": {
                        "type": "string",
                        "description": "Group to grant to user.\n"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ldap user federation provider to attach this mapper to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm in which the ldap user federation provider exists.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/hardcodedRoleMapper:HardcodedRoleMapper": {
            "description": "Allows for creating and managing hardcoded role mappers for Keycloak users federated via LDAP.\n\nThe LDAP hardcoded role mapper will grant a specified Keycloak role to each Keycloak user linked with LDAP.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Realm Role)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldapUserFederation\", {\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst realmAdminRole = new keycloak.Role(\"realmAdminRole\", {\n    realmId: realm.id,\n    description: \"My Realm Role\",\n});\nconst assignAdminRoleToAllUsers = new keycloak.ldap.HardcodedRoleMapper(\"assignAdminRoleToAllUsers\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    role: realmAdminRole.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nrealm_admin_role = keycloak.Role(\"realmAdminRole\",\n    realm_id=realm.id,\n    description=\"My Realm Role\")\nassign_admin_role_to_all_users = keycloak.ldap.HardcodedRoleMapper(\"assignAdminRoleToAllUsers\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    role=realm_admin_role.name)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            RealmId = realm.Id,\n            UsernameLdapAttribute = \"cn\",\n            RdnLdapAttribute = \"cn\",\n            UuidLdapAttribute = \"entryDN\",\n            UserObjectClasses = \n            {\n                \"simpleSecurityObject\",\n                \"organizationalRole\",\n            },\n            ConnectionUrl = \"ldap://openldap\",\n            UsersDn = \"dc=example,dc=org\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            BindCredential = \"admin\",\n        });\n        var realmAdminRole = new Keycloak.Role(\"realmAdminRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            Description = \"My Realm Role\",\n        });\n        var assignAdminRoleToAllUsers = new Keycloak.Ldap.HardcodedRoleMapper(\"assignAdminRoleToAllUsers\", new Keycloak.Ldap.HardcodedRoleMapperArgs\n        {\n            RealmId = realm.Id,\n            LdapUserFederationId = ldapUserFederation.Id,\n            Role = realmAdminRole.Name,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmAdminRole, err := keycloak.NewRole(ctx, \"realmAdminRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tDescription: pulumi.String(\"My Realm Role\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewHardcodedRoleMapper(ctx, \"assignAdminRoleToAllUsers\", \u0026ldap.HardcodedRoleMapperArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t\tRole:                 realmAdminRole.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Role)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldapUserFederation\", {\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst realmManagement = realm.id.apply(id =\u003e keycloak.openid.getClient({\n    realmId: id,\n    clientId: \"realm-management\",\n}));\nconst createClient = pulumi.all([realm.id, realmManagement]).apply(([id, realmManagement]) =\u003e keycloak.getRole({\n    realmId: id,\n    clientId: realmManagement.id,\n    name: \"create-client\",\n}));\nconst assignAdminRoleToAllUsers = new keycloak.ldap.HardcodedRoleMapper(\"assignAdminRoleToAllUsers\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    role: pulumi.interpolate`${realmManagement.clientId}.${createClient.name}`,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nrealm_management = realm.id.apply(lambda id: keycloak.openid.get_client(realm_id=id,\n    client_id=\"realm-management\"))\ncreate_client = pulumi.Output.all(realm.id, realm_management).apply(lambda id, realm_management: keycloak.get_role(realm_id=id,\n    client_id=realm_management.id,\n    name=\"create-client\"))\nassign_admin_role_to_all_users = keycloak.ldap.HardcodedRoleMapper(\"assignAdminRoleToAllUsers\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    role=pulumi.Output.all(realm_management, create_client).apply(lambda realm_management, create_client: f\"{realm_management.client_id}.{create_client.name}\"))\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            RealmId = realm.Id,\n            UsernameLdapAttribute = \"cn\",\n            RdnLdapAttribute = \"cn\",\n            UuidLdapAttribute = \"entryDN\",\n            UserObjectClasses = \n            {\n                \"simpleSecurityObject\",\n                \"organizationalRole\",\n            },\n            ConnectionUrl = \"ldap://openldap\",\n            UsersDn = \"dc=example,dc=org\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            BindCredential = \"admin\",\n        });\n        var realmManagement = realm.Id.Apply(id =\u003e Keycloak.OpenId.GetClient.InvokeAsync(new Keycloak.OpenId.GetClientArgs\n        {\n            RealmId = id,\n            ClientId = \"realm-management\",\n        }));\n        var createClient = Output.Tuple(realm.Id, realmManagement).Apply(values =\u003e\n        {\n            var id = values.Item1;\n            var realmManagement = values.Item2;\n            return Keycloak.GetRole.InvokeAsync(new Keycloak.GetRoleArgs\n            {\n                RealmId = id,\n                ClientId = realmManagement.Id,\n                Name = \"create-client\",\n            });\n        });\n        var assignAdminRoleToAllUsers = new Keycloak.Ldap.HardcodedRoleMapper(\"assignAdminRoleToAllUsers\", new Keycloak.Ldap.HardcodedRoleMapperArgs\n        {\n            RealmId = realm.Id,\n            LdapUserFederationId = ldapUserFederation.Id,\n            Role = Output.Tuple(realmManagement, createClient).Apply(values =\u003e\n            {\n                var realmManagement = values.Item1;\n                var createClient = values.Item2;\n                return $\"{realmManagement.ClientId}.{createClient.Name}\";\n            }),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewHardcodedRoleMapper(ctx, \"assignAdminRoleToAllUsers\", \u0026ldap.HardcodedRoleMapperArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t\tRole: pulumi.All(realmManagement, createClient).ApplyT(func(_args []interface{}) (string, error) {\n\t\t\t\trealmManagement := _args[0].(openid.LookupClientResult)\n\t\t\t\tcreateClient := _args[1].(keycloak.LookupRoleResult)\n\t\t\t\treturn fmt.Sprintf(\"%v%v%v\", realmManagement.ClientId, \".\", createClient.Name), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role which should be assigned to the users. Client roles should use the format `{{client_id}}.{{client_role_name}}`.\n"
                }
            },
            "required": [
                "ldapUserFederationId",
                "name",
                "realmId",
                "role"
            ],
            "inputProperties": {
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role which should be assigned to the users. Client roles should use the format `{{client_id}}.{{client_role_name}}`.\n"
                }
            },
            "requiredInputs": [
                "ldapUserFederationId",
                "realmId",
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedRoleMapper resources.\n",
                "properties": {
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this LDAP mapper will exist in.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the role which should be assigned to the users. Client roles should use the format `{{client_id}}.{{client_role_name}}`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/msadLdsUserAccountControlMapper:MsadLdsUserAccountControlMapper": {
            "description": "Allows for creating and managing MSAD-LDS user account control mappers for Keycloak\nusers federated via LDAP.\n\nThe MSAD-LDS (Microsoft Active Directory Lightweight Directory Service) user account control mapper is specific\nto LDAP user federation providers that are pulling from AD-LDS, and it can propagate\nAD-LDS user state to Keycloak in order to enforce settings like expired passwords\nor disabled accounts.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldapUserFederation\", {\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"objectGUID\",\n    userObjectClasses: [\n        \"person\",\n        \"organizationalPerson\",\n        \"user\",\n    ],\n    connectionUrl: \"ldap://my-ad-server\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst msadLdsUserAccountControlMapper = new keycloak.ldap.MsadLdsUserAccountControlMapper(\"msadLdsUserAccountControlMapper\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"objectGUID\",\n    user_object_classes=[\n        \"person\",\n        \"organizationalPerson\",\n        \"user\",\n    ],\n    connection_url=\"ldap://my-ad-server\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nmsad_lds_user_account_control_mapper = keycloak.ldap.MsadLdsUserAccountControlMapper(\"msadLdsUserAccountControlMapper\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            RealmId = realm.Id,\n            UsernameLdapAttribute = \"cn\",\n            RdnLdapAttribute = \"cn\",\n            UuidLdapAttribute = \"objectGUID\",\n            UserObjectClasses = \n            {\n                \"person\",\n                \"organizationalPerson\",\n                \"user\",\n            },\n            ConnectionUrl = \"ldap://my-ad-server\",\n            UsersDn = \"dc=example,dc=org\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            BindCredential = \"admin\",\n        });\n        var msadLdsUserAccountControlMapper = new Keycloak.Ldap.MsadLdsUserAccountControlMapper(\"msadLdsUserAccountControlMapper\", new Keycloak.Ldap.MsadLdsUserAccountControlMapperArgs\n        {\n            RealmId = realm.Id,\n            LdapUserFederationId = ldapUserFederation.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"objectGUID\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"person\"),\n\t\t\t\tpulumi.String(\"organizationalPerson\"),\n\t\t\t\tpulumi.String(\"user\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://my-ad-server\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewMsadLdsUserAccountControlMapper(ctx, \"msadLdsUserAccountControlMapper\", \u0026ldap.MsadLdsUserAccountControlMapperArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                }
            },
            "required": [
                "ldapUserFederationId",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                }
            },
            "requiredInputs": [
                "ldapUserFederationId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MsadLdsUserAccountControlMapper resources.\n",
                "properties": {
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this LDAP mapper will exist in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/msadUserAccountControlMapper:MsadUserAccountControlMapper": {
            "description": "Allows for creating and managing MSAD user account control mappers for Keycloak\nusers federated via LDAP.\n\nThe MSAD (Microsoft Active Directory) user account control mapper is specific\nto LDAP user federation providers that are pulling from AD, and it can propagate\nAD user state to Keycloak in order to enforce settings like expired passwords\nor disabled accounts.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldapUserFederation\", {\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"objectGUID\",\n    userObjectClasses: [\n        \"person\",\n        \"organizationalPerson\",\n        \"user\",\n    ],\n    connectionUrl: \"ldap://my-ad-server\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst msadUserAccountControlMapper = new keycloak.ldap.MsadUserAccountControlMapper(\"msadUserAccountControlMapper\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"objectGUID\",\n    user_object_classes=[\n        \"person\",\n        \"organizationalPerson\",\n        \"user\",\n    ],\n    connection_url=\"ldap://my-ad-server\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nmsad_user_account_control_mapper = keycloak.ldap.MsadUserAccountControlMapper(\"msadUserAccountControlMapper\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            RealmId = realm.Id,\n            UsernameLdapAttribute = \"cn\",\n            RdnLdapAttribute = \"cn\",\n            UuidLdapAttribute = \"objectGUID\",\n            UserObjectClasses = \n            {\n                \"person\",\n                \"organizationalPerson\",\n                \"user\",\n            },\n            ConnectionUrl = \"ldap://my-ad-server\",\n            UsersDn = \"dc=example,dc=org\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            BindCredential = \"admin\",\n        });\n        var msadUserAccountControlMapper = new Keycloak.Ldap.MsadUserAccountControlMapper(\"msadUserAccountControlMapper\", new Keycloak.Ldap.MsadUserAccountControlMapperArgs\n        {\n            RealmId = realm.Id,\n            LdapUserFederationId = ldapUserFederation.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"objectGUID\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"person\"),\n\t\t\t\tpulumi.String(\"organizationalPerson\"),\n\t\t\t\tpulumi.String(\"user\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://my-ad-server\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewMsadUserAccountControlMapper(ctx, \"msadUserAccountControlMapper\", \u0026ldap.MsadUserAccountControlMapperArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "ldapPasswordPolicyHintsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, advanced password policies, such as password hints and previous password history will be used when writing new passwords to AD. Defaults to `false`.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                }
            },
            "required": [
                "ldapUserFederationId",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "ldapPasswordPolicyHintsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, advanced password policies, such as password hints and previous password history will be used when writing new passwords to AD. Defaults to `false`.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                }
            },
            "requiredInputs": [
                "ldapUserFederationId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MsadUserAccountControlMapper resources.\n",
                "properties": {
                    "ldapPasswordPolicyHintsEnabled": {
                        "type": "boolean",
                        "description": "When `true`, advanced password policies, such as password hints and previous password history will be used when writing new passwords to AD. Defaults to `false`.\n"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this LDAP mapper will exist in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/roleMapper:RoleMapper": {
            "properties": {
                "clientId": {
                    "type": "string"
                },
                "ldapRolesDn": {
                    "type": "string"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "memberofLdapAttribute": {
                    "type": "string"
                },
                "membershipAttributeType": {
                    "type": "string"
                },
                "membershipLdapAttribute": {
                    "type": "string"
                },
                "membershipUserLdapAttribute": {
                    "type": "string"
                },
                "mode": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                },
                "roleNameLdapAttribute": {
                    "type": "string"
                },
                "roleObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "rolesLdapFilter": {
                    "type": "string"
                },
                "useRealmRolesMapping": {
                    "type": "boolean"
                },
                "userRolesRetrieveStrategy": {
                    "type": "string"
                }
            },
            "required": [
                "ldapRolesDn",
                "ldapUserFederationId",
                "membershipLdapAttribute",
                "membershipUserLdapAttribute",
                "name",
                "realmId",
                "roleNameLdapAttribute",
                "roleObjectClasses"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string"
                },
                "ldapRolesDn": {
                    "type": "string"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ldap user federation provider to attach this mapper to.\n"
                },
                "memberofLdapAttribute": {
                    "type": "string"
                },
                "membershipAttributeType": {
                    "type": "string"
                },
                "membershipLdapAttribute": {
                    "type": "string"
                },
                "membershipUserLdapAttribute": {
                    "type": "string"
                },
                "mode": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the mapper when displayed in the console.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm in which the ldap user federation provider exists.\n"
                },
                "roleNameLdapAttribute": {
                    "type": "string"
                },
                "roleObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "rolesLdapFilter": {
                    "type": "string"
                },
                "useRealmRolesMapping": {
                    "type": "boolean"
                },
                "userRolesRetrieveStrategy": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "ldapRolesDn",
                "ldapUserFederationId",
                "membershipLdapAttribute",
                "membershipUserLdapAttribute",
                "realmId",
                "roleNameLdapAttribute",
                "roleObjectClasses"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering RoleMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "ldapRolesDn": {
                        "type": "string"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ldap user federation provider to attach this mapper to.\n"
                    },
                    "memberofLdapAttribute": {
                        "type": "string"
                    },
                    "membershipAttributeType": {
                        "type": "string"
                    },
                    "membershipLdapAttribute": {
                        "type": "string"
                    },
                    "membershipUserLdapAttribute": {
                        "type": "string"
                    },
                    "mode": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the mapper when displayed in the console.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm in which the ldap user federation provider exists.\n"
                    },
                    "roleNameLdapAttribute": {
                        "type": "string"
                    },
                    "roleObjectClasses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "rolesLdapFilter": {
                        "type": "string"
                    },
                    "useRealmRolesMapping": {
                        "type": "boolean"
                    },
                    "userRolesRetrieveStrategy": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/userAttributeMapper:UserAttributeMapper": {
            "description": "Allows for creating and managing user attribute mappers for Keycloak users\nfederated via LDAP.\n\nThe LDAP user attribute mapper can be used to map a single LDAP attribute\nto an attribute on the Keycloak user model.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldapUserFederation\", {\n    realmId: realm.id,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n});\nconst ldapUserAttributeMapper = new keycloak.ldap.UserAttributeMapper(\"ldapUserAttributeMapper\", {\n    realmId: realm.id,\n    ldapUserFederationId: ldapUserFederation.id,\n    userModelAttribute: \"foo\",\n    ldapAttribute: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    realm_id=realm.id,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\")\nldap_user_attribute_mapper = keycloak.ldap.UserAttributeMapper(\"ldapUserAttributeMapper\",\n    realm_id=realm.id,\n    ldap_user_federation_id=ldap_user_federation.id,\n    user_model_attribute=\"foo\",\n    ldap_attribute=\"bar\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            RealmId = realm.Id,\n            UsernameLdapAttribute = \"cn\",\n            RdnLdapAttribute = \"cn\",\n            UuidLdapAttribute = \"entryDN\",\n            UserObjectClasses = \n            {\n                \"simpleSecurityObject\",\n                \"organizationalRole\",\n            },\n            ConnectionUrl = \"ldap://openldap\",\n            UsersDn = \"dc=example,dc=org\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            BindCredential = \"admin\",\n        });\n        var ldapUserAttributeMapper = new Keycloak.Ldap.UserAttributeMapper(\"ldapUserAttributeMapper\", new Keycloak.Ldap.UserAttributeMapperArgs\n        {\n            RealmId = realm.Id,\n            LdapUserFederationId = ldapUserFederation.Id,\n            UserModelAttribute = \"foo\",\n            LdapAttribute = \"bar\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tldapUserFederation, err := ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:  pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:        pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:         pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential: pulumi.String(\"admin\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewUserAttributeMapper(ctx, \"ldapUserAttributeMapper\", \u0026ldap.UserAttributeMapperArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tLdapUserFederationId: ldapUserFederation.ID(),\n\t\t\tUserModelAttribute:   pulumi.String(\"foo\"),\n\t\t\tLdapAttribute:        pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "alwaysReadValueFromLdap": {
                    "type": "boolean",
                    "description": "When `true`, the value fetched from LDAP will override the value stored in Keycloak. Defaults to `false`.\n"
                },
                "isMandatoryInLdap": {
                    "type": "boolean",
                    "description": "When `true`, this attribute must exist in LDAP. Defaults to `false`.\n"
                },
                "ldapAttribute": {
                    "type": "string",
                    "description": "Name of the mapped attribute on the LDAP object.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "When `true`, this attribute is not saved back to LDAP when the user attribute is updated in Keycloak. Defaults to `false`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                },
                "userModelAttribute": {
                    "type": "string",
                    "description": "Name of the user property or attribute you want to map the LDAP attribute into.\n"
                }
            },
            "required": [
                "ldapAttribute",
                "ldapUserFederationId",
                "name",
                "realmId",
                "userModelAttribute"
            ],
            "inputProperties": {
                "alwaysReadValueFromLdap": {
                    "type": "boolean",
                    "description": "When `true`, the value fetched from LDAP will override the value stored in Keycloak. Defaults to `false`.\n"
                },
                "isMandatoryInLdap": {
                    "type": "boolean",
                    "description": "When `true`, this attribute must exist in LDAP. Defaults to `false`.\n"
                },
                "ldapAttribute": {
                    "type": "string",
                    "description": "Name of the mapped attribute on the LDAP object.\n"
                },
                "ldapUserFederationId": {
                    "type": "string",
                    "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of this mapper when displayed in the console.\n"
                },
                "readOnly": {
                    "type": "boolean",
                    "description": "When `true`, this attribute is not saved back to LDAP when the user attribute is updated in Keycloak. Defaults to `false`.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this LDAP mapper will exist in.\n"
                },
                "userModelAttribute": {
                    "type": "string",
                    "description": "Name of the user property or attribute you want to map the LDAP attribute into.\n"
                }
            },
            "requiredInputs": [
                "ldapAttribute",
                "ldapUserFederationId",
                "realmId",
                "userModelAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserAttributeMapper resources.\n",
                "properties": {
                    "alwaysReadValueFromLdap": {
                        "type": "boolean",
                        "description": "When `true`, the value fetched from LDAP will override the value stored in Keycloak. Defaults to `false`.\n"
                    },
                    "isMandatoryInLdap": {
                        "type": "boolean",
                        "description": "When `true`, this attribute must exist in LDAP. Defaults to `false`.\n"
                    },
                    "ldapAttribute": {
                        "type": "string",
                        "description": "Name of the mapped attribute on the LDAP object.\n"
                    },
                    "ldapUserFederationId": {
                        "type": "string",
                        "description": "The ID of the LDAP user federation provider to attach this mapper to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of this mapper when displayed in the console.\n"
                    },
                    "readOnly": {
                        "type": "boolean",
                        "description": "When `true`, this attribute is not saved back to LDAP when the user attribute is updated in Keycloak. Defaults to `false`.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this LDAP mapper will exist in.\n"
                    },
                    "userModelAttribute": {
                        "type": "string",
                        "description": "Name of the user property or attribute you want to map the LDAP attribute into.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:ldap/userFederation:UserFederation": {
            "description": "Allows for creating and managing LDAP user federation providers within Keycloak.\n\nKeycloak can use an LDAP user federation provider to federate users to Keycloak\nfrom a directory system such as LDAP or Active Directory. Federated users\nwill exist within the realm and will be able to log in to clients. Federated\nusers can have their attributes defined using mappers.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst ldapUserFederation = new keycloak.ldap.UserFederation(\"ldapUserFederation\", {\n    realmId: realm.id,\n    enabled: true,\n    usernameLdapAttribute: \"cn\",\n    rdnLdapAttribute: \"cn\",\n    uuidLdapAttribute: \"entryDN\",\n    userObjectClasses: [\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connectionUrl: \"ldap://openldap\",\n    usersDn: \"dc=example,dc=org\",\n    bindDn: \"cn=admin,dc=example,dc=org\",\n    bindCredential: \"admin\",\n    connectionTimeout: \"5s\",\n    readTimeout: \"10s\",\n    kerberos: {\n        kerberosRealm: \"FOO.LOCAL\",\n        serverPrincipal: \"HTTP/host.foo.com@FOO.LOCAL\",\n        keytab: \"/etc/host.keytab\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nldap_user_federation = keycloak.ldap.UserFederation(\"ldapUserFederation\",\n    realm_id=realm.id,\n    enabled=True,\n    username_ldap_attribute=\"cn\",\n    rdn_ldap_attribute=\"cn\",\n    uuid_ldap_attribute=\"entryDN\",\n    user_object_classes=[\n        \"simpleSecurityObject\",\n        \"organizationalRole\",\n    ],\n    connection_url=\"ldap://openldap\",\n    users_dn=\"dc=example,dc=org\",\n    bind_dn=\"cn=admin,dc=example,dc=org\",\n    bind_credential=\"admin\",\n    connection_timeout=\"5s\",\n    read_timeout=\"10s\",\n    kerberos=keycloak.ldap.UserFederationKerberosArgs(\n        kerberos_realm=\"FOO.LOCAL\",\n        server_principal=\"HTTP/host.foo.com@FOO.LOCAL\",\n        keytab=\"/etc/host.keytab\",\n    ))\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var ldapUserFederation = new Keycloak.Ldap.UserFederation(\"ldapUserFederation\", new Keycloak.Ldap.UserFederationArgs\n        {\n            RealmId = realm.Id,\n            Enabled = true,\n            UsernameLdapAttribute = \"cn\",\n            RdnLdapAttribute = \"cn\",\n            UuidLdapAttribute = \"entryDN\",\n            UserObjectClasses = \n            {\n                \"simpleSecurityObject\",\n                \"organizationalRole\",\n            },\n            ConnectionUrl = \"ldap://openldap\",\n            UsersDn = \"dc=example,dc=org\",\n            BindDn = \"cn=admin,dc=example,dc=org\",\n            BindCredential = \"admin\",\n            ConnectionTimeout = \"5s\",\n            ReadTimeout = \"10s\",\n            Kerberos = new Keycloak.Ldap.Inputs.UserFederationKerberosArgs\n            {\n                KerberosRealm = \"FOO.LOCAL\",\n                ServerPrincipal = \"HTTP/host.foo.com@FOO.LOCAL\",\n                Keytab = \"/etc/host.keytab\",\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/ldap\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ldap.NewUserFederation(ctx, \"ldapUserFederation\", \u0026ldap.UserFederationArgs{\n\t\t\tRealmId:               realm.ID(),\n\t\t\tEnabled:               pulumi.Bool(true),\n\t\t\tUsernameLdapAttribute: pulumi.String(\"cn\"),\n\t\t\tRdnLdapAttribute:      pulumi.String(\"cn\"),\n\t\t\tUuidLdapAttribute:     pulumi.String(\"entryDN\"),\n\t\t\tUserObjectClasses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"simpleSecurityObject\"),\n\t\t\t\tpulumi.String(\"organizationalRole\"),\n\t\t\t},\n\t\t\tConnectionUrl:     pulumi.String(\"ldap://openldap\"),\n\t\t\tUsersDn:           pulumi.String(\"dc=example,dc=org\"),\n\t\t\tBindDn:            pulumi.String(\"cn=admin,dc=example,dc=org\"),\n\t\t\tBindCredential:    pulumi.String(\"admin\"),\n\t\t\tConnectionTimeout: pulumi.String(\"5s\"),\n\t\t\tReadTimeout:       pulumi.String(\"10s\"),\n\t\t\tKerberos: \u0026ldap.UserFederationKerberosArgs{\n\t\t\t\tKerberosRealm:   pulumi.String(\"FOO.LOCAL\"),\n\t\t\t\tServerPrincipal: pulumi.String(\"HTTP/host.foo.com@FOO.LOCAL\"),\n\t\t\t\tKeytab:          pulumi.String(\"/etc/host.keytab\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "batchSizeForSync": {
                    "type": "integer",
                    "description": "The number of users to sync within a single transaction. Defaults to `1000`.\n"
                },
                "bindCredential": {
                    "type": "string",
                    "description": "Password of LDAP admin. This attribute must be set if `bind_dn` is set.\n"
                },
                "bindDn": {
                    "type": "string",
                    "description": "DN of LDAP admin, which will be used by Keycloak to access LDAP server. This attribute must be set if `bind_credential` is set.\n"
                },
                "cache": {
                    "$ref": "#/types/keycloak:ldap/UserFederationCache:UserFederationCache",
                    "description": "A block containing the cache settings.\n"
                },
                "cachePolicy": {
                    "type": "string",
                    "description": "**Deprecated** Can be one of `DEFAULT`, `EVICT_DAILY`, `EVICT_WEEKLY`, `MAX_LIFESPAN`, or `NO_CACHE`. Defaults to `DEFAULT`.\n",
                    "deprecationMessage": "use cache.policy instead"
                },
                "changedSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync changed LDAP users, in seconds. Omit this property to disable periodic changed users sync.\n"
                },
                "connectionTimeout": {
                    "type": "string",
                    "description": "LDAP connection timeout in the format of a [Go duration string](https://golang.org/pkg/time/#Duration.String).\n"
                },
                "connectionUrl": {
                    "type": "string",
                    "description": "Connection URL to the LDAP server.\n"
                },
                "customUserSearchFilter": {
                    "type": "string",
                    "description": "Additional LDAP filter for filtering searched users. Must begin with `(` and end with `)`.\n"
                },
                "editMode": {
                    "type": "string",
                    "description": "Can be one of `READ_ONLY`, `WRITABLE`, or `UNSYNCED`. `UNSYNCED` allows user data to be imported but not synced back to LDAP. Defaults to `READ_ONLY`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, this provider will not be used when performing queries for users. Defaults to `true`.\n"
                },
                "fullSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync all LDAP users, in seconds. Omit this property to disable periodic full sync.\n"
                },
                "importEnabled": {
                    "type": "boolean",
                    "description": "When `true`, LDAP users will be imported into the Keycloak database. Defaults to `true`.\n"
                },
                "kerberos": {
                    "$ref": "#/types/keycloak:ldap/UserFederationKerberos:UserFederationKerberos",
                    "description": "A block containing the kerberos settings.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the provider when displayed in the console.\n"
                },
                "pagination": {
                    "type": "boolean",
                    "description": "When true, Keycloak assumes the LDAP server supports pagination. Defaults to `true`.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of this provider when looking up users. Lower values are first. Defaults to `0`.\n"
                },
                "rdnLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as the relative distinguished name.\n"
                },
                "readTimeout": {
                    "type": "string",
                    "description": "LDAP read timeout in the format of a [Go duration string](https://golang.org/pkg/time/#Duration.String).\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this provider will provide user federation for.\n"
                },
                "searchScope": {
                    "type": "string",
                    "description": "Can be one of `ONE_LEVEL` or `SUBTREE`:\n- `ONE_LEVEL`: Only search for users in the DN specified by `user_dn`.\n- `SUBTREE`: Search entire LDAP subtree.\n"
                },
                "syncRegistrations": {
                    "type": "boolean",
                    "description": "When `true`, newly created users will be synced back to LDAP. Defaults to `false`.\n"
                },
                "useTruststoreSpi": {
                    "type": "string",
                    "description": "Can be one of `ALWAYS`, `ONLY_FOR_LDAPS`, or `NEVER`:\n"
                },
                "userObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of all values of LDAP objectClass attribute for users in LDAP. Must contain at least one.\n"
                },
                "usernameLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as the Keycloak username.\n"
                },
                "usersDn": {
                    "type": "string",
                    "description": "Full DN of LDAP tree where your users are.\n"
                },
                "uuidLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as a unique object identifier for objects in LDAP.\n"
                },
                "validatePasswordPolicy": {
                    "type": "boolean",
                    "description": "When `true`, Keycloak will validate passwords using the realm policy before updating it.\n"
                },
                "vendor": {
                    "type": "string",
                    "description": "Can be one of `OTHER`, `EDIRECTORY`, `AD`, `RHDS`, or `TIVOLI`. When this is selected in the GUI, it provides reasonable defaults for other fields. When used with the Keycloak API, this attribute does nothing, but is still required. Defaults to `OTHER`.\n"
                }
            },
            "required": [
                "connectionUrl",
                "name",
                "rdnLdapAttribute",
                "realmId",
                "userObjectClasses",
                "usernameLdapAttribute",
                "usersDn",
                "uuidLdapAttribute"
            ],
            "inputProperties": {
                "batchSizeForSync": {
                    "type": "integer",
                    "description": "The number of users to sync within a single transaction. Defaults to `1000`.\n"
                },
                "bindCredential": {
                    "type": "string",
                    "description": "Password of LDAP admin. This attribute must be set if `bind_dn` is set.\n"
                },
                "bindDn": {
                    "type": "string",
                    "description": "DN of LDAP admin, which will be used by Keycloak to access LDAP server. This attribute must be set if `bind_credential` is set.\n"
                },
                "cache": {
                    "$ref": "#/types/keycloak:ldap/UserFederationCache:UserFederationCache",
                    "description": "A block containing the cache settings.\n"
                },
                "cachePolicy": {
                    "type": "string",
                    "description": "**Deprecated** Can be one of `DEFAULT`, `EVICT_DAILY`, `EVICT_WEEKLY`, `MAX_LIFESPAN`, or `NO_CACHE`. Defaults to `DEFAULT`.\n",
                    "deprecationMessage": "use cache.policy instead"
                },
                "changedSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync changed LDAP users, in seconds. Omit this property to disable periodic changed users sync.\n"
                },
                "connectionTimeout": {
                    "type": "string",
                    "description": "LDAP connection timeout in the format of a [Go duration string](https://golang.org/pkg/time/#Duration.String).\n"
                },
                "connectionUrl": {
                    "type": "string",
                    "description": "Connection URL to the LDAP server.\n"
                },
                "customUserSearchFilter": {
                    "type": "string",
                    "description": "Additional LDAP filter for filtering searched users. Must begin with `(` and end with `)`.\n"
                },
                "editMode": {
                    "type": "string",
                    "description": "Can be one of `READ_ONLY`, `WRITABLE`, or `UNSYNCED`. `UNSYNCED` allows user data to be imported but not synced back to LDAP. Defaults to `READ_ONLY`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, this provider will not be used when performing queries for users. Defaults to `true`.\n"
                },
                "fullSyncPeriod": {
                    "type": "integer",
                    "description": "How frequently Keycloak should sync all LDAP users, in seconds. Omit this property to disable periodic full sync.\n"
                },
                "importEnabled": {
                    "type": "boolean",
                    "description": "When `true`, LDAP users will be imported into the Keycloak database. Defaults to `true`.\n"
                },
                "kerberos": {
                    "$ref": "#/types/keycloak:ldap/UserFederationKerberos:UserFederationKerberos",
                    "description": "A block containing the kerberos settings.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Display name of the provider when displayed in the console.\n"
                },
                "pagination": {
                    "type": "boolean",
                    "description": "When true, Keycloak assumes the LDAP server supports pagination. Defaults to `true`.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of this provider when looking up users. Lower values are first. Defaults to `0`.\n"
                },
                "rdnLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as the relative distinguished name.\n"
                },
                "readTimeout": {
                    "type": "string",
                    "description": "LDAP read timeout in the format of a [Go duration string](https://golang.org/pkg/time/#Duration.String).\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm that this provider will provide user federation for.\n"
                },
                "searchScope": {
                    "type": "string",
                    "description": "Can be one of `ONE_LEVEL` or `SUBTREE`:\n- `ONE_LEVEL`: Only search for users in the DN specified by `user_dn`.\n- `SUBTREE`: Search entire LDAP subtree.\n"
                },
                "syncRegistrations": {
                    "type": "boolean",
                    "description": "When `true`, newly created users will be synced back to LDAP. Defaults to `false`.\n"
                },
                "useTruststoreSpi": {
                    "type": "string",
                    "description": "Can be one of `ALWAYS`, `ONLY_FOR_LDAPS`, or `NEVER`:\n"
                },
                "userObjectClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of all values of LDAP objectClass attribute for users in LDAP. Must contain at least one.\n"
                },
                "usernameLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as the Keycloak username.\n"
                },
                "usersDn": {
                    "type": "string",
                    "description": "Full DN of LDAP tree where your users are.\n"
                },
                "uuidLdapAttribute": {
                    "type": "string",
                    "description": "Name of the LDAP attribute to use as a unique object identifier for objects in LDAP.\n"
                },
                "validatePasswordPolicy": {
                    "type": "boolean",
                    "description": "When `true`, Keycloak will validate passwords using the realm policy before updating it.\n"
                },
                "vendor": {
                    "type": "string",
                    "description": "Can be one of `OTHER`, `EDIRECTORY`, `AD`, `RHDS`, or `TIVOLI`. When this is selected in the GUI, it provides reasonable defaults for other fields. When used with the Keycloak API, this attribute does nothing, but is still required. Defaults to `OTHER`.\n"
                }
            },
            "requiredInputs": [
                "connectionUrl",
                "rdnLdapAttribute",
                "realmId",
                "userObjectClasses",
                "usernameLdapAttribute",
                "usersDn",
                "uuidLdapAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserFederation resources.\n",
                "properties": {
                    "batchSizeForSync": {
                        "type": "integer",
                        "description": "The number of users to sync within a single transaction. Defaults to `1000`.\n"
                    },
                    "bindCredential": {
                        "type": "string",
                        "description": "Password of LDAP admin. This attribute must be set if `bind_dn` is set.\n"
                    },
                    "bindDn": {
                        "type": "string",
                        "description": "DN of LDAP admin, which will be used by Keycloak to access LDAP server. This attribute must be set if `bind_credential` is set.\n"
                    },
                    "cache": {
                        "$ref": "#/types/keycloak:ldap/UserFederationCache:UserFederationCache",
                        "description": "A block containing the cache settings.\n"
                    },
                    "cachePolicy": {
                        "type": "string",
                        "description": "**Deprecated** Can be one of `DEFAULT`, `EVICT_DAILY`, `EVICT_WEEKLY`, `MAX_LIFESPAN`, or `NO_CACHE`. Defaults to `DEFAULT`.\n",
                        "deprecationMessage": "use cache.policy instead"
                    },
                    "changedSyncPeriod": {
                        "type": "integer",
                        "description": "How frequently Keycloak should sync changed LDAP users, in seconds. Omit this property to disable periodic changed users sync.\n"
                    },
                    "connectionTimeout": {
                        "type": "string",
                        "description": "LDAP connection timeout in the format of a [Go duration string](https://golang.org/pkg/time/#Duration.String).\n"
                    },
                    "connectionUrl": {
                        "type": "string",
                        "description": "Connection URL to the LDAP server.\n"
                    },
                    "customUserSearchFilter": {
                        "type": "string",
                        "description": "Additional LDAP filter for filtering searched users. Must begin with `(` and end with `)`.\n"
                    },
                    "editMode": {
                        "type": "string",
                        "description": "Can be one of `READ_ONLY`, `WRITABLE`, or `UNSYNCED`. `UNSYNCED` allows user data to be imported but not synced back to LDAP. Defaults to `READ_ONLY`.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, this provider will not be used when performing queries for users. Defaults to `true`.\n"
                    },
                    "fullSyncPeriod": {
                        "type": "integer",
                        "description": "How frequently Keycloak should sync all LDAP users, in seconds. Omit this property to disable periodic full sync.\n"
                    },
                    "importEnabled": {
                        "type": "boolean",
                        "description": "When `true`, LDAP users will be imported into the Keycloak database. Defaults to `true`.\n"
                    },
                    "kerberos": {
                        "$ref": "#/types/keycloak:ldap/UserFederationKerberos:UserFederationKerberos",
                        "description": "A block containing the kerberos settings.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Display name of the provider when displayed in the console.\n"
                    },
                    "pagination": {
                        "type": "boolean",
                        "description": "When true, Keycloak assumes the LDAP server supports pagination. Defaults to `true`.\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority of this provider when looking up users. Lower values are first. Defaults to `0`.\n"
                    },
                    "rdnLdapAttribute": {
                        "type": "string",
                        "description": "Name of the LDAP attribute to use as the relative distinguished name.\n"
                    },
                    "readTimeout": {
                        "type": "string",
                        "description": "LDAP read timeout in the format of a [Go duration string](https://golang.org/pkg/time/#Duration.String).\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that this provider will provide user federation for.\n"
                    },
                    "searchScope": {
                        "type": "string",
                        "description": "Can be one of `ONE_LEVEL` or `SUBTREE`:\n- `ONE_LEVEL`: Only search for users in the DN specified by `user_dn`.\n- `SUBTREE`: Search entire LDAP subtree.\n"
                    },
                    "syncRegistrations": {
                        "type": "boolean",
                        "description": "When `true`, newly created users will be synced back to LDAP. Defaults to `false`.\n"
                    },
                    "useTruststoreSpi": {
                        "type": "string",
                        "description": "Can be one of `ALWAYS`, `ONLY_FOR_LDAPS`, or `NEVER`:\n"
                    },
                    "userObjectClasses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Array of all values of LDAP objectClass attribute for users in LDAP. Must contain at least one.\n"
                    },
                    "usernameLdapAttribute": {
                        "type": "string",
                        "description": "Name of the LDAP attribute to use as the Keycloak username.\n"
                    },
                    "usersDn": {
                        "type": "string",
                        "description": "Full DN of LDAP tree where your users are.\n"
                    },
                    "uuidLdapAttribute": {
                        "type": "string",
                        "description": "Name of the LDAP attribute to use as a unique object identifier for objects in LDAP.\n"
                    },
                    "validatePasswordPolicy": {
                        "type": "boolean",
                        "description": "When `true`, Keycloak will validate passwords using the realm policy before updating it.\n"
                    },
                    "vendor": {
                        "type": "string",
                        "description": "Can be one of `OTHER`, `EDIRECTORY`, `AD`, `RHDS`, or `TIVOLI`. When this is selected in the GUI, it provides reasonable defaults for other fields. When used with the Keycloak API, this attribute does nothing, but is still required. Defaults to `OTHER`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:oidc/googleIdentityProvider:GoogleIdentityProvider": {
            "description": "Allows for creating and managing OIDC Identity Providers within Keycloak.\n\nOIDC (OpenID Connect) identity providers allows users to authenticate through a third party system using the OIDC standard.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst google = new keycloak.oidc.GoogleIdentityProvider(\"google\", {\n    realm: realm.id,\n    clientId: _var.google_identity_provider_client_id,\n    clientSecret: _var.google_identity_provider_client_secret,\n    trustEmail: true,\n    hostedDomain: \"example.com\",\n    extraConfig: {\n        syncMode: \"IMPORT\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\ngoogle = keycloak.oidc.GoogleIdentityProvider(\"google\",\n    realm=realm.id,\n    client_id=var[\"google_identity_provider_client_id\"],\n    client_secret=var[\"google_identity_provider_client_secret\"],\n    trust_email=True,\n    hosted_domain=\"example.com\",\n    extra_config={\n        \"syncMode\": \"IMPORT\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var google = new Keycloak.Oidc.GoogleIdentityProvider(\"google\", new Keycloak.Oidc.GoogleIdentityProviderArgs\n        {\n            Realm = realm.Id,\n            ClientId = @var.Google_identity_provider_client_id,\n            ClientSecret = @var.Google_identity_provider_client_secret,\n            TrustEmail = true,\n            HostedDomain = \"example.com\",\n            ExtraConfig = \n            {\n                { \"syncMode\", \"IMPORT\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/oidc\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = oidc.NewGoogleIdentityProvider(ctx, \"google\", \u0026oidc.GoogleIdentityProviderArgs{\n\t\t\tRealm:        realm.ID(),\n\t\t\tClientId:     pulumi.Any(_var.Google_identity_provider_client_id),\n\t\t\tClientSecret: pulumi.Any(_var.Google_identity_provider_client_secret),\n\t\t\tTrustEmail:   pulumi.Bool(true),\n\t\t\tHostedDomain: pulumi.String(\"example.com\"),\n\t\t\tExtraConfig: pulumi.StringMap{\n\t\t\t\t\"syncMode\": pulumi.String(\"IMPORT\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "acceptsPromptNoneForwardFromClient": {
                    "type": "boolean",
                    "description": "When `true`, unauthenticated requests with `prompt=none` will be forwarded to Google instead of returning an error. Defaults to `false`.\n"
                },
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                },
                "alias": {
                    "type": "string",
                    "description": "(Computed) The alias for the Google identity provider.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client or client identifier registered within the identity provider.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use $${vault.ID} format.\n"
                },
                "defaultScopes": {
                    "type": "string",
                    "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to `openid profile email`.\n"
                },
                "disableUserInfo": {
                    "type": "boolean",
                    "description": "When `true`, disables the usage of the user info service to obtain additional user information. Defaults to `false`.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "(Computed) Display name for the Google identity provider in the GUI.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `true`, users will be able to log in to this realm using this identity provider. Defaults to `true`.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use when users log in for the first time through this identity provider. Defaults to `first broker login`.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "When `true`, this identity provider will be hidden on the login page. Defaults to `false`.\n"
                },
                "hostedDomain": {
                    "type": "string",
                    "description": "Sets the \"hd\" query parameter when logging in with Google. Google will only list accounts for this domain. Keycloak will validate that the returned identity token has a claim for this domain. When `*` is entered, an account from any domain can be used.\n"
                },
                "internalId": {
                    "type": "string",
                    "description": "(Computed) The unique ID that Keycloak assigns to the identity provider upon creation.\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use after users have successfully logged in, which can be used to perform additional user verification (such as OTP checking). Defaults to an empty string, which means no post login flow will be used.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The ID of the identity provider to use. Defaults to `google`, which should be used unless you have extended Keycloak and provided your own implementation.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak.\n"
                },
                "requestRefreshToken": {
                    "type": "boolean",
                    "description": "Sets the \"access_type\" query parameter to \"offline\" when redirecting to google authorization endpoint,to get a refresh token back. This is useful for using Token Exchange to retrieve a Google token to access Google APIs when the user is offline.\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                },
                "useUserIpParam": {
                    "type": "boolean",
                    "description": "Sets the \"userIp\" query parameter when querying Google's User Info service. This will use the user's IP address. This is useful if Google is throttling Keycloak's access to the User Info service.\n"
                }
            },
            "required": [
                "alias",
                "clientId",
                "clientSecret",
                "displayName",
                "internalId",
                "realm"
            ],
            "inputProperties": {
                "acceptsPromptNoneForwardFromClient": {
                    "type": "boolean",
                    "description": "When `true`, unauthenticated requests with `prompt=none` will be forwarded to Google instead of returning an error. Defaults to `false`.\n"
                },
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client or client identifier registered within the identity provider.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use $${vault.ID} format.\n"
                },
                "defaultScopes": {
                    "type": "string",
                    "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to `openid profile email`.\n"
                },
                "disableUserInfo": {
                    "type": "boolean",
                    "description": "When `true`, disables the usage of the user info service to obtain additional user information. Defaults to `false`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `true`, users will be able to log in to this realm using this identity provider. Defaults to `true`.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use when users log in for the first time through this identity provider. Defaults to `first broker login`.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "When `true`, this identity provider will be hidden on the login page. Defaults to `false`.\n"
                },
                "hostedDomain": {
                    "type": "string",
                    "description": "Sets the \"hd\" query parameter when logging in with Google. Google will only list accounts for this domain. Keycloak will validate that the returned identity token has a claim for this domain. When `*` is entered, an account from any domain can be used.\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use after users have successfully logged in, which can be used to perform additional user verification (such as OTP checking). Defaults to an empty string, which means no post login flow will be used.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The ID of the identity provider to use. Defaults to `google`, which should be used unless you have extended Keycloak and provided your own implementation.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak.\n"
                },
                "requestRefreshToken": {
                    "type": "boolean",
                    "description": "Sets the \"access_type\" query parameter to \"offline\" when redirecting to google authorization endpoint,to get a refresh token back. This is useful for using Token Exchange to retrieve a Google token to access Google APIs when the user is offline.\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                },
                "useUserIpParam": {
                    "type": "boolean",
                    "description": "Sets the \"userIp\" query parameter when querying Google's User Info service. This will use the user's IP address. This is useful if Google is throttling Keycloak's access to the User Info service.\n"
                }
            },
            "requiredInputs": [
                "clientId",
                "clientSecret",
                "realm"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GoogleIdentityProvider resources.\n",
                "properties": {
                    "acceptsPromptNoneForwardFromClient": {
                        "type": "boolean",
                        "description": "When `true`, unauthenticated requests with `prompt=none` will be forwarded to Google instead of returning an error. Defaults to `false`.\n"
                    },
                    "addReadTokenRoleOnCreate": {
                        "type": "boolean",
                        "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                    },
                    "alias": {
                        "type": "string",
                        "description": "(Computed) The alias for the Google identity provider.\n"
                    },
                    "authenticateByDefault": {
                        "type": "boolean",
                        "description": "Enable/disable authenticate users by default.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client or client identifier registered within the identity provider.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use $${vault.ID} format.\n"
                    },
                    "defaultScopes": {
                        "type": "string",
                        "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to `openid profile email`.\n"
                    },
                    "disableUserInfo": {
                        "type": "boolean",
                        "description": "When `true`, disables the usage of the user info service to obtain additional user information. Defaults to `false`.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "(Computed) Display name for the Google identity provider in the GUI.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `true`, users will be able to log in to this realm using this identity provider. Defaults to `true`.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "firstBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "The authentication flow to use when users log in for the first time through this identity provider. Defaults to `first broker login`.\n"
                    },
                    "hideOnLoginPage": {
                        "type": "boolean",
                        "description": "When `true`, this identity provider will be hidden on the login page. Defaults to `false`.\n"
                    },
                    "hostedDomain": {
                        "type": "string",
                        "description": "Sets the \"hd\" query parameter when logging in with Google. Google will only list accounts for this domain. Keycloak will validate that the returned identity token has a claim for this domain. When `*` is entered, an account from any domain can be used.\n"
                    },
                    "internalId": {
                        "type": "string",
                        "description": "(Computed) The unique ID that Keycloak assigns to the identity provider upon creation.\n"
                    },
                    "linkOnly": {
                        "type": "boolean",
                        "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                    },
                    "postBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "The authentication flow to use after users have successfully logged in, which can be used to perform additional user verification (such as OTP checking). Defaults to an empty string, which means no post login flow will be used.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The ID of the identity provider to use. Defaults to `google`, which should be used unless you have extended Keycloak and provided your own implementation.\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "The name of the realm. This is unique across Keycloak.\n"
                    },
                    "requestRefreshToken": {
                        "type": "boolean",
                        "description": "Sets the \"access_type\" query parameter to \"offline\" when redirecting to google authorization endpoint,to get a refresh token back. This is useful for using Token Exchange to retrieve a Google token to access Google APIs when the user is offline.\n"
                    },
                    "storeToken": {
                        "type": "boolean",
                        "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                    },
                    "trustEmail": {
                        "type": "boolean",
                        "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                    },
                    "useUserIpParam": {
                        "type": "boolean",
                        "description": "Sets the \"userIp\" query parameter when querying Google's User Info service. This will use the user's IP address. This is useful if Google is throttling Keycloak's access to the User Info service.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:oidc/identityProvider:IdentityProvider": {
            "description": "Allows for creating and managing OIDC Identity Providers within Keycloak.\n\nOIDC (OpenID Connect) identity providers allows users to authenticate through a third party system using the OIDC standard.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst realmIdentityProvider = new keycloak.oidc.IdentityProvider(\"realmIdentityProvider\", {\n    realm: realm.id,\n    alias: \"my-idp\",\n    authorizationUrl: \"https://authorizationurl.com\",\n    clientId: \"clientID\",\n    clientSecret: \"clientSecret\",\n    tokenUrl: \"https://tokenurl.com\",\n    extraConfig: {\n        clientAuthMethod: \"client_secret_post\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrealm_identity_provider = keycloak.oidc.IdentityProvider(\"realmIdentityProvider\",\n    realm=realm.id,\n    alias=\"my-idp\",\n    authorization_url=\"https://authorizationurl.com\",\n    client_id=\"clientID\",\n    client_secret=\"clientSecret\",\n    token_url=\"https://tokenurl.com\",\n    extra_config={\n        \"clientAuthMethod\": \"client_secret_post\",\n    })\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var realmIdentityProvider = new Keycloak.Oidc.IdentityProvider(\"realmIdentityProvider\", new Keycloak.Oidc.IdentityProviderArgs\n        {\n            Realm = realm.Id,\n            Alias = \"my-idp\",\n            AuthorizationUrl = \"https://authorizationurl.com\",\n            ClientId = \"clientID\",\n            ClientSecret = \"clientSecret\",\n            TokenUrl = \"https://tokenurl.com\",\n            ExtraConfig = \n            {\n                { \"clientAuthMethod\", \"client_secret_post\" },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/oidc\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = oidc.NewIdentityProvider(ctx, \"realmIdentityProvider\", \u0026oidc.IdentityProviderArgs{\n\t\t\tRealm:            realm.ID(),\n\t\t\tAlias:            pulumi.String(\"my-idp\"),\n\t\t\tAuthorizationUrl: pulumi.String(\"https://authorizationurl.com\"),\n\t\t\tClientId:         pulumi.String(\"clientID\"),\n\t\t\tClientSecret:     pulumi.String(\"clientSecret\"),\n\t\t\tTokenUrl:         pulumi.String(\"https://tokenurl.com\"),\n\t\t\tExtraConfig: pulumi.StringMap{\n\t\t\t\t\"clientAuthMethod\": pulumi.String(\"client_secret_post\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "acceptsPromptNoneForwardFromClient": {
                    "type": "boolean",
                    "description": "When `true`, the IDP will accept forwarded authentication requests that contain the `prompt=none` query parameter. Defaults to `false`.\n"
                },
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                },
                "alias": {
                    "type": "string",
                    "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "authorizationUrl": {
                    "type": "string",
                    "description": "The Authorization Url.\n"
                },
                "backchannelSupported": {
                    "type": "boolean",
                    "description": "Does the external IDP support backchannel logout? Defaults to `true`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client or client identifier registered within the identity provider.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use $${vault.ID} format.\n"
                },
                "defaultScopes": {
                    "type": "string",
                    "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to `openid`.\n"
                },
                "disableUserInfo": {
                    "type": "boolean",
                    "description": "When `true`, disables the usage of the user info service to obtain additional user information. Defaults to `false`.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "Display name for the identity provider in the GUI.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `true`, users will be able to log in to this realm using this identity provider. Defaults to `true`.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use when users log in for the first time through this identity provider. Defaults to `first broker login`.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "When `true`, this provider will be hidden on the login page, and is only accessible when requested explicitly. Defaults to `false`.\n"
                },
                "internalId": {
                    "type": "string",
                    "description": "(Computed) The unique ID that Keycloak assigns to the identity provider upon creation.\n"
                },
                "jwksUrl": {
                    "type": "string",
                    "description": "JSON Web Key Set URL.\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                },
                "loginHint": {
                    "type": "string",
                    "description": "Pass login hint to identity provider.\n"
                },
                "logoutUrl": {
                    "type": "string",
                    "description": "The Logout URL is the end session endpoint to use to logout user from external identity provider.\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use after users have successfully logged in, which can be used to perform additional user verification (such as OTP checking). Defaults to an empty string, which means no post login flow will be used.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The ID of the identity provider to use. Defaults to `oidc`, which should be used unless you have extended Keycloak and provided your own implementation.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak.\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                },
                "tokenUrl": {
                    "type": "string",
                    "description": "The Token URL.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                },
                "uiLocales": {
                    "type": "boolean",
                    "description": "Pass current locale to identity provider. Defaults to `false`.\n"
                },
                "userInfoUrl": {
                    "type": "string",
                    "description": "User Info URL.\n"
                },
                "validateSignature": {
                    "type": "boolean",
                    "description": "Enable/disable signature validation of external IDP signatures. Defaults to `false`.\n"
                }
            },
            "required": [
                "alias",
                "authorizationUrl",
                "clientId",
                "clientSecret",
                "internalId",
                "realm",
                "tokenUrl"
            ],
            "inputProperties": {
                "acceptsPromptNoneForwardFromClient": {
                    "type": "boolean",
                    "description": "When `true`, the IDP will accept forwarded authentication requests that contain the `prompt=none` query parameter. Defaults to `false`.\n"
                },
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                },
                "alias": {
                    "type": "string",
                    "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Enable/disable authenticate users by default.\n"
                },
                "authorizationUrl": {
                    "type": "string",
                    "description": "The Authorization Url.\n"
                },
                "backchannelSupported": {
                    "type": "boolean",
                    "description": "Does the external IDP support backchannel logout? Defaults to `true`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client or client identifier registered within the identity provider.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use $${vault.ID} format.\n"
                },
                "defaultScopes": {
                    "type": "string",
                    "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to `openid`.\n"
                },
                "disableUserInfo": {
                    "type": "boolean",
                    "description": "When `true`, disables the usage of the user info service to obtain additional user information. Defaults to `false`.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "Display name for the identity provider in the GUI.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `true`, users will be able to log in to this realm using this identity provider. Defaults to `true`.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use when users log in for the first time through this identity provider. Defaults to `first broker login`.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "When `true`, this provider will be hidden on the login page, and is only accessible when requested explicitly. Defaults to `false`.\n"
                },
                "jwksUrl": {
                    "type": "string",
                    "description": "JSON Web Key Set URL.\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                },
                "loginHint": {
                    "type": "string",
                    "description": "Pass login hint to identity provider.\n"
                },
                "logoutUrl": {
                    "type": "string",
                    "description": "The Logout URL is the end session endpoint to use to logout user from external identity provider.\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "The authentication flow to use after users have successfully logged in, which can be used to perform additional user verification (such as OTP checking). Defaults to an empty string, which means no post login flow will be used.\n"
                },
                "providerId": {
                    "type": "string",
                    "description": "The ID of the identity provider to use. Defaults to `oidc`, which should be used unless you have extended Keycloak and provided your own implementation.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak.\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                },
                "tokenUrl": {
                    "type": "string",
                    "description": "The Token URL.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                },
                "uiLocales": {
                    "type": "boolean",
                    "description": "Pass current locale to identity provider. Defaults to `false`.\n"
                },
                "userInfoUrl": {
                    "type": "string",
                    "description": "User Info URL.\n"
                },
                "validateSignature": {
                    "type": "boolean",
                    "description": "Enable/disable signature validation of external IDP signatures. Defaults to `false`.\n"
                }
            },
            "requiredInputs": [
                "alias",
                "authorizationUrl",
                "clientId",
                "clientSecret",
                "realm",
                "tokenUrl"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IdentityProvider resources.\n",
                "properties": {
                    "acceptsPromptNoneForwardFromClient": {
                        "type": "boolean",
                        "description": "When `true`, the IDP will accept forwarded authentication requests that contain the `prompt=none` query parameter. Defaults to `false`.\n"
                    },
                    "addReadTokenRoleOnCreate": {
                        "type": "boolean",
                        "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                    },
                    "alias": {
                        "type": "string",
                        "description": "The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\n"
                    },
                    "authenticateByDefault": {
                        "type": "boolean",
                        "description": "Enable/disable authenticate users by default.\n"
                    },
                    "authorizationUrl": {
                        "type": "string",
                        "description": "The Authorization Url.\n"
                    },
                    "backchannelSupported": {
                        "type": "boolean",
                        "description": "Does the external IDP support backchannel logout? Defaults to `true`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client or client identifier registered within the identity provider.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use $${vault.ID} format.\n"
                    },
                    "defaultScopes": {
                        "type": "string",
                        "description": "The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to `openid`.\n"
                    },
                    "disableUserInfo": {
                        "type": "boolean",
                        "description": "When `true`, disables the usage of the user info service to obtain additional user information. Defaults to `false`.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "Display name for the identity provider in the GUI.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `true`, users will be able to log in to this realm using this identity provider. Defaults to `true`.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "firstBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "The authentication flow to use when users log in for the first time through this identity provider. Defaults to `first broker login`.\n"
                    },
                    "hideOnLoginPage": {
                        "type": "boolean",
                        "description": "When `true`, this provider will be hidden on the login page, and is only accessible when requested explicitly. Defaults to `false`.\n"
                    },
                    "internalId": {
                        "type": "string",
                        "description": "(Computed) The unique ID that Keycloak assigns to the identity provider upon creation.\n"
                    },
                    "jwksUrl": {
                        "type": "string",
                        "description": "JSON Web Key Set URL.\n"
                    },
                    "linkOnly": {
                        "type": "boolean",
                        "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                    },
                    "loginHint": {
                        "type": "string",
                        "description": "Pass login hint to identity provider.\n"
                    },
                    "logoutUrl": {
                        "type": "string",
                        "description": "The Logout URL is the end session endpoint to use to logout user from external identity provider.\n"
                    },
                    "postBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "The authentication flow to use after users have successfully logged in, which can be used to perform additional user verification (such as OTP checking). Defaults to an empty string, which means no post login flow will be used.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The ID of the identity provider to use. Defaults to `oidc`, which should be used unless you have extended Keycloak and provided your own implementation.\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "The name of the realm. This is unique across Keycloak.\n"
                    },
                    "storeToken": {
                        "type": "boolean",
                        "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                    },
                    "tokenUrl": {
                        "type": "string",
                        "description": "The Token URL.\n"
                    },
                    "trustEmail": {
                        "type": "boolean",
                        "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                    },
                    "uiLocales": {
                        "type": "boolean",
                        "description": "Pass current locale to identity provider. Defaults to `false`.\n"
                    },
                    "userInfoUrl": {
                        "type": "string",
                        "description": "User Info URL.\n"
                    },
                    "validateSignature": {
                        "type": "boolean",
                        "description": "Enable/disable signature validation of external IDP signatures. Defaults to `false`.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/audienceProtocolMapper:AudienceProtocolMapper": {
            "description": "Allows for creating and managing audience protocol mappers within Keycloak.\n\nAudience protocol mappers allow you add audiences to the `aud` claim within issued tokens. The audience can be a custom\nstring, or it can be mapped to the ID of a pre-existing client.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst audienceMapper = new keycloak.openid.AudienceProtocolMapper(\"audienceMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    includedCustomAudience: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\naudience_mapper = keycloak.openid.AudienceProtocolMapper(\"audienceMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    included_custom_audience=\"foo\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var audienceMapper = new Keycloak.OpenId.AudienceProtocolMapper(\"audienceMapper\", new Keycloak.OpenId.AudienceProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n            IncludedCustomAudience = \"foo\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewAudienceProtocolMapper(ctx, \"audienceMapper\", \u0026openid.AudienceProtocolMapperArgs{\n\t\t\tRealmId:                realm.ID(),\n\t\t\tClientId:               openidClient.ID(),\n\t\t\tIncludedCustomAudience: pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst audienceMapper = new keycloak.openid.AudienceProtocolMapper(\"audienceMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    includedCustomAudience: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\naudience_mapper = keycloak.openid.AudienceProtocolMapper(\"audienceMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    included_custom_audience=\"foo\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var audienceMapper = new Keycloak.OpenId.AudienceProtocolMapper(\"audienceMapper\", new Keycloak.OpenId.AudienceProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            IncludedCustomAudience = \"foo\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewAudienceProtocolMapper(ctx, \"audienceMapper\", \u0026openid.AudienceProtocolMapperArgs{\n\t\t\tRealmId:                realm.ID(),\n\t\t\tClientScopeId:          clientScope.ID(),\n\t\t\tIncludedCustomAudience: pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "includedClientAudience": {
                    "type": "string",
                    "description": "A client ID to include within the token's `aud` claim. Conflicts with `included_custom_audience`. One of `included_client_audience` or `included_custom_audience` must be specified.\n"
                },
                "includedCustomAudience": {
                    "type": "string",
                    "description": "A custom audience to include within the token's `aud` claim. Conflicts with `included_client_audience`. One of `included_client_audience` or `included_custom_audience` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "includedClientAudience": {
                    "type": "string",
                    "description": "A client ID to include within the token's `aud` claim. Conflicts with `included_custom_audience`. One of `included_client_audience` or `included_custom_audience` must be specified.\n"
                },
                "includedCustomAudience": {
                    "type": "string",
                    "description": "A custom audience to include within the token's `aud` claim. Conflicts with `included_client_audience`. One of `included_client_audience` or `included_custom_audience` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AudienceProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "includedClientAudience": {
                        "type": "string",
                        "description": "A client ID to include within the token's `aud` claim. Conflicts with `included_custom_audience`. One of `included_client_audience` or `included_custom_audience` must be specified.\n"
                    },
                    "includedCustomAudience": {
                        "type": "string",
                        "description": "A custom audience to include within the token's `aud` claim. Conflicts with `included_client_audience`. One of `included_client_audience` or `included_custom_audience` must be specified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/client:Client": {
            "description": "Allows for creating and managing Keycloak clients that use the OpenID Connect protocol.\n\nClients are entities that can use Keycloak for user authentication. Typically,\nclients are applications that redirect users to Keycloak for authentication\nin order to take advantage of Keycloak's user sessions for SSO.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"test-client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n    loginTheme: \"keycloak\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"test-client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"],\n    login_theme=\"keycloak\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"test-client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n            LoginTheme = \"keycloak\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"test-client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t\tLoginTheme: pulumi.String(\"keycloak\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "accessTokenLifespan": {
                    "type": "string",
                    "description": "The amount of time in seconds before an access token expires. This will override the default for the realm.\n"
                },
                "accessType": {
                    "type": "string",
                    "description": "Specifies the type of client, which can be one of the following:\n"
                },
                "adminUrl": {
                    "type": "string",
                    "description": "URL to the admin interface of the client.\n"
                },
                "authenticationFlowBindingOverrides": {
                    "$ref": "#/types/keycloak:openid/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides",
                    "description": "Override realm authentication flow bindings\n"
                },
                "authorization": {
                    "$ref": "#/types/keycloak:openid/ClientAuthorization:ClientAuthorization",
                    "description": "When this block is present, fine-grained authorization will be enabled for this client. The client's `access_type` must be `CONFIDENTIAL`, and `service_accounts_enabled` must be `true`. This block has the following arguments:\n"
                },
                "baseUrl": {
                    "type": "string",
                    "description": "Default URL to use when the auth server needs to redirect or link back to the client.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The Client ID for this client, referenced in the URI during authentication and in issued tokens.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The secret for clients with an `access_type` of `CONFIDENTIAL` or `BEARER-ONLY`. This value is sensitive and should be treated with the same care as a password. If omitted, this will be generated by Keycloak.\n"
                },
                "consentRequired": {
                    "type": "boolean",
                    "description": "When `true`, users have to consent to client access.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client in the GUI.\n"
                },
                "directAccessGrantsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, the OAuth2 Resource Owner Password Grant will be enabled for this client. Defaults to `false`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.\n"
                },
                "excludeSessionStateFromAuthResponse": {
                    "type": "boolean",
                    "description": "When `true`, the parameter `session_state` will not be included in OpenID Connect Authentication Response.\n"
                },
                "fullScopeAllowed": {
                    "type": "boolean",
                    "description": "Allow to include all roles mappings in the access token.\n"
                },
                "implicitFlowEnabled": {
                    "type": "boolean",
                    "description": "When `true`, the OAuth2 Implicit Grant will be enabled for this client. Defaults to `false`.\n"
                },
                "loginTheme": {
                    "type": "string",
                    "description": "The client login theme. This will override the default theme for the realm.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this client in the GUI.\n"
                },
                "pkceCodeChallengeMethod": {
                    "type": "string",
                    "description": "The challenge method to use for Proof Key for Code Exchange. Can be either `plain` or `S256` or set to empty value ``.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client is attached to.\n"
                },
                "resourceServerId": {
                    "type": "string",
                    "description": "(Computed) When authorization is enabled for this client, this attribute is the unique ID for the client (the same value as the `.id` attribute).\n"
                },
                "rootUrl": {
                    "type": "string",
                    "description": "When specified, this URL is prepended to any relative URLs found within `valid_redirect_uris`, `web_origins`, and `admin_url`. NOTE: Due to limitations in the Keycloak API, when the `root_url` attribute is used, the `valid_redirect_uris`, `web_origins`, and `admin_url` attributes will be required.\n"
                },
                "serviceAccountUserId": {
                    "type": "string",
                    "description": "(Computed) When service accounts are enabled for this client, this attribute is the unique ID for the Keycloak user that represents this service account.\n"
                },
                "serviceAccountsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, the OAuth2 Client Credentials grant will be enabled for this client. Defaults to `false`.\n"
                },
                "standardFlowEnabled": {
                    "type": "boolean",
                    "description": "When `true`, the OAuth2 Authorization Code Grant will be enabled for this client. Defaults to `false`.\n"
                },
                "validRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of valid URIs a browser is permitted to redirect to after a successful login or logout. Simple\nwildcards in the form of an asterisk can be used here. This attribute must be set if either `standard_flow_enabled` or `implicit_flow_enabled`\nis set to `true`.\n"
                },
                "webOrigins": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of allowed CORS origins. `+` can be used to permit all valid redirect URIs, and `*` can be used to permit all origins.\n"
                }
            },
            "required": [
                "accessType",
                "clientId",
                "clientSecret",
                "name",
                "realmId",
                "resourceServerId",
                "serviceAccountUserId"
            ],
            "inputProperties": {
                "accessTokenLifespan": {
                    "type": "string",
                    "description": "The amount of time in seconds before an access token expires. This will override the default for the realm.\n"
                },
                "accessType": {
                    "type": "string",
                    "description": "Specifies the type of client, which can be one of the following:\n"
                },
                "adminUrl": {
                    "type": "string",
                    "description": "URL to the admin interface of the client.\n"
                },
                "authenticationFlowBindingOverrides": {
                    "$ref": "#/types/keycloak:openid/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides",
                    "description": "Override realm authentication flow bindings\n"
                },
                "authorization": {
                    "$ref": "#/types/keycloak:openid/ClientAuthorization:ClientAuthorization",
                    "description": "When this block is present, fine-grained authorization will be enabled for this client. The client's `access_type` must be `CONFIDENTIAL`, and `service_accounts_enabled` must be `true`. This block has the following arguments:\n"
                },
                "baseUrl": {
                    "type": "string",
                    "description": "Default URL to use when the auth server needs to redirect or link back to the client.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The Client ID for this client, referenced in the URI during authentication and in issued tokens.\n"
                },
                "clientSecret": {
                    "type": "string",
                    "description": "The secret for clients with an `access_type` of `CONFIDENTIAL` or `BEARER-ONLY`. This value is sensitive and should be treated with the same care as a password. If omitted, this will be generated by Keycloak.\n"
                },
                "consentRequired": {
                    "type": "boolean",
                    "description": "When `true`, users have to consent to client access.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client in the GUI.\n"
                },
                "directAccessGrantsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, the OAuth2 Resource Owner Password Grant will be enabled for this client. Defaults to `false`.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.\n"
                },
                "excludeSessionStateFromAuthResponse": {
                    "type": "boolean",
                    "description": "When `true`, the parameter `session_state` will not be included in OpenID Connect Authentication Response.\n"
                },
                "fullScopeAllowed": {
                    "type": "boolean",
                    "description": "Allow to include all roles mappings in the access token.\n"
                },
                "implicitFlowEnabled": {
                    "type": "boolean",
                    "description": "When `true`, the OAuth2 Implicit Grant will be enabled for this client. Defaults to `false`.\n"
                },
                "loginTheme": {
                    "type": "string",
                    "description": "The client login theme. This will override the default theme for the realm.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this client in the GUI.\n"
                },
                "pkceCodeChallengeMethod": {
                    "type": "string",
                    "description": "The challenge method to use for Proof Key for Code Exchange. Can be either `plain` or `S256` or set to empty value ``.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client is attached to.\n"
                },
                "rootUrl": {
                    "type": "string",
                    "description": "When specified, this URL is prepended to any relative URLs found within `valid_redirect_uris`, `web_origins`, and `admin_url`. NOTE: Due to limitations in the Keycloak API, when the `root_url` attribute is used, the `valid_redirect_uris`, `web_origins`, and `admin_url` attributes will be required.\n"
                },
                "serviceAccountsEnabled": {
                    "type": "boolean",
                    "description": "When `true`, the OAuth2 Client Credentials grant will be enabled for this client. Defaults to `false`.\n"
                },
                "standardFlowEnabled": {
                    "type": "boolean",
                    "description": "When `true`, the OAuth2 Authorization Code Grant will be enabled for this client. Defaults to `false`.\n"
                },
                "validRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of valid URIs a browser is permitted to redirect to after a successful login or logout. Simple\nwildcards in the form of an asterisk can be used here. This attribute must be set if either `standard_flow_enabled` or `implicit_flow_enabled`\nis set to `true`.\n"
                },
                "webOrigins": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of allowed CORS origins. `+` can be used to permit all valid redirect URIs, and `*` can be used to permit all origins.\n"
                }
            },
            "requiredInputs": [
                "accessType",
                "clientId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Client resources.\n",
                "properties": {
                    "accessTokenLifespan": {
                        "type": "string",
                        "description": "The amount of time in seconds before an access token expires. This will override the default for the realm.\n"
                    },
                    "accessType": {
                        "type": "string",
                        "description": "Specifies the type of client, which can be one of the following:\n"
                    },
                    "adminUrl": {
                        "type": "string",
                        "description": "URL to the admin interface of the client.\n"
                    },
                    "authenticationFlowBindingOverrides": {
                        "$ref": "#/types/keycloak:openid/ClientAuthenticationFlowBindingOverrides:ClientAuthenticationFlowBindingOverrides",
                        "description": "Override realm authentication flow bindings\n"
                    },
                    "authorization": {
                        "$ref": "#/types/keycloak:openid/ClientAuthorization:ClientAuthorization",
                        "description": "When this block is present, fine-grained authorization will be enabled for this client. The client's `access_type` must be `CONFIDENTIAL`, and `service_accounts_enabled` must be `true`. This block has the following arguments:\n"
                    },
                    "baseUrl": {
                        "type": "string",
                        "description": "Default URL to use when the auth server needs to redirect or link back to the client.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The Client ID for this client, referenced in the URI during authentication and in issued tokens.\n"
                    },
                    "clientSecret": {
                        "type": "string",
                        "description": "The secret for clients with an `access_type` of `CONFIDENTIAL` or `BEARER-ONLY`. This value is sensitive and should be treated with the same care as a password. If omitted, this will be generated by Keycloak.\n"
                    },
                    "consentRequired": {
                        "type": "boolean",
                        "description": "When `true`, users have to consent to client access.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of this client in the GUI.\n"
                    },
                    "directAccessGrantsEnabled": {
                        "type": "boolean",
                        "description": "When `true`, the OAuth2 Resource Owner Password Grant will be enabled for this client. Defaults to `false`.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.\n"
                    },
                    "excludeSessionStateFromAuthResponse": {
                        "type": "boolean",
                        "description": "When `true`, the parameter `session_state` will not be included in OpenID Connect Authentication Response.\n"
                    },
                    "fullScopeAllowed": {
                        "type": "boolean",
                        "description": "Allow to include all roles mappings in the access token.\n"
                    },
                    "implicitFlowEnabled": {
                        "type": "boolean",
                        "description": "When `true`, the OAuth2 Implicit Grant will be enabled for this client. Defaults to `false`.\n"
                    },
                    "loginTheme": {
                        "type": "string",
                        "description": "The client login theme. This will override the default theme for the realm.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this client in the GUI.\n"
                    },
                    "pkceCodeChallengeMethod": {
                        "type": "string",
                        "description": "The challenge method to use for Proof Key for Code Exchange. Can be either `plain` or `S256` or set to empty value ``.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this client is attached to.\n"
                    },
                    "resourceServerId": {
                        "type": "string",
                        "description": "(Computed) When authorization is enabled for this client, this attribute is the unique ID for the client (the same value as the `.id` attribute).\n"
                    },
                    "rootUrl": {
                        "type": "string",
                        "description": "When specified, this URL is prepended to any relative URLs found within `valid_redirect_uris`, `web_origins`, and `admin_url`. NOTE: Due to limitations in the Keycloak API, when the `root_url` attribute is used, the `valid_redirect_uris`, `web_origins`, and `admin_url` attributes will be required.\n"
                    },
                    "serviceAccountUserId": {
                        "type": "string",
                        "description": "(Computed) When service accounts are enabled for this client, this attribute is the unique ID for the Keycloak user that represents this service account.\n"
                    },
                    "serviceAccountsEnabled": {
                        "type": "boolean",
                        "description": "When `true`, the OAuth2 Client Credentials grant will be enabled for this client. Defaults to `false`.\n"
                    },
                    "standardFlowEnabled": {
                        "type": "boolean",
                        "description": "When `true`, the OAuth2 Authorization Code Grant will be enabled for this client. Defaults to `false`.\n"
                    },
                    "validRedirectUris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of valid URIs a browser is permitted to redirect to after a successful login or logout. Simple\nwildcards in the form of an asterisk can be used here. This attribute must be set if either `standard_flow_enabled` or `implicit_flow_enabled`\nis set to `true`.\n"
                    },
                    "webOrigins": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of allowed CORS origins. `+` can be used to permit all valid redirect URIs, and `*` can be used to permit all origins.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientAggregatePolicy:ClientAggregatePolicy": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "required": [
                "decisionStrategy",
                "name",
                "policies",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "decisionStrategy",
                "policies",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientAggregatePolicy resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientAuthorizationPermission:ClientAuthorizationPermission": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "resources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "resources": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "type": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientAuthorizationPermission resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "resources": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientAuthorizationResource:ClientAuthorizationResource": {
            "properties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "displayName": {
                    "type": "string"
                },
                "iconUri": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "ownerManagedAccess": {
                    "type": "boolean"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "type": {
                    "type": "string"
                },
                "uris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "attributes": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    }
                },
                "displayName": {
                    "type": "string"
                },
                "iconUri": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "ownerManagedAccess": {
                    "type": "boolean"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "type": {
                    "type": "string"
                },
                "uris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "requiredInputs": [
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientAuthorizationResource resources.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "displayName": {
                        "type": "string"
                    },
                    "iconUri": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "ownerManagedAccess": {
                        "type": "boolean"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "type": {
                        "type": "string"
                    },
                    "uris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientAuthorizationScope:ClientAuthorizationScope": {
            "properties": {
                "displayName": {
                    "type": "string"
                },
                "iconUri": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "displayName": {
                    "type": "string"
                },
                "iconUri": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientAuthorizationScope resources.\n",
                "properties": {
                    "displayName": {
                        "type": "string"
                    },
                    "iconUri": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientDefaultScopes:ClientDefaultScopes": {
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client to attach default scopes to. Note that this is the unique ID of the client generated by Keycloak.\n"
                },
                "defaultScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of client scope names to attach to this client.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client and scopes exists in.\n"
                }
            },
            "required": [
                "clientId",
                "defaultScopes",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client to attach default scopes to. Note that this is the unique ID of the client generated by Keycloak.\n"
                },
                "defaultScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of client scope names to attach to this client.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client and scopes exists in.\n"
                }
            },
            "requiredInputs": [
                "clientId",
                "defaultScopes",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientDefaultScopes resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The ID of the client to attach default scopes to. Note that this is the unique ID of the client generated by Keycloak.\n"
                    },
                    "defaultScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of client scope names to attach to this client.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this client and scopes exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientGroupPolicy:ClientGroupPolicy": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:openid/ClientGroupPolicyGroup:ClientGroupPolicyGroup"
                    }
                },
                "groupsClaim": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "required": [
                "decisionStrategy",
                "groups",
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:openid/ClientGroupPolicyGroup:ClientGroupPolicyGroup"
                    }
                },
                "groupsClaim": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "decisionStrategy",
                "groups",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientGroupPolicy resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "groups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:openid/ClientGroupPolicyGroup:ClientGroupPolicyGroup"
                        }
                    },
                    "groupsClaim": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientJsPolicy:ClientJsPolicy": {
            "properties": {
                "code": {
                    "type": "string"
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "code",
                "decisionStrategy",
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "code": {
                    "type": "string"
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "code",
                "decisionStrategy",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientJsPolicy resources.\n",
                "properties": {
                    "code": {
                        "type": "string"
                    },
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientOptionalScopes:ClientOptionalScopes": {
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client to attach optional scopes to. Note that this is the unique ID of the client generated by Keycloak.\n"
                },
                "optionalScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of client scope names to attach to this client as optional scopes.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client and scopes exists in.\n"
                }
            },
            "required": [
                "clientId",
                "optionalScopes",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client to attach optional scopes to. Note that this is the unique ID of the client generated by Keycloak.\n"
                },
                "optionalScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of client scope names to attach to this client as optional scopes.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client and scopes exists in.\n"
                }
            },
            "requiredInputs": [
                "clientId",
                "optionalScopes",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientOptionalScopes resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The ID of the client to attach optional scopes to. Note that this is the unique ID of the client generated by Keycloak.\n"
                    },
                    "optionalScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of client scope names to attach to this client as optional scopes.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this client and scopes exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientPolicy:ClientPolicy": {
            "properties": {
                "clients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "required": [
                "clients",
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "clients": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "clients",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientPolicy resources.\n",
                "properties": {
                    "clients": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientRolePolicy:ClientRolePolicy": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:openid/ClientRolePolicyRole:ClientRolePolicyRole"
                    }
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "name",
                "realmId",
                "resourceServerId",
                "roles",
                "type"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/keycloak:openid/ClientRolePolicyRole:ClientRolePolicyRole"
                    }
                },
                "type": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "realmId",
                "resourceServerId",
                "roles",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientRolePolicy resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:openid/ClientRolePolicyRole:ClientRolePolicyRole"
                        }
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientScope:ClientScope": {
            "description": "Allows for creating and managing Keycloak client scopes that can be attached to clients that use the OpenID Connect protocol.\n\nClient Scopes can be used to share common protocol and role mappings between multiple clients within a realm. They can also\nbe used by clients to conditionally request claims or roles for a user based on the OAuth 2.0 `scope` parameter.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClientScope = new keycloak.openid.ClientScope(\"openidClientScope\", {\n    realmId: realm.id,\n    description: \"When requested, this scope will map a user's group memberships to a claim\",\n    includeInTokenScope: true,\n    guiOrder: 1,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client_scope = keycloak.openid.ClientScope(\"openidClientScope\",\n    realm_id=realm.id,\n    description=\"When requested, this scope will map a user's group memberships to a claim\",\n    include_in_token_scope=True,\n    gui_order=1)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClientScope = new Keycloak.OpenId.ClientScope(\"openidClientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n            Description = \"When requested, this scope will map a user's group memberships to a claim\",\n            IncludeInTokenScope = true,\n            GuiOrder = 1,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientScope(ctx, \"openidClientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId:             realm.ID(),\n\t\t\tDescription:         pulumi.String(\"When requested, this scope will map a user's group memberships to a claim\"),\n\t\t\tIncludeInTokenScope: pulumi.Bool(true),\n\t\t\tGuiOrder:            pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "consentScreenText": {
                    "type": "string",
                    "description": "When set, a consent screen will be displayed to users authenticating to clients with this scope attached. The consent screen will display the string value of this attribute.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client scope in the GUI.\n"
                },
                "guiOrder": {
                    "type": "integer",
                    "description": "Specify order of the client scope in GUI (such as in Consent page) as integer.\n"
                },
                "includeInTokenScope": {
                    "type": "boolean",
                    "description": "When `true`, the name of this client scope will be added to the access token property 'scope' as well as to the Token Introspection Endpoint response.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this client scope in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client scope belongs to.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "consentScreenText": {
                    "type": "string",
                    "description": "When set, a consent screen will be displayed to users authenticating to clients with this scope attached. The consent screen will display the string value of this attribute.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client scope in the GUI.\n"
                },
                "guiOrder": {
                    "type": "integer",
                    "description": "Specify order of the client scope in GUI (such as in Consent page) as integer.\n"
                },
                "includeInTokenScope": {
                    "type": "boolean",
                    "description": "When `true`, the name of this client scope will be added to the access token property 'scope' as well as to the Token Introspection Endpoint response.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this client scope in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client scope belongs to.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientScope resources.\n",
                "properties": {
                    "consentScreenText": {
                        "type": "string",
                        "description": "When set, a consent screen will be displayed to users authenticating to clients with this scope attached. The consent screen will display the string value of this attribute.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of this client scope in the GUI.\n"
                    },
                    "guiOrder": {
                        "type": "integer",
                        "description": "Specify order of the client scope in GUI (such as in Consent page) as integer.\n"
                    },
                    "includeInTokenScope": {
                        "type": "boolean",
                        "description": "When `true`, the name of this client scope will be added to the access token property 'scope' as well as to the Token Introspection Endpoint response.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this client scope in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this client scope belongs to.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientServiceAccountRealmRole:ClientServiceAccountRealmRole": {
            "description": "Allows for assigning realm roles to the service account of an openid client.\nYou need to set `service_accounts_enabled` to `true` for the openid client that should be assigned the role.\n\nIf you'd like to attach client roles to a service account, please use the `keycloak.openid.ClientServiceAccountRole`\nresource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst realmRole = new keycloak.Role(\"realmRole\", {realmId: realm.id});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    serviceAccountsEnabled: true,\n});\nconst clientServiceAccountRole = new keycloak.openid.ClientServiceAccountRealmRole(\"clientServiceAccountRole\", {\n    realmId: realm.id,\n    serviceAccountUserId: client.serviceAccountUserId,\n    role: realmRole.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrealm_role = keycloak.Role(\"realmRole\", realm_id=realm.id)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    service_accounts_enabled=True)\nclient_service_account_role = keycloak.openid.ClientServiceAccountRealmRole(\"clientServiceAccountRole\",\n    realm_id=realm.id,\n    service_account_user_id=client.service_account_user_id,\n    role=realm_role.name)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var realmRole = new Keycloak.Role(\"realmRole\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n        });\n        var client = new Keycloak.OpenId.Client(\"client\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ServiceAccountsEnabled = true,\n        });\n        var clientServiceAccountRole = new Keycloak.OpenId.ClientServiceAccountRealmRole(\"clientServiceAccountRole\", new Keycloak.OpenId.ClientServiceAccountRealmRoleArgs\n        {\n            RealmId = realm.Id,\n            ServiceAccountUserId = client.ServiceAccountUserId,\n            Role = realmRole.Name,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trealmRole, err := keycloak.NewRole(ctx, \"realmRole\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:                realm.ID(),\n\t\t\tServiceAccountsEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientServiceAccountRealmRole(ctx, \"clientServiceAccountRole\", \u0026openid.ClientServiceAccountRealmRoleArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tServiceAccountUserId: client.ServiceAccountUserId,\n\t\t\tRole:                 realmRole.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "realmId": {
                    "type": "string",
                    "description": "The realm that the client and role belong to.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role that is assigned.\n"
                },
                "serviceAccountUserId": {
                    "type": "string",
                    "description": "The id of the service account that is assigned the role (the service account of the client that \"consumes\" the role).\n"
                }
            },
            "required": [
                "realmId",
                "role",
                "serviceAccountUserId"
            ],
            "inputProperties": {
                "realmId": {
                    "type": "string",
                    "description": "The realm that the client and role belong to.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role that is assigned.\n"
                },
                "serviceAccountUserId": {
                    "type": "string",
                    "description": "The id of the service account that is assigned the role (the service account of the client that \"consumes\" the role).\n"
                }
            },
            "requiredInputs": [
                "realmId",
                "role",
                "serviceAccountUserId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientServiceAccountRealmRole resources.\n",
                "properties": {
                    "realmId": {
                        "type": "string",
                        "description": "The realm that the client and role belong to.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the role that is assigned.\n"
                    },
                    "serviceAccountUserId": {
                        "type": "string",
                        "description": "The id of the service account that is assigned the role (the service account of the client that \"consumes\" the role).\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientServiceAccountRole:ClientServiceAccountRole": {
            "description": "Allows for assigning client roles to the service account of an openid client.\nYou need to set `service_accounts_enabled` to `true` for the openid client that should be assigned the role.\n\nIf you'd like to attach realm roles to a service account, please use the `keycloak.openid.ClientServiceAccountRealmRole`\nresource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\n// client1 provides a role to other clients\nconst client1 = new keycloak.openid.Client(\"client1\", {realmId: realm.id});\nconst client1Role = new keycloak.Role(\"client1Role\", {\n    realmId: realm.id,\n    clientId: client1.id,\n    description: \"A role that client1 provides\",\n});\n// client2 is assigned the role of client1\nconst client2 = new keycloak.openid.Client(\"client2\", {\n    realmId: realm.id,\n    serviceAccountsEnabled: true,\n});\nconst client2ServiceAccountRole = new keycloak.openid.ClientServiceAccountRole(\"client2ServiceAccountRole\", {\n    realmId: realm.id,\n    serviceAccountUserId: client2.serviceAccountUserId,\n    clientId: client1.id,\n    role: client1Role.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\n# client1 provides a role to other clients\nclient1 = keycloak.openid.Client(\"client1\", realm_id=realm.id)\nclient1_role = keycloak.Role(\"client1Role\",\n    realm_id=realm.id,\n    client_id=client1.id,\n    description=\"A role that client1 provides\")\n# client2 is assigned the role of client1\nclient2 = keycloak.openid.Client(\"client2\",\n    realm_id=realm.id,\n    service_accounts_enabled=True)\nclient2_service_account_role = keycloak.openid.ClientServiceAccountRole(\"client2ServiceAccountRole\",\n    realm_id=realm.id,\n    service_account_user_id=client2.service_account_user_id,\n    client_id=client1.id,\n    role=client1_role.name)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        // client1 provides a role to other clients\n        var client1 = new Keycloak.OpenId.Client(\"client1\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n        });\n        var client1Role = new Keycloak.Role(\"client1Role\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n            ClientId = client1.Id,\n            Description = \"A role that client1 provides\",\n        });\n        // client2 is assigned the role of client1\n        var client2 = new Keycloak.OpenId.Client(\"client2\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ServiceAccountsEnabled = true,\n        });\n        var client2ServiceAccountRole = new Keycloak.OpenId.ClientServiceAccountRole(\"client2ServiceAccountRole\", new Keycloak.OpenId.ClientServiceAccountRoleArgs\n        {\n            RealmId = realm.Id,\n            ServiceAccountUserId = client2.ServiceAccountUserId,\n            ClientId = client1.Id,\n            Role = client1Role.Name,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient1, err := openid.NewClient(ctx, \"client1\", \u0026openid.ClientArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient1Role, err := keycloak.NewRole(ctx, \"client1Role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tClientId:    client1.ID(),\n\t\t\tDescription: pulumi.String(\"A role that client1 provides\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient2, err := openid.NewClient(ctx, \"client2\", \u0026openid.ClientArgs{\n\t\t\tRealmId:                realm.ID(),\n\t\t\tServiceAccountsEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientServiceAccountRole(ctx, \"client2ServiceAccountRole\", \u0026openid.ClientServiceAccountRoleArgs{\n\t\t\tRealmId:              realm.ID(),\n\t\t\tServiceAccountUserId: client2.ServiceAccountUserId,\n\t\t\tClientId:             client1.ID(),\n\t\t\tRole:                 client1Role.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The id of the client that provides the role.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the clients and roles belong to.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role that is assigned.\n"
                },
                "serviceAccountUserId": {
                    "type": "string",
                    "description": "The id of the service account that is assigned the role (the service account of the client that \"consumes\" the role).\n"
                }
            },
            "required": [
                "clientId",
                "realmId",
                "role",
                "serviceAccountUserId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The id of the client that provides the role.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm the clients and roles belong to.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role that is assigned.\n"
                },
                "serviceAccountUserId": {
                    "type": "string",
                    "description": "The id of the service account that is assigned the role (the service account of the client that \"consumes\" the role).\n"
                }
            },
            "requiredInputs": [
                "clientId",
                "realmId",
                "role",
                "serviceAccountUserId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientServiceAccountRole resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The id of the client that provides the role.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm the clients and roles belong to.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the role that is assigned.\n"
                    },
                    "serviceAccountUserId": {
                        "type": "string",
                        "description": "The id of the service account that is assigned the role (the service account of the client that \"consumes\" the role).\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientTimePolicy:ClientTimePolicy": {
            "properties": {
                "dayMonth": {
                    "type": "string"
                },
                "dayMonthEnd": {
                    "type": "string"
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "hour": {
                    "type": "string"
                },
                "hourEnd": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "minute": {
                    "type": "string"
                },
                "minuteEnd": {
                    "type": "string"
                },
                "month": {
                    "type": "string"
                },
                "monthEnd": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "notBefore": {
                    "type": "string"
                },
                "notOnOrAfter": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "year": {
                    "type": "string"
                },
                "yearEnd": {
                    "type": "string"
                }
            },
            "required": [
                "decisionStrategy",
                "name",
                "realmId",
                "resourceServerId"
            ],
            "inputProperties": {
                "dayMonth": {
                    "type": "string"
                },
                "dayMonthEnd": {
                    "type": "string"
                },
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "hour": {
                    "type": "string"
                },
                "hourEnd": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "minute": {
                    "type": "string"
                },
                "minuteEnd": {
                    "type": "string"
                },
                "month": {
                    "type": "string"
                },
                "monthEnd": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "notBefore": {
                    "type": "string"
                },
                "notOnOrAfter": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "year": {
                    "type": "string"
                },
                "yearEnd": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "decisionStrategy",
                "realmId",
                "resourceServerId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientTimePolicy resources.\n",
                "properties": {
                    "dayMonth": {
                        "type": "string"
                    },
                    "dayMonthEnd": {
                        "type": "string"
                    },
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "hour": {
                        "type": "string"
                    },
                    "hourEnd": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "minute": {
                        "type": "string"
                    },
                    "minuteEnd": {
                        "type": "string"
                    },
                    "month": {
                        "type": "string"
                    },
                    "monthEnd": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "notBefore": {
                        "type": "string"
                    },
                    "notOnOrAfter": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "year": {
                        "type": "string"
                    },
                    "yearEnd": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/clientUserPolicy:ClientUserPolicy": {
            "properties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "decisionStrategy",
                "name",
                "realmId",
                "resourceServerId",
                "users"
            ],
            "inputProperties": {
                "decisionStrategy": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "logic": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "realmId": {
                    "type": "string"
                },
                "resourceServerId": {
                    "type": "string"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "requiredInputs": [
                "decisionStrategy",
                "realmId",
                "resourceServerId",
                "users"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientUserPolicy resources.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "logic": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "users": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/fullNameProtocolMapper:FullNameProtocolMapper": {
            "description": "Allows for creating and managing full name protocol mappers within Keycloak.\n\nFull name protocol mappers allow you to map a user's first and last name to the OpenID Connect `name` claim in a token.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst fullNameMapper = new keycloak.openid.FullNameProtocolMapper(\"fullNameMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nfull_name_mapper = keycloak.openid.FullNameProtocolMapper(\"fullNameMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var fullNameMapper = new Keycloak.OpenId.FullNameProtocolMapper(\"fullNameMapper\", new Keycloak.OpenId.FullNameProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewFullNameProtocolMapper(ctx, \"fullNameMapper\", \u0026openid.FullNameProtocolMapperArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: openidClient.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst fullNameMapper = new keycloak.openid.FullNameProtocolMapper(\"fullNameMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nfull_name_mapper = keycloak.openid.FullNameProtocolMapper(\"fullNameMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var fullNameMapper = new Keycloak.OpenId.FullNameProtocolMapper(\"fullNameMapper\", new Keycloak.OpenId.FullNameProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewFullNameProtocolMapper(ctx, \"fullNameMapper\", \u0026openid.FullNameProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the user's full name should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the user's full name should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the user's full name should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the user's full name should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the user's full name should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the user's full name should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FullNameProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the user's full name should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the user's full name should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the user's full name should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/groupMembershipProtocolMapper:GroupMembershipProtocolMapper": {
            "description": "Allows for creating and managing group membership protocol mappers within Keycloak.\n\nGroup membership protocol mappers allow you to map a user's group memberships to a claim in a token.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst groupMembershipMapper = new keycloak.openid.GroupMembershipProtocolMapper(\"groupMembershipMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    claimName: \"groups\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\ngroup_membership_mapper = keycloak.openid.GroupMembershipProtocolMapper(\"groupMembershipMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    claim_name=\"groups\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var groupMembershipMapper = new Keycloak.OpenId.GroupMembershipProtocolMapper(\"groupMembershipMapper\", new Keycloak.OpenId.GroupMembershipProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n            ClaimName = \"groups\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewGroupMembershipProtocolMapper(ctx, \"groupMembershipMapper\", \u0026openid.GroupMembershipProtocolMapperArgs{\n\t\t\tRealmId:   realm.ID(),\n\t\t\tClientId:  openidClient.ID(),\n\t\t\tClaimName: pulumi.String(\"groups\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst groupMembershipMapper = new keycloak.openid.GroupMembershipProtocolMapper(\"groupMembershipMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    claimName: \"groups\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\ngroup_membership_mapper = keycloak.openid.GroupMembershipProtocolMapper(\"groupMembershipMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    claim_name=\"groups\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var groupMembershipMapper = new Keycloak.OpenId.GroupMembershipProtocolMapper(\"groupMembershipMapper\", new Keycloak.OpenId.GroupMembershipProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            ClaimName = \"groups\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewGroupMembershipProtocolMapper(ctx, \"groupMembershipMapper\", \u0026openid.GroupMembershipProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tClaimName:     pulumi.String(\"groups\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "fullPath": {
                    "type": "boolean",
                    "description": "Indicates whether the full path of the group including its parents will be used. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "fullPath": {
                    "type": "boolean",
                    "description": "Indicates whether the full path of the group including its parents will be used. Defaults to `true`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GroupMembershipProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "The name of the claim to insert into a token.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "fullPath": {
                        "type": "boolean",
                        "description": "Indicates whether the full path of the group including its parents will be used. Defaults to `true`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/hardcodedClaimProtocolMapper:HardcodedClaimProtocolMapper": {
            "description": "Allows for creating and managing hardcoded claim protocol mappers within Keycloak.\n\nHardcoded claim protocol mappers allow you to define a claim with a hardcoded value.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst hardcodedClaimMapper = new keycloak.openid.HardcodedClaimProtocolMapper(\"hardcodedClaimMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    claimName: \"foo\",\n    claimValue: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nhardcoded_claim_mapper = keycloak.openid.HardcodedClaimProtocolMapper(\"hardcodedClaimMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    claim_name=\"foo\",\n    claim_value=\"bar\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var hardcodedClaimMapper = new Keycloak.OpenId.HardcodedClaimProtocolMapper(\"hardcodedClaimMapper\", new Keycloak.OpenId.HardcodedClaimProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n            ClaimName = \"foo\",\n            ClaimValue = \"bar\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewHardcodedClaimProtocolMapper(ctx, \"hardcodedClaimMapper\", \u0026openid.HardcodedClaimProtocolMapperArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   openidClient.ID(),\n\t\t\tClaimName:  pulumi.String(\"foo\"),\n\t\t\tClaimValue: pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst hardcodedClaimMapper = new keycloak.openid.HardcodedClaimProtocolMapper(\"hardcodedClaimMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    claimName: \"foo\",\n    claimValue: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nhardcoded_claim_mapper = keycloak.openid.HardcodedClaimProtocolMapper(\"hardcodedClaimMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    claim_name=\"foo\",\n    claim_value=\"bar\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var hardcodedClaimMapper = new Keycloak.OpenId.HardcodedClaimProtocolMapper(\"hardcodedClaimMapper\", new Keycloak.OpenId.HardcodedClaimProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            ClaimName = \"foo\",\n            ClaimValue = \"bar\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewHardcodedClaimProtocolMapper(ctx, \"hardcodedClaimMapper\", \u0026openid.HardcodedClaimProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tClaimName:     pulumi.String(\"foo\"),\n\t\t\tClaimValue:    pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValue": {
                    "type": "string",
                    "description": "The hardcoded value of the claim.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "required": [
                "claimName",
                "claimValue",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValue": {
                    "type": "string",
                    "description": "The hardcoded value of the claim.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "claimValue",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedClaimProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "The name of the claim to insert into a token.\n"
                    },
                    "claimValue": {
                        "type": "string",
                        "description": "The hardcoded value of the claim.\n"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/hardcodedRoleProtocolMapper:HardcodedRoleProtocolMapper": {
            "description": "Allows for creating and managing hardcoded role protocol mappers within Keycloak.\n\nHardcoded role protocol mappers allow you to specify a single role to always map to an access token for a client.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst role = new keycloak.Role(\"role\", {realmId: realm.id});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst hardcodedRoleMapper = new keycloak.openid.HardcodedRoleProtocolMapper(\"hardcodedRoleMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    roleId: role.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrole = keycloak.Role(\"role\", realm_id=realm.id)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nhardcoded_role_mapper = keycloak.openid.HardcodedRoleProtocolMapper(\"hardcodedRoleMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    role_id=role.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var role = new Keycloak.Role(\"role\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var hardcodedRoleMapper = new Keycloak.OpenId.HardcodedRoleProtocolMapper(\"hardcodedRoleMapper\", new Keycloak.OpenId.HardcodedRoleProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n            RoleId = role.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trole, err := keycloak.NewRole(ctx, \"role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewHardcodedRoleProtocolMapper(ctx, \"hardcodedRoleMapper\", \u0026openid.HardcodedRoleProtocolMapperArgs{\n\t\t\tRealmId:  realm.ID(),\n\t\t\tClientId: openidClient.ID(),\n\t\t\tRoleId:   role.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst role = new keycloak.Role(\"role\", {realmId: realm.id});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst hardcodedRoleMapper = new keycloak.openid.HardcodedRoleProtocolMapper(\"hardcodedRoleMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    roleId: role.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrole = keycloak.Role(\"role\", realm_id=realm.id)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nhardcoded_role_mapper = keycloak.openid.HardcodedRoleProtocolMapper(\"hardcodedRoleMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    role_id=role.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var role = new Keycloak.Role(\"role\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Id,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var hardcodedRoleMapper = new Keycloak.OpenId.HardcodedRoleProtocolMapper(\"hardcodedRoleMapper\", new Keycloak.OpenId.HardcodedRoleProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            RoleId = role.Id,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trole, err := keycloak.NewRole(ctx, \"role\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewHardcodedRoleProtocolMapper(ctx, \"hardcodedRoleMapper\", \u0026openid.HardcodedRoleProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tRoleId:        role.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to map to an access token.\n"
                }
            },
            "required": [
                "name",
                "realmId",
                "roleId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The ID of the role to map to an access token.\n"
                }
            },
            "requiredInputs": [
                "realmId",
                "roleId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HardcodedRoleProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The ID of the role to map to an access token.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userAttributeProtocolMapper:UserAttributeProtocolMapper": {
            "description": "Allows for creating and managing user attribute protocol mappers within Keycloak.\n\nUser attribute protocol mappers allow you to map custom attributes defined for a user within Keycloak to a claim in a token.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userAttributeMapper = new keycloak.openid.UserAttributeProtocolMapper(\"userAttributeMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    userAttribute: \"foo\",\n    claimName: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_attribute_mapper = keycloak.openid.UserAttributeProtocolMapper(\"userAttributeMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    user_attribute=\"foo\",\n    claim_name=\"bar\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var userAttributeMapper = new Keycloak.OpenId.UserAttributeProtocolMapper(\"userAttributeMapper\", new Keycloak.OpenId.UserAttributeProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n            UserAttribute = \"foo\",\n            ClaimName = \"bar\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserAttributeProtocolMapper(ctx, \"userAttributeMapper\", \u0026openid.UserAttributeProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientId:      openidClient.ID(),\n\t\t\tUserAttribute: pulumi.String(\"foo\"),\n\t\t\tClaimName:     pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst userAttributeMapper = new keycloak.openid.UserAttributeProtocolMapper(\"userAttributeMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    userAttribute: \"foo\",\n    claimName: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nuser_attribute_mapper = keycloak.openid.UserAttributeProtocolMapper(\"userAttributeMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    user_attribute=\"foo\",\n    claim_name=\"bar\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var userAttributeMapper = new Keycloak.OpenId.UserAttributeProtocolMapper(\"userAttributeMapper\", new Keycloak.OpenId.UserAttributeProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            UserAttribute = \"foo\",\n            ClaimName = \"bar\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserAttributeProtocolMapper(ctx, \"userAttributeMapper\", \u0026openid.UserAttributeProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tUserAttribute: pulumi.String(\"foo\"),\n\t\t\tClaimName:     pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "aggregateAttributes": {
                    "type": "boolean",
                    "description": "Indicates whether this attribute is a single value or an array of values. Defaults to `false`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates whether this attribute is a single value or an array of values. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "userAttribute": {
                    "type": "string",
                    "description": "The custom user attribute to map a claim for.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId",
                "userAttribute"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the attribute should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "aggregateAttributes": {
                    "type": "boolean",
                    "description": "Indicates whether this attribute is a single value or an array of values. Defaults to `false`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates whether this attribute is a single value or an array of values. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "userAttribute": {
                    "type": "string",
                    "description": "The custom user attribute to map a claim for.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId",
                "userAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserAttributeProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the attribute should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                    },
                    "aggregateAttributes": {
                        "type": "boolean",
                        "description": "Indicates whether this attribute is a single value or an array of values. Defaults to `false`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "The name of the claim to insert into a token.\n"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "multivalued": {
                        "type": "boolean",
                        "description": "Indicates whether this attribute is a single value or an array of values. Defaults to `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    },
                    "userAttribute": {
                        "type": "string",
                        "description": "The custom user attribute to map a claim for.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userClientRoleProtocolMapper:UserClientRoleProtocolMapper": {
            "description": "Allows for creating and managing user client role protocol mappers within Keycloak.\n\nUser client role protocol mappers allow you to define a claim containing the list of a client roles.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userClientRoleMapper = new keycloak.openid.UserClientRoleProtocolMapper(\"userClientRoleMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    claimName: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_client_role_mapper = keycloak.openid.UserClientRoleProtocolMapper(\"userClientRoleMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    claim_name=\"foo\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var userClientRoleMapper = new Keycloak.OpenId.UserClientRoleProtocolMapper(\"userClientRoleMapper\", new Keycloak.OpenId.UserClientRoleProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n            ClaimName = \"foo\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserClientRoleProtocolMapper(ctx, \"userClientRoleMapper\", \u0026openid.UserClientRoleProtocolMapperArgs{\n\t\t\tRealmId:   realm.ID(),\n\t\t\tClientId:  openidClient.ID(),\n\t\t\tClaimName: pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst userClientRoleMapper = new keycloak.openid.UserClientRoleProtocolMapper(\"userClientRoleMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    claimName: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nuser_client_role_mapper = keycloak.openid.UserClientRoleProtocolMapper(\"userClientRoleMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    claim_name=\"foo\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var userClientRoleMapper = new Keycloak.OpenId.UserClientRoleProtocolMapper(\"userClientRoleMapper\", new Keycloak.OpenId.UserClientRoleProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            ClaimName = \"foo\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserClientRoleProtocolMapper(ctx, \"userClientRoleMapper\", \u0026openid.UserClientRoleProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tClaimName:     pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientIdForRoleMappings": {
                    "type": "string",
                    "description": "The Client ID for role mappings. Just client roles of this client will be added to the token. If this is unset, client roles of all clients will be added to the token.\n"
                },
                "clientRolePrefix": {
                    "type": "string",
                    "description": "A prefix for each Client Role.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientIdForRoleMappings": {
                    "type": "string",
                    "description": "The Client ID for role mappings. Just client roles of this client will be added to the token. If this is unset, client roles of all clients will be added to the token.\n"
                },
                "clientRolePrefix": {
                    "type": "string",
                    "description": "A prefix for each Client Role.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserClientRoleProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "The name of the claim to insert into a token.\n"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientIdForRoleMappings": {
                        "type": "string",
                        "description": "The Client ID for role mappings. Just client roles of this client will be added to the token. If this is unset, client roles of all clients will be added to the token.\n"
                    },
                    "clientRolePrefix": {
                        "type": "string",
                        "description": "A prefix for each Client Role.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "multivalued": {
                        "type": "boolean",
                        "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userPropertyProtocolMapper:UserPropertyProtocolMapper": {
            "description": "Allows for creating and managing user property protocol mappers within Keycloak.\n\nUser property protocol mappers allow you to map built in properties defined on the Keycloak user interface to a claim in\na token.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userPropertyMapper = new keycloak.openid.UserPropertyProtocolMapper(\"userPropertyMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    userProperty: \"email\",\n    claimName: \"email\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_property_mapper = keycloak.openid.UserPropertyProtocolMapper(\"userPropertyMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    user_property=\"email\",\n    claim_name=\"email\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var userPropertyMapper = new Keycloak.OpenId.UserPropertyProtocolMapper(\"userPropertyMapper\", new Keycloak.OpenId.UserPropertyProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n            UserProperty = \"email\",\n            ClaimName = \"email\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserPropertyProtocolMapper(ctx, \"userPropertyMapper\", \u0026openid.UserPropertyProtocolMapperArgs{\n\t\t\tRealmId:      realm.ID(),\n\t\t\tClientId:     openidClient.ID(),\n\t\t\tUserProperty: pulumi.String(\"email\"),\n\t\t\tClaimName:    pulumi.String(\"email\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst userPropertyMapper = new keycloak.openid.UserPropertyProtocolMapper(\"userPropertyMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    userProperty: \"email\",\n    claimName: \"email\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nuser_property_mapper = keycloak.openid.UserPropertyProtocolMapper(\"userPropertyMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    user_property=\"email\",\n    claim_name=\"email\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var userPropertyMapper = new Keycloak.OpenId.UserPropertyProtocolMapper(\"userPropertyMapper\", new Keycloak.OpenId.UserPropertyProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            UserProperty = \"email\",\n            ClaimName = \"email\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserPropertyProtocolMapper(ctx, \"userPropertyMapper\", \u0026openid.UserPropertyProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tUserProperty:  pulumi.String(\"email\"),\n\t\t\tClaimName:     pulumi.String(\"email\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified. `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "userProperty": {
                    "type": "string",
                    "description": "The built in user property (such as email) to map a claim for.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId",
                "userProperty"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified. `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "userProperty": {
                    "type": "string",
                    "description": "The built in user property (such as email) to map a claim for.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId",
                "userProperty"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserPropertyProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "The name of the claim to insert into a token.\n"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified. `client_scope_id` - (Required if `client_id` is not specified) The client scope this protocol mapper is attached to.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    },
                    "userProperty": {
                        "type": "string",
                        "description": "The built in user property (such as email) to map a claim for.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userRealmRoleProtocolMapper:UserRealmRoleProtocolMapper": {
            "description": "Allows for creating and managing user realm role protocol mappers within Keycloak.\n\nUser realm role protocol mappers allow you to define a claim containing the list of the realm roles.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userRealmRoleMapper = new keycloak.openid.UserRealmRoleProtocolMapper(\"userRealmRoleMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    claimName: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_realm_role_mapper = keycloak.openid.UserRealmRoleProtocolMapper(\"userRealmRoleMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    claim_name=\"foo\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var userRealmRoleMapper = new Keycloak.OpenId.UserRealmRoleProtocolMapper(\"userRealmRoleMapper\", new Keycloak.OpenId.UserRealmRoleProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n            ClaimName = \"foo\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserRealmRoleProtocolMapper(ctx, \"userRealmRoleMapper\", \u0026openid.UserRealmRoleProtocolMapperArgs{\n\t\t\tRealmId:   realm.ID(),\n\t\t\tClientId:  openidClient.ID(),\n\t\t\tClaimName: pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst userRealmRoleMapper = new keycloak.openid.UserRealmRoleProtocolMapper(\"userRealmRoleMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    claimName: \"foo\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nuser_realm_role_mapper = keycloak.openid.UserRealmRoleProtocolMapper(\"userRealmRoleMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    claim_name=\"foo\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var userRealmRoleMapper = new Keycloak.OpenId.UserRealmRoleProtocolMapper(\"userRealmRoleMapper\", new Keycloak.OpenId.UserRealmRoleProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            ClaimName = \"foo\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserRealmRoleProtocolMapper(ctx, \"userRealmRoleMapper\", \u0026openid.UserRealmRoleProtocolMapperArgs{\n\t\t\tRealmId:       realm.ID(),\n\t\t\tClientScopeId: clientScope.ID(),\n\t\t\tClaimName:     pulumi.String(\"foo\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "realmRolePrefix": {
                    "type": "string",
                    "description": "A prefix for each Realm Role.\n"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "addToUserinfo": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "multivalued": {
                    "type": "boolean",
                    "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "realmRolePrefix": {
                    "type": "string",
                    "description": "A prefix for each Realm Role.\n"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserRealmRoleProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "addToUserinfo": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the UserInfo response body. Defaults to `true`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "The name of the claim to insert into a token.\n"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "multivalued": {
                        "type": "boolean",
                        "description": "Indicates if attribute supports multiple values. If true, then the list of all values of this attribute will be set as claim. If false, then just first value will be set as claim. Defaults to `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    },
                    "realmRolePrefix": {
                        "type": "string",
                        "description": "A prefix for each Realm Role.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:openid/userSessionNoteProtocolMapper:UserSessionNoteProtocolMapper": {
            "description": "Allows for creating and managing user session note protocol mappers within Keycloak.\n\nUser session note protocol mappers map a custom user session note to a token claim.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Client)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst openidClient = new keycloak.openid.Client(\"openidClient\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    enabled: true,\n    accessType: \"CONFIDENTIAL\",\n    validRedirectUris: [\"http://localhost:8080/openid-callback\"],\n});\nconst userSessionNoteMapper = new keycloak.openid.UserSessionNoteProtocolMapper(\"userSessionNoteMapper\", {\n    realmId: realm.id,\n    clientId: openidClient.id,\n    claimName: \"foo\",\n    claimValueType: \"String\",\n    sessionNote: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nopenid_client = keycloak.openid.Client(\"openidClient\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    enabled=True,\n    access_type=\"CONFIDENTIAL\",\n    valid_redirect_uris=[\"http://localhost:8080/openid-callback\"])\nuser_session_note_mapper = keycloak.openid.UserSessionNoteProtocolMapper(\"userSessionNoteMapper\",\n    realm_id=realm.id,\n    client_id=openid_client.id,\n    claim_name=\"foo\",\n    claim_value_type=\"String\",\n    session_note=\"bar\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var openidClient = new Keycloak.OpenId.Client(\"openidClient\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            Enabled = true,\n            AccessType = \"CONFIDENTIAL\",\n            ValidRedirectUris = \n            {\n                \"http://localhost:8080/openid-callback\",\n            },\n        });\n        var userSessionNoteMapper = new Keycloak.OpenId.UserSessionNoteProtocolMapper(\"userSessionNoteMapper\", new Keycloak.OpenId.UserSessionNoteProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientId = openidClient.Id,\n            ClaimName = \"foo\",\n            ClaimValueType = \"String\",\n            SessionNote = \"bar\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topenidClient, err := openid.NewClient(ctx, \"openidClient\", \u0026openid.ClientArgs{\n\t\t\tRealmId:    realm.ID(),\n\t\t\tClientId:   pulumi.String(\"client\"),\n\t\t\tEnabled:    pulumi.Bool(true),\n\t\t\tAccessType: pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tValidRedirectUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"http://localhost:8080/openid-callback\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserSessionNoteProtocolMapper(ctx, \"userSessionNoteMapper\", \u0026openid.UserSessionNoteProtocolMapperArgs{\n\t\t\tRealmId:        realm.ID(),\n\t\t\tClientId:       openidClient.ID(),\n\t\t\tClaimName:      pulumi.String(\"foo\"),\n\t\t\tClaimValueType: pulumi.String(\"String\"),\n\t\t\tSessionNote:    pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Client Scope)\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientScope = new keycloak.openid.ClientScope(\"clientScope\", {realmId: realm.id});\nconst userSessionNoteMapper = new keycloak.openid.UserSessionNoteProtocolMapper(\"userSessionNoteMapper\", {\n    realmId: realm.id,\n    clientScopeId: clientScope.id,\n    claimName: \"foo\",\n    claimValueType: \"String\",\n    sessionNote: \"bar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_scope = keycloak.openid.ClientScope(\"clientScope\", realm_id=realm.id)\nuser_session_note_mapper = keycloak.openid.UserSessionNoteProtocolMapper(\"userSessionNoteMapper\",\n    realm_id=realm.id,\n    client_scope_id=client_scope.id,\n    claim_name=\"foo\",\n    claim_value_type=\"String\",\n    session_note=\"bar\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientScope = new Keycloak.OpenId.ClientScope(\"clientScope\", new Keycloak.OpenId.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n        });\n        var userSessionNoteMapper = new Keycloak.OpenId.UserSessionNoteProtocolMapper(\"userSessionNoteMapper\", new Keycloak.OpenId.UserSessionNoteProtocolMapperArgs\n        {\n            RealmId = realm.Id,\n            ClientScopeId = clientScope.Id,\n            ClaimName = \"foo\",\n            ClaimValueType = \"String\",\n            SessionNote = \"bar\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientScope, err := openid.NewClientScope(ctx, \"clientScope\", \u0026openid.ClientScopeArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewUserSessionNoteProtocolMapper(ctx, \"userSessionNoteMapper\", \u0026openid.UserSessionNoteProtocolMapperArgs{\n\t\t\tRealmId:        realm.ID(),\n\t\t\tClientScopeId:  clientScope.ID(),\n\t\t\tClaimName:      pulumi.String(\"foo\"),\n\t\t\tClaimValueType: pulumi.String(\"String\"),\n\t\t\tSessionNote:    pulumi.String(\"bar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "sessionNote": {
                    "type": "string",
                    "description": "String value being the name of stored user session note within the UserSessionModel.note map.\n"
                },
                "sessionNoteLabel": {
                    "type": "string",
                    "description": "**Deprecated** Use `session_note` instead.\n",
                    "deprecationMessage": "use session_note instead"
                }
            },
            "required": [
                "claimName",
                "name",
                "realmId"
            ],
            "inputProperties": {
                "addToAccessToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                },
                "addToIdToken": {
                    "type": "boolean",
                    "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                },
                "claimName": {
                    "type": "string",
                    "description": "The name of the claim to insert into a token.\n"
                },
                "claimValueType": {
                    "type": "string",
                    "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "sessionNote": {
                    "type": "string",
                    "description": "String value being the name of stored user session note within the UserSessionModel.note map.\n"
                },
                "sessionNoteLabel": {
                    "type": "string",
                    "description": "**Deprecated** Use `session_note` instead.\n",
                    "deprecationMessage": "use session_note instead"
                }
            },
            "requiredInputs": [
                "claimName",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserSessionNoteProtocolMapper resources.\n",
                "properties": {
                    "addToAccessToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the access token. Defaults to `true`.\n"
                    },
                    "addToIdToken": {
                        "type": "boolean",
                        "description": "Indicates if the property should be added as a claim to the id token. Defaults to `true`.\n"
                    },
                    "claimName": {
                        "type": "string",
                        "description": "The name of the claim to insert into a token.\n"
                    },
                    "claimValueType": {
                        "type": "string",
                        "description": "The claim type used when serializing JSON tokens. Can be one of `String`, `JSON`, `long`, `int`, or `boolean`. Defaults to `String`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    },
                    "sessionNote": {
                        "type": "string",
                        "description": "String value being the name of stored user session note within the UserSessionModel.note map.\n"
                    },
                    "sessionNoteLabel": {
                        "type": "string",
                        "description": "**Deprecated** Use `session_note` instead.\n",
                        "deprecationMessage": "use session_note instead"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/client:Client": {
            "description": "Allows for creating and managing Keycloak clients that use the SAML protocol.\n\nClients are entities that can use Keycloak for user authentication. Typically, clients are applications that redirect users\nto Keycloak for authentication in order to take advantage of Keycloak's user sessions for SSO.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\nimport * from \"fs\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClient = new keycloak.saml.Client(\"samlClient\", {\n    realmId: realm.id,\n    clientId: \"saml-client\",\n    signDocuments: false,\n    signAssertions: true,\n    includeAuthnStatement: true,\n    signingCertificate: fs.readFileSync(\"saml-cert.pem\"),\n    signingPrivateKey: fs.readFileSync(\"saml-key.pem\"),\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client = keycloak.saml.Client(\"samlClient\",\n    realm_id=realm.id,\n    client_id=\"saml-client\",\n    sign_documents=False,\n    sign_assertions=True,\n    include_authn_statement=True,\n    signing_certificate=(lambda path: open(path).read())(\"saml-cert.pem\"),\n    signing_private_key=(lambda path: open(path).read())(\"saml-key.pem\"))\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var samlClient = new Keycloak.Saml.Client(\"samlClient\", new Keycloak.Saml.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"saml-client\",\n            SignDocuments = false,\n            SignAssertions = true,\n            IncludeAuthnStatement = true,\n            SigningCertificate = File.ReadAllText(\"saml-cert.pem\"),\n            SigningPrivateKey = File.ReadAllText(\"saml-key.pem\"),\n        });\n    }\n\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "assertionConsumerPostUrl": {
                    "type": "string",
                    "description": "SAML POST Binding URL for the client's assertion consumer service (login responses).\n"
                },
                "assertionConsumerRedirectUrl": {
                    "type": "string",
                    "description": "SAML Redirect Binding URL for the client's assertion consumer service (login responses).\n"
                },
                "baseUrl": {
                    "type": "string",
                    "description": "When specified, this URL will be used whenever Keycloak needs to link to this client.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The unique ID of this client, referenced in the URI during authentication and in issued tokens.\n"
                },
                "clientSignatureRequired": {
                    "type": "boolean",
                    "description": "When `true`, Keycloak will expect that documents originating from a client will be signed using the certificate and/or key configured via `signing_certificate` and `signing_private_key`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client in the GUI.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When false, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.\n"
                },
                "encryptAssertions": {
                    "type": "boolean",
                    "description": "When `true`, the SAML assertions will be encrypted by Keycloak using the client's public key.\n"
                },
                "encryptionCertificate": {
                    "type": "string",
                    "description": "If assertions for the client are encrypted, this certificate will be used for encryption.\n"
                },
                "forceNameIdFormat": {
                    "type": "boolean",
                    "description": "Ignore requested NameID subject format and use the one defined in `name_id_format` instead.\n"
                },
                "forcePostBinding": {
                    "type": "boolean",
                    "description": "When `true`, Keycloak will always respond to an authentication request via the SAML POST Binding.\n"
                },
                "frontChannelLogout": {
                    "type": "boolean",
                    "description": "When `true`, this client will require a browser redirect in order to perform a logout.\n"
                },
                "fullScopeAllowed": {
                    "type": "boolean",
                    "description": "- Allow to include all roles mappings in the access token\n"
                },
                "idpInitiatedSsoRelayState": {
                    "type": "string",
                    "description": "Relay state you want to send with SAML request when you want to do IDP Initiated SSO.\n"
                },
                "idpInitiatedSsoUrlName": {
                    "type": "string",
                    "description": "URL fragment name to reference client when you want to do IDP Initiated SSO.\n"
                },
                "includeAuthnStatement": {
                    "type": "boolean",
                    "description": "When `true`, an `AuthnStatement` will be included in the SAML response.\n"
                },
                "logoutServicePostBindingUrl": {
                    "type": "string",
                    "description": "SAML POST Binding URL for the client's single logout service.\n"
                },
                "logoutServiceRedirectBindingUrl": {
                    "type": "string",
                    "description": "SAML Redirect Binding URL for the client's single logout service.\n"
                },
                "masterSamlProcessingUrl": {
                    "type": "string",
                    "description": "When specified, this URL will be used for all SAML requests.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this client in the GUI.\n"
                },
                "nameIdFormat": {
                    "type": "string",
                    "description": "Sets the Name ID format for the subject.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client is attached to.\n"
                },
                "rootUrl": {
                    "type": "string",
                    "description": "When specified, this value is prepended to all relative URLs.\n"
                },
                "signAssertions": {
                    "type": "boolean",
                    "description": "When `true`, the SAML assertions will be signed by Keycloak using the realm's private key, and embedded within the SAML XML Auth response.\n"
                },
                "signDocuments": {
                    "type": "boolean",
                    "description": "When `true`, the SAML document will be signed by Keycloak using the realm's private key.\n"
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "description": "The signature algorithm used to sign documents. Should be one of \"RSA_SHA1\", \"RSA_SHA256\", \"RSA_SHA512\", or \"DSA_SHA1\".\n"
                },
                "signingCertificate": {
                    "type": "string",
                    "description": "If documents or assertions from the client are signed, this certificate will be used to verify the signature.\n"
                },
                "signingPrivateKey": {
                    "type": "string",
                    "description": "If documents or assertions from the client are signed, this private key will be used to verify the signature.\n"
                },
                "validRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "When specified, Keycloak will use this list to validate given Assertion Consumer URLs specified in the authentication request.\n"
                }
            },
            "required": [
                "clientId",
                "clientSignatureRequired",
                "encryptAssertions",
                "forceNameIdFormat",
                "forcePostBinding",
                "frontChannelLogout",
                "includeAuthnStatement",
                "name",
                "nameIdFormat",
                "realmId",
                "signAssertions",
                "signDocuments"
            ],
            "inputProperties": {
                "assertionConsumerPostUrl": {
                    "type": "string",
                    "description": "SAML POST Binding URL for the client's assertion consumer service (login responses).\n"
                },
                "assertionConsumerRedirectUrl": {
                    "type": "string",
                    "description": "SAML Redirect Binding URL for the client's assertion consumer service (login responses).\n"
                },
                "baseUrl": {
                    "type": "string",
                    "description": "When specified, this URL will be used whenever Keycloak needs to link to this client.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The unique ID of this client, referenced in the URI during authentication and in issued tokens.\n"
                },
                "clientSignatureRequired": {
                    "type": "boolean",
                    "description": "When `true`, Keycloak will expect that documents originating from a client will be signed using the certificate and/or key configured via `signing_certificate` and `signing_private_key`.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client in the GUI.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When false, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.\n"
                },
                "encryptAssertions": {
                    "type": "boolean",
                    "description": "When `true`, the SAML assertions will be encrypted by Keycloak using the client's public key.\n"
                },
                "encryptionCertificate": {
                    "type": "string",
                    "description": "If assertions for the client are encrypted, this certificate will be used for encryption.\n"
                },
                "forceNameIdFormat": {
                    "type": "boolean",
                    "description": "Ignore requested NameID subject format and use the one defined in `name_id_format` instead.\n"
                },
                "forcePostBinding": {
                    "type": "boolean",
                    "description": "When `true`, Keycloak will always respond to an authentication request via the SAML POST Binding.\n"
                },
                "frontChannelLogout": {
                    "type": "boolean",
                    "description": "When `true`, this client will require a browser redirect in order to perform a logout.\n"
                },
                "fullScopeAllowed": {
                    "type": "boolean",
                    "description": "- Allow to include all roles mappings in the access token\n"
                },
                "idpInitiatedSsoRelayState": {
                    "type": "string",
                    "description": "Relay state you want to send with SAML request when you want to do IDP Initiated SSO.\n"
                },
                "idpInitiatedSsoUrlName": {
                    "type": "string",
                    "description": "URL fragment name to reference client when you want to do IDP Initiated SSO.\n"
                },
                "includeAuthnStatement": {
                    "type": "boolean",
                    "description": "When `true`, an `AuthnStatement` will be included in the SAML response.\n"
                },
                "logoutServicePostBindingUrl": {
                    "type": "string",
                    "description": "SAML POST Binding URL for the client's single logout service.\n"
                },
                "logoutServiceRedirectBindingUrl": {
                    "type": "string",
                    "description": "SAML Redirect Binding URL for the client's single logout service.\n"
                },
                "masterSamlProcessingUrl": {
                    "type": "string",
                    "description": "When specified, this URL will be used for all SAML requests.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this client in the GUI.\n"
                },
                "nameIdFormat": {
                    "type": "string",
                    "description": "Sets the Name ID format for the subject.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client is attached to.\n"
                },
                "rootUrl": {
                    "type": "string",
                    "description": "When specified, this value is prepended to all relative URLs.\n"
                },
                "signAssertions": {
                    "type": "boolean",
                    "description": "When `true`, the SAML assertions will be signed by Keycloak using the realm's private key, and embedded within the SAML XML Auth response.\n"
                },
                "signDocuments": {
                    "type": "boolean",
                    "description": "When `true`, the SAML document will be signed by Keycloak using the realm's private key.\n"
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "description": "The signature algorithm used to sign documents. Should be one of \"RSA_SHA1\", \"RSA_SHA256\", \"RSA_SHA512\", or \"DSA_SHA1\".\n"
                },
                "signingCertificate": {
                    "type": "string",
                    "description": "If documents or assertions from the client are signed, this certificate will be used to verify the signature.\n"
                },
                "signingPrivateKey": {
                    "type": "string",
                    "description": "If documents or assertions from the client are signed, this private key will be used to verify the signature.\n"
                },
                "validRedirectUris": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "When specified, Keycloak will use this list to validate given Assertion Consumer URLs specified in the authentication request.\n"
                }
            },
            "requiredInputs": [
                "clientId",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Client resources.\n",
                "properties": {
                    "assertionConsumerPostUrl": {
                        "type": "string",
                        "description": "SAML POST Binding URL for the client's assertion consumer service (login responses).\n"
                    },
                    "assertionConsumerRedirectUrl": {
                        "type": "string",
                        "description": "SAML Redirect Binding URL for the client's assertion consumer service (login responses).\n"
                    },
                    "baseUrl": {
                        "type": "string",
                        "description": "When specified, this URL will be used whenever Keycloak needs to link to this client.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "The unique ID of this client, referenced in the URI during authentication and in issued tokens.\n"
                    },
                    "clientSignatureRequired": {
                        "type": "boolean",
                        "description": "When `true`, Keycloak will expect that documents originating from a client will be signed using the certificate and/or key configured via `signing_certificate` and `signing_private_key`.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of this client in the GUI.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When false, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.\n"
                    },
                    "encryptAssertions": {
                        "type": "boolean",
                        "description": "When `true`, the SAML assertions will be encrypted by Keycloak using the client's public key.\n"
                    },
                    "encryptionCertificate": {
                        "type": "string",
                        "description": "If assertions for the client are encrypted, this certificate will be used for encryption.\n"
                    },
                    "forceNameIdFormat": {
                        "type": "boolean",
                        "description": "Ignore requested NameID subject format and use the one defined in `name_id_format` instead.\n"
                    },
                    "forcePostBinding": {
                        "type": "boolean",
                        "description": "When `true`, Keycloak will always respond to an authentication request via the SAML POST Binding.\n"
                    },
                    "frontChannelLogout": {
                        "type": "boolean",
                        "description": "When `true`, this client will require a browser redirect in order to perform a logout.\n"
                    },
                    "fullScopeAllowed": {
                        "type": "boolean",
                        "description": "- Allow to include all roles mappings in the access token\n"
                    },
                    "idpInitiatedSsoRelayState": {
                        "type": "string",
                        "description": "Relay state you want to send with SAML request when you want to do IDP Initiated SSO.\n"
                    },
                    "idpInitiatedSsoUrlName": {
                        "type": "string",
                        "description": "URL fragment name to reference client when you want to do IDP Initiated SSO.\n"
                    },
                    "includeAuthnStatement": {
                        "type": "boolean",
                        "description": "When `true`, an `AuthnStatement` will be included in the SAML response.\n"
                    },
                    "logoutServicePostBindingUrl": {
                        "type": "string",
                        "description": "SAML POST Binding URL for the client's single logout service.\n"
                    },
                    "logoutServiceRedirectBindingUrl": {
                        "type": "string",
                        "description": "SAML Redirect Binding URL for the client's single logout service.\n"
                    },
                    "masterSamlProcessingUrl": {
                        "type": "string",
                        "description": "When specified, this URL will be used for all SAML requests.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this client in the GUI.\n"
                    },
                    "nameIdFormat": {
                        "type": "string",
                        "description": "Sets the Name ID format for the subject.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this client is attached to.\n"
                    },
                    "rootUrl": {
                        "type": "string",
                        "description": "When specified, this value is prepended to all relative URLs.\n"
                    },
                    "signAssertions": {
                        "type": "boolean",
                        "description": "When `true`, the SAML assertions will be signed by Keycloak using the realm's private key, and embedded within the SAML XML Auth response.\n"
                    },
                    "signDocuments": {
                        "type": "boolean",
                        "description": "When `true`, the SAML document will be signed by Keycloak using the realm's private key.\n"
                    },
                    "signatureAlgorithm": {
                        "type": "string",
                        "description": "The signature algorithm used to sign documents. Should be one of \"RSA_SHA1\", \"RSA_SHA256\", \"RSA_SHA512\", or \"DSA_SHA1\".\n"
                    },
                    "signingCertificate": {
                        "type": "string",
                        "description": "If documents or assertions from the client are signed, this certificate will be used to verify the signature.\n"
                    },
                    "signingPrivateKey": {
                        "type": "string",
                        "description": "If documents or assertions from the client are signed, this private key will be used to verify the signature.\n"
                    },
                    "validRedirectUris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "When specified, Keycloak will use this list to validate given Assertion Consumer URLs specified in the authentication request.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/clientDefaultScope:ClientDefaultScope": {
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client to attach default scopes to. Note that this is the unique ID of the client generated by Keycloak.\n"
                },
                "defaultScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of client scope names to attach to this client.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client and scopes exists in.\n"
                }
            },
            "required": [
                "clientId",
                "defaultScopes",
                "realmId"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The ID of the client to attach default scopes to. Note that this is the unique ID of the client generated by Keycloak.\n"
                },
                "defaultScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of client scope names to attach to this client.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client and scopes exists in.\n"
                }
            },
            "requiredInputs": [
                "clientId",
                "defaultScopes",
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientDefaultScope resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The ID of the client to attach default scopes to. Note that this is the unique ID of the client generated by Keycloak.\n"
                    },
                    "defaultScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of client scope names to attach to this client.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this client and scopes exists in.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/clientScope:ClientScope": {
            "description": "Allows for creating and managing Keycloak client scopes that can be attached to clients that use the SAML protocol.\n\nClient Scopes can be used to share common protocol and role mappings between multiple clients within a realm.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClientScope = new keycloak.saml.ClientScope(\"samlClientScope\", {\n    realmId: realm.id,\n    description: \"This scope will map a user's group memberships to SAML assertion\",\n    guiOrder: 1,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client_scope = keycloak.saml.ClientScope(\"samlClientScope\",\n    realm_id=realm.id,\n    description=\"This scope will map a user's group memberships to SAML assertion\",\n    gui_order=1)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var samlClientScope = new Keycloak.Saml.ClientScope(\"samlClientScope\", new Keycloak.Saml.ClientScopeArgs\n        {\n            RealmId = realm.Id,\n            Description = \"This scope will map a user's group memberships to SAML assertion\",\n            GuiOrder = 1,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = saml.NewClientScope(ctx, \"samlClientScope\", \u0026saml.ClientScopeArgs{\n\t\t\tRealmId:     realm.ID(),\n\t\t\tDescription: pulumi.String(\"This scope will map a user's group memberships to SAML assertion\"),\n\t\t\tGuiOrder:    pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "consentScreenText": {
                    "type": "string",
                    "description": "When set, a consent screen will be displayed to users authenticating to clients with this scope attached. The consent screen will display the string value of this attribute.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client scope in the GUI.\n"
                },
                "guiOrder": {
                    "type": "integer",
                    "description": "Specify order of the client scope in GUI (such as in Consent page) as integer.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this client scope in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client scope belongs to.\n"
                }
            },
            "required": [
                "name",
                "realmId"
            ],
            "inputProperties": {
                "consentScreenText": {
                    "type": "string",
                    "description": "When set, a consent screen will be displayed to users authenticating to clients with this scope attached. The consent screen will display the string value of this attribute.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of this client scope in the GUI.\n"
                },
                "guiOrder": {
                    "type": "integer",
                    "description": "Specify order of the client scope in GUI (such as in Consent page) as integer.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this client scope in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this client scope belongs to.\n"
                }
            },
            "requiredInputs": [
                "realmId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClientScope resources.\n",
                "properties": {
                    "consentScreenText": {
                        "type": "string",
                        "description": "When set, a consent screen will be displayed to users authenticating to clients with this scope attached. The consent screen will display the string value of this attribute.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of this client scope in the GUI.\n"
                    },
                    "guiOrder": {
                        "type": "integer",
                        "description": "Specify order of the client scope in GUI (such as in Consent page) as integer.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this client scope in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this client scope belongs to.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/identityProvider:IdentityProvider": {
            "description": "Allows for creating and managing SAML Identity Providers within Keycloak.\n\nSAML (Security Assertion Markup Language) identity providers allows users to authenticate through a third-party system using the SAML protocol.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst realmSamlIdentityProvider = new keycloak.saml.IdentityProvider(\"realmSamlIdentityProvider\", {\n    realm: realm.id,\n    alias: \"my-saml-idp\",\n    singleSignOnServiceUrl: \"https://domain.com/adfs/ls/\",\n    singleLogoutServiceUrl: \"https://domain.com/adfs/ls/?wa=wsignout1.0\",\n    backchannelSupported: true,\n    postBindingResponse: true,\n    postBindingLogout: true,\n    postBindingAuthnRequest: true,\n    storeToken: false,\n    trustEmail: true,\n    forceAuthn: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nrealm_saml_identity_provider = keycloak.saml.IdentityProvider(\"realmSamlIdentityProvider\",\n    realm=realm.id,\n    alias=\"my-saml-idp\",\n    single_sign_on_service_url=\"https://domain.com/adfs/ls/\",\n    single_logout_service_url=\"https://domain.com/adfs/ls/?wa=wsignout1.0\",\n    backchannel_supported=True,\n    post_binding_response=True,\n    post_binding_logout=True,\n    post_binding_authn_request=True,\n    store_token=False,\n    trust_email=True,\n    force_authn=True)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var realmSamlIdentityProvider = new Keycloak.Saml.IdentityProvider(\"realmSamlIdentityProvider\", new Keycloak.Saml.IdentityProviderArgs\n        {\n            Realm = realm.Id,\n            Alias = \"my-saml-idp\",\n            SingleSignOnServiceUrl = \"https://domain.com/adfs/ls/\",\n            SingleLogoutServiceUrl = \"https://domain.com/adfs/ls/?wa=wsignout1.0\",\n            BackchannelSupported = true,\n            PostBindingResponse = true,\n            PostBindingLogout = true,\n            PostBindingAuthnRequest = true,\n            StoreToken = false,\n            TrustEmail = true,\n            ForceAuthn = true,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = saml.NewIdentityProvider(ctx, \"realmSamlIdentityProvider\", \u0026saml.IdentityProviderArgs{\n\t\t\tRealm:                   realm.ID(),\n\t\t\tAlias:                   pulumi.String(\"my-saml-idp\"),\n\t\t\tSingleSignOnServiceUrl:  pulumi.String(\"https://domain.com/adfs/ls/\"),\n\t\t\tSingleLogoutServiceUrl:  pulumi.String(\"https://domain.com/adfs/ls/?wa=wsignout1.0\"),\n\t\t\tBackchannelSupported:    pulumi.Bool(true),\n\t\t\tPostBindingResponse:     pulumi.Bool(true),\n\t\t\tPostBindingLogout:       pulumi.Bool(true),\n\t\t\tPostBindingAuthnRequest: pulumi.Bool(true),\n\t\t\tStoreToken:              pulumi.Bool(false),\n\t\t\tTrustEmail:              pulumi.Bool(true),\n\t\t\tForceAuthn:              pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                },
                "alias": {
                    "type": "string",
                    "description": "The unique name of identity provider.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Authenticate users by default. Defaults to `false`.\n"
                },
                "backchannelSupported": {
                    "type": "boolean",
                    "description": "Does the external IDP support back-channel logout ?.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "The display name for the realm that is shown when logging in to the admin console.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, users and clients will not be able to access this realm. Defaults to `true`.\n"
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that there is not yet existing Keycloak account linked with the authenticated identity provider account. Defaults to `first broker login`.\n"
                },
                "forceAuthn": {
                    "type": "boolean",
                    "description": "Indicates whether the identity provider must authenticate the presenter directly rather than rely on a previous security context.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "If hidden, then login with this provider is possible only if requested explicitly, e.g. using the 'kc_idp_hint' parameter.\n"
                },
                "internalId": {
                    "type": "string",
                    "description": "Internal Identity Provider Id\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                },
                "nameIdPolicyFormat": {
                    "type": "string",
                    "description": "Specifies the URI reference corresponding to a name identifier format. Defaults to empty.\n"
                },
                "postBindingAuthnRequest": {
                    "type": "boolean",
                    "description": "Indicates whether the AuthnRequest must be sent using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\n"
                },
                "postBindingLogout": {
                    "type": "boolean",
                    "description": "Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\n"
                },
                "postBindingResponse": {
                    "type": "boolean",
                    "description": "Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used..\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it. Defaults to empty.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak.\n"
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "description": "Signing Algorithm. Defaults to empty.\n"
                },
                "signingCertificate": {
                    "type": "string",
                    "description": "Signing Certificate.\n"
                },
                "singleLogoutServiceUrl": {
                    "type": "string",
                    "description": "The Url that must be used to send logout requests.\n"
                },
                "singleSignOnServiceUrl": {
                    "type": "string",
                    "description": "The Url that must be used to send authentication requests (SAML AuthnRequest).\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                },
                "validateSignature": {
                    "type": "boolean",
                    "description": "Enable/disable signature validation of SAML responses.\n"
                },
                "wantAssertionsEncrypted": {
                    "type": "boolean",
                    "description": "Indicates whether this service provider expects an encrypted Assertion.\n"
                },
                "wantAssertionsSigned": {
                    "type": "boolean",
                    "description": "Indicates whether this service provider expects a signed Assertion.\n"
                },
                "xmlSignKeyInfoKeyNameTransformer": {
                    "type": "string",
                    "description": "Sign Key Transformer. Defaults to empty.\n"
                }
            },
            "required": [
                "alias",
                "internalId",
                "realm",
                "singleSignOnServiceUrl"
            ],
            "inputProperties": {
                "addReadTokenRoleOnCreate": {
                    "type": "boolean",
                    "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                },
                "alias": {
                    "type": "string",
                    "description": "The unique name of identity provider.\n"
                },
                "authenticateByDefault": {
                    "type": "boolean",
                    "description": "Authenticate users by default. Defaults to `false`.\n"
                },
                "backchannelSupported": {
                    "type": "boolean",
                    "description": "Does the external IDP support back-channel logout ?.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "The display name for the realm that is shown when logging in to the admin console.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "When `false`, users and clients will not be able to access this realm. Defaults to `true`.\n"
                },
                "firstBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that there is not yet existing Keycloak account linked with the authenticated identity provider account. Defaults to `first broker login`.\n"
                },
                "forceAuthn": {
                    "type": "boolean",
                    "description": "Indicates whether the identity provider must authenticate the presenter directly rather than rely on a previous security context.\n"
                },
                "hideOnLoginPage": {
                    "type": "boolean",
                    "description": "If hidden, then login with this provider is possible only if requested explicitly, e.g. using the 'kc_idp_hint' parameter.\n"
                },
                "linkOnly": {
                    "type": "boolean",
                    "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                },
                "nameIdPolicyFormat": {
                    "type": "string",
                    "description": "Specifies the URI reference corresponding to a name identifier format. Defaults to empty.\n"
                },
                "postBindingAuthnRequest": {
                    "type": "boolean",
                    "description": "Indicates whether the AuthnRequest must be sent using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\n"
                },
                "postBindingLogout": {
                    "type": "boolean",
                    "description": "Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\n"
                },
                "postBindingResponse": {
                    "type": "boolean",
                    "description": "Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used..\n"
                },
                "postBrokerLoginFlowAlias": {
                    "type": "string",
                    "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it. Defaults to empty.\n"
                },
                "realm": {
                    "type": "string",
                    "description": "The name of the realm. This is unique across Keycloak.\n"
                },
                "signatureAlgorithm": {
                    "type": "string",
                    "description": "Signing Algorithm. Defaults to empty.\n"
                },
                "signingCertificate": {
                    "type": "string",
                    "description": "Signing Certificate.\n"
                },
                "singleLogoutServiceUrl": {
                    "type": "string",
                    "description": "The Url that must be used to send logout requests.\n"
                },
                "singleSignOnServiceUrl": {
                    "type": "string",
                    "description": "The Url that must be used to send authentication requests (SAML AuthnRequest).\n"
                },
                "storeToken": {
                    "type": "boolean",
                    "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                },
                "trustEmail": {
                    "type": "boolean",
                    "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                },
                "validateSignature": {
                    "type": "boolean",
                    "description": "Enable/disable signature validation of SAML responses.\n"
                },
                "wantAssertionsEncrypted": {
                    "type": "boolean",
                    "description": "Indicates whether this service provider expects an encrypted Assertion.\n"
                },
                "wantAssertionsSigned": {
                    "type": "boolean",
                    "description": "Indicates whether this service provider expects a signed Assertion.\n"
                },
                "xmlSignKeyInfoKeyNameTransformer": {
                    "type": "string",
                    "description": "Sign Key Transformer. Defaults to empty.\n"
                }
            },
            "requiredInputs": [
                "alias",
                "realm",
                "singleSignOnServiceUrl"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IdentityProvider resources.\n",
                "properties": {
                    "addReadTokenRoleOnCreate": {
                        "type": "boolean",
                        "description": "When `true`, new users will be able to read stored tokens. This will automatically assign the `broker.read-token` role. Defaults to `false`.\n"
                    },
                    "alias": {
                        "type": "string",
                        "description": "The unique name of identity provider.\n"
                    },
                    "authenticateByDefault": {
                        "type": "boolean",
                        "description": "Authenticate users by default. Defaults to `false`.\n"
                    },
                    "backchannelSupported": {
                        "type": "boolean",
                        "description": "Does the external IDP support back-channel logout ?.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "The display name for the realm that is shown when logging in to the admin console.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "When `false`, users and clients will not be able to access this realm. Defaults to `true`.\n"
                    },
                    "firstBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that there is not yet existing Keycloak account linked with the authenticated identity provider account. Defaults to `first broker login`.\n"
                    },
                    "forceAuthn": {
                        "type": "boolean",
                        "description": "Indicates whether the identity provider must authenticate the presenter directly rather than rely on a previous security context.\n"
                    },
                    "hideOnLoginPage": {
                        "type": "boolean",
                        "description": "If hidden, then login with this provider is possible only if requested explicitly, e.g. using the 'kc_idp_hint' parameter.\n"
                    },
                    "internalId": {
                        "type": "string",
                        "description": "Internal Identity Provider Id\n"
                    },
                    "linkOnly": {
                        "type": "boolean",
                        "description": "When `true`, users cannot login using this provider, but their existing accounts will be linked when possible. Defaults to `false`.\n"
                    },
                    "nameIdPolicyFormat": {
                        "type": "string",
                        "description": "Specifies the URI reference corresponding to a name identifier format. Defaults to empty.\n"
                    },
                    "postBindingAuthnRequest": {
                        "type": "boolean",
                        "description": "Indicates whether the AuthnRequest must be sent using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\n"
                    },
                    "postBindingLogout": {
                        "type": "boolean",
                        "description": "Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\n"
                    },
                    "postBindingResponse": {
                        "type": "boolean",
                        "description": "Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used..\n"
                    },
                    "postBrokerLoginFlowAlias": {
                        "type": "string",
                        "description": "Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it. Defaults to empty.\n"
                    },
                    "realm": {
                        "type": "string",
                        "description": "The name of the realm. This is unique across Keycloak.\n"
                    },
                    "signatureAlgorithm": {
                        "type": "string",
                        "description": "Signing Algorithm. Defaults to empty.\n"
                    },
                    "signingCertificate": {
                        "type": "string",
                        "description": "Signing Certificate.\n"
                    },
                    "singleLogoutServiceUrl": {
                        "type": "string",
                        "description": "The Url that must be used to send logout requests.\n"
                    },
                    "singleSignOnServiceUrl": {
                        "type": "string",
                        "description": "The Url that must be used to send authentication requests (SAML AuthnRequest).\n"
                    },
                    "storeToken": {
                        "type": "boolean",
                        "description": "When `true`, tokens will be stored after authenticating users. Defaults to `true`.\n"
                    },
                    "trustEmail": {
                        "type": "boolean",
                        "description": "When `true`, email addresses for users in this provider will automatically be verified regardless of the realm's email verification policy. Defaults to `false`.\n"
                    },
                    "validateSignature": {
                        "type": "boolean",
                        "description": "Enable/disable signature validation of SAML responses.\n"
                    },
                    "wantAssertionsEncrypted": {
                        "type": "boolean",
                        "description": "Indicates whether this service provider expects an encrypted Assertion.\n"
                    },
                    "wantAssertionsSigned": {
                        "type": "boolean",
                        "description": "Indicates whether this service provider expects a signed Assertion.\n"
                    },
                    "xmlSignKeyInfoKeyNameTransformer": {
                        "type": "string",
                        "description": "Sign Key Transformer. Defaults to empty.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/userAttributeProtocolMapper:UserAttributeProtocolMapper": {
            "description": "Allows for creating and managing user attribute protocol mappers for SAML clients within Keycloak.\n\nSAML user attribute protocol mappers allow you to map custom attributes defined for a user within Keycloak to an attribute\nin a SAML assertion.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClient = new keycloak.saml.Client(\"samlClient\", {\n    realmId: keycloak_realm.test.id,\n    clientId: \"saml-client\",\n});\nconst samlUserAttributeMapper = new keycloak.saml.UserAttributeProtocolMapper(\"samlUserAttributeMapper\", {\n    realmId: keycloak_realm.test.id,\n    clientId: samlClient.id,\n    userAttribute: \"displayName\",\n    samlAttributeName: \"displayName\",\n    samlAttributeNameFormat: \"Unspecified\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client = keycloak.saml.Client(\"samlClient\",\n    realm_id=keycloak_realm[\"test\"][\"id\"],\n    client_id=\"saml-client\")\nsaml_user_attribute_mapper = keycloak.saml.UserAttributeProtocolMapper(\"samlUserAttributeMapper\",\n    realm_id=keycloak_realm[\"test\"][\"id\"],\n    client_id=saml_client.id,\n    user_attribute=\"displayName\",\n    saml_attribute_name=\"displayName\",\n    saml_attribute_name_format=\"Unspecified\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var samlClient = new Keycloak.Saml.Client(\"samlClient\", new Keycloak.Saml.ClientArgs\n        {\n            RealmId = keycloak_realm.Test.Id,\n            ClientId = \"saml-client\",\n        });\n        var samlUserAttributeMapper = new Keycloak.Saml.UserAttributeProtocolMapper(\"samlUserAttributeMapper\", new Keycloak.Saml.UserAttributeProtocolMapperArgs\n        {\n            RealmId = keycloak_realm.Test.Id,\n            ClientId = samlClient.Id,\n            UserAttribute = \"displayName\",\n            SamlAttributeName = \"displayName\",\n            SamlAttributeNameFormat = \"Unspecified\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsamlClient, err := saml.NewClient(ctx, \"samlClient\", \u0026saml.ClientArgs{\n\t\t\tRealmId:  pulumi.Any(keycloak_realm.Test.Id),\n\t\t\tClientId: pulumi.String(\"saml-client\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = saml.NewUserAttributeProtocolMapper(ctx, \"samlUserAttributeMapper\", \u0026saml.UserAttributeProtocolMapperArgs{\n\t\t\tRealmId:                 pulumi.Any(keycloak_realm.Test.Id),\n\t\t\tClientId:                samlClient.ID(),\n\t\t\tUserAttribute:           pulumi.String(\"displayName\"),\n\t\t\tSamlAttributeName:       pulumi.String(\"displayName\"),\n\t\t\tSamlAttributeNameFormat: pulumi.String(\"Unspecified\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "friendlyName": {
                    "type": "string",
                    "description": "An optional human-friendly name for this attribute.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "samlAttributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "samlAttributeNameFormat": {
                    "type": "string",
                    "description": "The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n"
                },
                "userAttribute": {
                    "type": "string",
                    "description": "The custom user attribute to map.\n"
                }
            },
            "required": [
                "name",
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "userAttribute"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "friendlyName": {
                    "type": "string",
                    "description": "An optional human-friendly name for this attribute.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "samlAttributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "samlAttributeNameFormat": {
                    "type": "string",
                    "description": "The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n"
                },
                "userAttribute": {
                    "type": "string",
                    "description": "The custom user attribute to map.\n"
                }
            },
            "requiredInputs": [
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "userAttribute"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserAttributeProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "friendlyName": {
                        "type": "string",
                        "description": "An optional human-friendly name for this attribute.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    },
                    "samlAttributeName": {
                        "type": "string",
                        "description": "The name of the SAML attribute.\n"
                    },
                    "samlAttributeNameFormat": {
                        "type": "string",
                        "description": "The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n"
                    },
                    "userAttribute": {
                        "type": "string",
                        "description": "The custom user attribute to map.\n"
                    }
                },
                "type": "object"
            }
        },
        "keycloak:saml/userPropertyProtocolMapper:UserPropertyProtocolMapper": {
            "description": "Allows for creating and managing user property protocol mappers for SAML clients within Keycloak.\n\nSAML user property protocol mappers allow you to map properties of the Keycloak\nuser model to an attribute in a SAML assertion.\n\nProtocol mappers can be defined for a single client, or they can be defined for a client scope which can be shared between\nmultiple different clients.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClient = new keycloak.saml.Client(\"samlClient\", {\n    realmId: keycloak_realm.test.id,\n    clientId: \"saml-client\",\n});\nconst samlUserPropertyMapper = new keycloak.saml.UserPropertyProtocolMapper(\"samlUserPropertyMapper\", {\n    realmId: keycloak_realm.test.id,\n    clientId: samlClient.id,\n    userProperty: \"email\",\n    samlAttributeName: \"email\",\n    samlAttributeNameFormat: \"Unspecified\",\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client = keycloak.saml.Client(\"samlClient\",\n    realm_id=keycloak_realm[\"test\"][\"id\"],\n    client_id=\"saml-client\")\nsaml_user_property_mapper = keycloak.saml.UserPropertyProtocolMapper(\"samlUserPropertyMapper\",\n    realm_id=keycloak_realm[\"test\"][\"id\"],\n    client_id=saml_client.id,\n    user_property=\"email\",\n    saml_attribute_name=\"email\",\n    saml_attribute_name_format=\"Unspecified\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var samlClient = new Keycloak.Saml.Client(\"samlClient\", new Keycloak.Saml.ClientArgs\n        {\n            RealmId = keycloak_realm.Test.Id,\n            ClientId = \"saml-client\",\n        });\n        var samlUserPropertyMapper = new Keycloak.Saml.UserPropertyProtocolMapper(\"samlUserPropertyMapper\", new Keycloak.Saml.UserPropertyProtocolMapperArgs\n        {\n            RealmId = keycloak_realm.Test.Id,\n            ClientId = samlClient.Id,\n            UserProperty = \"email\",\n            SamlAttributeName = \"email\",\n            SamlAttributeNameFormat = \"Unspecified\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/saml\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsamlClient, err := saml.NewClient(ctx, \"samlClient\", \u0026saml.ClientArgs{\n\t\t\tRealmId:  pulumi.Any(keycloak_realm.Test.Id),\n\t\t\tClientId: pulumi.String(\"saml-client\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = saml.NewUserPropertyProtocolMapper(ctx, \"samlUserPropertyMapper\", \u0026saml.UserPropertyProtocolMapperArgs{\n\t\t\tRealmId:                 pulumi.Any(keycloak_realm.Test.Id),\n\t\t\tClientId:                samlClient.ID(),\n\t\t\tUserProperty:            pulumi.String(\"email\"),\n\t\t\tSamlAttributeName:       pulumi.String(\"email\"),\n\t\t\tSamlAttributeNameFormat: pulumi.String(\"Unspecified\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "friendlyName": {
                    "type": "string",
                    "description": "An optional human-friendly name for this attribute.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "samlAttributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "samlAttributeNameFormat": {
                    "type": "string",
                    "description": "The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n"
                },
                "userProperty": {
                    "type": "string",
                    "description": "The property of the Keycloak user model to map.\n"
                }
            },
            "required": [
                "name",
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "userProperty"
            ],
            "inputProperties": {
                "clientId": {
                    "type": "string",
                    "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "clientScopeId": {
                    "type": "string",
                    "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                },
                "friendlyName": {
                    "type": "string",
                    "description": "An optional human-friendly name for this attribute.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of this protocol mapper in the GUI.\n"
                },
                "realmId": {
                    "type": "string",
                    "description": "The realm this protocol mapper exists within.\n"
                },
                "samlAttributeName": {
                    "type": "string",
                    "description": "The name of the SAML attribute.\n"
                },
                "samlAttributeNameFormat": {
                    "type": "string",
                    "description": "The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n"
                },
                "userProperty": {
                    "type": "string",
                    "description": "The property of the Keycloak user model to map.\n"
                }
            },
            "requiredInputs": [
                "realmId",
                "samlAttributeName",
                "samlAttributeNameFormat",
                "userProperty"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering UserPropertyProtocolMapper resources.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The client this protocol mapper should be attached to. Conflicts with `client_scope_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "clientScopeId": {
                        "type": "string",
                        "description": "The client scope this protocol mapper should be attached to. Conflicts with `client_id`. One of `client_id` or `client_scope_id` must be specified.\n"
                    },
                    "friendlyName": {
                        "type": "string",
                        "description": "An optional human-friendly name for this attribute.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of this protocol mapper in the GUI.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this protocol mapper exists within.\n"
                    },
                    "samlAttributeName": {
                        "type": "string",
                        "description": "The name of the SAML attribute.\n"
                    },
                    "samlAttributeNameFormat": {
                        "type": "string",
                        "description": "The SAML attribute Name Format. Can be one of `Unspecified`, `Basic`, or `URI Reference`.\n"
                    },
                    "userProperty": {
                        "type": "string",
                        "description": "The property of the Keycloak user model to map.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "keycloak:index/getGroup:getGroup": {
            "description": "This data source can be used to fetch properties of a Keycloak group for\nusage with other resources, such as `keycloak.GroupRoles`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst offlineAccess = realm.id.apply(id =\u003e keycloak.getRole({\n    realmId: id,\n    name: \"offline_access\",\n}));\nconst group = realm.id.apply(id =\u003e keycloak.getGroup({\n    realmId: id,\n    name: \"group\",\n}));\nconst groupRoles = new keycloak.GroupRoles(\"groupRoles\", {\n    realmId: realm.id,\n    groupId: group.id,\n    roleIds: [offlineAccess.id],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\noffline_access = realm.id.apply(lambda id: keycloak.get_role(realm_id=id,\n    name=\"offline_access\"))\ngroup = realm.id.apply(lambda id: keycloak.get_group(realm_id=id,\n    name=\"group\"))\ngroup_roles = keycloak.GroupRoles(\"groupRoles\",\n    realm_id=realm.id,\n    group_id=group.id,\n    role_ids=[offline_access.id])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var offlineAccess = realm.Id.Apply(id =\u003e Keycloak.GetRole.InvokeAsync(new Keycloak.GetRoleArgs\n        {\n            RealmId = id,\n            Name = \"offline_access\",\n        }));\n        var @group = realm.Id.Apply(id =\u003e Keycloak.GetGroup.InvokeAsync(new Keycloak.GetGroupArgs\n        {\n            RealmId = id,\n            Name = \"group\",\n        }));\n        var groupRoles = new Keycloak.GroupRoles(\"groupRoles\", new Keycloak.GroupRolesArgs\n        {\n            RealmId = realm.Id,\n            GroupId = @group.Apply(@group =\u003e @group.Id),\n            RoleIds = \n            {\n                offlineAccess.Apply(offlineAccess =\u003e offlineAccess.Id),\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGroupRoles(ctx, \"groupRoles\", \u0026keycloak.GroupRolesArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tGroupId: group.ApplyT(func(group keycloak.LookupGroupResult) (string, error) {\n\t\t\t\treturn group.Id, nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tRoleIds: pulumi.StringArray{\n\t\t\t\tofflineAccess.ApplyT(func(offlineAccess keycloak.LookupRoleResult) (string, error) {\n\t\t\t\t\treturn offlineAccess.Id, nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getGroup.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the group. If there are multiple groups match `name`, the first result will be returned.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this group exists within.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGroup.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "parentId": {
                        "type": "string"
                    },
                    "path": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "attributes",
                    "name",
                    "parentId",
                    "path",
                    "realmId",
                    "id"
                ]
            }
        },
        "keycloak:index/getRealm:getRealm": {
            "description": "This data source can be used to fetch properties of a Keycloak realm for\nusage with other resources.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = keycloak.getRealm({\n    realm: \"my-realm\",\n});\nconst group = new keycloak.Role(\"group\", {realmId: realm.then(realm =\u003e realm.id)});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.get_realm(realm=\"my-realm\")\ngroup = keycloak.Role(\"group\", realm_id=realm.id)\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = Output.Create(Keycloak.GetRealm.InvokeAsync(new Keycloak.GetRealmArgs\n        {\n            Realm = \"my-realm\",\n        }));\n        var @group = new Keycloak.Role(\"group\", new Keycloak.RoleArgs\n        {\n            RealmId = realm.Apply(realm =\u003e realm.Id),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.LookupRealm(ctx, \u0026keycloak.LookupRealmArgs{\n\t\t\tRealm: \"my-realm\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewRole(ctx, \"group\", \u0026keycloak.RoleArgs{\n\t\t\tRealmId: pulumi.String(realm.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getRealm.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "displayNameHtml": {
                        "type": "string"
                    },
                    "internationalizations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmInternationalization:getRealmInternationalization"
                        }
                    },
                    "realm": {
                        "type": "string",
                        "description": "The realm name.\n"
                    },
                    "securityDefenses": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmSecurityDefense:getRealmSecurityDefense"
                        }
                    },
                    "smtpServers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmSmtpServer:getRealmSmtpServer"
                        }
                    },
                    "webAuthnPasswordlessPolicy": {
                        "$ref": "#/types/keycloak:index/getRealmWebAuthnPasswordlessPolicy:getRealmWebAuthnPasswordlessPolicy"
                    },
                    "webAuthnPolicy": {
                        "$ref": "#/types/keycloak:index/getRealmWebAuthnPolicy:getRealmWebAuthnPolicy"
                    }
                },
                "type": "object",
                "required": [
                    "realm"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRealm.\n",
                "properties": {
                    "accessCodeLifespan": {
                        "type": "string"
                    },
                    "accessCodeLifespanLogin": {
                        "type": "string"
                    },
                    "accessCodeLifespanUserAction": {
                        "type": "string"
                    },
                    "accessTokenLifespan": {
                        "type": "string"
                    },
                    "accessTokenLifespanForImplicitFlow": {
                        "type": "string"
                    },
                    "accountTheme": {
                        "type": "string"
                    },
                    "actionTokenGeneratedByAdminLifespan": {
                        "type": "string"
                    },
                    "actionTokenGeneratedByUserLifespan": {
                        "type": "string"
                    },
                    "adminTheme": {
                        "type": "string"
                    },
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "browserFlow": {
                        "type": "string"
                    },
                    "clientAuthenticationFlow": {
                        "type": "string"
                    },
                    "defaultSignatureAlgorithm": {
                        "type": "string"
                    },
                    "directGrantFlow": {
                        "type": "string"
                    },
                    "displayName": {
                        "type": "string"
                    },
                    "displayNameHtml": {
                        "type": "string"
                    },
                    "dockerAuthenticationFlow": {
                        "type": "string"
                    },
                    "duplicateEmailsAllowed": {
                        "type": "boolean"
                    },
                    "editUsernameAllowed": {
                        "type": "boolean"
                    },
                    "emailTheme": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "internalId": {
                        "type": "string"
                    },
                    "internationalizations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmInternationalization:getRealmInternationalization"
                        }
                    },
                    "loginTheme": {
                        "type": "string"
                    },
                    "loginWithEmailAllowed": {
                        "type": "boolean"
                    },
                    "offlineSessionIdleTimeout": {
                        "type": "string"
                    },
                    "offlineSessionMaxLifespan": {
                        "type": "string"
                    },
                    "offlineSessionMaxLifespanEnabled": {
                        "type": "boolean"
                    },
                    "passwordPolicy": {
                        "type": "string"
                    },
                    "realm": {
                        "type": "string"
                    },
                    "refreshTokenMaxReuse": {
                        "type": "integer"
                    },
                    "registrationAllowed": {
                        "type": "boolean"
                    },
                    "registrationEmailAsUsername": {
                        "type": "boolean"
                    },
                    "registrationFlow": {
                        "type": "string"
                    },
                    "rememberMe": {
                        "type": "boolean"
                    },
                    "resetCredentialsFlow": {
                        "type": "string"
                    },
                    "resetPasswordAllowed": {
                        "type": "boolean"
                    },
                    "revokeRefreshToken": {
                        "type": "boolean"
                    },
                    "securityDefenses": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmSecurityDefense:getRealmSecurityDefense"
                        }
                    },
                    "smtpServers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmSmtpServer:getRealmSmtpServer"
                        }
                    },
                    "sslRequired": {
                        "type": "string"
                    },
                    "ssoSessionIdleTimeout": {
                        "type": "string"
                    },
                    "ssoSessionIdleTimeoutRememberMe": {
                        "type": "string"
                    },
                    "ssoSessionMaxLifespan": {
                        "type": "string"
                    },
                    "ssoSessionMaxLifespanRememberMe": {
                        "type": "string"
                    },
                    "userManagedAccess": {
                        "type": "boolean"
                    },
                    "verifyEmail": {
                        "type": "boolean"
                    },
                    "webAuthnPasswordlessPolicy": {
                        "$ref": "#/types/keycloak:index/getRealmWebAuthnPasswordlessPolicy:getRealmWebAuthnPasswordlessPolicy"
                    },
                    "webAuthnPolicy": {
                        "$ref": "#/types/keycloak:index/getRealmWebAuthnPolicy:getRealmWebAuthnPolicy"
                    }
                },
                "type": "object",
                "required": [
                    "accessCodeLifespan",
                    "accessCodeLifespanLogin",
                    "accessCodeLifespanUserAction",
                    "accessTokenLifespan",
                    "accessTokenLifespanForImplicitFlow",
                    "accountTheme",
                    "actionTokenGeneratedByAdminLifespan",
                    "actionTokenGeneratedByUserLifespan",
                    "adminTheme",
                    "attributes",
                    "browserFlow",
                    "clientAuthenticationFlow",
                    "defaultSignatureAlgorithm",
                    "directGrantFlow",
                    "displayName",
                    "dockerAuthenticationFlow",
                    "duplicateEmailsAllowed",
                    "editUsernameAllowed",
                    "emailTheme",
                    "enabled",
                    "internalId",
                    "internationalizations",
                    "loginTheme",
                    "loginWithEmailAllowed",
                    "offlineSessionIdleTimeout",
                    "offlineSessionMaxLifespan",
                    "offlineSessionMaxLifespanEnabled",
                    "passwordPolicy",
                    "realm",
                    "refreshTokenMaxReuse",
                    "registrationAllowed",
                    "registrationEmailAsUsername",
                    "registrationFlow",
                    "rememberMe",
                    "resetCredentialsFlow",
                    "resetPasswordAllowed",
                    "revokeRefreshToken",
                    "securityDefenses",
                    "smtpServers",
                    "sslRequired",
                    "ssoSessionIdleTimeout",
                    "ssoSessionIdleTimeoutRememberMe",
                    "ssoSessionMaxLifespan",
                    "ssoSessionMaxLifespanRememberMe",
                    "userManagedAccess",
                    "verifyEmail",
                    "webAuthnPasswordlessPolicy",
                    "webAuthnPolicy",
                    "id"
                ]
            }
        },
        "keycloak:index/getRealmKeys:getRealmKeys": {
            "description": "Use this data source to get the keys of a realm. Keys can be filtered by algorithm and status.\n\nRemarks:\n\n- A key must meet all filter criteria\n- This data source may return more than one value.\n- If no key matches the filter criteria, then an error will be returned.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRealmKeys.\n",
                "properties": {
                    "algorithms": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "When specified, keys will be filtered by algorithm. The algorithms can be any of `HS256`, `RS256`,`AES`, etc.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm from which the keys will be retrieved.\n"
                    },
                    "statuses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "When specified, keys will be filtered by status. The statuses can be any of `ACTIVE`, `DISABLED` and `PASSIVE`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRealmKeys.\n",
                "properties": {
                    "algorithms": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "keys": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:index/getRealmKeysKey:getRealmKeysKey"
                        },
                        "description": "(Computed) A list of keys that match the filter criteria. Each key has the following attributes:\n"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "statuses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Key status (string)\n"
                    }
                },
                "type": "object",
                "required": [
                    "keys",
                    "realmId",
                    "id"
                ]
            }
        },
        "keycloak:index/getRole:getRole": {
            "description": "This data source can be used to fetch properties of a Keycloak role for\nusage with other resources, such as `keycloak.GroupRoles`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst offlineAccess = realm.id.apply(id =\u003e keycloak.getRole({\n    realmId: id,\n    name: \"offline_access\",\n}));\nconst group = new keycloak.Group(\"group\", {realmId: realm.id});\nconst groupRoles = new keycloak.GroupRoles(\"groupRoles\", {\n    realmId: realm.id,\n    groupId: group.id,\n    roleIds: [offlineAccess.id],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\noffline_access = realm.id.apply(lambda id: keycloak.get_role(realm_id=id,\n    name=\"offline_access\"))\ngroup = keycloak.Group(\"group\", realm_id=realm.id)\ngroup_roles = keycloak.GroupRoles(\"groupRoles\",\n    realm_id=realm.id,\n    group_id=group.id,\n    role_ids=[offline_access.id])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var offlineAccess = realm.Id.Apply(id =\u003e Keycloak.GetRole.InvokeAsync(new Keycloak.GetRoleArgs\n        {\n            RealmId = id,\n            Name = \"offline_access\",\n        }));\n        var @group = new Keycloak.Group(\"group\", new Keycloak.GroupArgs\n        {\n            RealmId = realm.Id,\n        });\n        var groupRoles = new Keycloak.GroupRoles(\"groupRoles\", new Keycloak.GroupRolesArgs\n        {\n            RealmId = realm.Id,\n            GroupId = @group.Id,\n            RoleIds = \n            {\n                offlineAccess.Apply(offlineAccess =\u003e offlineAccess.Id),\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tgroup, err := keycloak.NewGroup(ctx, \"group\", \u0026keycloak.GroupArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewGroupRoles(ctx, \"groupRoles\", \u0026keycloak.GroupRolesArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tGroupId: group.ID(),\n\t\t\tRoleIds: pulumi.StringArray{\n\t\t\t\tofflineAccess.ApplyT(func(offlineAccess keycloak.LookupRoleResult) (string, error) {\n\t\t\t\t\treturn offlineAccess.Id, nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getRole.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "When specified, this role is assumed to be a client role belonging to the client with the provided ID. The `id` attribute of a `keycloak_client` resource should be used here.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this role exists within.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRole.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string",
                        "description": "(Computed) The description of the role.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "description",
                    "name",
                    "realmId",
                    "id"
                ]
            }
        },
        "keycloak:openid/getClient:getClient": {
            "description": "This data source can be used to fetch properties of a Keycloak OpenID client for usage with other resources.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realmManagement = keycloak.openid.getClient({\n    realmId: \"my-realm\",\n    clientId: \"realm-management\",\n});\nconst admin = realmManagement.then(realmManagement =\u003e keycloak.getRole({\n    realmId: \"my-realm\",\n    clientId: realmManagement.id,\n    name: \"realm-admin\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm_management = keycloak.openid.get_client(realm_id=\"my-realm\",\n    client_id=\"realm-management\")\nadmin = keycloak.get_role(realm_id=\"my-realm\",\n    client_id=realm_management.id,\n    name=\"realm-admin\")\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realmManagement = Output.Create(Keycloak.OpenId.GetClient.InvokeAsync(new Keycloak.OpenId.GetClientArgs\n        {\n            RealmId = \"my-realm\",\n            ClientId = \"realm-management\",\n        }));\n        var admin = realmManagement.Apply(realmManagement =\u003e Output.Create(Keycloak.GetRole.InvokeAsync(new Keycloak.GetRoleArgs\n        {\n            RealmId = \"my-realm\",\n            ClientId = realmManagement.Id,\n            Name = \"realm-admin\",\n        })));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealmManagement, err := openid.LookupClient(ctx, \u0026openid.LookupClientArgs{\n\t\t\tRealmId:  \"my-realm\",\n\t\t\tClientId: \"realm-management\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topt0 := realmManagement.Id\n\t\t_, err = keycloak.LookupRole(ctx, \u0026keycloak.LookupRoleArgs{\n\t\t\tRealmId:  \"my-realm\",\n\t\t\tClientId: \u0026opt0,\n\t\t\tName:     \"realm-admin\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getClient.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The client id (not its unique ID).\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm id.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clientId",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClient.\n",
                "properties": {
                    "accessTokenLifespan": {
                        "type": "string"
                    },
                    "accessType": {
                        "type": "string"
                    },
                    "adminUrl": {
                        "type": "string"
                    },
                    "authenticationFlowBindingOverrides": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:openid/getClientAuthenticationFlowBindingOverride:getClientAuthenticationFlowBindingOverride"
                        }
                    },
                    "authorizations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:openid/getClientAuthorization:getClientAuthorization"
                        }
                    },
                    "baseUrl": {
                        "type": "string"
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "clientSecret": {
                        "type": "string"
                    },
                    "consentRequired": {
                        "type": "boolean"
                    },
                    "description": {
                        "type": "string"
                    },
                    "directAccessGrantsEnabled": {
                        "type": "boolean"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "excludeSessionStateFromAuthResponse": {
                        "type": "boolean"
                    },
                    "fullScopeAllowed": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "implicitFlowEnabled": {
                        "type": "boolean"
                    },
                    "loginTheme": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "pkceCodeChallengeMethod": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "rootUrl": {
                        "type": "string"
                    },
                    "serviceAccountUserId": {
                        "type": "string"
                    },
                    "serviceAccountsEnabled": {
                        "type": "boolean"
                    },
                    "standardFlowEnabled": {
                        "type": "boolean"
                    },
                    "validRedirectUris": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "webOrigins": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "accessTokenLifespan",
                    "accessType",
                    "adminUrl",
                    "authenticationFlowBindingOverrides",
                    "authorizations",
                    "baseUrl",
                    "clientId",
                    "clientSecret",
                    "consentRequired",
                    "description",
                    "directAccessGrantsEnabled",
                    "enabled",
                    "excludeSessionStateFromAuthResponse",
                    "fullScopeAllowed",
                    "implicitFlowEnabled",
                    "loginTheme",
                    "name",
                    "pkceCodeChallengeMethod",
                    "realmId",
                    "resourceServerId",
                    "rootUrl",
                    "serviceAccountUserId",
                    "serviceAccountsEnabled",
                    "standardFlowEnabled",
                    "validRedirectUris",
                    "webOrigins",
                    "id"
                ]
            }
        },
        "keycloak:openid/getClientAuthorizationPolicy:getClientAuthorizationPolicy": {
            "description": "This data source can be used to fetch policy and permission information for an OpenID client that has authorization enabled.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nIn this example, we'll create a new OpenID client with authorization enabled. This will cause Keycloak to create a default\npermission for this client called \"Default Permission\". We'll use the `keycloak.openid.getClientAuthorizationPolicy` data\nsource to fetch information about this permission, so we can use it to create a new resource-based authorization permission.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst clientWithAuthz = new keycloak.openid.Client(\"clientWithAuthz\", {\n    clientId: \"client-with-authz\",\n    realmId: realm.id,\n    accessType: \"CONFIDENTIAL\",\n    serviceAccountsEnabled: true,\n    authorization: {\n        policyEnforcementMode: \"ENFORCING\",\n    },\n});\nconst defaultPermission = clientWithAuthz.resourceServerId.apply(resourceServerId =\u003e keycloak.openid.getClientAuthorizationPolicy({\n    realmId: keycloak_realm.test.id,\n    resourceServerId: resourceServerId,\n    name: \"Default Permission\",\n}));\nconst resource = new keycloak.openid.ClientAuthorizationResource(\"resource\", {\n    resourceServerId: clientWithAuthz.resourceServerId,\n    realmId: keycloak_realm.test.id,\n    uris: [\"/endpoint/*\"],\n    attributes: {\n        foo: \"bar\",\n    },\n});\nconst permission = new keycloak.openid.ClientAuthorizationPermission(\"permission\", {\n    resourceServerId: clientWithAuthz.resourceServerId,\n    realmId: keycloak_realm.test.id,\n    policies: [defaultPermission.id],\n    resources: [resource.id],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient_with_authz = keycloak.openid.Client(\"clientWithAuthz\",\n    client_id=\"client-with-authz\",\n    realm_id=realm.id,\n    access_type=\"CONFIDENTIAL\",\n    service_accounts_enabled=True,\n    authorization=keycloak.openid.ClientAuthorizationArgs(\n        policy_enforcement_mode=\"ENFORCING\",\n    ))\ndefault_permission = client_with_authz.resource_server_id.apply(lambda resource_server_id: keycloak.openid.get_client_authorization_policy(realm_id=keycloak_realm[\"test\"][\"id\"],\n    resource_server_id=resource_server_id,\n    name=\"Default Permission\"))\nresource = keycloak.openid.ClientAuthorizationResource(\"resource\",\n    resource_server_id=client_with_authz.resource_server_id,\n    realm_id=keycloak_realm[\"test\"][\"id\"],\n    uris=[\"/endpoint/*\"],\n    attributes={\n        \"foo\": \"bar\",\n    })\npermission = keycloak.openid.ClientAuthorizationPermission(\"permission\",\n    resource_server_id=client_with_authz.resource_server_id,\n    realm_id=keycloak_realm[\"test\"][\"id\"],\n    policies=[default_permission.id],\n    resources=[resource.id])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var clientWithAuthz = new Keycloak.OpenId.Client(\"clientWithAuthz\", new Keycloak.OpenId.ClientArgs\n        {\n            ClientId = \"client-with-authz\",\n            RealmId = realm.Id,\n            AccessType = \"CONFIDENTIAL\",\n            ServiceAccountsEnabled = true,\n            Authorization = new Keycloak.OpenId.Inputs.ClientAuthorizationArgs\n            {\n                PolicyEnforcementMode = \"ENFORCING\",\n            },\n        });\n        var defaultPermission = clientWithAuthz.ResourceServerId.Apply(resourceServerId =\u003e Keycloak.OpenId.GetClientAuthorizationPolicy.InvokeAsync(new Keycloak.OpenId.GetClientAuthorizationPolicyArgs\n        {\n            RealmId = keycloak_realm.Test.Id,\n            ResourceServerId = resourceServerId,\n            Name = \"Default Permission\",\n        }));\n        var resource = new Keycloak.OpenId.ClientAuthorizationResource(\"resource\", new Keycloak.OpenId.ClientAuthorizationResourceArgs\n        {\n            ResourceServerId = clientWithAuthz.ResourceServerId,\n            RealmId = keycloak_realm.Test.Id,\n            Uris = \n            {\n                \"/endpoint/*\",\n            },\n            Attributes = \n            {\n                { \"foo\", \"bar\" },\n            },\n        });\n        var permission = new Keycloak.OpenId.ClientAuthorizationPermission(\"permission\", new Keycloak.OpenId.ClientAuthorizationPermissionArgs\n        {\n            ResourceServerId = clientWithAuthz.ResourceServerId,\n            RealmId = keycloak_realm.Test.Id,\n            Policies = \n            {\n                defaultPermission.Apply(defaultPermission =\u003e defaultPermission.Id),\n            },\n            Resources = \n            {\n                resource.Id,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientWithAuthz, err := openid.NewClient(ctx, \"clientWithAuthz\", \u0026openid.ClientArgs{\n\t\t\tClientId:               pulumi.String(\"client-with-authz\"),\n\t\t\tRealmId:                realm.ID(),\n\t\t\tAccessType:             pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tServiceAccountsEnabled: pulumi.Bool(true),\n\t\t\tAuthorization: \u0026openid.ClientAuthorizationArgs{\n\t\t\t\tPolicyEnforcementMode: pulumi.String(\"ENFORCING\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tresource, err := openid.NewClientAuthorizationResource(ctx, \"resource\", \u0026openid.ClientAuthorizationResourceArgs{\n\t\t\tResourceServerId: clientWithAuthz.ResourceServerId,\n\t\t\tRealmId:          pulumi.Any(keycloak_realm.Test.Id),\n\t\t\tUris: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"/endpoint/*\"),\n\t\t\t},\n\t\t\tAttributes: pulumi.StringMap{\n\t\t\t\t\"foo\": pulumi.String(\"bar\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = openid.NewClientAuthorizationPermission(ctx, \"permission\", \u0026openid.ClientAuthorizationPermissionArgs{\n\t\t\tResourceServerId: clientWithAuthz.ResourceServerId,\n\t\t\tRealmId:          pulumi.Any(keycloak_realm.Test.Id),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tdefaultPermission.ApplyT(func(defaultPermission openid.GetClientAuthorizationPolicyResult) (string, error) {\n\t\t\t\t\treturn defaultPermission.Id, nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t},\n\t\t\tResources: pulumi.StringArray{\n\t\t\t\tresource.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getClientAuthorizationPolicy.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the authorization policy.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm this authorization policy exists within.\n"
                    },
                    "resourceServerId": {
                        "type": "string",
                        "description": "The ID of the resource server this authorization policy is attached to.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "realmId",
                    "resourceServerId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClientAuthorizationPolicy.\n",
                "properties": {
                    "decisionStrategy": {
                        "type": "string",
                        "description": "(Computed) Dictates how the policies associated with a given permission are evaluated and how a final decision is obtained. Could be one of `AFFIRMATIVE`, `CONSENSUS`, or `UNANIMOUS`. Applies to permissions.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "logic": {
                        "type": "string",
                        "description": "(Computed) Dictates how the policy decision should be made. Can be either `POSITIVE` or `NEGATIVE`. Applies to policies.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "owner": {
                        "type": "string",
                        "description": "(Computed) The ID of the owning resource. Applies to resources.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(Computed) The IDs of the policies that must be applied to scopes/resources for this policy/permission. Applies to policies and permissions.\n"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "resourceServerId": {
                        "type": "string"
                    },
                    "resources": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(Computed) The IDs of the resources that this permission applies to. Applies to resource-based permissions.\n"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "(Computed) The IDs of the scopes that this permission applies to. Applies to scope-based permissions.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "(Computed) The type of this policy / permission. For permissions, this could be `resource` or `scope`. For policies, this could be any type of authorization policy, such as `js`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "decisionStrategy",
                    "logic",
                    "name",
                    "owner",
                    "policies",
                    "realmId",
                    "resourceServerId",
                    "resources",
                    "scopes",
                    "type",
                    "id"
                ]
            }
        },
        "keycloak:openid/getClientServiceAccountUser:getClientServiceAccountUser": {
            "description": "This data source can be used to fetch information about the service account user that is associated with an OpenID client\nthat has service accounts enabled.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nIn this example, we'll create an OpenID client with service accounts enabled. This causes Keycloak to create a special user\nthat represents the service account. We'll use this data source to grab this user's ID in order to assign some roles to this\nuser, using the `keycloak.UserRoles` resource.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as keycloak from \"@pulumi/keycloak\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst client = new keycloak.openid.Client(\"client\", {\n    realmId: realm.id,\n    clientId: \"client\",\n    accessType: \"CONFIDENTIAL\",\n    serviceAccountsEnabled: true,\n});\nconst serviceAccountUser = pulumi.all([realm.id, client.id]).apply(([realmId, clientId]) =\u003e keycloak.openid.getClientServiceAccountUser({\n    realmId: realmId,\n    clientId: clientId,\n}));\nconst offlineAccess = realm.id.apply(id =\u003e keycloak.getRole({\n    realmId: id,\n    name: \"offline_access\",\n}));\nconst serviceAccountUserRoles = new keycloak.UserRoles(\"serviceAccountUserRoles\", {\n    realmId: realm.id,\n    userId: serviceAccountUser.id,\n    roleIds: [offlineAccess.id],\n});\n```\n```python\nimport pulumi\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nclient = keycloak.openid.Client(\"client\",\n    realm_id=realm.id,\n    client_id=\"client\",\n    access_type=\"CONFIDENTIAL\",\n    service_accounts_enabled=True)\nservice_account_user = pulumi.Output.all(realm.id, client.id).apply(lambda realmId, clientId: keycloak.openid.get_client_service_account_user(realm_id=realm_id,\n    client_id=client_id))\noffline_access = realm.id.apply(lambda id: keycloak.get_role(realm_id=id,\n    name=\"offline_access\"))\nservice_account_user_roles = keycloak.UserRoles(\"serviceAccountUserRoles\",\n    realm_id=realm.id,\n    user_id=service_account_user.id,\n    role_ids=[offline_access.id])\n```\n```csharp\nusing Pulumi;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var client = new Keycloak.OpenId.Client(\"client\", new Keycloak.OpenId.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"client\",\n            AccessType = \"CONFIDENTIAL\",\n            ServiceAccountsEnabled = true,\n        });\n        var serviceAccountUser = Output.Tuple(realm.Id, client.Id).Apply(values =\u003e\n        {\n            var realmId = values.Item1;\n            var clientId = values.Item2;\n            return Keycloak.OpenId.GetClientServiceAccountUser.InvokeAsync(new Keycloak.OpenId.GetClientServiceAccountUserArgs\n            {\n                RealmId = realmId,\n                ClientId = clientId,\n            });\n        });\n        var offlineAccess = realm.Id.Apply(id =\u003e Keycloak.GetRole.InvokeAsync(new Keycloak.GetRoleArgs\n        {\n            RealmId = id,\n            Name = \"offline_access\",\n        }));\n        var serviceAccountUserRoles = new Keycloak.UserRoles(\"serviceAccountUserRoles\", new Keycloak.UserRolesArgs\n        {\n            RealmId = realm.Id,\n            UserId = serviceAccountUser.Apply(serviceAccountUser =\u003e serviceAccountUser.Id),\n            RoleIds = \n            {\n                offlineAccess.Apply(offlineAccess =\u003e offlineAccess.Id),\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak\"\n\t\"github.com/pulumi/pulumi-keycloak/sdk/v3/go/keycloak/openid\"\n\t\"github.com/pulumi/pulumi/sdk/v2/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trealm, err := keycloak.NewRealm(ctx, \"realm\", \u0026keycloak.RealmArgs{\n\t\t\tRealm:   pulumi.String(\"my-realm\"),\n\t\t\tEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := openid.NewClient(ctx, \"client\", \u0026openid.ClientArgs{\n\t\t\tRealmId:                realm.ID(),\n\t\t\tClientId:               pulumi.String(\"client\"),\n\t\t\tAccessType:             pulumi.String(\"CONFIDENTIAL\"),\n\t\t\tServiceAccountsEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = keycloak.NewUserRoles(ctx, \"serviceAccountUserRoles\", \u0026keycloak.UserRolesArgs{\n\t\t\tRealmId: realm.ID(),\n\t\t\tUserId: serviceAccountUser.ApplyT(func(serviceAccountUser openid.GetClientServiceAccountUserResult) (string, error) {\n\t\t\t\treturn serviceAccountUser.Id, nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tRoleIds: pulumi.StringArray{\n\t\t\t\tofflineAccess.ApplyT(func(offlineAccess keycloak.LookupRoleResult) (string, error) {\n\t\t\t\t\treturn offlineAccess.Id, nil\n\t\t\t\t}).(pulumi.StringOutput),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getClientServiceAccountUser.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The ID of the OpenID client with service accounts enabled.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that the OpenID client exists within.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clientId",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClientServiceAccountUser.\n",
                "properties": {
                    "attributes": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "clientId": {
                        "type": "string"
                    },
                    "email": {
                        "type": "string"
                    },
                    "emailVerified": {
                        "type": "boolean"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "federatedIdentities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/keycloak:openid/getClientServiceAccountUserFederatedIdentity:getClientServiceAccountUserFederatedIdentity"
                        }
                    },
                    "firstName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "lastName": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "attributes",
                    "clientId",
                    "email",
                    "emailVerified",
                    "enabled",
                    "federatedIdentities",
                    "firstName",
                    "lastName",
                    "realmId",
                    "username",
                    "id"
                ]
            }
        },
        "keycloak:saml/getClientInstallationProvider:getClientInstallationProvider": {
            "description": "This data source can be used to retrieve Installation Provider of a SAML Client.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nIn the example below, we extract the SAML metadata IDPSSODescriptor to pass it to the AWS IAM SAML Provider.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\nimport * as keycloak from \"@pulumi/keycloak\";\nimport * from \"fs\";\n\nconst realm = new keycloak.Realm(\"realm\", {\n    realm: \"my-realm\",\n    enabled: true,\n});\nconst samlClient = new keycloak.saml.Client(\"samlClient\", {\n    realmId: realm.id,\n    clientId: \"test-saml-client\",\n    signDocuments: false,\n    signAssertions: true,\n    includeAuthnStatement: true,\n    signingCertificate: fs.readFileSync(\"saml-cert.pem\"),\n    signingPrivateKey: fs.readFileSync(\"saml-key.pem\"),\n});\nconst samlIdpDescriptor = pulumi.all([realm.id, samlClient.id]).apply(([realmId, samlClientId]) =\u003e keycloak.saml.getClientInstallationProvider({\n    realmId: realmId,\n    clientId: samlClientId,\n    providerId: \"saml-idp-descriptor\",\n}));\nconst _default = new aws.iam.SamlProvider(\"default\", {samlMetadataDocument: samlIdpDescriptor.value});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\nimport pulumi_keycloak as keycloak\n\nrealm = keycloak.Realm(\"realm\",\n    realm=\"my-realm\",\n    enabled=True)\nsaml_client = keycloak.saml.Client(\"samlClient\",\n    realm_id=realm.id,\n    client_id=\"test-saml-client\",\n    sign_documents=False,\n    sign_assertions=True,\n    include_authn_statement=True,\n    signing_certificate=(lambda path: open(path).read())(\"saml-cert.pem\"),\n    signing_private_key=(lambda path: open(path).read())(\"saml-key.pem\"))\nsaml_idp_descriptor = pulumi.Output.all(realm.id, saml_client.id).apply(lambda realmId, samlClientId: keycloak.saml.get_client_installation_provider(realm_id=realm_id,\n    client_id=saml_client_id,\n    provider_id=\"saml-idp-descriptor\"))\ndefault = aws.iam.SamlProvider(\"default\", saml_metadata_document=saml_idp_descriptor.value)\n```\n```csharp\nusing System.IO;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\nusing Keycloak = Pulumi.Keycloak;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var realm = new Keycloak.Realm(\"realm\", new Keycloak.RealmArgs\n        {\n            Realm = \"my-realm\",\n            Enabled = true,\n        });\n        var samlClient = new Keycloak.Saml.Client(\"samlClient\", new Keycloak.Saml.ClientArgs\n        {\n            RealmId = realm.Id,\n            ClientId = \"test-saml-client\",\n            SignDocuments = false,\n            SignAssertions = true,\n            IncludeAuthnStatement = true,\n            SigningCertificate = File.ReadAllText(\"saml-cert.pem\"),\n            SigningPrivateKey = File.ReadAllText(\"saml-key.pem\"),\n        });\n        var samlIdpDescriptor = Output.Tuple(realm.Id, samlClient.Id).Apply(values =\u003e\n        {\n            var realmId = values.Item1;\n            var samlClientId = values.Item2;\n            return Keycloak.Saml.GetClientInstallationProvider.InvokeAsync(new Keycloak.Saml.GetClientInstallationProviderArgs\n            {\n                RealmId = realmId,\n                ClientId = samlClientId,\n                ProviderId = \"saml-idp-descriptor\",\n            });\n        });\n        var @default = new Aws.Iam.SamlProvider(\"default\", new Aws.Iam.SamlProviderArgs\n        {\n            SamlMetadataDocument = samlIdpDescriptor.Apply(samlIdpDescriptor =\u003e samlIdpDescriptor.Value),\n        });\n    }\n\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getClientInstallationProvider.\n",
                "properties": {
                    "clientId": {
                        "type": "string",
                        "description": "The ID of the SAML client. The `id` attribute of a `keycloak_client` resource should be used here.\n"
                    },
                    "providerId": {
                        "type": "string",
                        "description": "The ID of the SAML installation provider. Could be one of `saml-idp-descriptor`, `keycloak-saml`, `saml-sp-descriptor`, `keycloak-saml-subsystem`, `mod-auth-mellon`, etc.\n"
                    },
                    "realmId": {
                        "type": "string",
                        "description": "The realm that the SAML client exists within.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clientId",
                    "providerId",
                    "realmId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClientInstallationProvider.\n",
                "properties": {
                    "clientId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "providerId": {
                        "type": "string"
                    },
                    "realmId": {
                        "type": "string"
                    },
                    "value": {
                        "type": "string",
                        "description": "(Computed) The returned document needed for SAML installation.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clientId",
                    "providerId",
                    "realmId",
                    "value",
                    "id"
                ]
            }
        }
    },
    "language": {
        "csharp": {
            "namespaces": {
                "authentication": "Authentication",
                "index": "index",
                "keycloak": "Keycloak",
                "ldap": "Ldap",
                "oidc": "Oidc",
                "openid": "OpenId",
                "saml": "Saml"
            },
            "packageReferences": {
                "Pulumi": "2.*",
                "System.Collections.Immutable": "1.6.0"
            }
        },
        "nodejs": {
            "dependencies": {
                "@pulumi/pulumi": "^2.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^8.0.25"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing keycloak cloud resources.",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/mrparkers/terraform-provider-keycloak)\n\u003e distributed under [MIT](https://mit-license.org/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-keycloak` repo](https://github.com/pulumi/pulumi-keycloak/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`mrparkers/terraform-provider-keycloak` repo](https://github.com/mrparkers/terraform-provider-keycloak/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/mrparkers/terraform-provider-keycloak)\n\u003e distributed under [MIT](https://mit-license.org/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-keycloak` repo](https://github.com/pulumi/pulumi-keycloak/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`mrparkers/terraform-provider-keycloak` repo](https://github.com/mrparkers/terraform-provider-keycloak/issues).",
            "requires": {
                "pulumi": "\u003e=2.9.0,\u003c3.0.0"
            },
            "usesIOClasses": true
        }
    }
}