// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.keycloak.openid;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.keycloak.Utilities;
import com.pulumi.keycloak.openid.ClientTimePolicyArgs;
import com.pulumi.keycloak.openid.inputs.ClientTimePolicyState;
import java.lang.String;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Allows you to manage time policies.
 * 
 * Time policies allow you to define conditions based on time ranges. You can specify when access should be granted using various time constraints including date, month, year, hour, and minute ranges.
 * 
 * ## Example Usage
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.keycloak.Realm;
 * import com.pulumi.keycloak.RealmArgs;
 * import com.pulumi.keycloak.openid.Client;
 * import com.pulumi.keycloak.openid.ClientArgs;
 * import com.pulumi.keycloak.openid.inputs.ClientAuthorizationArgs;
 * import com.pulumi.keycloak.openid.ClientTimePolicy;
 * import com.pulumi.keycloak.openid.ClientTimePolicyArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var realm = new Realm("realm", RealmArgs.builder()
 *             .realm("my-realm")
 *             .enabled(true)
 *             .build());
 * 
 *         var test = new Client("test", ClientArgs.builder()
 *             .clientId("client_id")
 *             .realmId(realm.id())
 *             .accessType("CONFIDENTIAL")
 *             .serviceAccountsEnabled(true)
 *             .authorization(ClientAuthorizationArgs.builder()
 *                 .policyEnforcementMode("ENFORCING")
 *                 .build())
 *             .build());
 * 
 *         // Policy for business hours only (9 AM - 5 PM)
 *         var businessHours = new ClientTimePolicy("businessHours", ClientTimePolicyArgs.builder()
 *             .resourceServerId(test.resourceServerId())
 *             .realmId(realm.id())
 *             .name("business_hours_policy")
 *             .decisionStrategy("UNANIMOUS")
 *             .logic("POSITIVE")
 *             .hour("09")
 *             .hourEnd("17")
 *             .build());
 * 
 *         // Policy for specific date range
 *         var dateRange = new ClientTimePolicy("dateRange", ClientTimePolicyArgs.builder()
 *             .resourceServerId(test.resourceServerId())
 *             .realmId(realm.id())
 *             .name("date_range_policy")
 *             .decisionStrategy("UNANIMOUS")
 *             .logic("POSITIVE")
 *             .notBefore("2024-01-01 00:00:00")
 *             .notOnOrAfter("2024-12-31 23:59:59")
 *             .build());
 * 
 *         // Policy for specific months (January to March)
 *         var quarter1 = new ClientTimePolicy("quarter1", ClientTimePolicyArgs.builder()
 *             .resourceServerId(test.resourceServerId())
 *             .realmId(realm.id())
 *             .name("q1_policy")
 *             .decisionStrategy("UNANIMOUS")
 *             .logic("POSITIVE")
 *             .month("1")
 *             .monthEnd("3")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Argument Reference
 * 
 * The following arguments are supported:
 * 
 * - `realmId` - (Required) The realm this policy exists in.
 * - `resourceServerId` - (Required) The ID of the resource server.
 * - `name` - (Required) The name of the policy.
 * - `decisionStrategy` - (Required) The decision strategy, can be one of `UNANIMOUS`, `AFFIRMATIVE`, or `CONSENSUS`.
 * - `logic` - (Optional) The logic, can be one of `POSITIVE` or `NEGATIVE`. Defaults to `POSITIVE`.
 * - `notBefore` - (Optional) The policy is valid only after this date/time (format: `YYYY-MM-DD HH:MM:SS`).
 * - `notOnOrAfter` - (Optional) The policy is valid only before this date/time (format: `YYYY-MM-DD HH:MM:SS`).
 * - `dayMonth` - (Optional) Starting day of the month (1-31).
 * - `dayMonthEnd` - (Optional) Ending day of the month (1-31).
 * - `month` - (Optional) Starting month (1-12).
 * - `monthEnd` - (Optional) Ending month (1-12).
 * - `year` - (Optional) Starting year.
 * - `yearEnd` - (Optional) Ending year.
 * - `hour` - (Optional) Starting hour (0-23).
 * - `hourEnd` - (Optional) Ending hour (0-23).
 * - `minute` - (Optional) Starting minute (0-59).
 * - `minuteEnd` - (Optional) Ending minute (0-59).
 * - `description` - (Optional) A description for the authorization policy.
 * 
 * ### Attributes Reference
 * 
 * In addition to the arguments listed above, the following computed attributes are exported:
 * 
 * - `id` - Policy ID representing the time policy.
 * 
 * ## Import
 * 
 * Time policies can be imported using the format: `{{realmId}}/{{resourceServerId}}/{{policyId}}`.
 * 
 * Example:
 * 
 */
@ResourceType(type="keycloak:openid/clientTimePolicy:ClientTimePolicy")
public class ClientTimePolicy extends com.pulumi.resources.CustomResource {
    @Export(name="dayMonth", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> dayMonth;

    public Output<Optional<String>> dayMonth() {
        return Codegen.optional(this.dayMonth);
    }
    @Export(name="dayMonthEnd", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> dayMonthEnd;

    public Output<Optional<String>> dayMonthEnd() {
        return Codegen.optional(this.dayMonthEnd);
    }
    @Export(name="decisionStrategy", refs={String.class}, tree="[0]")
    private Output<String> decisionStrategy;

    public Output<String> decisionStrategy() {
        return this.decisionStrategy;
    }
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    @Export(name="hour", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> hour;

    public Output<Optional<String>> hour() {
        return Codegen.optional(this.hour);
    }
    @Export(name="hourEnd", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> hourEnd;

    public Output<Optional<String>> hourEnd() {
        return Codegen.optional(this.hourEnd);
    }
    @Export(name="logic", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> logic;

    public Output<Optional<String>> logic() {
        return Codegen.optional(this.logic);
    }
    @Export(name="minute", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> minute;

    public Output<Optional<String>> minute() {
        return Codegen.optional(this.minute);
    }
    @Export(name="minuteEnd", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> minuteEnd;

    public Output<Optional<String>> minuteEnd() {
        return Codegen.optional(this.minuteEnd);
    }
    @Export(name="month", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> month;

    public Output<Optional<String>> month() {
        return Codegen.optional(this.month);
    }
    @Export(name="monthEnd", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> monthEnd;

    public Output<Optional<String>> monthEnd() {
        return Codegen.optional(this.monthEnd);
    }
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    public Output<String> name() {
        return this.name;
    }
    @Export(name="notBefore", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> notBefore;

    public Output<Optional<String>> notBefore() {
        return Codegen.optional(this.notBefore);
    }
    @Export(name="notOnOrAfter", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> notOnOrAfter;

    public Output<Optional<String>> notOnOrAfter() {
        return Codegen.optional(this.notOnOrAfter);
    }
    @Export(name="realmId", refs={String.class}, tree="[0]")
    private Output<String> realmId;

    public Output<String> realmId() {
        return this.realmId;
    }
    @Export(name="resourceServerId", refs={String.class}, tree="[0]")
    private Output<String> resourceServerId;

    public Output<String> resourceServerId() {
        return this.resourceServerId;
    }
    @Export(name="year", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> year;

    public Output<Optional<String>> year() {
        return Codegen.optional(this.year);
    }
    @Export(name="yearEnd", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> yearEnd;

    public Output<Optional<String>> yearEnd() {
        return Codegen.optional(this.yearEnd);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public ClientTimePolicy(java.lang.String name) {
        this(name, ClientTimePolicyArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public ClientTimePolicy(java.lang.String name, ClientTimePolicyArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public ClientTimePolicy(java.lang.String name, ClientTimePolicyArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("keycloak:openid/clientTimePolicy:ClientTimePolicy", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private ClientTimePolicy(java.lang.String name, Output<java.lang.String> id, @Nullable ClientTimePolicyState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("keycloak:openid/clientTimePolicy:ClientTimePolicy", name, state, makeResourceOptions(options, id), false);
    }

    private static ClientTimePolicyArgs makeArgs(ClientTimePolicyArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? ClientTimePolicyArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static ClientTimePolicy get(java.lang.String name, Output<java.lang.String> id, @Nullable ClientTimePolicyState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new ClientTimePolicy(name, id, state, options);
    }
}
