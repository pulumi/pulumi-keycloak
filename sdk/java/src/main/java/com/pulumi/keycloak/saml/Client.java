// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.keycloak.saml;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.keycloak.Utilities;
import com.pulumi.keycloak.saml.ClientArgs;
import com.pulumi.keycloak.saml.inputs.ClientState;
import com.pulumi.keycloak.saml.outputs.ClientAuthenticationFlowBindingOverrides;
import java.lang.Boolean;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Allows for creating and managing Keycloak clients that use the SAML protocol.
 * 
 * Clients are entities that can use Keycloak for user authentication. Typically, clients are applications that redirect users
 * to Keycloak for authentication in order to take advantage of Keycloak&#39;s user sessions for SSO.
 * 
 * ## Example Usage
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.keycloak.Realm;
 * import com.pulumi.keycloak.RealmArgs;
 * import com.pulumi.keycloak.saml.Client;
 * import com.pulumi.keycloak.saml.ClientArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var realm = new Realm(&#34;realm&#34;, RealmArgs.builder()        
 *             .realm(&#34;my-realm&#34;)
 *             .enabled(true)
 *             .build());
 * 
 *         var samlClient = new Client(&#34;samlClient&#34;, ClientArgs.builder()        
 *             .realmId(realm.id())
 *             .clientId(&#34;saml-client&#34;)
 *             .signDocuments(false)
 *             .signAssertions(true)
 *             .includeAuthnStatement(true)
 *             .signingCertificate(Files.readString(Paths.get(&#34;saml-cert.pem&#34;)))
 *             .signingPrivateKey(Files.readString(Paths.get(&#34;saml-key.pem&#34;)))
 *             .build());
 * 
 *     }
 * }
 * ```
 * 
 * ## Import
 * 
 * Clients can be imported using the format `{{realm_id}}/{{client_keycloak_id}}`, where `client_keycloak_id` is the unique ID that Keycloak assigns to the client upon creation. This value can be found in the URI when editing this client in the GUI, and is typically a GUID. Examplebash
 * 
 * ```sh
 *  $ pulumi import keycloak:saml/client:Client saml_client my-realm/dcbc4c73-e478-4928-ae2e-d5e420223352
 * ```
 * 
 */
@ResourceType(type="keycloak:saml/client:Client")
public class Client extends com.pulumi.resources.CustomResource {
    /**
     * SAML POST Binding URL for the client&#39;s assertion consumer service (login responses).
     * 
     */
    @Export(name="assertionConsumerPostUrl", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> assertionConsumerPostUrl;

    /**
     * @return SAML POST Binding URL for the client&#39;s assertion consumer service (login responses).
     * 
     */
    public Output<Optional<String>> assertionConsumerPostUrl() {
        return Codegen.optional(this.assertionConsumerPostUrl);
    }
    /**
     * SAML Redirect Binding URL for the client&#39;s assertion consumer service (login responses).
     * 
     */
    @Export(name="assertionConsumerRedirectUrl", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> assertionConsumerRedirectUrl;

    /**
     * @return SAML Redirect Binding URL for the client&#39;s assertion consumer service (login responses).
     * 
     */
    public Output<Optional<String>> assertionConsumerRedirectUrl() {
        return Codegen.optional(this.assertionConsumerRedirectUrl);
    }
    /**
     * Override realm authentication flow bindings
     * 
     */
    @Export(name="authenticationFlowBindingOverrides", refs={ClientAuthenticationFlowBindingOverrides.class}, tree="[0]")
    private Output</* @Nullable */ ClientAuthenticationFlowBindingOverrides> authenticationFlowBindingOverrides;

    /**
     * @return Override realm authentication flow bindings
     * 
     */
    public Output<Optional<ClientAuthenticationFlowBindingOverrides>> authenticationFlowBindingOverrides() {
        return Codegen.optional(this.authenticationFlowBindingOverrides);
    }
    /**
     * When specified, this URL will be used whenever Keycloak needs to link to this client.
     * 
     */
    @Export(name="baseUrl", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> baseUrl;

    /**
     * @return When specified, this URL will be used whenever Keycloak needs to link to this client.
     * 
     */
    public Output<Optional<String>> baseUrl() {
        return Codegen.optional(this.baseUrl);
    }
    /**
     * The Canonicalization Method for XML signatures. Should be one of &#34;EXCLUSIVE&#34;, &#34;EXCLUSIVE_WITH_COMMENTS&#34;, &#34;INCLUSIVE&#34;, or &#34;INCLUSIVE_WITH_COMMENTS&#34;. Defaults to &#34;EXCLUSIVE&#34;.
     * 
     */
    @Export(name="canonicalizationMethod", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> canonicalizationMethod;

    /**
     * @return The Canonicalization Method for XML signatures. Should be one of &#34;EXCLUSIVE&#34;, &#34;EXCLUSIVE_WITH_COMMENTS&#34;, &#34;INCLUSIVE&#34;, or &#34;INCLUSIVE_WITH_COMMENTS&#34;. Defaults to &#34;EXCLUSIVE&#34;.
     * 
     */
    public Output<Optional<String>> canonicalizationMethod() {
        return Codegen.optional(this.canonicalizationMethod);
    }
    /**
     * The unique ID of this client, referenced in the URI during authentication and in issued tokens.
     * 
     */
    @Export(name="clientId", refs={String.class}, tree="[0]")
    private Output<String> clientId;

    /**
     * @return The unique ID of this client, referenced in the URI during authentication and in issued tokens.
     * 
     */
    public Output<String> clientId() {
        return this.clientId;
    }
    /**
     * When `true`, Keycloak will expect that documents originating from a client will be signed using the certificate and/or key configured via `signing_certificate` and `signing_private_key`. Defaults to `true`.
     * 
     */
    @Export(name="clientSignatureRequired", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> clientSignatureRequired;

    /**
     * @return When `true`, Keycloak will expect that documents originating from a client will be signed using the certificate and/or key configured via `signing_certificate` and `signing_private_key`. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> clientSignatureRequired() {
        return Codegen.optional(this.clientSignatureRequired);
    }
    /**
     * The description of this client in the GUI.
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return The description of this client in the GUI.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * When false, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.
     * 
     */
    @Export(name="enabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enabled;

    /**
     * @return When false, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> enabled() {
        return Codegen.optional(this.enabled);
    }
    /**
     * When `true`, the SAML assertions will be encrypted by Keycloak using the client&#39;s public key. Defaults to `false`.
     * 
     */
    @Export(name="encryptAssertions", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> encryptAssertions;

    /**
     * @return When `true`, the SAML assertions will be encrypted by Keycloak using the client&#39;s public key. Defaults to `false`.
     * 
     */
    public Output<Optional<Boolean>> encryptAssertions() {
        return Codegen.optional(this.encryptAssertions);
    }
    /**
     * If assertions for the client are encrypted, this certificate will be used for encryption.
     * 
     */
    @Export(name="encryptionCertificate", refs={String.class}, tree="[0]")
    private Output<String> encryptionCertificate;

    /**
     * @return If assertions for the client are encrypted, this certificate will be used for encryption.
     * 
     */
    public Output<String> encryptionCertificate() {
        return this.encryptionCertificate;
    }
    /**
     * (Computed) The sha1sum fingerprint of the encryption certificate. If the encryption certificate is not in correct base64 format, this will be left empty.
     * 
     */
    @Export(name="encryptionCertificateSha1", refs={String.class}, tree="[0]")
    private Output<String> encryptionCertificateSha1;

    /**
     * @return (Computed) The sha1sum fingerprint of the encryption certificate. If the encryption certificate is not in correct base64 format, this will be left empty.
     * 
     */
    public Output<String> encryptionCertificateSha1() {
        return this.encryptionCertificateSha1;
    }
    @Export(name="extraConfig", refs={Map.class,String.class,Object.class}, tree="[0,1,2]")
    private Output</* @Nullable */ Map<String,Object>> extraConfig;

    public Output<Optional<Map<String,Object>>> extraConfig() {
        return Codegen.optional(this.extraConfig);
    }
    /**
     * Ignore requested NameID subject format and use the one defined in `name_id_format` instead. Defaults to `false`.
     * 
     */
    @Export(name="forceNameIdFormat", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> forceNameIdFormat;

    /**
     * @return Ignore requested NameID subject format and use the one defined in `name_id_format` instead. Defaults to `false`.
     * 
     */
    public Output<Optional<Boolean>> forceNameIdFormat() {
        return Codegen.optional(this.forceNameIdFormat);
    }
    /**
     * When `true`, Keycloak will always respond to an authentication request via the SAML POST Binding. Defaults to `true`.
     * 
     */
    @Export(name="forcePostBinding", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> forcePostBinding;

    /**
     * @return When `true`, Keycloak will always respond to an authentication request via the SAML POST Binding. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> forcePostBinding() {
        return Codegen.optional(this.forcePostBinding);
    }
    /**
     * When `true`, this client will require a browser redirect in order to perform a logout. Defaults to `true`.
     * 
     */
    @Export(name="frontChannelLogout", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> frontChannelLogout;

    /**
     * @return When `true`, this client will require a browser redirect in order to perform a logout. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> frontChannelLogout() {
        return Codegen.optional(this.frontChannelLogout);
    }
    /**
     * Allow to include all roles mappings in the access token
     * 
     */
    @Export(name="fullScopeAllowed", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> fullScopeAllowed;

    /**
     * @return Allow to include all roles mappings in the access token
     * 
     */
    public Output<Optional<Boolean>> fullScopeAllowed() {
        return Codegen.optional(this.fullScopeAllowed);
    }
    /**
     * Relay state you want to send with SAML request when you want to do IDP Initiated SSO.
     * 
     */
    @Export(name="idpInitiatedSsoRelayState", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> idpInitiatedSsoRelayState;

    /**
     * @return Relay state you want to send with SAML request when you want to do IDP Initiated SSO.
     * 
     */
    public Output<Optional<String>> idpInitiatedSsoRelayState() {
        return Codegen.optional(this.idpInitiatedSsoRelayState);
    }
    /**
     * URL fragment name to reference client when you want to do IDP Initiated SSO.
     * 
     */
    @Export(name="idpInitiatedSsoUrlName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> idpInitiatedSsoUrlName;

    /**
     * @return URL fragment name to reference client when you want to do IDP Initiated SSO.
     * 
     */
    public Output<Optional<String>> idpInitiatedSsoUrlName() {
        return Codegen.optional(this.idpInitiatedSsoUrlName);
    }
    /**
     * When `true`, an `AuthnStatement` will be included in the SAML response. Defaults to `true`.
     * 
     */
    @Export(name="includeAuthnStatement", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> includeAuthnStatement;

    /**
     * @return When `true`, an `AuthnStatement` will be included in the SAML response. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> includeAuthnStatement() {
        return Codegen.optional(this.includeAuthnStatement);
    }
    /**
     * The login theme of this client.
     * 
     */
    @Export(name="loginTheme", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> loginTheme;

    /**
     * @return The login theme of this client.
     * 
     */
    public Output<Optional<String>> loginTheme() {
        return Codegen.optional(this.loginTheme);
    }
    /**
     * SAML POST Binding URL for the client&#39;s single logout service.
     * 
     */
    @Export(name="logoutServicePostBindingUrl", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> logoutServicePostBindingUrl;

    /**
     * @return SAML POST Binding URL for the client&#39;s single logout service.
     * 
     */
    public Output<Optional<String>> logoutServicePostBindingUrl() {
        return Codegen.optional(this.logoutServicePostBindingUrl);
    }
    /**
     * SAML Redirect Binding URL for the client&#39;s single logout service.
     * 
     */
    @Export(name="logoutServiceRedirectBindingUrl", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> logoutServiceRedirectBindingUrl;

    /**
     * @return SAML Redirect Binding URL for the client&#39;s single logout service.
     * 
     */
    public Output<Optional<String>> logoutServiceRedirectBindingUrl() {
        return Codegen.optional(this.logoutServiceRedirectBindingUrl);
    }
    /**
     * When specified, this URL will be used for all SAML requests.
     * 
     */
    @Export(name="masterSamlProcessingUrl", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> masterSamlProcessingUrl;

    /**
     * @return When specified, this URL will be used for all SAML requests.
     * 
     */
    public Output<Optional<String>> masterSamlProcessingUrl() {
        return Codegen.optional(this.masterSamlProcessingUrl);
    }
    /**
     * The display name of this client in the GUI.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The display name of this client in the GUI.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Sets the Name ID format for the subject.
     * 
     */
    @Export(name="nameIdFormat", refs={String.class}, tree="[0]")
    private Output<String> nameIdFormat;

    /**
     * @return Sets the Name ID format for the subject.
     * 
     */
    public Output<String> nameIdFormat() {
        return this.nameIdFormat;
    }
    /**
     * The realm this client is attached to.
     * 
     */
    @Export(name="realmId", refs={String.class}, tree="[0]")
    private Output<String> realmId;

    /**
     * @return The realm this client is attached to.
     * 
     */
    public Output<String> realmId() {
        return this.realmId;
    }
    /**
     * When specified, this value is prepended to all relative URLs.
     * 
     */
    @Export(name="rootUrl", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> rootUrl;

    /**
     * @return When specified, this value is prepended to all relative URLs.
     * 
     */
    public Output<Optional<String>> rootUrl() {
        return Codegen.optional(this.rootUrl);
    }
    /**
     * When `true`, the SAML assertions will be signed by Keycloak using the realm&#39;s private key, and embedded within the SAML XML Auth response. Defaults to `false`.
     * 
     */
    @Export(name="signAssertions", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> signAssertions;

    /**
     * @return When `true`, the SAML assertions will be signed by Keycloak using the realm&#39;s private key, and embedded within the SAML XML Auth response. Defaults to `false`.
     * 
     */
    public Output<Optional<Boolean>> signAssertions() {
        return Codegen.optional(this.signAssertions);
    }
    /**
     * When `true`, the SAML document will be signed by Keycloak using the realm&#39;s private key. Defaults to `true`.
     * 
     */
    @Export(name="signDocuments", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> signDocuments;

    /**
     * @return When `true`, the SAML document will be signed by Keycloak using the realm&#39;s private key. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> signDocuments() {
        return Codegen.optional(this.signDocuments);
    }
    /**
     * The signature algorithm used to sign documents. Should be one of &#34;RSA_SHA1&#34;, &#34;RSA_SHA256&#34;, &#34;RSA_SHA256_MGF1, &#34;RSA_SHA512&#34;, &#34;RSA_SHA512_MGF1&#34; or &#34;DSA_SHA1&#34;.
     * 
     */
    @Export(name="signatureAlgorithm", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> signatureAlgorithm;

    /**
     * @return The signature algorithm used to sign documents. Should be one of &#34;RSA_SHA1&#34;, &#34;RSA_SHA256&#34;, &#34;RSA_SHA256_MGF1, &#34;RSA_SHA512&#34;, &#34;RSA_SHA512_MGF1&#34; or &#34;DSA_SHA1&#34;.
     * 
     */
    public Output<Optional<String>> signatureAlgorithm() {
        return Codegen.optional(this.signatureAlgorithm);
    }
    /**
     * The value of the `KeyName` element within the signed SAML document. Should be one of &#34;NONE&#34;, &#34;KEY_ID&#34;, or &#34;CERT_SUBJECT&#34;. Defaults to &#34;KEY_ID&#34;.
     * 
     */
    @Export(name="signatureKeyName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> signatureKeyName;

    /**
     * @return The value of the `KeyName` element within the signed SAML document. Should be one of &#34;NONE&#34;, &#34;KEY_ID&#34;, or &#34;CERT_SUBJECT&#34;. Defaults to &#34;KEY_ID&#34;.
     * 
     */
    public Output<Optional<String>> signatureKeyName() {
        return Codegen.optional(this.signatureKeyName);
    }
    /**
     * If documents or assertions from the client are signed, this certificate will be used to verify the signature.
     * 
     */
    @Export(name="signingCertificate", refs={String.class}, tree="[0]")
    private Output<String> signingCertificate;

    /**
     * @return If documents or assertions from the client are signed, this certificate will be used to verify the signature.
     * 
     */
    public Output<String> signingCertificate() {
        return this.signingCertificate;
    }
    /**
     * (Computed) The sha1sum fingerprint of the signing certificate. If the signing certificate is not in correct base64 format, this will be left empty.
     * 
     */
    @Export(name="signingCertificateSha1", refs={String.class}, tree="[0]")
    private Output<String> signingCertificateSha1;

    /**
     * @return (Computed) The sha1sum fingerprint of the signing certificate. If the signing certificate is not in correct base64 format, this will be left empty.
     * 
     */
    public Output<String> signingCertificateSha1() {
        return this.signingCertificateSha1;
    }
    /**
     * If documents or assertions from the client are signed, this private key will be used to verify the signature.
     * 
     */
    @Export(name="signingPrivateKey", refs={String.class}, tree="[0]")
    private Output<String> signingPrivateKey;

    /**
     * @return If documents or assertions from the client are signed, this private key will be used to verify the signature.
     * 
     */
    public Output<String> signingPrivateKey() {
        return this.signingPrivateKey;
    }
    /**
     * (Computed) The sha1sum fingerprint of the signing private key. If the signing private key is not in correct base64 format, this will be left empty.
     * 
     */
    @Export(name="signingPrivateKeySha1", refs={String.class}, tree="[0]")
    private Output<String> signingPrivateKeySha1;

    /**
     * @return (Computed) The sha1sum fingerprint of the signing private key. If the signing private key is not in correct base64 format, this will be left empty.
     * 
     */
    public Output<String> signingPrivateKeySha1() {
        return this.signingPrivateKeySha1;
    }
    /**
     * When specified, Keycloak will use this list to validate given Assertion Consumer URLs specified in the authentication request.
     * 
     */
    @Export(name="validRedirectUris", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> validRedirectUris;

    /**
     * @return When specified, Keycloak will use this list to validate given Assertion Consumer URLs specified in the authentication request.
     * 
     */
    public Output<Optional<List<String>>> validRedirectUris() {
        return Codegen.optional(this.validRedirectUris);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Client(String name) {
        this(name, ClientArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Client(String name, ClientArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Client(String name, ClientArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("keycloak:saml/client:Client", name, args == null ? ClientArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private Client(String name, Output<String> id, @Nullable ClientState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("keycloak:saml/client:Client", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Client get(String name, Output<String> id, @Nullable ClientState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Client(name, id, state, options);
    }
}
