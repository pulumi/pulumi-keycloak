// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.keycloak.saml;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.keycloak.Utilities;
import com.pulumi.keycloak.saml.ClientArgs;
import com.pulumi.keycloak.saml.inputs.ClientState;
import com.pulumi.keycloak.saml.outputs.ClientAuthenticationFlowBindingOverrides;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Allows for creating and managing Keycloak clients that use the SAML protocol.
 * 
 * Clients are entities that can use Keycloak for user authentication. Typically, clients are applications that redirect users
 * to Keycloak for authentication in order to take advantage of Keycloak&#39;s user sessions for SSO.
 * 
 * ## Example Usage
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.keycloak.Realm;
 * import com.pulumi.keycloak.RealmArgs;
 * import com.pulumi.keycloak.saml.Client;
 * import com.pulumi.keycloak.saml.ClientArgs;
 * import com.pulumi.std.StdFunctions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var realm = new Realm("realm", RealmArgs.builder()
 *             .realm("my-realm")
 *             .enabled(true)
 *             .build());
 * 
 *         var samlClient = new Client("samlClient", ClientArgs.builder()
 *             .realmId(realm.id())
 *             .clientId("saml-client")
 *             .name("saml-client")
 *             .signDocuments(false)
 *             .signAssertions(true)
 *             .includeAuthnStatement(true)
 *             .signingCertificate(StdFunctions.file(Map.of("input", "saml-cert.pem")).result())
 *             .signingPrivateKey(StdFunctions.file(Map.of("input", "saml-key.pem")).result())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Import
 * 
 * Clients can be imported using the format `{{realm_id}}/{{client_keycloak_id}}`, where `clientKeycloakId` is the unique ID that Keycloak
 * assigns to the client upon creation. This value can be found in the URI when editing this client in the GUI, and is typically a GUID.
 * 
 * Example:
 * 
 */
@ResourceType(type="keycloak:saml/client:Client")
public class Client extends com.pulumi.resources.CustomResource {
    /**
     * Always list this client in the Account UI, even if the user does not have an active session.
     * 
     */
    @Export(name="alwaysDisplayInConsole", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> alwaysDisplayInConsole;

    /**
     * @return Always list this client in the Account UI, even if the user does not have an active session.
     * 
     */
    public Output<Optional<Boolean>> alwaysDisplayInConsole() {
        return Codegen.optional(this.alwaysDisplayInConsole);
    }
    /**
     * SAML POST Binding URL for the client&#39;s assertion consumer service (login responses).
     * 
     */
    @Export(name="assertionConsumerPostUrl", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> assertionConsumerPostUrl;

    /**
     * @return SAML POST Binding URL for the client&#39;s assertion consumer service (login responses).
     * 
     */
    public Output<Optional<String>> assertionConsumerPostUrl() {
        return Codegen.optional(this.assertionConsumerPostUrl);
    }
    /**
     * SAML Redirect Binding URL for the client&#39;s assertion consumer service (login responses).
     * 
     */
    @Export(name="assertionConsumerRedirectUrl", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> assertionConsumerRedirectUrl;

    /**
     * @return SAML Redirect Binding URL for the client&#39;s assertion consumer service (login responses).
     * 
     */
    public Output<Optional<String>> assertionConsumerRedirectUrl() {
        return Codegen.optional(this.assertionConsumerRedirectUrl);
    }
    /**
     * Override realm authentication flow bindings
     * 
     */
    @Export(name="authenticationFlowBindingOverrides", refs={ClientAuthenticationFlowBindingOverrides.class}, tree="[0]")
    private Output</* @Nullable */ ClientAuthenticationFlowBindingOverrides> authenticationFlowBindingOverrides;

    /**
     * @return Override realm authentication flow bindings
     * 
     */
    public Output<Optional<ClientAuthenticationFlowBindingOverrides>> authenticationFlowBindingOverrides() {
        return Codegen.optional(this.authenticationFlowBindingOverrides);
    }
    /**
     * When specified, this URL will be used whenever Keycloak needs to link to this client.
     * 
     */
    @Export(name="baseUrl", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> baseUrl;

    /**
     * @return When specified, this URL will be used whenever Keycloak needs to link to this client.
     * 
     */
    public Output<Optional<String>> baseUrl() {
        return Codegen.optional(this.baseUrl);
    }
    /**
     * The Canonicalization Method for XML signatures. Should be one of &#34;EXCLUSIVE&#34;, &#34;EXCLUSIVE_WITH_COMMENTS&#34;, &#34;INCLUSIVE&#34;, or &#34;INCLUSIVE_WITH_COMMENTS&#34;. Defaults to &#34;EXCLUSIVE&#34;.
     * 
     */
    @Export(name="canonicalizationMethod", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> canonicalizationMethod;

    /**
     * @return The Canonicalization Method for XML signatures. Should be one of &#34;EXCLUSIVE&#34;, &#34;EXCLUSIVE_WITH_COMMENTS&#34;, &#34;INCLUSIVE&#34;, or &#34;INCLUSIVE_WITH_COMMENTS&#34;. Defaults to &#34;EXCLUSIVE&#34;.
     * 
     */
    public Output<Optional<String>> canonicalizationMethod() {
        return Codegen.optional(this.canonicalizationMethod);
    }
    /**
     * The unique ID of this client, referenced in the URI during authentication and in issued tokens.
     * 
     */
    @Export(name="clientId", refs={String.class}, tree="[0]")
    private Output<String> clientId;

    /**
     * @return The unique ID of this client, referenced in the URI during authentication and in issued tokens.
     * 
     */
    public Output<String> clientId() {
        return this.clientId;
    }
    /**
     * When `true`, Keycloak will expect that documents originating from a client will be signed using the certificate and/or key configured via `signingCertificate` and `signingPrivateKey`. Defaults to `true`.
     * 
     */
    @Export(name="clientSignatureRequired", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> clientSignatureRequired;

    /**
     * @return When `true`, Keycloak will expect that documents originating from a client will be signed using the certificate and/or key configured via `signingCertificate` and `signingPrivateKey`. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> clientSignatureRequired() {
        return Codegen.optional(this.clientSignatureRequired);
    }
    /**
     * When `true`, users have to consent to client access. Defaults to `false`.
     * 
     */
    @Export(name="consentRequired", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> consentRequired;

    /**
     * @return When `true`, users have to consent to client access. Defaults to `false`.
     * 
     */
    public Output<Boolean> consentRequired() {
        return this.consentRequired;
    }
    /**
     * The description of this client in the GUI.
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return The description of this client in the GUI.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * When false, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.
     * 
     */
    @Export(name="enabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enabled;

    /**
     * @return When false, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> enabled() {
        return Codegen.optional(this.enabled);
    }
    /**
     * When `true`, the SAML assertions will be encrypted by Keycloak using the client&#39;s public key. Defaults to `false`.
     * 
     */
    @Export(name="encryptAssertions", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> encryptAssertions;

    /**
     * @return When `true`, the SAML assertions will be encrypted by Keycloak using the client&#39;s public key. Defaults to `false`.
     * 
     */
    public Output<Optional<Boolean>> encryptAssertions() {
        return Codegen.optional(this.encryptAssertions);
    }
    /**
     * Algorithm used to encrypt SAML assertions. Allowed values: `AES_256_GCM`, `AES_192_GCM`, `AES_128_GCM`, `AES_256_CBC`, `AES_192_CBC`, or `AES_128_CBC`.
     * 
     */
    @Export(name="encryptionAlgorithm", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> encryptionAlgorithm;

    /**
     * @return Algorithm used to encrypt SAML assertions. Allowed values: `AES_256_GCM`, `AES_192_GCM`, `AES_128_GCM`, `AES_256_CBC`, `AES_192_CBC`, or `AES_128_CBC`.
     * 
     */
    public Output<Optional<String>> encryptionAlgorithm() {
        return Codegen.optional(this.encryptionAlgorithm);
    }
    /**
     * If assertions for the client are encrypted, this certificate will be used for encryption.
     * 
     */
    @Export(name="encryptionCertificate", refs={String.class}, tree="[0]")
    private Output<String> encryptionCertificate;

    /**
     * @return If assertions for the client are encrypted, this certificate will be used for encryption.
     * 
     */
    public Output<String> encryptionCertificate() {
        return this.encryptionCertificate;
    }
    /**
     * (Computed) The sha1sum fingerprint of the encryption certificate. If the encryption certificate is not in correct base64 format, this will be left empty.
     * 
     */
    @Export(name="encryptionCertificateSha1", refs={String.class}, tree="[0]")
    private Output<String> encryptionCertificateSha1;

    /**
     * @return (Computed) The sha1sum fingerprint of the encryption certificate. If the encryption certificate is not in correct base64 format, this will be left empty.
     * 
     */
    public Output<String> encryptionCertificateSha1() {
        return this.encryptionCertificateSha1;
    }
    /**
     * Digest method used with SAML encryption. Allowed values: `SHA-512`, `SHA-256`, or `SHA-1`. Only valid when `encryptionKeyAlgorithm` is `RSA-OAEP-11` or `RSA-OAEP-MGF1P`. Default is `SHA-256`.
     * 
     */
    @Export(name="encryptionDigestMethod", refs={String.class}, tree="[0]")
    private Output<String> encryptionDigestMethod;

    /**
     * @return Digest method used with SAML encryption. Allowed values: `SHA-512`, `SHA-256`, or `SHA-1`. Only valid when `encryptionKeyAlgorithm` is `RSA-OAEP-11` or `RSA-OAEP-MGF1P`. Default is `SHA-256`.
     * 
     */
    public Output<String> encryptionDigestMethod() {
        return this.encryptionDigestMethod;
    }
    /**
     * Key transport algorithm used by the client to encrypt the secret key for SAML assertion encryption. Allowed values: `RSA-OAEP-11`, `RSA-OAEP-MGF1P`, or `RSA1_5`. Default is `RSA-OAEP-11`.
     * 
     */
    @Export(name="encryptionKeyAlgorithm", refs={String.class}, tree="[0]")
    private Output<String> encryptionKeyAlgorithm;

    /**
     * @return Key transport algorithm used by the client to encrypt the secret key for SAML assertion encryption. Allowed values: `RSA-OAEP-11`, `RSA-OAEP-MGF1P`, or `RSA1_5`. Default is `RSA-OAEP-11`.
     * 
     */
    public Output<String> encryptionKeyAlgorithm() {
        return this.encryptionKeyAlgorithm;
    }
    /**
     * Mask generation function used with SAML encryption. Allowed values: `mgf1sha1`, `mgf1sha224`, `mgf1sha256`, `mgf1sha384`, or `mgf1sha512`. Only valid when `encryptionKeyAlgorithm` is `RSA-OAEP-11`. Default is `mgf1sha256`.
     * 
     */
    @Export(name="encryptionMaskGenerationFunction", refs={String.class}, tree="[0]")
    private Output<String> encryptionMaskGenerationFunction;

    /**
     * @return Mask generation function used with SAML encryption. Allowed values: `mgf1sha1`, `mgf1sha224`, `mgf1sha256`, `mgf1sha384`, or `mgf1sha512`. Only valid when `encryptionKeyAlgorithm` is `RSA-OAEP-11`. Default is `mgf1sha256`.
     * 
     */
    public Output<String> encryptionMaskGenerationFunction() {
        return this.encryptionMaskGenerationFunction;
    }
    /**
     * A map of key/value pairs to add extra configuration attributes to this client. This can be used for custom attributes, or to add configuration attributes that is not yet supported by this Terraform provider. Use this attribute at your own risk, as s may conflict with top-level configuration attributes in future provider updates.
     * 
     */
    @Export(name="extraConfig", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> extraConfig;

    /**
     * @return A map of key/value pairs to add extra configuration attributes to this client. This can be used for custom attributes, or to add configuration attributes that is not yet supported by this Terraform provider. Use this attribute at your own risk, as s may conflict with top-level configuration attributes in future provider updates.
     * 
     */
    public Output<Optional<Map<String,String>>> extraConfig() {
        return Codegen.optional(this.extraConfig);
    }
    /**
     * Ignore requested NameID subject format and use the one defined in `nameIdFormat` instead. Defaults to `false`.
     * 
     */
    @Export(name="forceNameIdFormat", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> forceNameIdFormat;

    /**
     * @return Ignore requested NameID subject format and use the one defined in `nameIdFormat` instead. Defaults to `false`.
     * 
     */
    public Output<Optional<Boolean>> forceNameIdFormat() {
        return Codegen.optional(this.forceNameIdFormat);
    }
    /**
     * When `true`, Keycloak will always respond to an authentication request via the SAML POST Binding. Defaults to `true`.
     * 
     */
    @Export(name="forcePostBinding", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> forcePostBinding;

    /**
     * @return When `true`, Keycloak will always respond to an authentication request via the SAML POST Binding. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> forcePostBinding() {
        return Codegen.optional(this.forcePostBinding);
    }
    /**
     * When `true`, this client will require a browser redirect in order to perform a logout. Defaults to `true`.
     * 
     */
    @Export(name="frontChannelLogout", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> frontChannelLogout;

    /**
     * @return When `true`, this client will require a browser redirect in order to perform a logout. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> frontChannelLogout() {
        return Codegen.optional(this.frontChannelLogout);
    }
    /**
     * Allow to include all roles mappings in the access token
     * 
     */
    @Export(name="fullScopeAllowed", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> fullScopeAllowed;

    /**
     * @return Allow to include all roles mappings in the access token
     * 
     */
    public Output<Optional<Boolean>> fullScopeAllowed() {
        return Codegen.optional(this.fullScopeAllowed);
    }
    /**
     * Relay state you want to send with SAML request when you want to do IDP Initiated SSO.
     * 
     */
    @Export(name="idpInitiatedSsoRelayState", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> idpInitiatedSsoRelayState;

    /**
     * @return Relay state you want to send with SAML request when you want to do IDP Initiated SSO.
     * 
     */
    public Output<Optional<String>> idpInitiatedSsoRelayState() {
        return Codegen.optional(this.idpInitiatedSsoRelayState);
    }
    /**
     * URL fragment name to reference client when you want to do IDP Initiated SSO.
     * 
     */
    @Export(name="idpInitiatedSsoUrlName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> idpInitiatedSsoUrlName;

    /**
     * @return URL fragment name to reference client when you want to do IDP Initiated SSO.
     * 
     */
    public Output<Optional<String>> idpInitiatedSsoUrlName() {
        return Codegen.optional(this.idpInitiatedSsoUrlName);
    }
    /**
     * When `true`, an `AuthnStatement` will be included in the SAML response. Defaults to `true`.
     * 
     */
    @Export(name="includeAuthnStatement", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> includeAuthnStatement;

    /**
     * @return When `true`, an `AuthnStatement` will be included in the SAML response. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> includeAuthnStatement() {
        return Codegen.optional(this.includeAuthnStatement);
    }
    /**
     * The login theme of this client.
     * 
     */
    @Export(name="loginTheme", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> loginTheme;

    /**
     * @return The login theme of this client.
     * 
     */
    public Output<Optional<String>> loginTheme() {
        return Codegen.optional(this.loginTheme);
    }
    /**
     * SAML POST Binding URL for the client&#39;s single logout service.
     * 
     */
    @Export(name="logoutServicePostBindingUrl", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> logoutServicePostBindingUrl;

    /**
     * @return SAML POST Binding URL for the client&#39;s single logout service.
     * 
     */
    public Output<Optional<String>> logoutServicePostBindingUrl() {
        return Codegen.optional(this.logoutServicePostBindingUrl);
    }
    /**
     * SAML Redirect Binding URL for the client&#39;s single logout service.
     * 
     */
    @Export(name="logoutServiceRedirectBindingUrl", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> logoutServiceRedirectBindingUrl;

    /**
     * @return SAML Redirect Binding URL for the client&#39;s single logout service.
     * 
     */
    public Output<Optional<String>> logoutServiceRedirectBindingUrl() {
        return Codegen.optional(this.logoutServiceRedirectBindingUrl);
    }
    /**
     * When specified, this URL will be used for all SAML requests.
     * 
     */
    @Export(name="masterSamlProcessingUrl", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> masterSamlProcessingUrl;

    /**
     * @return When specified, this URL will be used for all SAML requests.
     * 
     */
    public Output<Optional<String>> masterSamlProcessingUrl() {
        return Codegen.optional(this.masterSamlProcessingUrl);
    }
    /**
     * The display name of this client in the GUI.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The display name of this client in the GUI.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Sets the Name ID format for the subject.
     * 
     */
    @Export(name="nameIdFormat", refs={String.class}, tree="[0]")
    private Output<String> nameIdFormat;

    /**
     * @return Sets the Name ID format for the subject.
     * 
     */
    public Output<String> nameIdFormat() {
        return this.nameIdFormat;
    }
    /**
     * The realm this client is attached to.
     * 
     */
    @Export(name="realmId", refs={String.class}, tree="[0]")
    private Output<String> realmId;

    /**
     * @return The realm this client is attached to.
     * 
     */
    public Output<String> realmId() {
        return this.realmId;
    }
    /**
     * When specified, this value is prepended to all relative URLs.
     * 
     */
    @Export(name="rootUrl", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> rootUrl;

    /**
     * @return When specified, this value is prepended to all relative URLs.
     * 
     */
    public Output<Optional<String>> rootUrl() {
        return Codegen.optional(this.rootUrl);
    }
    /**
     * When `true`, the SAML assertions will be signed by Keycloak using the realm&#39;s private key, and embedded within the SAML XML Auth response. Defaults to `false`.
     * 
     */
    @Export(name="signAssertions", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> signAssertions;

    /**
     * @return When `true`, the SAML assertions will be signed by Keycloak using the realm&#39;s private key, and embedded within the SAML XML Auth response. Defaults to `false`.
     * 
     */
    public Output<Optional<Boolean>> signAssertions() {
        return Codegen.optional(this.signAssertions);
    }
    /**
     * When `true`, the SAML document will be signed by Keycloak using the realm&#39;s private key. Defaults to `true`.
     * 
     */
    @Export(name="signDocuments", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> signDocuments;

    /**
     * @return When `true`, the SAML document will be signed by Keycloak using the realm&#39;s private key. Defaults to `true`.
     * 
     */
    public Output<Optional<Boolean>> signDocuments() {
        return Codegen.optional(this.signDocuments);
    }
    /**
     * The signature algorithm used to sign documents. Should be one of &#34;RSA_SHA1&#34;, &#34;RSA_SHA256&#34;, &#34;RSA_SHA256_MGF1, &#34;RSA_SHA512&#34;, &#34;RSA_SHA512_MGF1&#34; or &#34;DSA_SHA1&#34;.
     * 
     */
    @Export(name="signatureAlgorithm", refs={String.class}, tree="[0]")
    private Output<String> signatureAlgorithm;

    /**
     * @return The signature algorithm used to sign documents. Should be one of &#34;RSA_SHA1&#34;, &#34;RSA_SHA256&#34;, &#34;RSA_SHA256_MGF1, &#34;RSA_SHA512&#34;, &#34;RSA_SHA512_MGF1&#34; or &#34;DSA_SHA1&#34;.
     * 
     */
    public Output<String> signatureAlgorithm() {
        return this.signatureAlgorithm;
    }
    /**
     * The value of the `KeyName` element within the signed SAML document. Should be one of &#34;NONE&#34;, &#34;KEY_ID&#34;, or &#34;CERT_SUBJECT&#34;. Defaults to &#34;KEY_ID&#34;.
     * 
     */
    @Export(name="signatureKeyName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> signatureKeyName;

    /**
     * @return The value of the `KeyName` element within the signed SAML document. Should be one of &#34;NONE&#34;, &#34;KEY_ID&#34;, or &#34;CERT_SUBJECT&#34;. Defaults to &#34;KEY_ID&#34;.
     * 
     */
    public Output<Optional<String>> signatureKeyName() {
        return Codegen.optional(this.signatureKeyName);
    }
    /**
     * If documents or assertions from the client are signed, this certificate will be used to verify the signature.
     * 
     */
    @Export(name="signingCertificate", refs={String.class}, tree="[0]")
    private Output<String> signingCertificate;

    /**
     * @return If documents or assertions from the client are signed, this certificate will be used to verify the signature.
     * 
     */
    public Output<String> signingCertificate() {
        return this.signingCertificate;
    }
    /**
     * (Computed) The sha1sum fingerprint of the signing certificate. If the signing certificate is not in correct base64 format, this will be left empty.
     * 
     */
    @Export(name="signingCertificateSha1", refs={String.class}, tree="[0]")
    private Output<String> signingCertificateSha1;

    /**
     * @return (Computed) The sha1sum fingerprint of the signing certificate. If the signing certificate is not in correct base64 format, this will be left empty.
     * 
     */
    public Output<String> signingCertificateSha1() {
        return this.signingCertificateSha1;
    }
    /**
     * If documents or assertions from the client are signed, this private key will be used to verify the signature.
     * 
     */
    @Export(name="signingPrivateKey", refs={String.class}, tree="[0]")
    private Output<String> signingPrivateKey;

    /**
     * @return If documents or assertions from the client are signed, this private key will be used to verify the signature.
     * 
     */
    public Output<String> signingPrivateKey() {
        return this.signingPrivateKey;
    }
    /**
     * (Computed) The sha1sum fingerprint of the signing private key. If the signing private key is not in correct base64 format, this will be left empty.
     * 
     */
    @Export(name="signingPrivateKeySha1", refs={String.class}, tree="[0]")
    private Output<String> signingPrivateKeySha1;

    /**
     * @return (Computed) The sha1sum fingerprint of the signing private key. If the signing private key is not in correct base64 format, this will be left empty.
     * 
     */
    public Output<String> signingPrivateKeySha1() {
        return this.signingPrivateKeySha1;
    }
    /**
     * When specified, Keycloak will use this list to validate given Assertion Consumer URLs specified in the authentication request.
     * 
     */
    @Export(name="validRedirectUris", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> validRedirectUris;

    /**
     * @return When specified, Keycloak will use this list to validate given Assertion Consumer URLs specified in the authentication request.
     * 
     */
    public Output<Optional<List<String>>> validRedirectUris() {
        return Codegen.optional(this.validRedirectUris);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Client(java.lang.String name) {
        this(name, ClientArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Client(java.lang.String name, ClientArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Client(java.lang.String name, ClientArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("keycloak:saml/client:Client", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Client(java.lang.String name, Output<java.lang.String> id, @Nullable ClientState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("keycloak:saml/client:Client", name, state, makeResourceOptions(options, id), false);
    }

    private static ClientArgs makeArgs(ClientArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? ClientArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Client get(java.lang.String name, Output<java.lang.String> id, @Nullable ClientState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Client(name, id, state, options);
    }
}
