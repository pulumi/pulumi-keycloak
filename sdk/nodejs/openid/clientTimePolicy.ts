// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "../utilities";

/**
 * Allows you to manage time policies.
 *
 * Time policies allow you to define conditions based on time ranges. You can specify when access should be granted using various time constraints including date, month, year, hour, and minute ranges.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as keycloak from "@pulumi/keycloak";
 *
 * const realm = new keycloak.Realm("realm", {
 *     realm: "my-realm",
 *     enabled: true,
 * });
 * const test = new keycloak.openid.Client("test", {
 *     clientId: "client_id",
 *     realmId: realm.id,
 *     accessType: "CONFIDENTIAL",
 *     serviceAccountsEnabled: true,
 *     authorization: {
 *         policyEnforcementMode: "ENFORCING",
 *     },
 * });
 * // Policy for business hours only (9 AM - 5 PM)
 * const businessHours = new keycloak.openid.ClientTimePolicy("business_hours", {
 *     resourceServerId: test.resourceServerId,
 *     realmId: realm.id,
 *     name: "business_hours_policy",
 *     decisionStrategy: "UNANIMOUS",
 *     logic: "POSITIVE",
 *     hour: "09",
 *     hourEnd: "17",
 * });
 * // Policy for specific date range
 * const dateRange = new keycloak.openid.ClientTimePolicy("date_range", {
 *     resourceServerId: test.resourceServerId,
 *     realmId: realm.id,
 *     name: "date_range_policy",
 *     decisionStrategy: "UNANIMOUS",
 *     logic: "POSITIVE",
 *     notBefore: "2024-01-01 00:00:00",
 *     notOnOrAfter: "2024-12-31 23:59:59",
 * });
 * // Policy for specific months (January to March)
 * const quarter1 = new keycloak.openid.ClientTimePolicy("quarter1", {
 *     resourceServerId: test.resourceServerId,
 *     realmId: realm.id,
 *     name: "q1_policy",
 *     decisionStrategy: "UNANIMOUS",
 *     logic: "POSITIVE",
 *     month: "1",
 *     monthEnd: "3",
 * });
 * ```
 *
 * ### Argument Reference
 *
 * The following arguments are supported:
 *
 * - `realmId` - (Required) The realm this policy exists in.
 * - `resourceServerId` - (Required) The ID of the resource server.
 * - `name` - (Required) The name of the policy.
 * - `decisionStrategy` - (Required) The decision strategy, can be one of `UNANIMOUS`, `AFFIRMATIVE`, or `CONSENSUS`.
 * - `logic` - (Optional) The logic, can be one of `POSITIVE` or `NEGATIVE`. Defaults to `POSITIVE`.
 * - `notBefore` - (Optional) The policy is valid only after this date/time (format: `YYYY-MM-DD HH:MM:SS`).
 * - `notOnOrAfter` - (Optional) The policy is valid only before this date/time (format: `YYYY-MM-DD HH:MM:SS`).
 * - `dayMonth` - (Optional) Starting day of the month (1-31).
 * - `dayMonthEnd` - (Optional) Ending day of the month (1-31).
 * - `month` - (Optional) Starting month (1-12).
 * - `monthEnd` - (Optional) Ending month (1-12).
 * - `year` - (Optional) Starting year.
 * - `yearEnd` - (Optional) Ending year.
 * - `hour` - (Optional) Starting hour (0-23).
 * - `hourEnd` - (Optional) Ending hour (0-23).
 * - `minute` - (Optional) Starting minute (0-59).
 * - `minuteEnd` - (Optional) Ending minute (0-59).
 * - `description` - (Optional) A description for the authorization policy.
 *
 * ### Attributes Reference
 *
 * In addition to the arguments listed above, the following computed attributes are exported:
 *
 * - `id` - Policy ID representing the time policy.
 *
 * ## Import
 *
 * Time policies can be imported using the format: `{{realmId}}/{{resourceServerId}}/{{policyId}}`.
 *
 * Example:
 *
 * ```sh
 * $ pulumi import keycloak:openid/clientTimePolicy:ClientTimePolicy test my-realm/3bd4a686-1062-4b59-97b8-e4e3f10b99da/63b3cde8-987d-4cd9-9306-1955579281d9
 * ```
 */
export class ClientTimePolicy extends pulumi.CustomResource {
    /**
     * Get an existing ClientTimePolicy resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ClientTimePolicyState, opts?: pulumi.CustomResourceOptions): ClientTimePolicy {
        return new ClientTimePolicy(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'keycloak:openid/clientTimePolicy:ClientTimePolicy';

    /**
     * Returns true if the given object is an instance of ClientTimePolicy.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is ClientTimePolicy {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ClientTimePolicy.__pulumiType;
    }

    declare public readonly dayMonth: pulumi.Output<string | undefined>;
    declare public readonly dayMonthEnd: pulumi.Output<string | undefined>;
    declare public readonly decisionStrategy: pulumi.Output<string>;
    declare public readonly description: pulumi.Output<string | undefined>;
    declare public readonly hour: pulumi.Output<string | undefined>;
    declare public readonly hourEnd: pulumi.Output<string | undefined>;
    declare public readonly logic: pulumi.Output<string | undefined>;
    declare public readonly minute: pulumi.Output<string | undefined>;
    declare public readonly minuteEnd: pulumi.Output<string | undefined>;
    declare public readonly month: pulumi.Output<string | undefined>;
    declare public readonly monthEnd: pulumi.Output<string | undefined>;
    declare public readonly name: pulumi.Output<string>;
    declare public readonly notBefore: pulumi.Output<string | undefined>;
    declare public readonly notOnOrAfter: pulumi.Output<string | undefined>;
    declare public readonly realmId: pulumi.Output<string>;
    declare public readonly resourceServerId: pulumi.Output<string>;
    declare public readonly year: pulumi.Output<string | undefined>;
    declare public readonly yearEnd: pulumi.Output<string | undefined>;

    /**
     * Create a ClientTimePolicy resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ClientTimePolicyArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ClientTimePolicyArgs | ClientTimePolicyState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ClientTimePolicyState | undefined;
            resourceInputs["dayMonth"] = state?.dayMonth;
            resourceInputs["dayMonthEnd"] = state?.dayMonthEnd;
            resourceInputs["decisionStrategy"] = state?.decisionStrategy;
            resourceInputs["description"] = state?.description;
            resourceInputs["hour"] = state?.hour;
            resourceInputs["hourEnd"] = state?.hourEnd;
            resourceInputs["logic"] = state?.logic;
            resourceInputs["minute"] = state?.minute;
            resourceInputs["minuteEnd"] = state?.minuteEnd;
            resourceInputs["month"] = state?.month;
            resourceInputs["monthEnd"] = state?.monthEnd;
            resourceInputs["name"] = state?.name;
            resourceInputs["notBefore"] = state?.notBefore;
            resourceInputs["notOnOrAfter"] = state?.notOnOrAfter;
            resourceInputs["realmId"] = state?.realmId;
            resourceInputs["resourceServerId"] = state?.resourceServerId;
            resourceInputs["year"] = state?.year;
            resourceInputs["yearEnd"] = state?.yearEnd;
        } else {
            const args = argsOrState as ClientTimePolicyArgs | undefined;
            if (args?.decisionStrategy === undefined && !opts.urn) {
                throw new Error("Missing required property 'decisionStrategy'");
            }
            if (args?.realmId === undefined && !opts.urn) {
                throw new Error("Missing required property 'realmId'");
            }
            if (args?.resourceServerId === undefined && !opts.urn) {
                throw new Error("Missing required property 'resourceServerId'");
            }
            resourceInputs["dayMonth"] = args?.dayMonth;
            resourceInputs["dayMonthEnd"] = args?.dayMonthEnd;
            resourceInputs["decisionStrategy"] = args?.decisionStrategy;
            resourceInputs["description"] = args?.description;
            resourceInputs["hour"] = args?.hour;
            resourceInputs["hourEnd"] = args?.hourEnd;
            resourceInputs["logic"] = args?.logic;
            resourceInputs["minute"] = args?.minute;
            resourceInputs["minuteEnd"] = args?.minuteEnd;
            resourceInputs["month"] = args?.month;
            resourceInputs["monthEnd"] = args?.monthEnd;
            resourceInputs["name"] = args?.name;
            resourceInputs["notBefore"] = args?.notBefore;
            resourceInputs["notOnOrAfter"] = args?.notOnOrAfter;
            resourceInputs["realmId"] = args?.realmId;
            resourceInputs["resourceServerId"] = args?.resourceServerId;
            resourceInputs["year"] = args?.year;
            resourceInputs["yearEnd"] = args?.yearEnd;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(ClientTimePolicy.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering ClientTimePolicy resources.
 */
export interface ClientTimePolicyState {
    dayMonth?: pulumi.Input<string>;
    dayMonthEnd?: pulumi.Input<string>;
    decisionStrategy?: pulumi.Input<string>;
    description?: pulumi.Input<string>;
    hour?: pulumi.Input<string>;
    hourEnd?: pulumi.Input<string>;
    logic?: pulumi.Input<string>;
    minute?: pulumi.Input<string>;
    minuteEnd?: pulumi.Input<string>;
    month?: pulumi.Input<string>;
    monthEnd?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    notBefore?: pulumi.Input<string>;
    notOnOrAfter?: pulumi.Input<string>;
    realmId?: pulumi.Input<string>;
    resourceServerId?: pulumi.Input<string>;
    year?: pulumi.Input<string>;
    yearEnd?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a ClientTimePolicy resource.
 */
export interface ClientTimePolicyArgs {
    dayMonth?: pulumi.Input<string>;
    dayMonthEnd?: pulumi.Input<string>;
    decisionStrategy: pulumi.Input<string>;
    description?: pulumi.Input<string>;
    hour?: pulumi.Input<string>;
    hourEnd?: pulumi.Input<string>;
    logic?: pulumi.Input<string>;
    minute?: pulumi.Input<string>;
    minuteEnd?: pulumi.Input<string>;
    month?: pulumi.Input<string>;
    monthEnd?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    notBefore?: pulumi.Input<string>;
    notOnOrAfter?: pulumi.Input<string>;
    realmId: pulumi.Input<string>;
    resourceServerId: pulumi.Input<string>;
    year?: pulumi.Input<string>;
    yearEnd?: pulumi.Input<string>;
}
