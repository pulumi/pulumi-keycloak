// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "../utilities";

/**
 * ## # keycloak.saml.IdentityProvider
 *
 * Allows to create and manage SAML Identity Providers within Keycloak.
 *
 * SAML (Security Assertion Markup Language) identity providers allows to authenticate through a third-party system, using SAML standard.
 *
 * ### Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as keycloak from "@pulumi/keycloak";
 *
 * const realmIdentityProvider = new keycloak.saml.IdentityProvider("realm_identity_provider", {
 *     realm: "my-realm",
 *     alias: "my-idp",
 *     singleSignOnServiceUrl: "https://domain.com/adfs/ls/",
 *     singleLogoutServiceUrl: "https://domain.com/adfs/ls/?wa=wsignout1.0",
 *     backchannelSupported: true,
 *     postBindingResponse: true,
 *     postBindingLogout: true,
 *     postBindingAuthnRequest: true,
 *     storeToken: false,
 *     trustEmail: true,
 *     forceAuthn: true,
 * });
 * ```
 *
 * ### Argument Reference
 *
 * The following arguments are supported:
 *
 * - `realm` - (Required) The name of the realm. This is unique across Keycloak.
 * - `alias` - (Optional) The uniq name of identity provider.
 * - `enabled` - (Optional) When false, users and clients will not be able to access this realm. Defaults to `true`.
 * - `displayName` - (Optional) The display name for the realm that is shown when logging in to the admin console.
 * - `storeToken` - (Optional) Enable/disable if tokens must be stored after authenticating users. Defaults to `true`.
 * - `addReadTokenRoleOnCreate` - (Optional) Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role. Defaults to `false`.
 * - `trustEmail` - (Optional) If enabled then email provided by this provider is not verified even if verification is enabled for the realm. Defaults to `false`.
 * - `linkOnly` - (Optional) If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't want to allow login from the provider, but want to integrate with a provider. Defaults to `false`.
 * - `hideOnLoginPage` - (Optional) If hidden, then login with this provider is possible only if requested explicitly, e.g. using the 'kc_idp_hint' parameter.
 * - `firstBrokerLoginFlowAlias` - (Optional) Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that there is not yet existing Keycloak account linked with the authenticated identity provider account. Defaults to `first broker login`.
 * - `postBrokerLoginFlowAlias` - (Optional) Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it. Defaults to empty.
 * - `authenticateByDefault` - (Optional) Authenticate users by default. Defaults to `false`.
 *
 * #### SAML Configuration
 *
 * - `singleSignOnServiceUrl` - (Optional) The Url that must be used to send authentication requests (SAML AuthnRequest).
 * - `singleLogoutServiceUrl` - (Optional) The Url that must be used to send logout requests.
 * - `backchannelSupported` - (Optional) Does the external IDP support back-channel logout ?.
 * - `nameIdPolicyFormat` - (Optional) Specifies the URI reference corresponding to a name identifier format. Defaults to empty.
 * - `postBindingResponse` - (Optional) Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used..
 * - `postBindingAuthnRequest` - (Optional) Indicates whether the AuthnRequest must be sent using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.
 * - `postBindingLogout` - (Optional) Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.
 * - `wantAssertionsSigned` - (Optional) Indicates whether this service provider expects a signed Assertion.
 * - `wantAssertionsEncrypted` - (Optional) Indicates whether this service provider expects an encrypted Assertion.
 * - `forceAuthn` - (Optional) Indicates whether the identity provider must authenticate the presenter directly rather than rely on a previous security context.
 * - `validateSignature` - (Optional) Enable/disable signature validation of SAML responses.
 * - `signingCertificate` - (Optional) Signing Certificate.
 * - `signatureAlgorithm` - (Optional) Signing Algorithm. Defaults to empty.
 * - `xmlSignKeyInfoKeyNameTransformer` - (Optional) Sign Key Transformer. Defaults to empty.
 *
 * ### Import
 *
 * Identity providers can be imported using the format `{{realm_id}}/{{idp_alias}}`, where `idpAlias` is the identity provider alias.
 *
 * Example:
 */
export class IdentityProvider extends pulumi.CustomResource {
    /**
     * Get an existing IdentityProvider resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: IdentityProviderState, opts?: pulumi.CustomResourceOptions): IdentityProvider {
        return new IdentityProvider(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'keycloak:saml/identityProvider:IdentityProvider';

    /**
     * Returns true if the given object is an instance of IdentityProvider.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is IdentityProvider {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === IdentityProvider.__pulumiType;
    }

    /**
     * Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.
     */
    public readonly addReadTokenRoleOnCreate!: pulumi.Output<boolean | undefined>;
    /**
     * The alias uniquely identifies an identity provider and it is also used to build the redirect uri.
     */
    public readonly alias!: pulumi.Output<string>;
    /**
     * Enable/disable authenticate users by default.
     */
    public readonly authenticateByDefault!: pulumi.Output<boolean | undefined>;
    /**
     * AuthnContext ClassRefs
     */
    public readonly authnContextClassRefs!: pulumi.Output<string[] | undefined>;
    /**
     * AuthnContext Comparison
     */
    public readonly authnContextComparisonType!: pulumi.Output<string | undefined>;
    /**
     * AuthnContext DeclRefs
     */
    public readonly authnContextDeclRefs!: pulumi.Output<string[] | undefined>;
    /**
     * Does the external IDP support backchannel logout?
     */
    public readonly backchannelSupported!: pulumi.Output<boolean | undefined>;
    /**
     * Friendly name for Identity Providers.
     */
    public readonly displayName!: pulumi.Output<string | undefined>;
    /**
     * Enable/disable this identity provider.
     */
    public readonly enabled!: pulumi.Output<boolean | undefined>;
    /**
     * The Entity ID that will be used to uniquely identify this SAML Service Provider.
     */
    public readonly entityId!: pulumi.Output<string>;
    public readonly extraConfig!: pulumi.Output<{[key: string]: any} | undefined>;
    /**
     * Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means
     * that there is not yet existing Keycloak account linked with the authenticated identity provider account.
     */
    public readonly firstBrokerLoginFlowAlias!: pulumi.Output<string | undefined>;
    /**
     * Require Force Authn.
     */
    public readonly forceAuthn!: pulumi.Output<boolean | undefined>;
    /**
     * GUI Order
     */
    public readonly guiOrder!: pulumi.Output<string | undefined>;
    /**
     * Hide On Login Page.
     */
    public readonly hideOnLoginPage!: pulumi.Output<boolean | undefined>;
    /**
     * Internal Identity Provider Id
     */
    public /*out*/ readonly internalId!: pulumi.Output<string>;
    /**
     * If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't
     * want to allow login from the provider, but want to integrate with a provider
     */
    public readonly linkOnly!: pulumi.Output<boolean | undefined>;
    /**
     * Login Hint.
     */
    public readonly loginHint!: pulumi.Output<string | undefined>;
    /**
     * Name ID Policy Format.
     */
    public readonly nameIdPolicyFormat!: pulumi.Output<string | undefined>;
    /**
     * Post Binding Authn Request.
     */
    public readonly postBindingAuthnRequest!: pulumi.Output<boolean | undefined>;
    /**
     * Post Binding Logout.
     */
    public readonly postBindingLogout!: pulumi.Output<boolean | undefined>;
    /**
     * Post Binding Response.
     */
    public readonly postBindingResponse!: pulumi.Output<boolean | undefined>;
    /**
     * Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want
     * additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if
     * you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that
     * authenticator implementations must assume that user is already set in ClientSession as identity provider already set it.
     */
    public readonly postBrokerLoginFlowAlias!: pulumi.Output<string | undefined>;
    /**
     * Principal Attribute
     */
    public readonly principalAttribute!: pulumi.Output<string | undefined>;
    /**
     * Principal Type
     */
    public readonly principalType!: pulumi.Output<string | undefined>;
    /**
     * provider id, is always saml, unless you have a custom implementation
     */
    public readonly providerId!: pulumi.Output<string | undefined>;
    /**
     * Realm Name
     */
    public readonly realm!: pulumi.Output<string>;
    /**
     * Signing Algorithm.
     */
    public readonly signatureAlgorithm!: pulumi.Output<string | undefined>;
    /**
     * Signing Certificate.
     */
    public readonly signingCertificate!: pulumi.Output<string | undefined>;
    /**
     * Logout URL.
     */
    public readonly singleLogoutServiceUrl!: pulumi.Output<string | undefined>;
    /**
     * SSO Logout URL.
     */
    public readonly singleSignOnServiceUrl!: pulumi.Output<string>;
    /**
     * Enable/disable if tokens must be stored after authenticating users.
     */
    public readonly storeToken!: pulumi.Output<boolean | undefined>;
    /**
     * Sync Mode
     */
    public readonly syncMode!: pulumi.Output<string | undefined>;
    /**
     * If enabled then email provided by this provider is not verified even if verification is enabled for the realm.
     */
    public readonly trustEmail!: pulumi.Output<boolean | undefined>;
    /**
     * Enable/disable signature validation of SAML responses.
     */
    public readonly validateSignature!: pulumi.Output<boolean | undefined>;
    /**
     * Want Assertions Encrypted.
     */
    public readonly wantAssertionsEncrypted!: pulumi.Output<boolean | undefined>;
    /**
     * Want Assertions Signed.
     */
    public readonly wantAssertionsSigned!: pulumi.Output<boolean | undefined>;
    /**
     * Sign Key Transformer.
     */
    public readonly xmlSignKeyInfoKeyNameTransformer!: pulumi.Output<string | undefined>;

    /**
     * Create a IdentityProvider resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: IdentityProviderArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: IdentityProviderArgs | IdentityProviderState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as IdentityProviderState | undefined;
            resourceInputs["addReadTokenRoleOnCreate"] = state ? state.addReadTokenRoleOnCreate : undefined;
            resourceInputs["alias"] = state ? state.alias : undefined;
            resourceInputs["authenticateByDefault"] = state ? state.authenticateByDefault : undefined;
            resourceInputs["authnContextClassRefs"] = state ? state.authnContextClassRefs : undefined;
            resourceInputs["authnContextComparisonType"] = state ? state.authnContextComparisonType : undefined;
            resourceInputs["authnContextDeclRefs"] = state ? state.authnContextDeclRefs : undefined;
            resourceInputs["backchannelSupported"] = state ? state.backchannelSupported : undefined;
            resourceInputs["displayName"] = state ? state.displayName : undefined;
            resourceInputs["enabled"] = state ? state.enabled : undefined;
            resourceInputs["entityId"] = state ? state.entityId : undefined;
            resourceInputs["extraConfig"] = state ? state.extraConfig : undefined;
            resourceInputs["firstBrokerLoginFlowAlias"] = state ? state.firstBrokerLoginFlowAlias : undefined;
            resourceInputs["forceAuthn"] = state ? state.forceAuthn : undefined;
            resourceInputs["guiOrder"] = state ? state.guiOrder : undefined;
            resourceInputs["hideOnLoginPage"] = state ? state.hideOnLoginPage : undefined;
            resourceInputs["internalId"] = state ? state.internalId : undefined;
            resourceInputs["linkOnly"] = state ? state.linkOnly : undefined;
            resourceInputs["loginHint"] = state ? state.loginHint : undefined;
            resourceInputs["nameIdPolicyFormat"] = state ? state.nameIdPolicyFormat : undefined;
            resourceInputs["postBindingAuthnRequest"] = state ? state.postBindingAuthnRequest : undefined;
            resourceInputs["postBindingLogout"] = state ? state.postBindingLogout : undefined;
            resourceInputs["postBindingResponse"] = state ? state.postBindingResponse : undefined;
            resourceInputs["postBrokerLoginFlowAlias"] = state ? state.postBrokerLoginFlowAlias : undefined;
            resourceInputs["principalAttribute"] = state ? state.principalAttribute : undefined;
            resourceInputs["principalType"] = state ? state.principalType : undefined;
            resourceInputs["providerId"] = state ? state.providerId : undefined;
            resourceInputs["realm"] = state ? state.realm : undefined;
            resourceInputs["signatureAlgorithm"] = state ? state.signatureAlgorithm : undefined;
            resourceInputs["signingCertificate"] = state ? state.signingCertificate : undefined;
            resourceInputs["singleLogoutServiceUrl"] = state ? state.singleLogoutServiceUrl : undefined;
            resourceInputs["singleSignOnServiceUrl"] = state ? state.singleSignOnServiceUrl : undefined;
            resourceInputs["storeToken"] = state ? state.storeToken : undefined;
            resourceInputs["syncMode"] = state ? state.syncMode : undefined;
            resourceInputs["trustEmail"] = state ? state.trustEmail : undefined;
            resourceInputs["validateSignature"] = state ? state.validateSignature : undefined;
            resourceInputs["wantAssertionsEncrypted"] = state ? state.wantAssertionsEncrypted : undefined;
            resourceInputs["wantAssertionsSigned"] = state ? state.wantAssertionsSigned : undefined;
            resourceInputs["xmlSignKeyInfoKeyNameTransformer"] = state ? state.xmlSignKeyInfoKeyNameTransformer : undefined;
        } else {
            const args = argsOrState as IdentityProviderArgs | undefined;
            if ((!args || args.alias === undefined) && !opts.urn) {
                throw new Error("Missing required property 'alias'");
            }
            if ((!args || args.entityId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'entityId'");
            }
            if ((!args || args.realm === undefined) && !opts.urn) {
                throw new Error("Missing required property 'realm'");
            }
            if ((!args || args.singleSignOnServiceUrl === undefined) && !opts.urn) {
                throw new Error("Missing required property 'singleSignOnServiceUrl'");
            }
            resourceInputs["addReadTokenRoleOnCreate"] = args ? args.addReadTokenRoleOnCreate : undefined;
            resourceInputs["alias"] = args ? args.alias : undefined;
            resourceInputs["authenticateByDefault"] = args ? args.authenticateByDefault : undefined;
            resourceInputs["authnContextClassRefs"] = args ? args.authnContextClassRefs : undefined;
            resourceInputs["authnContextComparisonType"] = args ? args.authnContextComparisonType : undefined;
            resourceInputs["authnContextDeclRefs"] = args ? args.authnContextDeclRefs : undefined;
            resourceInputs["backchannelSupported"] = args ? args.backchannelSupported : undefined;
            resourceInputs["displayName"] = args ? args.displayName : undefined;
            resourceInputs["enabled"] = args ? args.enabled : undefined;
            resourceInputs["entityId"] = args ? args.entityId : undefined;
            resourceInputs["extraConfig"] = args ? args.extraConfig : undefined;
            resourceInputs["firstBrokerLoginFlowAlias"] = args ? args.firstBrokerLoginFlowAlias : undefined;
            resourceInputs["forceAuthn"] = args ? args.forceAuthn : undefined;
            resourceInputs["guiOrder"] = args ? args.guiOrder : undefined;
            resourceInputs["hideOnLoginPage"] = args ? args.hideOnLoginPage : undefined;
            resourceInputs["linkOnly"] = args ? args.linkOnly : undefined;
            resourceInputs["loginHint"] = args ? args.loginHint : undefined;
            resourceInputs["nameIdPolicyFormat"] = args ? args.nameIdPolicyFormat : undefined;
            resourceInputs["postBindingAuthnRequest"] = args ? args.postBindingAuthnRequest : undefined;
            resourceInputs["postBindingLogout"] = args ? args.postBindingLogout : undefined;
            resourceInputs["postBindingResponse"] = args ? args.postBindingResponse : undefined;
            resourceInputs["postBrokerLoginFlowAlias"] = args ? args.postBrokerLoginFlowAlias : undefined;
            resourceInputs["principalAttribute"] = args ? args.principalAttribute : undefined;
            resourceInputs["principalType"] = args ? args.principalType : undefined;
            resourceInputs["providerId"] = args ? args.providerId : undefined;
            resourceInputs["realm"] = args ? args.realm : undefined;
            resourceInputs["signatureAlgorithm"] = args ? args.signatureAlgorithm : undefined;
            resourceInputs["signingCertificate"] = args ? args.signingCertificate : undefined;
            resourceInputs["singleLogoutServiceUrl"] = args ? args.singleLogoutServiceUrl : undefined;
            resourceInputs["singleSignOnServiceUrl"] = args ? args.singleSignOnServiceUrl : undefined;
            resourceInputs["storeToken"] = args ? args.storeToken : undefined;
            resourceInputs["syncMode"] = args ? args.syncMode : undefined;
            resourceInputs["trustEmail"] = args ? args.trustEmail : undefined;
            resourceInputs["validateSignature"] = args ? args.validateSignature : undefined;
            resourceInputs["wantAssertionsEncrypted"] = args ? args.wantAssertionsEncrypted : undefined;
            resourceInputs["wantAssertionsSigned"] = args ? args.wantAssertionsSigned : undefined;
            resourceInputs["xmlSignKeyInfoKeyNameTransformer"] = args ? args.xmlSignKeyInfoKeyNameTransformer : undefined;
            resourceInputs["internalId"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(IdentityProvider.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering IdentityProvider resources.
 */
export interface IdentityProviderState {
    /**
     * Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.
     */
    addReadTokenRoleOnCreate?: pulumi.Input<boolean>;
    /**
     * The alias uniquely identifies an identity provider and it is also used to build the redirect uri.
     */
    alias?: pulumi.Input<string>;
    /**
     * Enable/disable authenticate users by default.
     */
    authenticateByDefault?: pulumi.Input<boolean>;
    /**
     * AuthnContext ClassRefs
     */
    authnContextClassRefs?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * AuthnContext Comparison
     */
    authnContextComparisonType?: pulumi.Input<string>;
    /**
     * AuthnContext DeclRefs
     */
    authnContextDeclRefs?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Does the external IDP support backchannel logout?
     */
    backchannelSupported?: pulumi.Input<boolean>;
    /**
     * Friendly name for Identity Providers.
     */
    displayName?: pulumi.Input<string>;
    /**
     * Enable/disable this identity provider.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * The Entity ID that will be used to uniquely identify this SAML Service Provider.
     */
    entityId?: pulumi.Input<string>;
    extraConfig?: pulumi.Input<{[key: string]: any}>;
    /**
     * Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means
     * that there is not yet existing Keycloak account linked with the authenticated identity provider account.
     */
    firstBrokerLoginFlowAlias?: pulumi.Input<string>;
    /**
     * Require Force Authn.
     */
    forceAuthn?: pulumi.Input<boolean>;
    /**
     * GUI Order
     */
    guiOrder?: pulumi.Input<string>;
    /**
     * Hide On Login Page.
     */
    hideOnLoginPage?: pulumi.Input<boolean>;
    /**
     * Internal Identity Provider Id
     */
    internalId?: pulumi.Input<string>;
    /**
     * If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't
     * want to allow login from the provider, but want to integrate with a provider
     */
    linkOnly?: pulumi.Input<boolean>;
    /**
     * Login Hint.
     */
    loginHint?: pulumi.Input<string>;
    /**
     * Name ID Policy Format.
     */
    nameIdPolicyFormat?: pulumi.Input<string>;
    /**
     * Post Binding Authn Request.
     */
    postBindingAuthnRequest?: pulumi.Input<boolean>;
    /**
     * Post Binding Logout.
     */
    postBindingLogout?: pulumi.Input<boolean>;
    /**
     * Post Binding Response.
     */
    postBindingResponse?: pulumi.Input<boolean>;
    /**
     * Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want
     * additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if
     * you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that
     * authenticator implementations must assume that user is already set in ClientSession as identity provider already set it.
     */
    postBrokerLoginFlowAlias?: pulumi.Input<string>;
    /**
     * Principal Attribute
     */
    principalAttribute?: pulumi.Input<string>;
    /**
     * Principal Type
     */
    principalType?: pulumi.Input<string>;
    /**
     * provider id, is always saml, unless you have a custom implementation
     */
    providerId?: pulumi.Input<string>;
    /**
     * Realm Name
     */
    realm?: pulumi.Input<string>;
    /**
     * Signing Algorithm.
     */
    signatureAlgorithm?: pulumi.Input<string>;
    /**
     * Signing Certificate.
     */
    signingCertificate?: pulumi.Input<string>;
    /**
     * Logout URL.
     */
    singleLogoutServiceUrl?: pulumi.Input<string>;
    /**
     * SSO Logout URL.
     */
    singleSignOnServiceUrl?: pulumi.Input<string>;
    /**
     * Enable/disable if tokens must be stored after authenticating users.
     */
    storeToken?: pulumi.Input<boolean>;
    /**
     * Sync Mode
     */
    syncMode?: pulumi.Input<string>;
    /**
     * If enabled then email provided by this provider is not verified even if verification is enabled for the realm.
     */
    trustEmail?: pulumi.Input<boolean>;
    /**
     * Enable/disable signature validation of SAML responses.
     */
    validateSignature?: pulumi.Input<boolean>;
    /**
     * Want Assertions Encrypted.
     */
    wantAssertionsEncrypted?: pulumi.Input<boolean>;
    /**
     * Want Assertions Signed.
     */
    wantAssertionsSigned?: pulumi.Input<boolean>;
    /**
     * Sign Key Transformer.
     */
    xmlSignKeyInfoKeyNameTransformer?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a IdentityProvider resource.
 */
export interface IdentityProviderArgs {
    /**
     * Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.
     */
    addReadTokenRoleOnCreate?: pulumi.Input<boolean>;
    /**
     * The alias uniquely identifies an identity provider and it is also used to build the redirect uri.
     */
    alias: pulumi.Input<string>;
    /**
     * Enable/disable authenticate users by default.
     */
    authenticateByDefault?: pulumi.Input<boolean>;
    /**
     * AuthnContext ClassRefs
     */
    authnContextClassRefs?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * AuthnContext Comparison
     */
    authnContextComparisonType?: pulumi.Input<string>;
    /**
     * AuthnContext DeclRefs
     */
    authnContextDeclRefs?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Does the external IDP support backchannel logout?
     */
    backchannelSupported?: pulumi.Input<boolean>;
    /**
     * Friendly name for Identity Providers.
     */
    displayName?: pulumi.Input<string>;
    /**
     * Enable/disable this identity provider.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * The Entity ID that will be used to uniquely identify this SAML Service Provider.
     */
    entityId: pulumi.Input<string>;
    extraConfig?: pulumi.Input<{[key: string]: any}>;
    /**
     * Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means
     * that there is not yet existing Keycloak account linked with the authenticated identity provider account.
     */
    firstBrokerLoginFlowAlias?: pulumi.Input<string>;
    /**
     * Require Force Authn.
     */
    forceAuthn?: pulumi.Input<boolean>;
    /**
     * GUI Order
     */
    guiOrder?: pulumi.Input<string>;
    /**
     * Hide On Login Page.
     */
    hideOnLoginPage?: pulumi.Input<boolean>;
    /**
     * If true, users cannot log in through this provider. They can only link to this provider. This is useful if you don't
     * want to allow login from the provider, but want to integrate with a provider
     */
    linkOnly?: pulumi.Input<boolean>;
    /**
     * Login Hint.
     */
    loginHint?: pulumi.Input<string>;
    /**
     * Name ID Policy Format.
     */
    nameIdPolicyFormat?: pulumi.Input<string>;
    /**
     * Post Binding Authn Request.
     */
    postBindingAuthnRequest?: pulumi.Input<boolean>;
    /**
     * Post Binding Logout.
     */
    postBindingLogout?: pulumi.Input<boolean>;
    /**
     * Post Binding Response.
     */
    postBindingResponse?: pulumi.Input<boolean>;
    /**
     * Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want
     * additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if
     * you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that
     * authenticator implementations must assume that user is already set in ClientSession as identity provider already set it.
     */
    postBrokerLoginFlowAlias?: pulumi.Input<string>;
    /**
     * Principal Attribute
     */
    principalAttribute?: pulumi.Input<string>;
    /**
     * Principal Type
     */
    principalType?: pulumi.Input<string>;
    /**
     * provider id, is always saml, unless you have a custom implementation
     */
    providerId?: pulumi.Input<string>;
    /**
     * Realm Name
     */
    realm: pulumi.Input<string>;
    /**
     * Signing Algorithm.
     */
    signatureAlgorithm?: pulumi.Input<string>;
    /**
     * Signing Certificate.
     */
    signingCertificate?: pulumi.Input<string>;
    /**
     * Logout URL.
     */
    singleLogoutServiceUrl?: pulumi.Input<string>;
    /**
     * SSO Logout URL.
     */
    singleSignOnServiceUrl: pulumi.Input<string>;
    /**
     * Enable/disable if tokens must be stored after authenticating users.
     */
    storeToken?: pulumi.Input<boolean>;
    /**
     * Sync Mode
     */
    syncMode?: pulumi.Input<string>;
    /**
     * If enabled then email provided by this provider is not verified even if verification is enabled for the realm.
     */
    trustEmail?: pulumi.Input<boolean>;
    /**
     * Enable/disable signature validation of SAML responses.
     */
    validateSignature?: pulumi.Input<boolean>;
    /**
     * Want Assertions Encrypted.
     */
    wantAssertionsEncrypted?: pulumi.Input<boolean>;
    /**
     * Want Assertions Signed.
     */
    wantAssertionsSigned?: pulumi.Input<boolean>;
    /**
     * Sign Key Transformer.
     */
    xmlSignKeyInfoKeyNameTransformer?: pulumi.Input<string>;
}
