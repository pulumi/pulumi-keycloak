# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'GroupPermissionsManageMembersScope',
    'GroupPermissionsManageMembershipScope',
    'GroupPermissionsManageScope',
    'GroupPermissionsViewMembersScope',
    'GroupPermissionsViewScope',
    'OrganizationDomain',
    'RealmClientPolicyProfileExecutor',
    'RealmClientPolicyProfilePolicyCondition',
    'RealmInternationalization',
    'RealmOtpPolicy',
    'RealmSecurityDefenses',
    'RealmSecurityDefensesBruteForceDetection',
    'RealmSecurityDefensesHeaders',
    'RealmSmtpServer',
    'RealmSmtpServerAuth',
    'RealmUserProfileAttribute',
    'RealmUserProfileAttributePermissions',
    'RealmUserProfileAttributeValidator',
    'RealmUserProfileGroup',
    'RealmWebAuthnPasswordlessPolicy',
    'RealmWebAuthnPolicy',
    'UserFederatedIdentity',
    'UserInitialPassword',
    'UsersPermissionsImpersonateScope',
    'UsersPermissionsManageGroupMembershipScope',
    'UsersPermissionsManageScope',
    'UsersPermissionsMapRolesScope',
    'UsersPermissionsUserImpersonatedScope',
    'UsersPermissionsViewScope',
    'GetClientDescriptionConverterProtocolMapperResult',
    'GetOrganizationDomainResult',
    'GetRealmInternationalizationResult',
    'GetRealmKeysKeyResult',
    'GetRealmOtpPolicyResult',
    'GetRealmSecurityDefenseResult',
    'GetRealmSecurityDefenseBruteForceDetectionResult',
    'GetRealmSecurityDefenseHeaderResult',
    'GetRealmSmtpServerResult',
    'GetRealmSmtpServerAuthResult',
    'GetRealmWebAuthnPasswordlessPolicyResult',
    'GetRealmWebAuthnPolicyResult',
]

@pulumi.output_type
class GroupPermissionsManageMembersScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decisionStrategy":
            suggest = "decision_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPermissionsManageMembersScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPermissionsManageMembersScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPermissionsManageMembersScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decision_strategy: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 policies: Optional[Sequence[builtins.str]] = None):
        if decision_strategy is not None:
            pulumi.set(__self__, "decision_strategy", decision_strategy)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[builtins.str]:
        return pulumi.get(self, "decision_strategy")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "policies")


@pulumi.output_type
class GroupPermissionsManageMembershipScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decisionStrategy":
            suggest = "decision_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPermissionsManageMembershipScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPermissionsManageMembershipScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPermissionsManageMembershipScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decision_strategy: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 policies: Optional[Sequence[builtins.str]] = None):
        if decision_strategy is not None:
            pulumi.set(__self__, "decision_strategy", decision_strategy)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[builtins.str]:
        return pulumi.get(self, "decision_strategy")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "policies")


@pulumi.output_type
class GroupPermissionsManageScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decisionStrategy":
            suggest = "decision_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPermissionsManageScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPermissionsManageScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPermissionsManageScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decision_strategy: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 policies: Optional[Sequence[builtins.str]] = None):
        if decision_strategy is not None:
            pulumi.set(__self__, "decision_strategy", decision_strategy)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[builtins.str]:
        return pulumi.get(self, "decision_strategy")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "policies")


@pulumi.output_type
class GroupPermissionsViewMembersScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decisionStrategy":
            suggest = "decision_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPermissionsViewMembersScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPermissionsViewMembersScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPermissionsViewMembersScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decision_strategy: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 policies: Optional[Sequence[builtins.str]] = None):
        if decision_strategy is not None:
            pulumi.set(__self__, "decision_strategy", decision_strategy)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[builtins.str]:
        return pulumi.get(self, "decision_strategy")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "policies")


@pulumi.output_type
class GroupPermissionsViewScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decisionStrategy":
            suggest = "decision_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupPermissionsViewScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupPermissionsViewScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupPermissionsViewScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decision_strategy: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 policies: Optional[Sequence[builtins.str]] = None):
        if decision_strategy is not None:
            pulumi.set(__self__, "decision_strategy", decision_strategy)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[builtins.str]:
        return pulumi.get(self, "decision_strategy")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "policies")


@pulumi.output_type
class OrganizationDomain(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 verified: Optional[builtins.bool] = None):
        """
        :param builtins.str name: The name of the organization.
        :param builtins.bool verified: Whether domain is verified or not. Default is false.
        """
        pulumi.set(__self__, "name", name)
        if verified is not None:
            pulumi.set(__self__, "verified", verified)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def verified(self) -> Optional[builtins.bool]:
        """
        Whether domain is verified or not. Default is false.
        """
        return pulumi.get(self, "verified")


@pulumi.output_type
class RealmClientPolicyProfileExecutor(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 configuration: Optional[Mapping[str, builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def configuration(self) -> Optional[Mapping[str, builtins.str]]:
        return pulumi.get(self, "configuration")


@pulumi.output_type
class RealmClientPolicyProfilePolicyCondition(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 configuration: Optional[Mapping[str, builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def configuration(self) -> Optional[Mapping[str, builtins.str]]:
        return pulumi.get(self, "configuration")


@pulumi.output_type
class RealmInternationalization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultLocale":
            suggest = "default_locale"
        elif key == "supportedLocales":
            suggest = "supported_locales"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RealmInternationalization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RealmInternationalization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RealmInternationalization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_locale: builtins.str,
                 supported_locales: Sequence[builtins.str]):
        """
        :param builtins.str default_locale: The locale to use by default. This locale code must be present within the `supported_locales` list.
        :param Sequence[builtins.str] supported_locales: A list of [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) locale codes that the realm should support.
        """
        pulumi.set(__self__, "default_locale", default_locale)
        pulumi.set(__self__, "supported_locales", supported_locales)

    @property
    @pulumi.getter(name="defaultLocale")
    def default_locale(self) -> builtins.str:
        """
        The locale to use by default. This locale code must be present within the `supported_locales` list.
        """
        return pulumi.get(self, "default_locale")

    @property
    @pulumi.getter(name="supportedLocales")
    def supported_locales(self) -> Sequence[builtins.str]:
        """
        A list of [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) locale codes that the realm should support.
        """
        return pulumi.get(self, "supported_locales")


@pulumi.output_type
class RealmOtpPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialCounter":
            suggest = "initial_counter"
        elif key == "lookAheadWindow":
            suggest = "look_ahead_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RealmOtpPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RealmOtpPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RealmOtpPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: Optional[builtins.str] = None,
                 digits: Optional[builtins.int] = None,
                 initial_counter: Optional[builtins.int] = None,
                 look_ahead_window: Optional[builtins.int] = None,
                 period: Optional[builtins.int] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str algorithm: What hashing algorithm should be used to generate the OTP, Valid options are `HmacSHA1`,`HmacSHA256` and `HmacSHA512`. Defaults to `HmacSHA1`.
        :param builtins.int digits: How many digits the OTP have. Defaults to `6`.
        :param builtins.int initial_counter: What should the initial counter value be. Defaults to `2`.
        :param builtins.int look_ahead_window: How far ahead should the server look just in case the token generator and server are out of time sync or counter sync. Defaults to `1`.
        :param builtins.int period: How many seconds should an OTP token be valid. Defaults to `30`.
        :param builtins.str type: One Time Password Type, supported Values are `totp` for Time-Based One Time Password and `hotp` for Counter Based. Defaults to `totp`.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if digits is not None:
            pulumi.set(__self__, "digits", digits)
        if initial_counter is not None:
            pulumi.set(__self__, "initial_counter", initial_counter)
        if look_ahead_window is not None:
            pulumi.set(__self__, "look_ahead_window", look_ahead_window)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[builtins.str]:
        """
        What hashing algorithm should be used to generate the OTP, Valid options are `HmacSHA1`,`HmacSHA256` and `HmacSHA512`. Defaults to `HmacSHA1`.
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def digits(self) -> Optional[builtins.int]:
        """
        How many digits the OTP have. Defaults to `6`.
        """
        return pulumi.get(self, "digits")

    @property
    @pulumi.getter(name="initialCounter")
    def initial_counter(self) -> Optional[builtins.int]:
        """
        What should the initial counter value be. Defaults to `2`.
        """
        return pulumi.get(self, "initial_counter")

    @property
    @pulumi.getter(name="lookAheadWindow")
    def look_ahead_window(self) -> Optional[builtins.int]:
        """
        How far ahead should the server look just in case the token generator and server are out of time sync or counter sync. Defaults to `1`.
        """
        return pulumi.get(self, "look_ahead_window")

    @property
    @pulumi.getter
    def period(self) -> Optional[builtins.int]:
        """
        How many seconds should an OTP token be valid. Defaults to `30`.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        One Time Password Type, supported Values are `totp` for Time-Based One Time Password and `hotp` for Counter Based. Defaults to `totp`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RealmSecurityDefenses(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bruteForceDetection":
            suggest = "brute_force_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RealmSecurityDefenses. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RealmSecurityDefenses.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RealmSecurityDefenses.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 brute_force_detection: Optional['outputs.RealmSecurityDefensesBruteForceDetection'] = None,
                 headers: Optional['outputs.RealmSecurityDefensesHeaders'] = None):
        if brute_force_detection is not None:
            pulumi.set(__self__, "brute_force_detection", brute_force_detection)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter(name="bruteForceDetection")
    def brute_force_detection(self) -> Optional['outputs.RealmSecurityDefensesBruteForceDetection']:
        return pulumi.get(self, "brute_force_detection")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.RealmSecurityDefensesHeaders']:
        return pulumi.get(self, "headers")


@pulumi.output_type
class RealmSecurityDefensesBruteForceDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureResetTimeSeconds":
            suggest = "failure_reset_time_seconds"
        elif key == "maxFailureWaitSeconds":
            suggest = "max_failure_wait_seconds"
        elif key == "maxLoginFailures":
            suggest = "max_login_failures"
        elif key == "minimumQuickLoginWaitSeconds":
            suggest = "minimum_quick_login_wait_seconds"
        elif key == "permanentLockout":
            suggest = "permanent_lockout"
        elif key == "quickLoginCheckMilliSeconds":
            suggest = "quick_login_check_milli_seconds"
        elif key == "waitIncrementSeconds":
            suggest = "wait_increment_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RealmSecurityDefensesBruteForceDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RealmSecurityDefensesBruteForceDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RealmSecurityDefensesBruteForceDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_reset_time_seconds: Optional[builtins.int] = None,
                 max_failure_wait_seconds: Optional[builtins.int] = None,
                 max_login_failures: Optional[builtins.int] = None,
                 minimum_quick_login_wait_seconds: Optional[builtins.int] = None,
                 permanent_lockout: Optional[builtins.bool] = None,
                 quick_login_check_milli_seconds: Optional[builtins.int] = None,
                 wait_increment_seconds: Optional[builtins.int] = None):
        """
        :param builtins.int failure_reset_time_seconds: When will failure count be reset?
        :param builtins.int max_login_failures: How many failures before wait is triggered.
        :param builtins.int minimum_quick_login_wait_seconds: How long to wait after a quick login failure.
               - `max_failure_wait_seconds ` - (Optional) Max. time a user will be locked out.
        :param builtins.bool permanent_lockout: When `true`, this will lock the user permanently when the user exceeds the maximum login failures.
        :param builtins.int quick_login_check_milli_seconds: Configures the amount of time, in milliseconds, for consecutive failures to lock a user out.
        :param builtins.int wait_increment_seconds: This represents the amount of time a user should be locked out when the login failure threshold has been met.
        """
        if failure_reset_time_seconds is not None:
            pulumi.set(__self__, "failure_reset_time_seconds", failure_reset_time_seconds)
        if max_failure_wait_seconds is not None:
            pulumi.set(__self__, "max_failure_wait_seconds", max_failure_wait_seconds)
        if max_login_failures is not None:
            pulumi.set(__self__, "max_login_failures", max_login_failures)
        if minimum_quick_login_wait_seconds is not None:
            pulumi.set(__self__, "minimum_quick_login_wait_seconds", minimum_quick_login_wait_seconds)
        if permanent_lockout is not None:
            pulumi.set(__self__, "permanent_lockout", permanent_lockout)
        if quick_login_check_milli_seconds is not None:
            pulumi.set(__self__, "quick_login_check_milli_seconds", quick_login_check_milli_seconds)
        if wait_increment_seconds is not None:
            pulumi.set(__self__, "wait_increment_seconds", wait_increment_seconds)

    @property
    @pulumi.getter(name="failureResetTimeSeconds")
    def failure_reset_time_seconds(self) -> Optional[builtins.int]:
        """
        When will failure count be reset?
        """
        return pulumi.get(self, "failure_reset_time_seconds")

    @property
    @pulumi.getter(name="maxFailureWaitSeconds")
    def max_failure_wait_seconds(self) -> Optional[builtins.int]:
        return pulumi.get(self, "max_failure_wait_seconds")

    @property
    @pulumi.getter(name="maxLoginFailures")
    def max_login_failures(self) -> Optional[builtins.int]:
        """
        How many failures before wait is triggered.
        """
        return pulumi.get(self, "max_login_failures")

    @property
    @pulumi.getter(name="minimumQuickLoginWaitSeconds")
    def minimum_quick_login_wait_seconds(self) -> Optional[builtins.int]:
        """
        How long to wait after a quick login failure.
        - `max_failure_wait_seconds ` - (Optional) Max. time a user will be locked out.
        """
        return pulumi.get(self, "minimum_quick_login_wait_seconds")

    @property
    @pulumi.getter(name="permanentLockout")
    def permanent_lockout(self) -> Optional[builtins.bool]:
        """
        When `true`, this will lock the user permanently when the user exceeds the maximum login failures.
        """
        return pulumi.get(self, "permanent_lockout")

    @property
    @pulumi.getter(name="quickLoginCheckMilliSeconds")
    def quick_login_check_milli_seconds(self) -> Optional[builtins.int]:
        """
        Configures the amount of time, in milliseconds, for consecutive failures to lock a user out.
        """
        return pulumi.get(self, "quick_login_check_milli_seconds")

    @property
    @pulumi.getter(name="waitIncrementSeconds")
    def wait_increment_seconds(self) -> Optional[builtins.int]:
        """
        This represents the amount of time a user should be locked out when the login failure threshold has been met.
        """
        return pulumi.get(self, "wait_increment_seconds")


@pulumi.output_type
class RealmSecurityDefensesHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentSecurityPolicy":
            suggest = "content_security_policy"
        elif key == "contentSecurityPolicyReportOnly":
            suggest = "content_security_policy_report_only"
        elif key == "referrerPolicy":
            suggest = "referrer_policy"
        elif key == "strictTransportSecurity":
            suggest = "strict_transport_security"
        elif key == "xContentTypeOptions":
            suggest = "x_content_type_options"
        elif key == "xFrameOptions":
            suggest = "x_frame_options"
        elif key == "xRobotsTag":
            suggest = "x_robots_tag"
        elif key == "xXssProtection":
            suggest = "x_xss_protection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RealmSecurityDefensesHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RealmSecurityDefensesHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RealmSecurityDefensesHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_security_policy: Optional[builtins.str] = None,
                 content_security_policy_report_only: Optional[builtins.str] = None,
                 referrer_policy: Optional[builtins.str] = None,
                 strict_transport_security: Optional[builtins.str] = None,
                 x_content_type_options: Optional[builtins.str] = None,
                 x_frame_options: Optional[builtins.str] = None,
                 x_robots_tag: Optional[builtins.str] = None,
                 x_xss_protection: Optional[builtins.str] = None):
        """
        :param builtins.str content_security_policy: Sets the Content Security Policy, which can be used for prevent pages from being included by non-origin iframes. More information can be found in the [W3C-CSP](https://www.w3.org/TR/CSP/) Abstract.
        :param builtins.str content_security_policy_report_only: Used for testing Content Security Policies.
        :param builtins.str referrer_policy: The Referrer-Policy HTTP header controls how much referrer information (sent with the Referer header) should be included with requests.
        :param builtins.str strict_transport_security: The Script-Transport-Security HTTP header tells browsers to always use HTTPS.
        :param builtins.str x_content_type_options: Sets the X-Content-Type-Options, which can be used for prevent MIME-sniffing a response away from the declared content-type
        :param builtins.str x_frame_options: Sets the x-frame-option, which can be used to prevent pages from being included by non-origin iframes. More information can be found in the [RFC7034](https://tools.ietf.org/html/rfc7034)
        :param builtins.str x_robots_tag: Prevent pages from appearing in search engines.
        :param builtins.str x_xss_protection: This header configures the Cross-site scripting (XSS) filter in your browser.
        """
        if content_security_policy is not None:
            pulumi.set(__self__, "content_security_policy", content_security_policy)
        if content_security_policy_report_only is not None:
            pulumi.set(__self__, "content_security_policy_report_only", content_security_policy_report_only)
        if referrer_policy is not None:
            pulumi.set(__self__, "referrer_policy", referrer_policy)
        if strict_transport_security is not None:
            pulumi.set(__self__, "strict_transport_security", strict_transport_security)
        if x_content_type_options is not None:
            pulumi.set(__self__, "x_content_type_options", x_content_type_options)
        if x_frame_options is not None:
            pulumi.set(__self__, "x_frame_options", x_frame_options)
        if x_robots_tag is not None:
            pulumi.set(__self__, "x_robots_tag", x_robots_tag)
        if x_xss_protection is not None:
            pulumi.set(__self__, "x_xss_protection", x_xss_protection)

    @property
    @pulumi.getter(name="contentSecurityPolicy")
    def content_security_policy(self) -> Optional[builtins.str]:
        """
        Sets the Content Security Policy, which can be used for prevent pages from being included by non-origin iframes. More information can be found in the [W3C-CSP](https://www.w3.org/TR/CSP/) Abstract.
        """
        return pulumi.get(self, "content_security_policy")

    @property
    @pulumi.getter(name="contentSecurityPolicyReportOnly")
    def content_security_policy_report_only(self) -> Optional[builtins.str]:
        """
        Used for testing Content Security Policies.
        """
        return pulumi.get(self, "content_security_policy_report_only")

    @property
    @pulumi.getter(name="referrerPolicy")
    def referrer_policy(self) -> Optional[builtins.str]:
        """
        The Referrer-Policy HTTP header controls how much referrer information (sent with the Referer header) should be included with requests.
        """
        return pulumi.get(self, "referrer_policy")

    @property
    @pulumi.getter(name="strictTransportSecurity")
    def strict_transport_security(self) -> Optional[builtins.str]:
        """
        The Script-Transport-Security HTTP header tells browsers to always use HTTPS.
        """
        return pulumi.get(self, "strict_transport_security")

    @property
    @pulumi.getter(name="xContentTypeOptions")
    def x_content_type_options(self) -> Optional[builtins.str]:
        """
        Sets the X-Content-Type-Options, which can be used for prevent MIME-sniffing a response away from the declared content-type
        """
        return pulumi.get(self, "x_content_type_options")

    @property
    @pulumi.getter(name="xFrameOptions")
    def x_frame_options(self) -> Optional[builtins.str]:
        """
        Sets the x-frame-option, which can be used to prevent pages from being included by non-origin iframes. More information can be found in the [RFC7034](https://tools.ietf.org/html/rfc7034)
        """
        return pulumi.get(self, "x_frame_options")

    @property
    @pulumi.getter(name="xRobotsTag")
    def x_robots_tag(self) -> Optional[builtins.str]:
        """
        Prevent pages from appearing in search engines.
        """
        return pulumi.get(self, "x_robots_tag")

    @property
    @pulumi.getter(name="xXssProtection")
    def x_xss_protection(self) -> Optional[builtins.str]:
        """
        This header configures the Cross-site scripting (XSS) filter in your browser.
        """
        return pulumi.get(self, "x_xss_protection")


@pulumi.output_type
class RealmSmtpServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"
        elif key == "envelopeFrom":
            suggest = "envelope_from"
        elif key == "fromDisplayName":
            suggest = "from_display_name"
        elif key == "replyTo":
            suggest = "reply_to"
        elif key == "replyToDisplayName":
            suggest = "reply_to_display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RealmSmtpServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RealmSmtpServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RealmSmtpServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: builtins.str,
                 host: builtins.str,
                 auth: Optional['outputs.RealmSmtpServerAuth'] = None,
                 envelope_from: Optional[builtins.str] = None,
                 from_display_name: Optional[builtins.str] = None,
                 port: Optional[builtins.str] = None,
                 reply_to: Optional[builtins.str] = None,
                 reply_to_display_name: Optional[builtins.str] = None,
                 ssl: Optional[builtins.bool] = None,
                 starttls: Optional[builtins.bool] = None):
        """
        :param builtins.str from_: The email address for the sender.
        :param builtins.str host: The host of the SMTP server.
        :param 'RealmSmtpServerAuthArgs' auth: Enables authentication to the SMTP server.  This block supports the following arguments:
        :param builtins.str envelope_from: The email address uses for bounces.
        :param builtins.str from_display_name: The display name of the sender email address.
        :param builtins.str port: The port of the SMTP server (defaults to 25).
        :param builtins.str reply_to: The "reply to" email address.
        :param builtins.str reply_to_display_name: The display name of the "reply to" email address.
        :param builtins.bool ssl: When `true`, enables SSL. Defaults to `false`.
        :param builtins.bool starttls: When `true`, enables StartTLS. Defaults to `false`.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "host", host)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if envelope_from is not None:
            pulumi.set(__self__, "envelope_from", envelope_from)
        if from_display_name is not None:
            pulumi.set(__self__, "from_display_name", from_display_name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if reply_to is not None:
            pulumi.set(__self__, "reply_to", reply_to)
        if reply_to_display_name is not None:
            pulumi.set(__self__, "reply_to_display_name", reply_to_display_name)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if starttls is not None:
            pulumi.set(__self__, "starttls", starttls)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> builtins.str:
        """
        The email address for the sender.
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def host(self) -> builtins.str:
        """
        The host of the SMTP server.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def auth(self) -> Optional['outputs.RealmSmtpServerAuth']:
        """
        Enables authentication to the SMTP server.  This block supports the following arguments:
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter(name="envelopeFrom")
    def envelope_from(self) -> Optional[builtins.str]:
        """
        The email address uses for bounces.
        """
        return pulumi.get(self, "envelope_from")

    @property
    @pulumi.getter(name="fromDisplayName")
    def from_display_name(self) -> Optional[builtins.str]:
        """
        The display name of the sender email address.
        """
        return pulumi.get(self, "from_display_name")

    @property
    @pulumi.getter
    def port(self) -> Optional[builtins.str]:
        """
        The port of the SMTP server (defaults to 25).
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="replyTo")
    def reply_to(self) -> Optional[builtins.str]:
        """
        The "reply to" email address.
        """
        return pulumi.get(self, "reply_to")

    @property
    @pulumi.getter(name="replyToDisplayName")
    def reply_to_display_name(self) -> Optional[builtins.str]:
        """
        The display name of the "reply to" email address.
        """
        return pulumi.get(self, "reply_to_display_name")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[builtins.bool]:
        """
        When `true`, enables SSL. Defaults to `false`.
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def starttls(self) -> Optional[builtins.bool]:
        """
        When `true`, enables StartTLS. Defaults to `false`.
        """
        return pulumi.get(self, "starttls")


@pulumi.output_type
class RealmSmtpServerAuth(dict):
    def __init__(__self__, *,
                 password: builtins.str,
                 username: builtins.str):
        """
        :param builtins.str password: The SMTP server password.
        :param builtins.str username: The SMTP server username.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> builtins.str:
        """
        The SMTP server password.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> builtins.str:
        """
        The SMTP server username.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class RealmUserProfileAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "enabledWhenScopes":
            suggest = "enabled_when_scopes"
        elif key == "multiValued":
            suggest = "multi_valued"
        elif key == "requiredForRoles":
            suggest = "required_for_roles"
        elif key == "requiredForScopes":
            suggest = "required_for_scopes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RealmUserProfileAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RealmUserProfileAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RealmUserProfileAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 annotations: Optional[Mapping[str, builtins.str]] = None,
                 display_name: Optional[builtins.str] = None,
                 enabled_when_scopes: Optional[Sequence[builtins.str]] = None,
                 group: Optional[builtins.str] = None,
                 multi_valued: Optional[builtins.bool] = None,
                 permissions: Optional['outputs.RealmUserProfileAttributePermissions'] = None,
                 required_for_roles: Optional[Sequence[builtins.str]] = None,
                 required_for_scopes: Optional[Sequence[builtins.str]] = None,
                 validators: Optional[Sequence['outputs.RealmUserProfileAttributeValidator']] = None):
        """
        :param builtins.str display_name: The display name of the attribute.
        :param Sequence[builtins.str] enabled_when_scopes: A list of scopes. The attribute will only be enabled when these scopes are requested by clients.
        :param builtins.str group: A list of groups.
        :param builtins.bool multi_valued: If the attribute supports multiple values. Defaults to `false`.
        :param 'RealmUserProfileAttributePermissionsArgs' permissions: The permissions configuration information.
        :param Sequence[builtins.str] required_for_roles: A list of roles for which the attribute will be required.
        :param Sequence[builtins.str] required_for_scopes: A list of scopes for which the attribute will be required.
        :param Sequence['RealmUserProfileAttributeValidatorArgs'] validators: A list of validators for the attribute.
        """
        pulumi.set(__self__, "name", name)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if enabled_when_scopes is not None:
            pulumi.set(__self__, "enabled_when_scopes", enabled_when_scopes)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if multi_valued is not None:
            pulumi.set(__self__, "multi_valued", multi_valued)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if required_for_roles is not None:
            pulumi.set(__self__, "required_for_roles", required_for_roles)
        if required_for_scopes is not None:
            pulumi.set(__self__, "required_for_scopes", required_for_scopes)
        if validators is not None:
            pulumi.set(__self__, "validators", validators)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, builtins.str]]:
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        The display name of the attribute.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="enabledWhenScopes")
    def enabled_when_scopes(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of scopes. The attribute will only be enabled when these scopes are requested by clients.
        """
        return pulumi.get(self, "enabled_when_scopes")

    @property
    @pulumi.getter
    def group(self) -> Optional[builtins.str]:
        """
        A list of groups.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="multiValued")
    def multi_valued(self) -> Optional[builtins.bool]:
        """
        If the attribute supports multiple values. Defaults to `false`.
        """
        return pulumi.get(self, "multi_valued")

    @property
    @pulumi.getter
    def permissions(self) -> Optional['outputs.RealmUserProfileAttributePermissions']:
        """
        The permissions configuration information.
        """
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter(name="requiredForRoles")
    def required_for_roles(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of roles for which the attribute will be required.
        """
        return pulumi.get(self, "required_for_roles")

    @property
    @pulumi.getter(name="requiredForScopes")
    def required_for_scopes(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of scopes for which the attribute will be required.
        """
        return pulumi.get(self, "required_for_scopes")

    @property
    @pulumi.getter
    def validators(self) -> Optional[Sequence['outputs.RealmUserProfileAttributeValidator']]:
        """
        A list of validators for the attribute.
        """
        return pulumi.get(self, "validators")


@pulumi.output_type
class RealmUserProfileAttributePermissions(dict):
    def __init__(__self__, *,
                 edits: Sequence[builtins.str],
                 views: Sequence[builtins.str]):
        """
        :param Sequence[builtins.str] edits: A list of profiles that will be able to edit the attribute. One of `admin`, `user`.
        :param Sequence[builtins.str] views: A list of profiles that will be able to view the attribute. One of `admin`, `user`.
        """
        pulumi.set(__self__, "edits", edits)
        pulumi.set(__self__, "views", views)

    @property
    @pulumi.getter
    def edits(self) -> Sequence[builtins.str]:
        """
        A list of profiles that will be able to edit the attribute. One of `admin`, `user`.
        """
        return pulumi.get(self, "edits")

    @property
    @pulumi.getter
    def views(self) -> Sequence[builtins.str]:
        """
        A list of profiles that will be able to view the attribute. One of `admin`, `user`.
        """
        return pulumi.get(self, "views")


@pulumi.output_type
class RealmUserProfileAttributeValidator(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 config: Optional[Mapping[str, builtins.str]] = None):
        """
        :param Mapping[str, builtins.str] config: A map defining the configuration of the validator. Values can be a String or a json object.
        """
        pulumi.set(__self__, "name", name)
        if config is not None:
            pulumi.set(__self__, "config", config)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, builtins.str]]:
        """
        A map defining the configuration of the validator. Values can be a String or a json object.
        """
        return pulumi.get(self, "config")


@pulumi.output_type
class RealmUserProfileGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayDescription":
            suggest = "display_description"
        elif key == "displayHeader":
            suggest = "display_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RealmUserProfileGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RealmUserProfileGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RealmUserProfileGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 annotations: Optional[Mapping[str, builtins.str]] = None,
                 display_description: Optional[builtins.str] = None,
                 display_header: Optional[builtins.str] = None):
        """
        :param builtins.str display_description: The display description of the group.
        :param builtins.str display_header: The display header of the group.
        """
        pulumi.set(__self__, "name", name)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if display_description is not None:
            pulumi.set(__self__, "display_description", display_description)
        if display_header is not None:
            pulumi.set(__self__, "display_header", display_header)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, builtins.str]]:
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="displayDescription")
    def display_description(self) -> Optional[builtins.str]:
        """
        The display description of the group.
        """
        return pulumi.get(self, "display_description")

    @property
    @pulumi.getter(name="displayHeader")
    def display_header(self) -> Optional[builtins.str]:
        """
        The display header of the group.
        """
        return pulumi.get(self, "display_header")


@pulumi.output_type
class RealmWebAuthnPasswordlessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptableAaguids":
            suggest = "acceptable_aaguids"
        elif key == "attestationConveyancePreference":
            suggest = "attestation_conveyance_preference"
        elif key == "authenticatorAttachment":
            suggest = "authenticator_attachment"
        elif key == "avoidSameAuthenticatorRegister":
            suggest = "avoid_same_authenticator_register"
        elif key == "createTimeout":
            suggest = "create_timeout"
        elif key == "extraOrigins":
            suggest = "extra_origins"
        elif key == "relyingPartyEntityName":
            suggest = "relying_party_entity_name"
        elif key == "relyingPartyId":
            suggest = "relying_party_id"
        elif key == "requireResidentKey":
            suggest = "require_resident_key"
        elif key == "signatureAlgorithms":
            suggest = "signature_algorithms"
        elif key == "userVerificationRequirement":
            suggest = "user_verification_requirement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RealmWebAuthnPasswordlessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RealmWebAuthnPasswordlessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RealmWebAuthnPasswordlessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acceptable_aaguids: Optional[Sequence[builtins.str]] = None,
                 attestation_conveyance_preference: Optional[builtins.str] = None,
                 authenticator_attachment: Optional[builtins.str] = None,
                 avoid_same_authenticator_register: Optional[builtins.bool] = None,
                 create_timeout: Optional[builtins.int] = None,
                 extra_origins: Optional[Sequence[builtins.str]] = None,
                 relying_party_entity_name: Optional[builtins.str] = None,
                 relying_party_id: Optional[builtins.str] = None,
                 require_resident_key: Optional[builtins.str] = None,
                 signature_algorithms: Optional[Sequence[builtins.str]] = None,
                 user_verification_requirement: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] acceptable_aaguids: A set of AAGUIDs for which an authenticator can be registered.
        :param builtins.str attestation_conveyance_preference: Either none, indirect or direct
        :param builtins.str authenticator_attachment: Either platform or cross-platform
        :param builtins.bool avoid_same_authenticator_register: When `true`, Keycloak will avoid registering the authenticator for WebAuthn if it has already been registered. Defaults to `false`.
        :param builtins.int create_timeout: The timeout value for creating a user's public key credential in seconds. When set to `0`, this timeout option is not adapted. Defaults to `0`.
        :param Sequence[builtins.str] extra_origins: A set of extra origins for non-web applications.
        :param builtins.str relying_party_entity_name: A human-readable server name for the WebAuthn Relying Party. Defaults to `keycloak`.
        :param builtins.str relying_party_id: The WebAuthn relying party ID.
        :param builtins.str require_resident_key: Either Yes or No
        :param Sequence[builtins.str] signature_algorithms: Keycloak lists ES256, ES384, ES512, RS256, RS384, RS512, RS1 at the time of writing
        :param builtins.str user_verification_requirement: Either required, preferred or discouraged
        """
        if acceptable_aaguids is not None:
            pulumi.set(__self__, "acceptable_aaguids", acceptable_aaguids)
        if attestation_conveyance_preference is not None:
            pulumi.set(__self__, "attestation_conveyance_preference", attestation_conveyance_preference)
        if authenticator_attachment is not None:
            pulumi.set(__self__, "authenticator_attachment", authenticator_attachment)
        if avoid_same_authenticator_register is not None:
            pulumi.set(__self__, "avoid_same_authenticator_register", avoid_same_authenticator_register)
        if create_timeout is not None:
            pulumi.set(__self__, "create_timeout", create_timeout)
        if extra_origins is not None:
            pulumi.set(__self__, "extra_origins", extra_origins)
        if relying_party_entity_name is not None:
            pulumi.set(__self__, "relying_party_entity_name", relying_party_entity_name)
        if relying_party_id is not None:
            pulumi.set(__self__, "relying_party_id", relying_party_id)
        if require_resident_key is not None:
            pulumi.set(__self__, "require_resident_key", require_resident_key)
        if signature_algorithms is not None:
            pulumi.set(__self__, "signature_algorithms", signature_algorithms)
        if user_verification_requirement is not None:
            pulumi.set(__self__, "user_verification_requirement", user_verification_requirement)

    @property
    @pulumi.getter(name="acceptableAaguids")
    def acceptable_aaguids(self) -> Optional[Sequence[builtins.str]]:
        """
        A set of AAGUIDs for which an authenticator can be registered.
        """
        return pulumi.get(self, "acceptable_aaguids")

    @property
    @pulumi.getter(name="attestationConveyancePreference")
    def attestation_conveyance_preference(self) -> Optional[builtins.str]:
        """
        Either none, indirect or direct
        """
        return pulumi.get(self, "attestation_conveyance_preference")

    @property
    @pulumi.getter(name="authenticatorAttachment")
    def authenticator_attachment(self) -> Optional[builtins.str]:
        """
        Either platform or cross-platform
        """
        return pulumi.get(self, "authenticator_attachment")

    @property
    @pulumi.getter(name="avoidSameAuthenticatorRegister")
    def avoid_same_authenticator_register(self) -> Optional[builtins.bool]:
        """
        When `true`, Keycloak will avoid registering the authenticator for WebAuthn if it has already been registered. Defaults to `false`.
        """
        return pulumi.get(self, "avoid_same_authenticator_register")

    @property
    @pulumi.getter(name="createTimeout")
    def create_timeout(self) -> Optional[builtins.int]:
        """
        The timeout value for creating a user's public key credential in seconds. When set to `0`, this timeout option is not adapted. Defaults to `0`.
        """
        return pulumi.get(self, "create_timeout")

    @property
    @pulumi.getter(name="extraOrigins")
    def extra_origins(self) -> Optional[Sequence[builtins.str]]:
        """
        A set of extra origins for non-web applications.
        """
        return pulumi.get(self, "extra_origins")

    @property
    @pulumi.getter(name="relyingPartyEntityName")
    def relying_party_entity_name(self) -> Optional[builtins.str]:
        """
        A human-readable server name for the WebAuthn Relying Party. Defaults to `keycloak`.
        """
        return pulumi.get(self, "relying_party_entity_name")

    @property
    @pulumi.getter(name="relyingPartyId")
    def relying_party_id(self) -> Optional[builtins.str]:
        """
        The WebAuthn relying party ID.
        """
        return pulumi.get(self, "relying_party_id")

    @property
    @pulumi.getter(name="requireResidentKey")
    def require_resident_key(self) -> Optional[builtins.str]:
        """
        Either Yes or No
        """
        return pulumi.get(self, "require_resident_key")

    @property
    @pulumi.getter(name="signatureAlgorithms")
    def signature_algorithms(self) -> Optional[Sequence[builtins.str]]:
        """
        Keycloak lists ES256, ES384, ES512, RS256, RS384, RS512, RS1 at the time of writing
        """
        return pulumi.get(self, "signature_algorithms")

    @property
    @pulumi.getter(name="userVerificationRequirement")
    def user_verification_requirement(self) -> Optional[builtins.str]:
        """
        Either required, preferred or discouraged
        """
        return pulumi.get(self, "user_verification_requirement")


@pulumi.output_type
class RealmWebAuthnPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptableAaguids":
            suggest = "acceptable_aaguids"
        elif key == "attestationConveyancePreference":
            suggest = "attestation_conveyance_preference"
        elif key == "authenticatorAttachment":
            suggest = "authenticator_attachment"
        elif key == "avoidSameAuthenticatorRegister":
            suggest = "avoid_same_authenticator_register"
        elif key == "createTimeout":
            suggest = "create_timeout"
        elif key == "extraOrigins":
            suggest = "extra_origins"
        elif key == "relyingPartyEntityName":
            suggest = "relying_party_entity_name"
        elif key == "relyingPartyId":
            suggest = "relying_party_id"
        elif key == "requireResidentKey":
            suggest = "require_resident_key"
        elif key == "signatureAlgorithms":
            suggest = "signature_algorithms"
        elif key == "userVerificationRequirement":
            suggest = "user_verification_requirement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RealmWebAuthnPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RealmWebAuthnPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RealmWebAuthnPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acceptable_aaguids: Optional[Sequence[builtins.str]] = None,
                 attestation_conveyance_preference: Optional[builtins.str] = None,
                 authenticator_attachment: Optional[builtins.str] = None,
                 avoid_same_authenticator_register: Optional[builtins.bool] = None,
                 create_timeout: Optional[builtins.int] = None,
                 extra_origins: Optional[Sequence[builtins.str]] = None,
                 relying_party_entity_name: Optional[builtins.str] = None,
                 relying_party_id: Optional[builtins.str] = None,
                 require_resident_key: Optional[builtins.str] = None,
                 signature_algorithms: Optional[Sequence[builtins.str]] = None,
                 user_verification_requirement: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] acceptable_aaguids: A set of AAGUIDs for which an authenticator can be registered.
        :param builtins.str attestation_conveyance_preference: Either none, indirect or direct
        :param builtins.str authenticator_attachment: Either platform or cross-platform
        :param builtins.bool avoid_same_authenticator_register: When `true`, Keycloak will avoid registering the authenticator for WebAuthn if it has already been registered. Defaults to `false`.
        :param builtins.int create_timeout: The timeout value for creating a user's public key credential in seconds. When set to `0`, this timeout option is not adapted. Defaults to `0`.
        :param Sequence[builtins.str] extra_origins: A set of extra origins for non-web applications.
        :param builtins.str relying_party_entity_name: A human-readable server name for the WebAuthn Relying Party. Defaults to `keycloak`.
        :param builtins.str relying_party_id: The WebAuthn relying party ID.
        :param builtins.str require_resident_key: Either Yes or No
        :param Sequence[builtins.str] signature_algorithms: Keycloak lists ES256, ES384, ES512, RS256, RS384, RS512, RS1 at the time of writing
        :param builtins.str user_verification_requirement: Either required, preferred or discouraged
        """
        if acceptable_aaguids is not None:
            pulumi.set(__self__, "acceptable_aaguids", acceptable_aaguids)
        if attestation_conveyance_preference is not None:
            pulumi.set(__self__, "attestation_conveyance_preference", attestation_conveyance_preference)
        if authenticator_attachment is not None:
            pulumi.set(__self__, "authenticator_attachment", authenticator_attachment)
        if avoid_same_authenticator_register is not None:
            pulumi.set(__self__, "avoid_same_authenticator_register", avoid_same_authenticator_register)
        if create_timeout is not None:
            pulumi.set(__self__, "create_timeout", create_timeout)
        if extra_origins is not None:
            pulumi.set(__self__, "extra_origins", extra_origins)
        if relying_party_entity_name is not None:
            pulumi.set(__self__, "relying_party_entity_name", relying_party_entity_name)
        if relying_party_id is not None:
            pulumi.set(__self__, "relying_party_id", relying_party_id)
        if require_resident_key is not None:
            pulumi.set(__self__, "require_resident_key", require_resident_key)
        if signature_algorithms is not None:
            pulumi.set(__self__, "signature_algorithms", signature_algorithms)
        if user_verification_requirement is not None:
            pulumi.set(__self__, "user_verification_requirement", user_verification_requirement)

    @property
    @pulumi.getter(name="acceptableAaguids")
    def acceptable_aaguids(self) -> Optional[Sequence[builtins.str]]:
        """
        A set of AAGUIDs for which an authenticator can be registered.
        """
        return pulumi.get(self, "acceptable_aaguids")

    @property
    @pulumi.getter(name="attestationConveyancePreference")
    def attestation_conveyance_preference(self) -> Optional[builtins.str]:
        """
        Either none, indirect or direct
        """
        return pulumi.get(self, "attestation_conveyance_preference")

    @property
    @pulumi.getter(name="authenticatorAttachment")
    def authenticator_attachment(self) -> Optional[builtins.str]:
        """
        Either platform or cross-platform
        """
        return pulumi.get(self, "authenticator_attachment")

    @property
    @pulumi.getter(name="avoidSameAuthenticatorRegister")
    def avoid_same_authenticator_register(self) -> Optional[builtins.bool]:
        """
        When `true`, Keycloak will avoid registering the authenticator for WebAuthn if it has already been registered. Defaults to `false`.
        """
        return pulumi.get(self, "avoid_same_authenticator_register")

    @property
    @pulumi.getter(name="createTimeout")
    def create_timeout(self) -> Optional[builtins.int]:
        """
        The timeout value for creating a user's public key credential in seconds. When set to `0`, this timeout option is not adapted. Defaults to `0`.
        """
        return pulumi.get(self, "create_timeout")

    @property
    @pulumi.getter(name="extraOrigins")
    def extra_origins(self) -> Optional[Sequence[builtins.str]]:
        """
        A set of extra origins for non-web applications.
        """
        return pulumi.get(self, "extra_origins")

    @property
    @pulumi.getter(name="relyingPartyEntityName")
    def relying_party_entity_name(self) -> Optional[builtins.str]:
        """
        A human-readable server name for the WebAuthn Relying Party. Defaults to `keycloak`.
        """
        return pulumi.get(self, "relying_party_entity_name")

    @property
    @pulumi.getter(name="relyingPartyId")
    def relying_party_id(self) -> Optional[builtins.str]:
        """
        The WebAuthn relying party ID.
        """
        return pulumi.get(self, "relying_party_id")

    @property
    @pulumi.getter(name="requireResidentKey")
    def require_resident_key(self) -> Optional[builtins.str]:
        """
        Either Yes or No
        """
        return pulumi.get(self, "require_resident_key")

    @property
    @pulumi.getter(name="signatureAlgorithms")
    def signature_algorithms(self) -> Optional[Sequence[builtins.str]]:
        """
        Keycloak lists ES256, ES384, ES512, RS256, RS384, RS512, RS1 at the time of writing
        """
        return pulumi.get(self, "signature_algorithms")

    @property
    @pulumi.getter(name="userVerificationRequirement")
    def user_verification_requirement(self) -> Optional[builtins.str]:
        """
        Either required, preferred or discouraged
        """
        return pulumi.get(self, "user_verification_requirement")


@pulumi.output_type
class UserFederatedIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityProvider":
            suggest = "identity_provider"
        elif key == "userId":
            suggest = "user_id"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserFederatedIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserFederatedIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserFederatedIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_provider: builtins.str,
                 user_id: builtins.str,
                 user_name: builtins.str):
        """
        :param builtins.str identity_provider: The name of the identity provider
        :param builtins.str user_id: The ID of the user defined in the identity provider
        :param builtins.str user_name: The username of the user defined in the identity provider
        """
        pulumi.set(__self__, "identity_provider", identity_provider)
        pulumi.set(__self__, "user_id", user_id)
        pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="identityProvider")
    def identity_provider(self) -> builtins.str:
        """
        The name of the identity provider
        """
        return pulumi.get(self, "identity_provider")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> builtins.str:
        """
        The ID of the user defined in the identity provider
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> builtins.str:
        """
        The username of the user defined in the identity provider
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class UserInitialPassword(dict):
    def __init__(__self__, *,
                 value: builtins.str,
                 temporary: Optional[builtins.bool] = None):
        """
        :param builtins.str value: The initial password.
        :param builtins.bool temporary: If set to `true`, the initial password is set up for renewal on first use. Default to `false`.
        """
        pulumi.set(__self__, "value", value)
        if temporary is not None:
            pulumi.set(__self__, "temporary", temporary)

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        The initial password.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def temporary(self) -> Optional[builtins.bool]:
        """
        If set to `true`, the initial password is set up for renewal on first use. Default to `false`.
        """
        return pulumi.get(self, "temporary")


@pulumi.output_type
class UsersPermissionsImpersonateScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decisionStrategy":
            suggest = "decision_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UsersPermissionsImpersonateScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UsersPermissionsImpersonateScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UsersPermissionsImpersonateScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decision_strategy: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 policies: Optional[Sequence[builtins.str]] = None):
        if decision_strategy is not None:
            pulumi.set(__self__, "decision_strategy", decision_strategy)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[builtins.str]:
        return pulumi.get(self, "decision_strategy")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "policies")


@pulumi.output_type
class UsersPermissionsManageGroupMembershipScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decisionStrategy":
            suggest = "decision_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UsersPermissionsManageGroupMembershipScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UsersPermissionsManageGroupMembershipScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UsersPermissionsManageGroupMembershipScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decision_strategy: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 policies: Optional[Sequence[builtins.str]] = None):
        if decision_strategy is not None:
            pulumi.set(__self__, "decision_strategy", decision_strategy)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[builtins.str]:
        return pulumi.get(self, "decision_strategy")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "policies")


@pulumi.output_type
class UsersPermissionsManageScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decisionStrategy":
            suggest = "decision_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UsersPermissionsManageScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UsersPermissionsManageScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UsersPermissionsManageScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decision_strategy: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 policies: Optional[Sequence[builtins.str]] = None):
        if decision_strategy is not None:
            pulumi.set(__self__, "decision_strategy", decision_strategy)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[builtins.str]:
        return pulumi.get(self, "decision_strategy")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "policies")


@pulumi.output_type
class UsersPermissionsMapRolesScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decisionStrategy":
            suggest = "decision_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UsersPermissionsMapRolesScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UsersPermissionsMapRolesScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UsersPermissionsMapRolesScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decision_strategy: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 policies: Optional[Sequence[builtins.str]] = None):
        if decision_strategy is not None:
            pulumi.set(__self__, "decision_strategy", decision_strategy)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[builtins.str]:
        return pulumi.get(self, "decision_strategy")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "policies")


@pulumi.output_type
class UsersPermissionsUserImpersonatedScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decisionStrategy":
            suggest = "decision_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UsersPermissionsUserImpersonatedScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UsersPermissionsUserImpersonatedScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UsersPermissionsUserImpersonatedScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decision_strategy: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 policies: Optional[Sequence[builtins.str]] = None):
        if decision_strategy is not None:
            pulumi.set(__self__, "decision_strategy", decision_strategy)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[builtins.str]:
        return pulumi.get(self, "decision_strategy")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "policies")


@pulumi.output_type
class UsersPermissionsViewScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decisionStrategy":
            suggest = "decision_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UsersPermissionsViewScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UsersPermissionsViewScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UsersPermissionsViewScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decision_strategy: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 policies: Optional[Sequence[builtins.str]] = None):
        if decision_strategy is not None:
            pulumi.set(__self__, "decision_strategy", decision_strategy)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[builtins.str]:
        return pulumi.get(self, "decision_strategy")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "policies")


@pulumi.output_type
class GetClientDescriptionConverterProtocolMapperResult(dict):
    def __init__(__self__, *,
                 config: Mapping[str, builtins.str],
                 id: builtins.str,
                 name: builtins.str,
                 protocol: builtins.str,
                 protocol_mapper: builtins.str):
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "protocol_mapper", protocol_mapper)

    @property
    @pulumi.getter
    def config(self) -> Mapping[str, builtins.str]:
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> builtins.str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="protocolMapper")
    def protocol_mapper(self) -> builtins.str:
        return pulumi.get(self, "protocol_mapper")


@pulumi.output_type
class GetOrganizationDomainResult(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 verified: builtins.bool):
        """
        :param builtins.str name: The organization name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "verified", verified)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The organization name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def verified(self) -> builtins.bool:
        return pulumi.get(self, "verified")


@pulumi.output_type
class GetRealmInternationalizationResult(dict):
    def __init__(__self__, *,
                 default_locale: builtins.str,
                 supported_locales: Sequence[builtins.str]):
        pulumi.set(__self__, "default_locale", default_locale)
        pulumi.set(__self__, "supported_locales", supported_locales)

    @property
    @pulumi.getter(name="defaultLocale")
    def default_locale(self) -> builtins.str:
        return pulumi.get(self, "default_locale")

    @property
    @pulumi.getter(name="supportedLocales")
    def supported_locales(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "supported_locales")


@pulumi.output_type
class GetRealmKeysKeyResult(dict):
    def __init__(__self__, *,
                 algorithm: builtins.str,
                 certificate: builtins.str,
                 kid: builtins.str,
                 provider_id: builtins.str,
                 provider_priority: builtins.int,
                 public_key: builtins.str,
                 status: builtins.str,
                 type: builtins.str):
        """
        :param builtins.str algorithm: Key algorithm (string)
        :param builtins.str certificate: Key certificate (string)
        :param builtins.str kid: Key ID (string)
        :param builtins.str provider_id: Key provider ID (string)
        :param builtins.int provider_priority: Key provider priority (int64)
        :param builtins.str public_key: Key public key (string)
        :param builtins.str status: When specified, keys will be filtered by status. The statuses can be any of `ACTIVE`, `DISABLED` and `PASSIVE`.
        :param builtins.str type: Key type (string)
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "kid", kid)
        pulumi.set(__self__, "provider_id", provider_id)
        pulumi.set(__self__, "provider_priority", provider_priority)
        pulumi.set(__self__, "public_key", public_key)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def algorithm(self) -> builtins.str:
        """
        Key algorithm (string)
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def certificate(self) -> builtins.str:
        """
        Key certificate (string)
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def kid(self) -> builtins.str:
        """
        Key ID (string)
        """
        return pulumi.get(self, "kid")

    @property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> builtins.str:
        """
        Key provider ID (string)
        """
        return pulumi.get(self, "provider_id")

    @property
    @pulumi.getter(name="providerPriority")
    def provider_priority(self) -> builtins.int:
        """
        Key provider priority (int64)
        """
        return pulumi.get(self, "provider_priority")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> builtins.str:
        """
        Key public key (string)
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        When specified, keys will be filtered by status. The statuses can be any of `ACTIVE`, `DISABLED` and `PASSIVE`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Key type (string)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRealmOtpPolicyResult(dict):
    def __init__(__self__, *,
                 algorithm: builtins.str,
                 digits: builtins.int,
                 initial_counter: builtins.int,
                 look_ahead_window: builtins.int,
                 period: builtins.int,
                 type: builtins.str):
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "digits", digits)
        pulumi.set(__self__, "initial_counter", initial_counter)
        pulumi.set(__self__, "look_ahead_window", look_ahead_window)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def algorithm(self) -> builtins.str:
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def digits(self) -> builtins.int:
        return pulumi.get(self, "digits")

    @property
    @pulumi.getter(name="initialCounter")
    def initial_counter(self) -> builtins.int:
        return pulumi.get(self, "initial_counter")

    @property
    @pulumi.getter(name="lookAheadWindow")
    def look_ahead_window(self) -> builtins.int:
        return pulumi.get(self, "look_ahead_window")

    @property
    @pulumi.getter
    def period(self) -> builtins.int:
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRealmSecurityDefenseResult(dict):
    def __init__(__self__, *,
                 brute_force_detections: Sequence['outputs.GetRealmSecurityDefenseBruteForceDetectionResult'],
                 headers: Sequence['outputs.GetRealmSecurityDefenseHeaderResult']):
        pulumi.set(__self__, "brute_force_detections", brute_force_detections)
        pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter(name="bruteForceDetections")
    def brute_force_detections(self) -> Sequence['outputs.GetRealmSecurityDefenseBruteForceDetectionResult']:
        return pulumi.get(self, "brute_force_detections")

    @property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.GetRealmSecurityDefenseHeaderResult']:
        return pulumi.get(self, "headers")


@pulumi.output_type
class GetRealmSecurityDefenseBruteForceDetectionResult(dict):
    def __init__(__self__, *,
                 failure_reset_time_seconds: builtins.int,
                 max_failure_wait_seconds: builtins.int,
                 max_login_failures: builtins.int,
                 minimum_quick_login_wait_seconds: builtins.int,
                 permanent_lockout: builtins.bool,
                 quick_login_check_milli_seconds: builtins.int,
                 wait_increment_seconds: builtins.int):
        pulumi.set(__self__, "failure_reset_time_seconds", failure_reset_time_seconds)
        pulumi.set(__self__, "max_failure_wait_seconds", max_failure_wait_seconds)
        pulumi.set(__self__, "max_login_failures", max_login_failures)
        pulumi.set(__self__, "minimum_quick_login_wait_seconds", minimum_quick_login_wait_seconds)
        pulumi.set(__self__, "permanent_lockout", permanent_lockout)
        pulumi.set(__self__, "quick_login_check_milli_seconds", quick_login_check_milli_seconds)
        pulumi.set(__self__, "wait_increment_seconds", wait_increment_seconds)

    @property
    @pulumi.getter(name="failureResetTimeSeconds")
    def failure_reset_time_seconds(self) -> builtins.int:
        return pulumi.get(self, "failure_reset_time_seconds")

    @property
    @pulumi.getter(name="maxFailureWaitSeconds")
    def max_failure_wait_seconds(self) -> builtins.int:
        return pulumi.get(self, "max_failure_wait_seconds")

    @property
    @pulumi.getter(name="maxLoginFailures")
    def max_login_failures(self) -> builtins.int:
        return pulumi.get(self, "max_login_failures")

    @property
    @pulumi.getter(name="minimumQuickLoginWaitSeconds")
    def minimum_quick_login_wait_seconds(self) -> builtins.int:
        return pulumi.get(self, "minimum_quick_login_wait_seconds")

    @property
    @pulumi.getter(name="permanentLockout")
    def permanent_lockout(self) -> builtins.bool:
        return pulumi.get(self, "permanent_lockout")

    @property
    @pulumi.getter(name="quickLoginCheckMilliSeconds")
    def quick_login_check_milli_seconds(self) -> builtins.int:
        return pulumi.get(self, "quick_login_check_milli_seconds")

    @property
    @pulumi.getter(name="waitIncrementSeconds")
    def wait_increment_seconds(self) -> builtins.int:
        return pulumi.get(self, "wait_increment_seconds")


@pulumi.output_type
class GetRealmSecurityDefenseHeaderResult(dict):
    def __init__(__self__, *,
                 content_security_policy: builtins.str,
                 content_security_policy_report_only: builtins.str,
                 referrer_policy: builtins.str,
                 strict_transport_security: builtins.str,
                 x_content_type_options: builtins.str,
                 x_frame_options: builtins.str,
                 x_robots_tag: builtins.str,
                 x_xss_protection: builtins.str):
        pulumi.set(__self__, "content_security_policy", content_security_policy)
        pulumi.set(__self__, "content_security_policy_report_only", content_security_policy_report_only)
        pulumi.set(__self__, "referrer_policy", referrer_policy)
        pulumi.set(__self__, "strict_transport_security", strict_transport_security)
        pulumi.set(__self__, "x_content_type_options", x_content_type_options)
        pulumi.set(__self__, "x_frame_options", x_frame_options)
        pulumi.set(__self__, "x_robots_tag", x_robots_tag)
        pulumi.set(__self__, "x_xss_protection", x_xss_protection)

    @property
    @pulumi.getter(name="contentSecurityPolicy")
    def content_security_policy(self) -> builtins.str:
        return pulumi.get(self, "content_security_policy")

    @property
    @pulumi.getter(name="contentSecurityPolicyReportOnly")
    def content_security_policy_report_only(self) -> builtins.str:
        return pulumi.get(self, "content_security_policy_report_only")

    @property
    @pulumi.getter(name="referrerPolicy")
    def referrer_policy(self) -> builtins.str:
        return pulumi.get(self, "referrer_policy")

    @property
    @pulumi.getter(name="strictTransportSecurity")
    def strict_transport_security(self) -> builtins.str:
        return pulumi.get(self, "strict_transport_security")

    @property
    @pulumi.getter(name="xContentTypeOptions")
    def x_content_type_options(self) -> builtins.str:
        return pulumi.get(self, "x_content_type_options")

    @property
    @pulumi.getter(name="xFrameOptions")
    def x_frame_options(self) -> builtins.str:
        return pulumi.get(self, "x_frame_options")

    @property
    @pulumi.getter(name="xRobotsTag")
    def x_robots_tag(self) -> builtins.str:
        return pulumi.get(self, "x_robots_tag")

    @property
    @pulumi.getter(name="xXssProtection")
    def x_xss_protection(self) -> builtins.str:
        return pulumi.get(self, "x_xss_protection")


@pulumi.output_type
class GetRealmSmtpServerResult(dict):
    def __init__(__self__, *,
                 auths: Sequence['outputs.GetRealmSmtpServerAuthResult'],
                 envelope_from: builtins.str,
                 from_: builtins.str,
                 from_display_name: builtins.str,
                 host: builtins.str,
                 port: builtins.str,
                 reply_to: builtins.str,
                 reply_to_display_name: builtins.str,
                 ssl: builtins.bool,
                 starttls: builtins.bool):
        pulumi.set(__self__, "auths", auths)
        pulumi.set(__self__, "envelope_from", envelope_from)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "from_display_name", from_display_name)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "reply_to", reply_to)
        pulumi.set(__self__, "reply_to_display_name", reply_to_display_name)
        pulumi.set(__self__, "ssl", ssl)
        pulumi.set(__self__, "starttls", starttls)

    @property
    @pulumi.getter
    def auths(self) -> Sequence['outputs.GetRealmSmtpServerAuthResult']:
        return pulumi.get(self, "auths")

    @property
    @pulumi.getter(name="envelopeFrom")
    def envelope_from(self) -> builtins.str:
        return pulumi.get(self, "envelope_from")

    @property
    @pulumi.getter(name="from")
    def from_(self) -> builtins.str:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter(name="fromDisplayName")
    def from_display_name(self) -> builtins.str:
        return pulumi.get(self, "from_display_name")

    @property
    @pulumi.getter
    def host(self) -> builtins.str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> builtins.str:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="replyTo")
    def reply_to(self) -> builtins.str:
        return pulumi.get(self, "reply_to")

    @property
    @pulumi.getter(name="replyToDisplayName")
    def reply_to_display_name(self) -> builtins.str:
        return pulumi.get(self, "reply_to_display_name")

    @property
    @pulumi.getter
    def ssl(self) -> builtins.bool:
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def starttls(self) -> builtins.bool:
        return pulumi.get(self, "starttls")


@pulumi.output_type
class GetRealmSmtpServerAuthResult(dict):
    def __init__(__self__, *,
                 password: builtins.str,
                 username: builtins.str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> builtins.str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetRealmWebAuthnPasswordlessPolicyResult(dict):
    def __init__(__self__, *,
                 acceptable_aaguids: Sequence[builtins.str],
                 attestation_conveyance_preference: builtins.str,
                 authenticator_attachment: builtins.str,
                 avoid_same_authenticator_register: builtins.bool,
                 create_timeout: builtins.int,
                 extra_origins: Sequence[builtins.str],
                 relying_party_entity_name: builtins.str,
                 relying_party_id: builtins.str,
                 require_resident_key: builtins.str,
                 signature_algorithms: Sequence[builtins.str],
                 user_verification_requirement: builtins.str):
        """
        :param builtins.str attestation_conveyance_preference: Either none, indirect or direct
        :param builtins.str authenticator_attachment: Either platform or cross-platform
        :param builtins.str require_resident_key: Either Yes or No
        :param Sequence[builtins.str] signature_algorithms: Keycloak lists ES256, ES384, ES512, RS256, ES384, ES512 at the time of writing
        :param builtins.str user_verification_requirement: Either required, preferred or discouraged
        """
        pulumi.set(__self__, "acceptable_aaguids", acceptable_aaguids)
        pulumi.set(__self__, "attestation_conveyance_preference", attestation_conveyance_preference)
        pulumi.set(__self__, "authenticator_attachment", authenticator_attachment)
        pulumi.set(__self__, "avoid_same_authenticator_register", avoid_same_authenticator_register)
        pulumi.set(__self__, "create_timeout", create_timeout)
        pulumi.set(__self__, "extra_origins", extra_origins)
        pulumi.set(__self__, "relying_party_entity_name", relying_party_entity_name)
        pulumi.set(__self__, "relying_party_id", relying_party_id)
        pulumi.set(__self__, "require_resident_key", require_resident_key)
        pulumi.set(__self__, "signature_algorithms", signature_algorithms)
        pulumi.set(__self__, "user_verification_requirement", user_verification_requirement)

    @property
    @pulumi.getter(name="acceptableAaguids")
    def acceptable_aaguids(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "acceptable_aaguids")

    @property
    @pulumi.getter(name="attestationConveyancePreference")
    def attestation_conveyance_preference(self) -> builtins.str:
        """
        Either none, indirect or direct
        """
        return pulumi.get(self, "attestation_conveyance_preference")

    @property
    @pulumi.getter(name="authenticatorAttachment")
    def authenticator_attachment(self) -> builtins.str:
        """
        Either platform or cross-platform
        """
        return pulumi.get(self, "authenticator_attachment")

    @property
    @pulumi.getter(name="avoidSameAuthenticatorRegister")
    def avoid_same_authenticator_register(self) -> builtins.bool:
        return pulumi.get(self, "avoid_same_authenticator_register")

    @property
    @pulumi.getter(name="createTimeout")
    def create_timeout(self) -> builtins.int:
        return pulumi.get(self, "create_timeout")

    @property
    @pulumi.getter(name="extraOrigins")
    def extra_origins(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "extra_origins")

    @property
    @pulumi.getter(name="relyingPartyEntityName")
    def relying_party_entity_name(self) -> builtins.str:
        return pulumi.get(self, "relying_party_entity_name")

    @property
    @pulumi.getter(name="relyingPartyId")
    def relying_party_id(self) -> builtins.str:
        return pulumi.get(self, "relying_party_id")

    @property
    @pulumi.getter(name="requireResidentKey")
    def require_resident_key(self) -> builtins.str:
        """
        Either Yes or No
        """
        return pulumi.get(self, "require_resident_key")

    @property
    @pulumi.getter(name="signatureAlgorithms")
    def signature_algorithms(self) -> Sequence[builtins.str]:
        """
        Keycloak lists ES256, ES384, ES512, RS256, ES384, ES512 at the time of writing
        """
        return pulumi.get(self, "signature_algorithms")

    @property
    @pulumi.getter(name="userVerificationRequirement")
    def user_verification_requirement(self) -> builtins.str:
        """
        Either required, preferred or discouraged
        """
        return pulumi.get(self, "user_verification_requirement")


@pulumi.output_type
class GetRealmWebAuthnPolicyResult(dict):
    def __init__(__self__, *,
                 acceptable_aaguids: Sequence[builtins.str],
                 attestation_conveyance_preference: builtins.str,
                 authenticator_attachment: builtins.str,
                 avoid_same_authenticator_register: builtins.bool,
                 create_timeout: builtins.int,
                 extra_origins: Sequence[builtins.str],
                 relying_party_entity_name: builtins.str,
                 relying_party_id: builtins.str,
                 require_resident_key: builtins.str,
                 signature_algorithms: Sequence[builtins.str],
                 user_verification_requirement: builtins.str):
        """
        :param builtins.str attestation_conveyance_preference: Either none, indirect or direct
        :param builtins.str authenticator_attachment: Either platform or cross-platform
        :param builtins.str require_resident_key: Either Yes or No
        :param Sequence[builtins.str] signature_algorithms: Keycloak lists ES256, ES384, ES512, RS256, ES384, ES512 at the time of writing
        :param builtins.str user_verification_requirement: Either required, preferred or discouraged
        """
        pulumi.set(__self__, "acceptable_aaguids", acceptable_aaguids)
        pulumi.set(__self__, "attestation_conveyance_preference", attestation_conveyance_preference)
        pulumi.set(__self__, "authenticator_attachment", authenticator_attachment)
        pulumi.set(__self__, "avoid_same_authenticator_register", avoid_same_authenticator_register)
        pulumi.set(__self__, "create_timeout", create_timeout)
        pulumi.set(__self__, "extra_origins", extra_origins)
        pulumi.set(__self__, "relying_party_entity_name", relying_party_entity_name)
        pulumi.set(__self__, "relying_party_id", relying_party_id)
        pulumi.set(__self__, "require_resident_key", require_resident_key)
        pulumi.set(__self__, "signature_algorithms", signature_algorithms)
        pulumi.set(__self__, "user_verification_requirement", user_verification_requirement)

    @property
    @pulumi.getter(name="acceptableAaguids")
    def acceptable_aaguids(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "acceptable_aaguids")

    @property
    @pulumi.getter(name="attestationConveyancePreference")
    def attestation_conveyance_preference(self) -> builtins.str:
        """
        Either none, indirect or direct
        """
        return pulumi.get(self, "attestation_conveyance_preference")

    @property
    @pulumi.getter(name="authenticatorAttachment")
    def authenticator_attachment(self) -> builtins.str:
        """
        Either platform or cross-platform
        """
        return pulumi.get(self, "authenticator_attachment")

    @property
    @pulumi.getter(name="avoidSameAuthenticatorRegister")
    def avoid_same_authenticator_register(self) -> builtins.bool:
        return pulumi.get(self, "avoid_same_authenticator_register")

    @property
    @pulumi.getter(name="createTimeout")
    def create_timeout(self) -> builtins.int:
        return pulumi.get(self, "create_timeout")

    @property
    @pulumi.getter(name="extraOrigins")
    def extra_origins(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "extra_origins")

    @property
    @pulumi.getter(name="relyingPartyEntityName")
    def relying_party_entity_name(self) -> builtins.str:
        return pulumi.get(self, "relying_party_entity_name")

    @property
    @pulumi.getter(name="relyingPartyId")
    def relying_party_id(self) -> builtins.str:
        return pulumi.get(self, "relying_party_id")

    @property
    @pulumi.getter(name="requireResidentKey")
    def require_resident_key(self) -> builtins.str:
        """
        Either Yes or No
        """
        return pulumi.get(self, "require_resident_key")

    @property
    @pulumi.getter(name="signatureAlgorithms")
    def signature_algorithms(self) -> Sequence[builtins.str]:
        """
        Keycloak lists ES256, ES384, ES512, RS256, ES384, ES512 at the time of writing
        """
        return pulumi.get(self, "signature_algorithms")

    @property
    @pulumi.getter(name="userVerificationRequirement")
    def user_verification_requirement(self) -> builtins.str:
        """
        Either required, preferred or discouraged
        """
        return pulumi.get(self, "user_verification_requirement")


