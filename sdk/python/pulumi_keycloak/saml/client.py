# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Mapping, Optional, Tuple, Union
from .. import _utilities, _tables

__all__ = ['Client']


class Client(pulumi.CustomResource):
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 assertion_consumer_post_url: Optional[pulumi.Input[str]] = None,
                 assertion_consumer_redirect_url: Optional[pulumi.Input[str]] = None,
                 base_url: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_signature_required: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 encrypt_assertions: Optional[pulumi.Input[bool]] = None,
                 encryption_certificate: Optional[pulumi.Input[str]] = None,
                 force_name_id_format: Optional[pulumi.Input[bool]] = None,
                 force_post_binding: Optional[pulumi.Input[bool]] = None,
                 front_channel_logout: Optional[pulumi.Input[bool]] = None,
                 full_scope_allowed: Optional[pulumi.Input[bool]] = None,
                 idp_initiated_sso_relay_state: Optional[pulumi.Input[str]] = None,
                 idp_initiated_sso_url_name: Optional[pulumi.Input[str]] = None,
                 include_authn_statement: Optional[pulumi.Input[bool]] = None,
                 logout_service_post_binding_url: Optional[pulumi.Input[str]] = None,
                 logout_service_redirect_binding_url: Optional[pulumi.Input[str]] = None,
                 master_saml_processing_url: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 name_id_format: Optional[pulumi.Input[str]] = None,
                 realm_id: Optional[pulumi.Input[str]] = None,
                 root_url: Optional[pulumi.Input[str]] = None,
                 sign_assertions: Optional[pulumi.Input[bool]] = None,
                 sign_documents: Optional[pulumi.Input[bool]] = None,
                 signature_algorithm: Optional[pulumi.Input[str]] = None,
                 signing_certificate: Optional[pulumi.Input[str]] = None,
                 signing_private_key: Optional[pulumi.Input[str]] = None,
                 valid_redirect_uris: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 __props__=None,
                 __name__=None,
                 __opts__=None):
        """
        ## # saml.Client

        Allows for creating and managing Keycloak clients that use the SAML protocol.

        Clients are entities that can use Keycloak for user authentication. Typically,
        clients are applications that redirect users to Keycloak for authentication
        in order to take advantage of Keycloak's user sessions for SSO.

        ### Example Usage

        ```python
        import pulumi
        import pulumi_keycloak as keycloak

        realm = keycloak.Realm("realm",
            enabled=True,
            realm="my-realm")
        saml_client = keycloak.saml.Client("samlClient",
            client_id="test-saml-client",
            include_authn_statement=True,
            realm_id=realm.id,
            sign_assertions=True,
            sign_documents=False,
            signing_certificate=(lambda path: open(path).read())("saml-cert.pem"),
            signing_private_key=(lambda path: open(path).read())("saml-key.pem"))
        ```

        ### Argument Reference

        The following arguments are supported:

        - `realm_id` - (Required) The realm this client is attached to.
        - `client_id` - (Required) The unique ID of this client, referenced in the URI during authentication and in issued tokens.
        - `name` - (Optional) The display name of this client in the GUI.
        - `enabled` - (Optional) When false, this client will not be able to initiate a login or obtain access tokens. Defaults to `true`.
        - `description` - (Optional) The description of this client in the GUI.
        - `include_authn_statement` - (Optional) When `true`, an `AuthnStatement` will be included in the SAML response.
        - `sign_documents` - (Optional) When `true`, the SAML document will be signed by Keycloak using the realm's private key.
        - `sign_assertions` - (Optional) When `true`, the SAML assertions will be signed by Keycloak using the realm's private key, and embedded within the SAML XML Auth response.
        - `client_signature_required` - (Optional) When `true`, Keycloak will expect that documents originating from a client will be signed using the certificate and/or key configured via `signing_certificate` and `signing_private_key`.
        - `force_post_binding` - (Optional) When `true`, Keycloak will always respond to an authentication request via the SAML POST Binding.
        - `front_channel_logout` - (Optional) When `true`, this client will require a browser redirect in order to perform a logout.
        - `name_id_format` - (Optional) Sets the Name ID format for the subject.
        - `root_url` - (Optional) When specified, this value is prepended to all relative URLs.
        - `valid_redirect_uris` - (Optional) When specified, Keycloak will use this list to validate given Assertion Consumer URLs specified in the authentication request.
        - `base_url` - (Optional) When specified, this URL will be used whenever Keycloak needs to link to this client.
        - `master_saml_processing_url` - (Optional) When specified, this URL will be used for all SAML requests.
        - `signing_certificate` - (Optional) If documents or assertions from the client are signed, this certificate will be used to verify the signature.
        - `signing_private_key` - (Optional) If documents or assertions from the client are signed, this private key will be used to verify the signature.
        - `idp_initiated_sso_url_name` - (Optional) URL fragment name to reference client when you want to do IDP Initiated SSO.
        - `idp_initiated_sso_relay_state` - (Optional) Relay state you want to send with SAML request when you want to do IDP Initiated SSO.
        - `assertion_consumer_post_url` - (Optional) SAML POST Binding URL for the client's assertion consumer service (login responses).
        - `assertion_consumer_redirect_url` - (Optional) SAML Redirect Binding URL for the client's assertion consumer service (login responses).
        - `logout_service_post_binding_url` - (Optional) SAML POST Binding URL for the client's single logout service.
        - `logout_service_redirect_binding_url` - (Optional) SAML Redirect Binding URL for the client's single logout service.
        - `full_scope_allowed` - (Optional) - Allow to include all roles mappings in the access token

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        if __name__ is not None:
            warnings.warn("explicit use of __name__ is deprecated", DeprecationWarning)
            resource_name = __name__
        if __opts__ is not None:
            warnings.warn("explicit use of __opts__ is deprecated, use 'opts' instead", DeprecationWarning)
            opts = __opts__
        if opts is None:
            opts = pulumi.ResourceOptions()
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.version is None:
            opts.version = _utilities.get_version()
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = dict()

            __props__['assertion_consumer_post_url'] = assertion_consumer_post_url
            __props__['assertion_consumer_redirect_url'] = assertion_consumer_redirect_url
            __props__['base_url'] = base_url
            if client_id is None:
                raise TypeError("Missing required property 'client_id'")
            __props__['client_id'] = client_id
            __props__['client_signature_required'] = client_signature_required
            __props__['description'] = description
            __props__['enabled'] = enabled
            __props__['encrypt_assertions'] = encrypt_assertions
            __props__['encryption_certificate'] = encryption_certificate
            __props__['force_name_id_format'] = force_name_id_format
            __props__['force_post_binding'] = force_post_binding
            __props__['front_channel_logout'] = front_channel_logout
            __props__['full_scope_allowed'] = full_scope_allowed
            __props__['idp_initiated_sso_relay_state'] = idp_initiated_sso_relay_state
            __props__['idp_initiated_sso_url_name'] = idp_initiated_sso_url_name
            __props__['include_authn_statement'] = include_authn_statement
            __props__['logout_service_post_binding_url'] = logout_service_post_binding_url
            __props__['logout_service_redirect_binding_url'] = logout_service_redirect_binding_url
            __props__['master_saml_processing_url'] = master_saml_processing_url
            __props__['name'] = name
            __props__['name_id_format'] = name_id_format
            if realm_id is None:
                raise TypeError("Missing required property 'realm_id'")
            __props__['realm_id'] = realm_id
            __props__['root_url'] = root_url
            __props__['sign_assertions'] = sign_assertions
            __props__['sign_documents'] = sign_documents
            __props__['signature_algorithm'] = signature_algorithm
            __props__['signing_certificate'] = signing_certificate
            __props__['signing_private_key'] = signing_private_key
            __props__['valid_redirect_uris'] = valid_redirect_uris
        super(Client, __self__).__init__(
            'keycloak:saml/client:Client',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            assertion_consumer_post_url: Optional[pulumi.Input[str]] = None,
            assertion_consumer_redirect_url: Optional[pulumi.Input[str]] = None,
            base_url: Optional[pulumi.Input[str]] = None,
            client_id: Optional[pulumi.Input[str]] = None,
            client_signature_required: Optional[pulumi.Input[bool]] = None,
            description: Optional[pulumi.Input[str]] = None,
            enabled: Optional[pulumi.Input[bool]] = None,
            encrypt_assertions: Optional[pulumi.Input[bool]] = None,
            encryption_certificate: Optional[pulumi.Input[str]] = None,
            force_name_id_format: Optional[pulumi.Input[bool]] = None,
            force_post_binding: Optional[pulumi.Input[bool]] = None,
            front_channel_logout: Optional[pulumi.Input[bool]] = None,
            full_scope_allowed: Optional[pulumi.Input[bool]] = None,
            idp_initiated_sso_relay_state: Optional[pulumi.Input[str]] = None,
            idp_initiated_sso_url_name: Optional[pulumi.Input[str]] = None,
            include_authn_statement: Optional[pulumi.Input[bool]] = None,
            logout_service_post_binding_url: Optional[pulumi.Input[str]] = None,
            logout_service_redirect_binding_url: Optional[pulumi.Input[str]] = None,
            master_saml_processing_url: Optional[pulumi.Input[str]] = None,
            name: Optional[pulumi.Input[str]] = None,
            name_id_format: Optional[pulumi.Input[str]] = None,
            realm_id: Optional[pulumi.Input[str]] = None,
            root_url: Optional[pulumi.Input[str]] = None,
            sign_assertions: Optional[pulumi.Input[bool]] = None,
            sign_documents: Optional[pulumi.Input[bool]] = None,
            signature_algorithm: Optional[pulumi.Input[str]] = None,
            signing_certificate: Optional[pulumi.Input[str]] = None,
            signing_private_key: Optional[pulumi.Input[str]] = None,
            valid_redirect_uris: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None) -> 'Client':
        """
        Get an existing Client resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = dict()

        __props__["assertion_consumer_post_url"] = assertion_consumer_post_url
        __props__["assertion_consumer_redirect_url"] = assertion_consumer_redirect_url
        __props__["base_url"] = base_url
        __props__["client_id"] = client_id
        __props__["client_signature_required"] = client_signature_required
        __props__["description"] = description
        __props__["enabled"] = enabled
        __props__["encrypt_assertions"] = encrypt_assertions
        __props__["encryption_certificate"] = encryption_certificate
        __props__["force_name_id_format"] = force_name_id_format
        __props__["force_post_binding"] = force_post_binding
        __props__["front_channel_logout"] = front_channel_logout
        __props__["full_scope_allowed"] = full_scope_allowed
        __props__["idp_initiated_sso_relay_state"] = idp_initiated_sso_relay_state
        __props__["idp_initiated_sso_url_name"] = idp_initiated_sso_url_name
        __props__["include_authn_statement"] = include_authn_statement
        __props__["logout_service_post_binding_url"] = logout_service_post_binding_url
        __props__["logout_service_redirect_binding_url"] = logout_service_redirect_binding_url
        __props__["master_saml_processing_url"] = master_saml_processing_url
        __props__["name"] = name
        __props__["name_id_format"] = name_id_format
        __props__["realm_id"] = realm_id
        __props__["root_url"] = root_url
        __props__["sign_assertions"] = sign_assertions
        __props__["sign_documents"] = sign_documents
        __props__["signature_algorithm"] = signature_algorithm
        __props__["signing_certificate"] = signing_certificate
        __props__["signing_private_key"] = signing_private_key
        __props__["valid_redirect_uris"] = valid_redirect_uris
        return Client(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="assertionConsumerPostUrl")
    def assertion_consumer_post_url(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "assertion_consumer_post_url")

    @property
    @pulumi.getter(name="assertionConsumerRedirectUrl")
    def assertion_consumer_redirect_url(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "assertion_consumer_redirect_url")

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "base_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Output[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSignatureRequired")
    def client_signature_required(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "client_signature_required")

    @property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Output[Optional[bool]]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="encryptAssertions")
    def encrypt_assertions(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "encrypt_assertions")

    @property
    @pulumi.getter(name="encryptionCertificate")
    def encryption_certificate(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "encryption_certificate")

    @property
    @pulumi.getter(name="forceNameIdFormat")
    def force_name_id_format(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "force_name_id_format")

    @property
    @pulumi.getter(name="forcePostBinding")
    def force_post_binding(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "force_post_binding")

    @property
    @pulumi.getter(name="frontChannelLogout")
    def front_channel_logout(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "front_channel_logout")

    @property
    @pulumi.getter(name="fullScopeAllowed")
    def full_scope_allowed(self) -> pulumi.Output[Optional[bool]]:
        return pulumi.get(self, "full_scope_allowed")

    @property
    @pulumi.getter(name="idpInitiatedSsoRelayState")
    def idp_initiated_sso_relay_state(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "idp_initiated_sso_relay_state")

    @property
    @pulumi.getter(name="idpInitiatedSsoUrlName")
    def idp_initiated_sso_url_name(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "idp_initiated_sso_url_name")

    @property
    @pulumi.getter(name="includeAuthnStatement")
    def include_authn_statement(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "include_authn_statement")

    @property
    @pulumi.getter(name="logoutServicePostBindingUrl")
    def logout_service_post_binding_url(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "logout_service_post_binding_url")

    @property
    @pulumi.getter(name="logoutServiceRedirectBindingUrl")
    def logout_service_redirect_binding_url(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "logout_service_redirect_binding_url")

    @property
    @pulumi.getter(name="masterSamlProcessingUrl")
    def master_saml_processing_url(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "master_saml_processing_url")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameIdFormat")
    def name_id_format(self) -> pulumi.Output[str]:
        return pulumi.get(self, "name_id_format")

    @property
    @pulumi.getter(name="realmId")
    def realm_id(self) -> pulumi.Output[str]:
        return pulumi.get(self, "realm_id")

    @property
    @pulumi.getter(name="rootUrl")
    def root_url(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "root_url")

    @property
    @pulumi.getter(name="signAssertions")
    def sign_assertions(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "sign_assertions")

    @property
    @pulumi.getter(name="signDocuments")
    def sign_documents(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "sign_documents")

    @property
    @pulumi.getter(name="signatureAlgorithm")
    def signature_algorithm(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "signature_algorithm")

    @property
    @pulumi.getter(name="signingCertificate")
    def signing_certificate(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "signing_certificate")

    @property
    @pulumi.getter(name="signingPrivateKey")
    def signing_private_key(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "signing_private_key")

    @property
    @pulumi.getter(name="validRedirectUris")
    def valid_redirect_uris(self) -> pulumi.Output[Optional[List[str]]]:
        return pulumi.get(self, "valid_redirect_uris")

    def translate_output_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop

    def translate_input_property(self, prop):
        return _tables.SNAKE_TO_CAMEL_CASE_TABLE.get(prop) or prop

