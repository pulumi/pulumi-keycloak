# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'GroupPermissionsManageMembersScopeArgs',
    'GroupPermissionsManageMembershipScopeArgs',
    'GroupPermissionsManageScopeArgs',
    'GroupPermissionsViewMembersScopeArgs',
    'GroupPermissionsViewScopeArgs',
    'RealmInternationalizationArgs',
    'RealmOtpPolicyArgs',
    'RealmSecurityDefensesArgs',
    'RealmSecurityDefensesBruteForceDetectionArgs',
    'RealmSecurityDefensesHeadersArgs',
    'RealmSmtpServerArgs',
    'RealmSmtpServerAuthArgs',
    'RealmUserProfileAttributeArgs',
    'RealmUserProfileAttributePermissionsArgs',
    'RealmUserProfileAttributeValidatorArgs',
    'RealmUserProfileGroupArgs',
    'RealmWebAuthnPasswordlessPolicyArgs',
    'RealmWebAuthnPolicyArgs',
    'UserFederatedIdentityArgs',
    'UserInitialPasswordArgs',
    'UsersPermissionsImpersonateScopeArgs',
    'UsersPermissionsManageGroupMembershipScopeArgs',
    'UsersPermissionsManageScopeArgs',
    'UsersPermissionsMapRolesScopeArgs',
    'UsersPermissionsUserImpersonatedScopeArgs',
    'UsersPermissionsViewScopeArgs',
    'GetRealmInternationalizationArgs',
    'GetRealmOtpPolicyArgs',
    'GetRealmSecurityDefenseArgs',
    'GetRealmSecurityDefenseBruteForceDetectionArgs',
    'GetRealmSecurityDefenseHeaderArgs',
    'GetRealmSmtpServerArgs',
    'GetRealmSmtpServerAuthArgs',
    'GetRealmWebAuthnPasswordlessPolicyArgs',
    'GetRealmWebAuthnPolicyArgs',
]

@pulumi.input_type
class GroupPermissionsManageMembersScopeArgs:
    def __init__(__self__, *,
                 decision_strategy: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        GroupPermissionsManageMembersScopeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decision_strategy=decision_strategy,
            description=description,
            policies=policies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decision_strategy: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if decision_strategy is None and 'decisionStrategy' in kwargs:
            decision_strategy = kwargs['decisionStrategy']

        if decision_strategy is not None:
            _setter("decision_strategy", decision_strategy)
        if description is not None:
            _setter("description", description)
        if policies is not None:
            _setter("policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "decision_strategy")

    @decision_strategy.setter
    def decision_strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "decision_strategy", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)


@pulumi.input_type
class GroupPermissionsManageMembershipScopeArgs:
    def __init__(__self__, *,
                 decision_strategy: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        GroupPermissionsManageMembershipScopeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decision_strategy=decision_strategy,
            description=description,
            policies=policies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decision_strategy: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if decision_strategy is None and 'decisionStrategy' in kwargs:
            decision_strategy = kwargs['decisionStrategy']

        if decision_strategy is not None:
            _setter("decision_strategy", decision_strategy)
        if description is not None:
            _setter("description", description)
        if policies is not None:
            _setter("policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "decision_strategy")

    @decision_strategy.setter
    def decision_strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "decision_strategy", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)


@pulumi.input_type
class GroupPermissionsManageScopeArgs:
    def __init__(__self__, *,
                 decision_strategy: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        GroupPermissionsManageScopeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decision_strategy=decision_strategy,
            description=description,
            policies=policies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decision_strategy: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if decision_strategy is None and 'decisionStrategy' in kwargs:
            decision_strategy = kwargs['decisionStrategy']

        if decision_strategy is not None:
            _setter("decision_strategy", decision_strategy)
        if description is not None:
            _setter("description", description)
        if policies is not None:
            _setter("policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "decision_strategy")

    @decision_strategy.setter
    def decision_strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "decision_strategy", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)


@pulumi.input_type
class GroupPermissionsViewMembersScopeArgs:
    def __init__(__self__, *,
                 decision_strategy: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        GroupPermissionsViewMembersScopeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decision_strategy=decision_strategy,
            description=description,
            policies=policies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decision_strategy: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if decision_strategy is None and 'decisionStrategy' in kwargs:
            decision_strategy = kwargs['decisionStrategy']

        if decision_strategy is not None:
            _setter("decision_strategy", decision_strategy)
        if description is not None:
            _setter("description", description)
        if policies is not None:
            _setter("policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "decision_strategy")

    @decision_strategy.setter
    def decision_strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "decision_strategy", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)


@pulumi.input_type
class GroupPermissionsViewScopeArgs:
    def __init__(__self__, *,
                 decision_strategy: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        GroupPermissionsViewScopeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decision_strategy=decision_strategy,
            description=description,
            policies=policies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decision_strategy: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if decision_strategy is None and 'decisionStrategy' in kwargs:
            decision_strategy = kwargs['decisionStrategy']

        if decision_strategy is not None:
            _setter("decision_strategy", decision_strategy)
        if description is not None:
            _setter("description", description)
        if policies is not None:
            _setter("policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "decision_strategy")

    @decision_strategy.setter
    def decision_strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "decision_strategy", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)


@pulumi.input_type
class RealmInternationalizationArgs:
    def __init__(__self__, *,
                 default_locale: pulumi.Input[str],
                 supported_locales: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] default_locale: The locale to use by default. This locale code must be present within the `supported_locales` list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] supported_locales: A list of [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) locale codes that the realm should support.
        """
        RealmInternationalizationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_locale=default_locale,
            supported_locales=supported_locales,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_locale: Optional[pulumi.Input[str]] = None,
             supported_locales: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_locale is None and 'defaultLocale' in kwargs:
            default_locale = kwargs['defaultLocale']
        if default_locale is None:
            raise TypeError("Missing 'default_locale' argument")
        if supported_locales is None and 'supportedLocales' in kwargs:
            supported_locales = kwargs['supportedLocales']
        if supported_locales is None:
            raise TypeError("Missing 'supported_locales' argument")

        _setter("default_locale", default_locale)
        _setter("supported_locales", supported_locales)

    @property
    @pulumi.getter(name="defaultLocale")
    def default_locale(self) -> pulumi.Input[str]:
        """
        The locale to use by default. This locale code must be present within the `supported_locales` list.
        """
        return pulumi.get(self, "default_locale")

    @default_locale.setter
    def default_locale(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_locale", value)

    @property
    @pulumi.getter(name="supportedLocales")
    def supported_locales(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) locale codes that the realm should support.
        """
        return pulumi.get(self, "supported_locales")

    @supported_locales.setter
    def supported_locales(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "supported_locales", value)


@pulumi.input_type
class RealmOtpPolicyArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[str]] = None,
                 digits: Optional[pulumi.Input[int]] = None,
                 initial_counter: Optional[pulumi.Input[int]] = None,
                 look_ahead_window: Optional[pulumi.Input[int]] = None,
                 period: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] algorithm: What hashing algorithm should be used to generate the OTP, Valid options are `HmacSHA1`,`HmacSHA256` and `HmacSHA512`. Defaults to `HmacSHA1`.
        :param pulumi.Input[int] digits: How many digits the OTP have. Defaults to `6`.
        :param pulumi.Input[int] initial_counter: What should the initial counter value be. Defaults to `2`.
        :param pulumi.Input[int] look_ahead_window: How far ahead should the server look just in case the token generator and server are out of time sync or counter sync. Defaults to `1`.
        :param pulumi.Input[int] period: How many seconds should an OTP token be valid. Defaults to `30`.
        :param pulumi.Input[str] type: One Time Password Type, supported Values are `totp` for Time-Based One Time Password and `hotp` for Counter Based. Defaults to `totp`.
        """
        RealmOtpPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            algorithm=algorithm,
            digits=digits,
            initial_counter=initial_counter,
            look_ahead_window=look_ahead_window,
            period=period,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             algorithm: Optional[pulumi.Input[str]] = None,
             digits: Optional[pulumi.Input[int]] = None,
             initial_counter: Optional[pulumi.Input[int]] = None,
             look_ahead_window: Optional[pulumi.Input[int]] = None,
             period: Optional[pulumi.Input[int]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if initial_counter is None and 'initialCounter' in kwargs:
            initial_counter = kwargs['initialCounter']
        if look_ahead_window is None and 'lookAheadWindow' in kwargs:
            look_ahead_window = kwargs['lookAheadWindow']

        if algorithm is not None:
            _setter("algorithm", algorithm)
        if digits is not None:
            _setter("digits", digits)
        if initial_counter is not None:
            _setter("initial_counter", initial_counter)
        if look_ahead_window is not None:
            _setter("look_ahead_window", look_ahead_window)
        if period is not None:
            _setter("period", period)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        What hashing algorithm should be used to generate the OTP, Valid options are `HmacSHA1`,`HmacSHA256` and `HmacSHA512`. Defaults to `HmacSHA1`.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter
    def digits(self) -> Optional[pulumi.Input[int]]:
        """
        How many digits the OTP have. Defaults to `6`.
        """
        return pulumi.get(self, "digits")

    @digits.setter
    def digits(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "digits", value)

    @property
    @pulumi.getter(name="initialCounter")
    def initial_counter(self) -> Optional[pulumi.Input[int]]:
        """
        What should the initial counter value be. Defaults to `2`.
        """
        return pulumi.get(self, "initial_counter")

    @initial_counter.setter
    def initial_counter(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_counter", value)

    @property
    @pulumi.getter(name="lookAheadWindow")
    def look_ahead_window(self) -> Optional[pulumi.Input[int]]:
        """
        How far ahead should the server look just in case the token generator and server are out of time sync or counter sync. Defaults to `1`.
        """
        return pulumi.get(self, "look_ahead_window")

    @look_ahead_window.setter
    def look_ahead_window(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "look_ahead_window", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        """
        How many seconds should an OTP token be valid. Defaults to `30`.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        One Time Password Type, supported Values are `totp` for Time-Based One Time Password and `hotp` for Counter Based. Defaults to `totp`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RealmSecurityDefensesArgs:
    def __init__(__self__, *,
                 brute_force_detection: Optional[pulumi.Input['RealmSecurityDefensesBruteForceDetectionArgs']] = None,
                 headers: Optional[pulumi.Input['RealmSecurityDefensesHeadersArgs']] = None):
        RealmSecurityDefensesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            brute_force_detection=brute_force_detection,
            headers=headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             brute_force_detection: Optional[pulumi.Input['RealmSecurityDefensesBruteForceDetectionArgs']] = None,
             headers: Optional[pulumi.Input['RealmSecurityDefensesHeadersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if brute_force_detection is None and 'bruteForceDetection' in kwargs:
            brute_force_detection = kwargs['bruteForceDetection']

        if brute_force_detection is not None:
            _setter("brute_force_detection", brute_force_detection)
        if headers is not None:
            _setter("headers", headers)

    @property
    @pulumi.getter(name="bruteForceDetection")
    def brute_force_detection(self) -> Optional[pulumi.Input['RealmSecurityDefensesBruteForceDetectionArgs']]:
        return pulumi.get(self, "brute_force_detection")

    @brute_force_detection.setter
    def brute_force_detection(self, value: Optional[pulumi.Input['RealmSecurityDefensesBruteForceDetectionArgs']]):
        pulumi.set(self, "brute_force_detection", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['RealmSecurityDefensesHeadersArgs']]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['RealmSecurityDefensesHeadersArgs']]):
        pulumi.set(self, "headers", value)


@pulumi.input_type
class RealmSecurityDefensesBruteForceDetectionArgs:
    def __init__(__self__, *,
                 failure_reset_time_seconds: Optional[pulumi.Input[int]] = None,
                 max_failure_wait_seconds: Optional[pulumi.Input[int]] = None,
                 max_login_failures: Optional[pulumi.Input[int]] = None,
                 minimum_quick_login_wait_seconds: Optional[pulumi.Input[int]] = None,
                 permanent_lockout: Optional[pulumi.Input[bool]] = None,
                 quick_login_check_milli_seconds: Optional[pulumi.Input[int]] = None,
                 wait_increment_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] failure_reset_time_seconds: When will failure count be reset?
        :param pulumi.Input[int] max_login_failures: How many failures before wait is triggered.
        :param pulumi.Input[int] minimum_quick_login_wait_seconds: How long to wait after a quick login failure.
               - `max_failure_wait_seconds ` - (Optional) Max. time a user will be locked out.
        :param pulumi.Input[bool] permanent_lockout: When `true`, this will lock the user permanently when the user exceeds the maximum login failures.
        :param pulumi.Input[int] quick_login_check_milli_seconds: Configures the amount of time, in milliseconds, for consecutive failures to lock a user out.
        :param pulumi.Input[int] wait_increment_seconds: This represents the amount of time a user should be locked out when the login failure threshold has been met.
        """
        RealmSecurityDefensesBruteForceDetectionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_reset_time_seconds=failure_reset_time_seconds,
            max_failure_wait_seconds=max_failure_wait_seconds,
            max_login_failures=max_login_failures,
            minimum_quick_login_wait_seconds=minimum_quick_login_wait_seconds,
            permanent_lockout=permanent_lockout,
            quick_login_check_milli_seconds=quick_login_check_milli_seconds,
            wait_increment_seconds=wait_increment_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_reset_time_seconds: Optional[pulumi.Input[int]] = None,
             max_failure_wait_seconds: Optional[pulumi.Input[int]] = None,
             max_login_failures: Optional[pulumi.Input[int]] = None,
             minimum_quick_login_wait_seconds: Optional[pulumi.Input[int]] = None,
             permanent_lockout: Optional[pulumi.Input[bool]] = None,
             quick_login_check_milli_seconds: Optional[pulumi.Input[int]] = None,
             wait_increment_seconds: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failure_reset_time_seconds is None and 'failureResetTimeSeconds' in kwargs:
            failure_reset_time_seconds = kwargs['failureResetTimeSeconds']
        if max_failure_wait_seconds is None and 'maxFailureWaitSeconds' in kwargs:
            max_failure_wait_seconds = kwargs['maxFailureWaitSeconds']
        if max_login_failures is None and 'maxLoginFailures' in kwargs:
            max_login_failures = kwargs['maxLoginFailures']
        if minimum_quick_login_wait_seconds is None and 'minimumQuickLoginWaitSeconds' in kwargs:
            minimum_quick_login_wait_seconds = kwargs['minimumQuickLoginWaitSeconds']
        if permanent_lockout is None and 'permanentLockout' in kwargs:
            permanent_lockout = kwargs['permanentLockout']
        if quick_login_check_milli_seconds is None and 'quickLoginCheckMilliSeconds' in kwargs:
            quick_login_check_milli_seconds = kwargs['quickLoginCheckMilliSeconds']
        if wait_increment_seconds is None and 'waitIncrementSeconds' in kwargs:
            wait_increment_seconds = kwargs['waitIncrementSeconds']

        if failure_reset_time_seconds is not None:
            _setter("failure_reset_time_seconds", failure_reset_time_seconds)
        if max_failure_wait_seconds is not None:
            _setter("max_failure_wait_seconds", max_failure_wait_seconds)
        if max_login_failures is not None:
            _setter("max_login_failures", max_login_failures)
        if minimum_quick_login_wait_seconds is not None:
            _setter("minimum_quick_login_wait_seconds", minimum_quick_login_wait_seconds)
        if permanent_lockout is not None:
            _setter("permanent_lockout", permanent_lockout)
        if quick_login_check_milli_seconds is not None:
            _setter("quick_login_check_milli_seconds", quick_login_check_milli_seconds)
        if wait_increment_seconds is not None:
            _setter("wait_increment_seconds", wait_increment_seconds)

    @property
    @pulumi.getter(name="failureResetTimeSeconds")
    def failure_reset_time_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        When will failure count be reset?
        """
        return pulumi.get(self, "failure_reset_time_seconds")

    @failure_reset_time_seconds.setter
    def failure_reset_time_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_reset_time_seconds", value)

    @property
    @pulumi.getter(name="maxFailureWaitSeconds")
    def max_failure_wait_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_failure_wait_seconds")

    @max_failure_wait_seconds.setter
    def max_failure_wait_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_failure_wait_seconds", value)

    @property
    @pulumi.getter(name="maxLoginFailures")
    def max_login_failures(self) -> Optional[pulumi.Input[int]]:
        """
        How many failures before wait is triggered.
        """
        return pulumi.get(self, "max_login_failures")

    @max_login_failures.setter
    def max_login_failures(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_login_failures", value)

    @property
    @pulumi.getter(name="minimumQuickLoginWaitSeconds")
    def minimum_quick_login_wait_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How long to wait after a quick login failure.
        - `max_failure_wait_seconds ` - (Optional) Max. time a user will be locked out.
        """
        return pulumi.get(self, "minimum_quick_login_wait_seconds")

    @minimum_quick_login_wait_seconds.setter
    def minimum_quick_login_wait_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minimum_quick_login_wait_seconds", value)

    @property
    @pulumi.getter(name="permanentLockout")
    def permanent_lockout(self) -> Optional[pulumi.Input[bool]]:
        """
        When `true`, this will lock the user permanently when the user exceeds the maximum login failures.
        """
        return pulumi.get(self, "permanent_lockout")

    @permanent_lockout.setter
    def permanent_lockout(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "permanent_lockout", value)

    @property
    @pulumi.getter(name="quickLoginCheckMilliSeconds")
    def quick_login_check_milli_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Configures the amount of time, in milliseconds, for consecutive failures to lock a user out.
        """
        return pulumi.get(self, "quick_login_check_milli_seconds")

    @quick_login_check_milli_seconds.setter
    def quick_login_check_milli_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "quick_login_check_milli_seconds", value)

    @property
    @pulumi.getter(name="waitIncrementSeconds")
    def wait_increment_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        This represents the amount of time a user should be locked out when the login failure threshold has been met.
        """
        return pulumi.get(self, "wait_increment_seconds")

    @wait_increment_seconds.setter
    def wait_increment_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "wait_increment_seconds", value)


@pulumi.input_type
class RealmSecurityDefensesHeadersArgs:
    def __init__(__self__, *,
                 content_security_policy: Optional[pulumi.Input[str]] = None,
                 content_security_policy_report_only: Optional[pulumi.Input[str]] = None,
                 strict_transport_security: Optional[pulumi.Input[str]] = None,
                 x_content_type_options: Optional[pulumi.Input[str]] = None,
                 x_frame_options: Optional[pulumi.Input[str]] = None,
                 x_robots_tag: Optional[pulumi.Input[str]] = None,
                 x_xss_protection: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content_security_policy: Sets the Content Security Policy, which can be used for prevent pages from being included by non-origin iframes. More information can be found in the [W3C-CSP](https://www.w3.org/TR/CSP/) Abstract.
        :param pulumi.Input[str] content_security_policy_report_only: Used for testing Content Security Policies.
        :param pulumi.Input[str] strict_transport_security: The Script-Transport-Security HTTP header tells browsers to always use HTTPS.
        :param pulumi.Input[str] x_content_type_options: Sets the X-Content-Type-Options, which can be used for prevent MIME-sniffing a response away from the declared content-type
        :param pulumi.Input[str] x_frame_options: Sets the x-frame-option, which can be used to prevent pages from being included by non-origin iframes. More information can be found in the [RFC7034](https://tools.ietf.org/html/rfc7034)
        :param pulumi.Input[str] x_robots_tag: Prevent pages from appearing in search engines.
        :param pulumi.Input[str] x_xss_protection: This header configures the Cross-site scripting (XSS) filter in your browser.
        """
        RealmSecurityDefensesHeadersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content_security_policy=content_security_policy,
            content_security_policy_report_only=content_security_policy_report_only,
            strict_transport_security=strict_transport_security,
            x_content_type_options=x_content_type_options,
            x_frame_options=x_frame_options,
            x_robots_tag=x_robots_tag,
            x_xss_protection=x_xss_protection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content_security_policy: Optional[pulumi.Input[str]] = None,
             content_security_policy_report_only: Optional[pulumi.Input[str]] = None,
             strict_transport_security: Optional[pulumi.Input[str]] = None,
             x_content_type_options: Optional[pulumi.Input[str]] = None,
             x_frame_options: Optional[pulumi.Input[str]] = None,
             x_robots_tag: Optional[pulumi.Input[str]] = None,
             x_xss_protection: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if content_security_policy is None and 'contentSecurityPolicy' in kwargs:
            content_security_policy = kwargs['contentSecurityPolicy']
        if content_security_policy_report_only is None and 'contentSecurityPolicyReportOnly' in kwargs:
            content_security_policy_report_only = kwargs['contentSecurityPolicyReportOnly']
        if strict_transport_security is None and 'strictTransportSecurity' in kwargs:
            strict_transport_security = kwargs['strictTransportSecurity']
        if x_content_type_options is None and 'xContentTypeOptions' in kwargs:
            x_content_type_options = kwargs['xContentTypeOptions']
        if x_frame_options is None and 'xFrameOptions' in kwargs:
            x_frame_options = kwargs['xFrameOptions']
        if x_robots_tag is None and 'xRobotsTag' in kwargs:
            x_robots_tag = kwargs['xRobotsTag']
        if x_xss_protection is None and 'xXssProtection' in kwargs:
            x_xss_protection = kwargs['xXssProtection']

        if content_security_policy is not None:
            _setter("content_security_policy", content_security_policy)
        if content_security_policy_report_only is not None:
            _setter("content_security_policy_report_only", content_security_policy_report_only)
        if strict_transport_security is not None:
            _setter("strict_transport_security", strict_transport_security)
        if x_content_type_options is not None:
            _setter("x_content_type_options", x_content_type_options)
        if x_frame_options is not None:
            _setter("x_frame_options", x_frame_options)
        if x_robots_tag is not None:
            _setter("x_robots_tag", x_robots_tag)
        if x_xss_protection is not None:
            _setter("x_xss_protection", x_xss_protection)

    @property
    @pulumi.getter(name="contentSecurityPolicy")
    def content_security_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the Content Security Policy, which can be used for prevent pages from being included by non-origin iframes. More information can be found in the [W3C-CSP](https://www.w3.org/TR/CSP/) Abstract.
        """
        return pulumi.get(self, "content_security_policy")

    @content_security_policy.setter
    def content_security_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_security_policy", value)

    @property
    @pulumi.getter(name="contentSecurityPolicyReportOnly")
    def content_security_policy_report_only(self) -> Optional[pulumi.Input[str]]:
        """
        Used for testing Content Security Policies.
        """
        return pulumi.get(self, "content_security_policy_report_only")

    @content_security_policy_report_only.setter
    def content_security_policy_report_only(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_security_policy_report_only", value)

    @property
    @pulumi.getter(name="strictTransportSecurity")
    def strict_transport_security(self) -> Optional[pulumi.Input[str]]:
        """
        The Script-Transport-Security HTTP header tells browsers to always use HTTPS.
        """
        return pulumi.get(self, "strict_transport_security")

    @strict_transport_security.setter
    def strict_transport_security(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strict_transport_security", value)

    @property
    @pulumi.getter(name="xContentTypeOptions")
    def x_content_type_options(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the X-Content-Type-Options, which can be used for prevent MIME-sniffing a response away from the declared content-type
        """
        return pulumi.get(self, "x_content_type_options")

    @x_content_type_options.setter
    def x_content_type_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_content_type_options", value)

    @property
    @pulumi.getter(name="xFrameOptions")
    def x_frame_options(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the x-frame-option, which can be used to prevent pages from being included by non-origin iframes. More information can be found in the [RFC7034](https://tools.ietf.org/html/rfc7034)
        """
        return pulumi.get(self, "x_frame_options")

    @x_frame_options.setter
    def x_frame_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_frame_options", value)

    @property
    @pulumi.getter(name="xRobotsTag")
    def x_robots_tag(self) -> Optional[pulumi.Input[str]]:
        """
        Prevent pages from appearing in search engines.
        """
        return pulumi.get(self, "x_robots_tag")

    @x_robots_tag.setter
    def x_robots_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_robots_tag", value)

    @property
    @pulumi.getter(name="xXssProtection")
    def x_xss_protection(self) -> Optional[pulumi.Input[str]]:
        """
        This header configures the Cross-site scripting (XSS) filter in your browser.
        """
        return pulumi.get(self, "x_xss_protection")

    @x_xss_protection.setter
    def x_xss_protection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_xss_protection", value)


@pulumi.input_type
class RealmSmtpServerArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[str],
                 host: pulumi.Input[str],
                 auth: Optional[pulumi.Input['RealmSmtpServerAuthArgs']] = None,
                 envelope_from: Optional[pulumi.Input[str]] = None,
                 from_display_name: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None,
                 reply_to: Optional[pulumi.Input[str]] = None,
                 reply_to_display_name: Optional[pulumi.Input[str]] = None,
                 ssl: Optional[pulumi.Input[bool]] = None,
                 starttls: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] from_: The email address for the sender.
        :param pulumi.Input[str] host: The host of the SMTP server.
        :param pulumi.Input['RealmSmtpServerAuthArgs'] auth: Enables authentication to the SMTP server.  This block supports the following arguments:
        :param pulumi.Input[str] envelope_from: The email address uses for bounces.
        :param pulumi.Input[str] from_display_name: The display name of the sender email address.
        :param pulumi.Input[str] port: The port of the SMTP server (defaults to 25).
        :param pulumi.Input[str] reply_to: The "reply to" email address.
        :param pulumi.Input[str] reply_to_display_name: The display name of the "reply to" email address.
        :param pulumi.Input[bool] ssl: When `true`, enables SSL. Defaults to `false`.
        :param pulumi.Input[bool] starttls: When `true`, enables StartTLS. Defaults to `false`.
        """
        RealmSmtpServerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            host=host,
            auth=auth,
            envelope_from=envelope_from,
            from_display_name=from_display_name,
            port=port,
            reply_to=reply_to,
            reply_to_display_name=reply_to_display_name,
            ssl=ssl,
            starttls=starttls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: Optional[pulumi.Input[str]] = None,
             host: Optional[pulumi.Input[str]] = None,
             auth: Optional[pulumi.Input['RealmSmtpServerAuthArgs']] = None,
             envelope_from: Optional[pulumi.Input[str]] = None,
             from_display_name: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[str]] = None,
             reply_to: Optional[pulumi.Input[str]] = None,
             reply_to_display_name: Optional[pulumi.Input[str]] = None,
             ssl: Optional[pulumi.Input[bool]] = None,
             starttls: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']
        if from_ is None:
            raise TypeError("Missing 'from_' argument")
        if host is None:
            raise TypeError("Missing 'host' argument")
        if envelope_from is None and 'envelopeFrom' in kwargs:
            envelope_from = kwargs['envelopeFrom']
        if from_display_name is None and 'fromDisplayName' in kwargs:
            from_display_name = kwargs['fromDisplayName']
        if reply_to is None and 'replyTo' in kwargs:
            reply_to = kwargs['replyTo']
        if reply_to_display_name is None and 'replyToDisplayName' in kwargs:
            reply_to_display_name = kwargs['replyToDisplayName']

        _setter("from_", from_)
        _setter("host", host)
        if auth is not None:
            _setter("auth", auth)
        if envelope_from is not None:
            _setter("envelope_from", envelope_from)
        if from_display_name is not None:
            _setter("from_display_name", from_display_name)
        if port is not None:
            _setter("port", port)
        if reply_to is not None:
            _setter("reply_to", reply_to)
        if reply_to_display_name is not None:
            _setter("reply_to_display_name", reply_to_display_name)
        if ssl is not None:
            _setter("ssl", ssl)
        if starttls is not None:
            _setter("starttls", starttls)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[str]:
        """
        The email address for the sender.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[str]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The host of the SMTP server.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['RealmSmtpServerAuthArgs']]:
        """
        Enables authentication to the SMTP server.  This block supports the following arguments:
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['RealmSmtpServerAuthArgs']]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter(name="envelopeFrom")
    def envelope_from(self) -> Optional[pulumi.Input[str]]:
        """
        The email address uses for bounces.
        """
        return pulumi.get(self, "envelope_from")

    @envelope_from.setter
    def envelope_from(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "envelope_from", value)

    @property
    @pulumi.getter(name="fromDisplayName")
    def from_display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the sender email address.
        """
        return pulumi.get(self, "from_display_name")

    @from_display_name.setter
    def from_display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_display_name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        """
        The port of the SMTP server (defaults to 25).
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="replyTo")
    def reply_to(self) -> Optional[pulumi.Input[str]]:
        """
        The "reply to" email address.
        """
        return pulumi.get(self, "reply_to")

    @reply_to.setter
    def reply_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reply_to", value)

    @property
    @pulumi.getter(name="replyToDisplayName")
    def reply_to_display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the "reply to" email address.
        """
        return pulumi.get(self, "reply_to_display_name")

    @reply_to_display_name.setter
    def reply_to_display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reply_to_display_name", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        When `true`, enables SSL. Defaults to `false`.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter
    def starttls(self) -> Optional[pulumi.Input[bool]]:
        """
        When `true`, enables StartTLS. Defaults to `false`.
        """
        return pulumi.get(self, "starttls")

    @starttls.setter
    def starttls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "starttls", value)


@pulumi.input_type
class RealmSmtpServerAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: The SMTP server password.
        :param pulumi.Input[str] username: The SMTP server username.
        """
        RealmSmtpServerAuthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The SMTP server password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The SMTP server username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class RealmUserProfileAttributeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 enabled_when_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group: Optional[pulumi.Input[str]] = None,
                 permissions: Optional[pulumi.Input['RealmUserProfileAttributePermissionsArgs']] = None,
                 required_for_roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 required_for_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 validators: Optional[pulumi.Input[Sequence[pulumi.Input['RealmUserProfileAttributeValidatorArgs']]]] = None):
        """
        :param pulumi.Input[str] name: The name of the attribute.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: A map of annotations for the attribute. Values can be a String or a json object.
        :param pulumi.Input[str] display_name: The display name of the attribute.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] enabled_when_scopes: A list of scopes. The attribute will only be enabled when these scopes are requested by clients.
        :param pulumi.Input[str] group: A list of groups.
        :param pulumi.Input['RealmUserProfileAttributePermissionsArgs'] permissions: The permissions configuration information.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] required_for_roles: A list of roles for which the attribute will be required.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] required_for_scopes: A list of scopes for which the attribute will be required.
        :param pulumi.Input[Sequence[pulumi.Input['RealmUserProfileAttributeValidatorArgs']]] validators: A list of validators for the attribute.
        """
        RealmUserProfileAttributeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            annotations=annotations,
            display_name=display_name,
            enabled_when_scopes=enabled_when_scopes,
            group=group,
            permissions=permissions,
            required_for_roles=required_for_roles,
            required_for_scopes=required_for_scopes,
            validators=validators,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             enabled_when_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             group: Optional[pulumi.Input[str]] = None,
             permissions: Optional[pulumi.Input['RealmUserProfileAttributePermissionsArgs']] = None,
             required_for_roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             required_for_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             validators: Optional[pulumi.Input[Sequence[pulumi.Input['RealmUserProfileAttributeValidatorArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if enabled_when_scopes is None and 'enabledWhenScopes' in kwargs:
            enabled_when_scopes = kwargs['enabledWhenScopes']
        if required_for_roles is None and 'requiredForRoles' in kwargs:
            required_for_roles = kwargs['requiredForRoles']
        if required_for_scopes is None and 'requiredForScopes' in kwargs:
            required_for_scopes = kwargs['requiredForScopes']

        _setter("name", name)
        if annotations is not None:
            _setter("annotations", annotations)
        if display_name is not None:
            _setter("display_name", display_name)
        if enabled_when_scopes is not None:
            _setter("enabled_when_scopes", enabled_when_scopes)
        if group is not None:
            _setter("group", group)
        if permissions is not None:
            _setter("permissions", permissions)
        if required_for_roles is not None:
            _setter("required_for_roles", required_for_roles)
        if required_for_scopes is not None:
            _setter("required_for_scopes", required_for_scopes)
        if validators is not None:
            _setter("validators", validators)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of annotations for the attribute. Values can be a String or a json object.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the attribute.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="enabledWhenScopes")
    def enabled_when_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of scopes. The attribute will only be enabled when these scopes are requested by clients.
        """
        return pulumi.get(self, "enabled_when_scopes")

    @enabled_when_scopes.setter
    def enabled_when_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "enabled_when_scopes", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        A list of groups.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input['RealmUserProfileAttributePermissionsArgs']]:
        """
        The permissions configuration information.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input['RealmUserProfileAttributePermissionsArgs']]):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter(name="requiredForRoles")
    def required_for_roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of roles for which the attribute will be required.
        """
        return pulumi.get(self, "required_for_roles")

    @required_for_roles.setter
    def required_for_roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "required_for_roles", value)

    @property
    @pulumi.getter(name="requiredForScopes")
    def required_for_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of scopes for which the attribute will be required.
        """
        return pulumi.get(self, "required_for_scopes")

    @required_for_scopes.setter
    def required_for_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "required_for_scopes", value)

    @property
    @pulumi.getter
    def validators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RealmUserProfileAttributeValidatorArgs']]]]:
        """
        A list of validators for the attribute.
        """
        return pulumi.get(self, "validators")

    @validators.setter
    def validators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RealmUserProfileAttributeValidatorArgs']]]]):
        pulumi.set(self, "validators", value)


@pulumi.input_type
class RealmUserProfileAttributePermissionsArgs:
    def __init__(__self__, *,
                 edits: pulumi.Input[Sequence[pulumi.Input[str]]],
                 views: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] edits: A list of profiles that will be able to edit the attribute. One of `admin`, `user`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] views: A list of profiles that will be able to view the attribute. One of `admin`, `user`.
        """
        RealmUserProfileAttributePermissionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            edits=edits,
            views=views,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             edits: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             views: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if edits is None:
            raise TypeError("Missing 'edits' argument")
        if views is None:
            raise TypeError("Missing 'views' argument")

        _setter("edits", edits)
        _setter("views", views)

    @property
    @pulumi.getter
    def edits(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of profiles that will be able to edit the attribute. One of `admin`, `user`.
        """
        return pulumi.get(self, "edits")

    @edits.setter
    def edits(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "edits", value)

    @property
    @pulumi.getter
    def views(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of profiles that will be able to view the attribute. One of `admin`, `user`.
        """
        return pulumi.get(self, "views")

    @views.setter
    def views(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "views", value)


@pulumi.input_type
class RealmUserProfileAttributeValidatorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 config: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name of the attribute.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] config: A map defining the configuration of the validator. Values can be a String or a json object.
        """
        RealmUserProfileAttributeValidatorArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            config=config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             config: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)
        if config is not None:
            _setter("config", config)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map defining the configuration of the validator. Values can be a String or a json object.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "config", value)


@pulumi.input_type
class RealmUserProfileGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 display_description: Optional[pulumi.Input[str]] = None,
                 display_header: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the attribute.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: A map of annotations for the attribute. Values can be a String or a json object.
        :param pulumi.Input[str] display_description: The display description of the group.
        :param pulumi.Input[str] display_header: The display header of the group.
        """
        RealmUserProfileGroupArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            annotations=annotations,
            display_description=display_description,
            display_header=display_header,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             display_description: Optional[pulumi.Input[str]] = None,
             display_header: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if display_description is None and 'displayDescription' in kwargs:
            display_description = kwargs['displayDescription']
        if display_header is None and 'displayHeader' in kwargs:
            display_header = kwargs['displayHeader']

        _setter("name", name)
        if annotations is not None:
            _setter("annotations", annotations)
        if display_description is not None:
            _setter("display_description", display_description)
        if display_header is not None:
            _setter("display_header", display_header)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of annotations for the attribute. Values can be a String or a json object.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="displayDescription")
    def display_description(self) -> Optional[pulumi.Input[str]]:
        """
        The display description of the group.
        """
        return pulumi.get(self, "display_description")

    @display_description.setter
    def display_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_description", value)

    @property
    @pulumi.getter(name="displayHeader")
    def display_header(self) -> Optional[pulumi.Input[str]]:
        """
        The display header of the group.
        """
        return pulumi.get(self, "display_header")

    @display_header.setter
    def display_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_header", value)


@pulumi.input_type
class RealmWebAuthnPasswordlessPolicyArgs:
    def __init__(__self__, *,
                 acceptable_aaguids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 attestation_conveyance_preference: Optional[pulumi.Input[str]] = None,
                 authenticator_attachment: Optional[pulumi.Input[str]] = None,
                 avoid_same_authenticator_register: Optional[pulumi.Input[bool]] = None,
                 create_timeout: Optional[pulumi.Input[int]] = None,
                 relying_party_entity_name: Optional[pulumi.Input[str]] = None,
                 relying_party_id: Optional[pulumi.Input[str]] = None,
                 require_resident_key: Optional[pulumi.Input[str]] = None,
                 signature_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_verification_requirement: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] acceptable_aaguids: A set of AAGUIDs for which an authenticator can be registered.
        :param pulumi.Input[str] attestation_conveyance_preference: The preference of how to generate a WebAuthn attestation statement. Valid options are `not specified`, `none`, `indirect`, `direct`, or `enterprise`. Defaults to `not specified`.
        :param pulumi.Input[str] authenticator_attachment: The acceptable attachment pattern for the WebAuthn authenticator. Valid options are `not specified`, `platform`, or `cross-platform`. Defaults to `not specified`.
        :param pulumi.Input[bool] avoid_same_authenticator_register: When `true`, Keycloak will avoid registering the authenticator for WebAuthn if it has already been registered. Defaults to `false`.
        :param pulumi.Input[int] create_timeout: The timeout value for creating a user's public key credential in seconds. When set to `0`, this timeout option is not adapted. Defaults to `0`.
        :param pulumi.Input[str] relying_party_entity_name: A human readable server name for the WebAuthn Relying Party. Defaults to `keycloak`.
        :param pulumi.Input[str] relying_party_id: The WebAuthn relying party ID.
        :param pulumi.Input[str] require_resident_key: Specifies whether or not a public key should be created to represent the resident key. Valid options are `not specified`, `Yes`, or `No`. Defaults to `not specified`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] signature_algorithms: A set of signature algorithms that should be used for the authentication assertion. Valid options at the time these docs were written are `ES256`, `ES384`, `ES512`, `RS256`, `RS384`, `RS512`, and `RS1`.
        :param pulumi.Input[str] user_verification_requirement: Specifies the policy for verifying a user logging in via WebAuthn. Valid options are `not specified`, `required`, `preferred`, or `discouraged`. Defaults to `not specified`.
        """
        RealmWebAuthnPasswordlessPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acceptable_aaguids=acceptable_aaguids,
            attestation_conveyance_preference=attestation_conveyance_preference,
            authenticator_attachment=authenticator_attachment,
            avoid_same_authenticator_register=avoid_same_authenticator_register,
            create_timeout=create_timeout,
            relying_party_entity_name=relying_party_entity_name,
            relying_party_id=relying_party_id,
            require_resident_key=require_resident_key,
            signature_algorithms=signature_algorithms,
            user_verification_requirement=user_verification_requirement,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acceptable_aaguids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             attestation_conveyance_preference: Optional[pulumi.Input[str]] = None,
             authenticator_attachment: Optional[pulumi.Input[str]] = None,
             avoid_same_authenticator_register: Optional[pulumi.Input[bool]] = None,
             create_timeout: Optional[pulumi.Input[int]] = None,
             relying_party_entity_name: Optional[pulumi.Input[str]] = None,
             relying_party_id: Optional[pulumi.Input[str]] = None,
             require_resident_key: Optional[pulumi.Input[str]] = None,
             signature_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             user_verification_requirement: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if acceptable_aaguids is None and 'acceptableAaguids' in kwargs:
            acceptable_aaguids = kwargs['acceptableAaguids']
        if attestation_conveyance_preference is None and 'attestationConveyancePreference' in kwargs:
            attestation_conveyance_preference = kwargs['attestationConveyancePreference']
        if authenticator_attachment is None and 'authenticatorAttachment' in kwargs:
            authenticator_attachment = kwargs['authenticatorAttachment']
        if avoid_same_authenticator_register is None and 'avoidSameAuthenticatorRegister' in kwargs:
            avoid_same_authenticator_register = kwargs['avoidSameAuthenticatorRegister']
        if create_timeout is None and 'createTimeout' in kwargs:
            create_timeout = kwargs['createTimeout']
        if relying_party_entity_name is None and 'relyingPartyEntityName' in kwargs:
            relying_party_entity_name = kwargs['relyingPartyEntityName']
        if relying_party_id is None and 'relyingPartyId' in kwargs:
            relying_party_id = kwargs['relyingPartyId']
        if require_resident_key is None and 'requireResidentKey' in kwargs:
            require_resident_key = kwargs['requireResidentKey']
        if signature_algorithms is None and 'signatureAlgorithms' in kwargs:
            signature_algorithms = kwargs['signatureAlgorithms']
        if user_verification_requirement is None and 'userVerificationRequirement' in kwargs:
            user_verification_requirement = kwargs['userVerificationRequirement']

        if acceptable_aaguids is not None:
            _setter("acceptable_aaguids", acceptable_aaguids)
        if attestation_conveyance_preference is not None:
            _setter("attestation_conveyance_preference", attestation_conveyance_preference)
        if authenticator_attachment is not None:
            _setter("authenticator_attachment", authenticator_attachment)
        if avoid_same_authenticator_register is not None:
            _setter("avoid_same_authenticator_register", avoid_same_authenticator_register)
        if create_timeout is not None:
            _setter("create_timeout", create_timeout)
        if relying_party_entity_name is not None:
            _setter("relying_party_entity_name", relying_party_entity_name)
        if relying_party_id is not None:
            _setter("relying_party_id", relying_party_id)
        if require_resident_key is not None:
            _setter("require_resident_key", require_resident_key)
        if signature_algorithms is not None:
            _setter("signature_algorithms", signature_algorithms)
        if user_verification_requirement is not None:
            _setter("user_verification_requirement", user_verification_requirement)

    @property
    @pulumi.getter(name="acceptableAaguids")
    def acceptable_aaguids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of AAGUIDs for which an authenticator can be registered.
        """
        return pulumi.get(self, "acceptable_aaguids")

    @acceptable_aaguids.setter
    def acceptable_aaguids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "acceptable_aaguids", value)

    @property
    @pulumi.getter(name="attestationConveyancePreference")
    def attestation_conveyance_preference(self) -> Optional[pulumi.Input[str]]:
        """
        The preference of how to generate a WebAuthn attestation statement. Valid options are `not specified`, `none`, `indirect`, `direct`, or `enterprise`. Defaults to `not specified`.
        """
        return pulumi.get(self, "attestation_conveyance_preference")

    @attestation_conveyance_preference.setter
    def attestation_conveyance_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attestation_conveyance_preference", value)

    @property
    @pulumi.getter(name="authenticatorAttachment")
    def authenticator_attachment(self) -> Optional[pulumi.Input[str]]:
        """
        The acceptable attachment pattern for the WebAuthn authenticator. Valid options are `not specified`, `platform`, or `cross-platform`. Defaults to `not specified`.
        """
        return pulumi.get(self, "authenticator_attachment")

    @authenticator_attachment.setter
    def authenticator_attachment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authenticator_attachment", value)

    @property
    @pulumi.getter(name="avoidSameAuthenticatorRegister")
    def avoid_same_authenticator_register(self) -> Optional[pulumi.Input[bool]]:
        """
        When `true`, Keycloak will avoid registering the authenticator for WebAuthn if it has already been registered. Defaults to `false`.
        """
        return pulumi.get(self, "avoid_same_authenticator_register")

    @avoid_same_authenticator_register.setter
    def avoid_same_authenticator_register(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "avoid_same_authenticator_register", value)

    @property
    @pulumi.getter(name="createTimeout")
    def create_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout value for creating a user's public key credential in seconds. When set to `0`, this timeout option is not adapted. Defaults to `0`.
        """
        return pulumi.get(self, "create_timeout")

    @create_timeout.setter
    def create_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "create_timeout", value)

    @property
    @pulumi.getter(name="relyingPartyEntityName")
    def relying_party_entity_name(self) -> Optional[pulumi.Input[str]]:
        """
        A human readable server name for the WebAuthn Relying Party. Defaults to `keycloak`.
        """
        return pulumi.get(self, "relying_party_entity_name")

    @relying_party_entity_name.setter
    def relying_party_entity_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relying_party_entity_name", value)

    @property
    @pulumi.getter(name="relyingPartyId")
    def relying_party_id(self) -> Optional[pulumi.Input[str]]:
        """
        The WebAuthn relying party ID.
        """
        return pulumi.get(self, "relying_party_id")

    @relying_party_id.setter
    def relying_party_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relying_party_id", value)

    @property
    @pulumi.getter(name="requireResidentKey")
    def require_resident_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether or not a public key should be created to represent the resident key. Valid options are `not specified`, `Yes`, or `No`. Defaults to `not specified`.
        """
        return pulumi.get(self, "require_resident_key")

    @require_resident_key.setter
    def require_resident_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "require_resident_key", value)

    @property
    @pulumi.getter(name="signatureAlgorithms")
    def signature_algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of signature algorithms that should be used for the authentication assertion. Valid options at the time these docs were written are `ES256`, `ES384`, `ES512`, `RS256`, `RS384`, `RS512`, and `RS1`.
        """
        return pulumi.get(self, "signature_algorithms")

    @signature_algorithms.setter
    def signature_algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "signature_algorithms", value)

    @property
    @pulumi.getter(name="userVerificationRequirement")
    def user_verification_requirement(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the policy for verifying a user logging in via WebAuthn. Valid options are `not specified`, `required`, `preferred`, or `discouraged`. Defaults to `not specified`.
        """
        return pulumi.get(self, "user_verification_requirement")

    @user_verification_requirement.setter
    def user_verification_requirement(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_verification_requirement", value)


@pulumi.input_type
class RealmWebAuthnPolicyArgs:
    def __init__(__self__, *,
                 acceptable_aaguids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 attestation_conveyance_preference: Optional[pulumi.Input[str]] = None,
                 authenticator_attachment: Optional[pulumi.Input[str]] = None,
                 avoid_same_authenticator_register: Optional[pulumi.Input[bool]] = None,
                 create_timeout: Optional[pulumi.Input[int]] = None,
                 relying_party_entity_name: Optional[pulumi.Input[str]] = None,
                 relying_party_id: Optional[pulumi.Input[str]] = None,
                 require_resident_key: Optional[pulumi.Input[str]] = None,
                 signature_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_verification_requirement: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] acceptable_aaguids: A set of AAGUIDs for which an authenticator can be registered.
        :param pulumi.Input[str] attestation_conveyance_preference: The preference of how to generate a WebAuthn attestation statement. Valid options are `not specified`, `none`, `indirect`, `direct`, or `enterprise`. Defaults to `not specified`.
        :param pulumi.Input[str] authenticator_attachment: The acceptable attachment pattern for the WebAuthn authenticator. Valid options are `not specified`, `platform`, or `cross-platform`. Defaults to `not specified`.
        :param pulumi.Input[bool] avoid_same_authenticator_register: When `true`, Keycloak will avoid registering the authenticator for WebAuthn if it has already been registered. Defaults to `false`.
        :param pulumi.Input[int] create_timeout: The timeout value for creating a user's public key credential in seconds. When set to `0`, this timeout option is not adapted. Defaults to `0`.
        :param pulumi.Input[str] relying_party_entity_name: A human readable server name for the WebAuthn Relying Party. Defaults to `keycloak`.
        :param pulumi.Input[str] relying_party_id: The WebAuthn relying party ID.
        :param pulumi.Input[str] require_resident_key: Specifies whether or not a public key should be created to represent the resident key. Valid options are `not specified`, `Yes`, or `No`. Defaults to `not specified`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] signature_algorithms: A set of signature algorithms that should be used for the authentication assertion. Valid options at the time these docs were written are `ES256`, `ES384`, `ES512`, `RS256`, `RS384`, `RS512`, and `RS1`.
        :param pulumi.Input[str] user_verification_requirement: Specifies the policy for verifying a user logging in via WebAuthn. Valid options are `not specified`, `required`, `preferred`, or `discouraged`. Defaults to `not specified`.
        """
        RealmWebAuthnPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acceptable_aaguids=acceptable_aaguids,
            attestation_conveyance_preference=attestation_conveyance_preference,
            authenticator_attachment=authenticator_attachment,
            avoid_same_authenticator_register=avoid_same_authenticator_register,
            create_timeout=create_timeout,
            relying_party_entity_name=relying_party_entity_name,
            relying_party_id=relying_party_id,
            require_resident_key=require_resident_key,
            signature_algorithms=signature_algorithms,
            user_verification_requirement=user_verification_requirement,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acceptable_aaguids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             attestation_conveyance_preference: Optional[pulumi.Input[str]] = None,
             authenticator_attachment: Optional[pulumi.Input[str]] = None,
             avoid_same_authenticator_register: Optional[pulumi.Input[bool]] = None,
             create_timeout: Optional[pulumi.Input[int]] = None,
             relying_party_entity_name: Optional[pulumi.Input[str]] = None,
             relying_party_id: Optional[pulumi.Input[str]] = None,
             require_resident_key: Optional[pulumi.Input[str]] = None,
             signature_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             user_verification_requirement: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if acceptable_aaguids is None and 'acceptableAaguids' in kwargs:
            acceptable_aaguids = kwargs['acceptableAaguids']
        if attestation_conveyance_preference is None and 'attestationConveyancePreference' in kwargs:
            attestation_conveyance_preference = kwargs['attestationConveyancePreference']
        if authenticator_attachment is None and 'authenticatorAttachment' in kwargs:
            authenticator_attachment = kwargs['authenticatorAttachment']
        if avoid_same_authenticator_register is None and 'avoidSameAuthenticatorRegister' in kwargs:
            avoid_same_authenticator_register = kwargs['avoidSameAuthenticatorRegister']
        if create_timeout is None and 'createTimeout' in kwargs:
            create_timeout = kwargs['createTimeout']
        if relying_party_entity_name is None and 'relyingPartyEntityName' in kwargs:
            relying_party_entity_name = kwargs['relyingPartyEntityName']
        if relying_party_id is None and 'relyingPartyId' in kwargs:
            relying_party_id = kwargs['relyingPartyId']
        if require_resident_key is None and 'requireResidentKey' in kwargs:
            require_resident_key = kwargs['requireResidentKey']
        if signature_algorithms is None and 'signatureAlgorithms' in kwargs:
            signature_algorithms = kwargs['signatureAlgorithms']
        if user_verification_requirement is None and 'userVerificationRequirement' in kwargs:
            user_verification_requirement = kwargs['userVerificationRequirement']

        if acceptable_aaguids is not None:
            _setter("acceptable_aaguids", acceptable_aaguids)
        if attestation_conveyance_preference is not None:
            _setter("attestation_conveyance_preference", attestation_conveyance_preference)
        if authenticator_attachment is not None:
            _setter("authenticator_attachment", authenticator_attachment)
        if avoid_same_authenticator_register is not None:
            _setter("avoid_same_authenticator_register", avoid_same_authenticator_register)
        if create_timeout is not None:
            _setter("create_timeout", create_timeout)
        if relying_party_entity_name is not None:
            _setter("relying_party_entity_name", relying_party_entity_name)
        if relying_party_id is not None:
            _setter("relying_party_id", relying_party_id)
        if require_resident_key is not None:
            _setter("require_resident_key", require_resident_key)
        if signature_algorithms is not None:
            _setter("signature_algorithms", signature_algorithms)
        if user_verification_requirement is not None:
            _setter("user_verification_requirement", user_verification_requirement)

    @property
    @pulumi.getter(name="acceptableAaguids")
    def acceptable_aaguids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of AAGUIDs for which an authenticator can be registered.
        """
        return pulumi.get(self, "acceptable_aaguids")

    @acceptable_aaguids.setter
    def acceptable_aaguids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "acceptable_aaguids", value)

    @property
    @pulumi.getter(name="attestationConveyancePreference")
    def attestation_conveyance_preference(self) -> Optional[pulumi.Input[str]]:
        """
        The preference of how to generate a WebAuthn attestation statement. Valid options are `not specified`, `none`, `indirect`, `direct`, or `enterprise`. Defaults to `not specified`.
        """
        return pulumi.get(self, "attestation_conveyance_preference")

    @attestation_conveyance_preference.setter
    def attestation_conveyance_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attestation_conveyance_preference", value)

    @property
    @pulumi.getter(name="authenticatorAttachment")
    def authenticator_attachment(self) -> Optional[pulumi.Input[str]]:
        """
        The acceptable attachment pattern for the WebAuthn authenticator. Valid options are `not specified`, `platform`, or `cross-platform`. Defaults to `not specified`.
        """
        return pulumi.get(self, "authenticator_attachment")

    @authenticator_attachment.setter
    def authenticator_attachment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authenticator_attachment", value)

    @property
    @pulumi.getter(name="avoidSameAuthenticatorRegister")
    def avoid_same_authenticator_register(self) -> Optional[pulumi.Input[bool]]:
        """
        When `true`, Keycloak will avoid registering the authenticator for WebAuthn if it has already been registered. Defaults to `false`.
        """
        return pulumi.get(self, "avoid_same_authenticator_register")

    @avoid_same_authenticator_register.setter
    def avoid_same_authenticator_register(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "avoid_same_authenticator_register", value)

    @property
    @pulumi.getter(name="createTimeout")
    def create_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout value for creating a user's public key credential in seconds. When set to `0`, this timeout option is not adapted. Defaults to `0`.
        """
        return pulumi.get(self, "create_timeout")

    @create_timeout.setter
    def create_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "create_timeout", value)

    @property
    @pulumi.getter(name="relyingPartyEntityName")
    def relying_party_entity_name(self) -> Optional[pulumi.Input[str]]:
        """
        A human readable server name for the WebAuthn Relying Party. Defaults to `keycloak`.
        """
        return pulumi.get(self, "relying_party_entity_name")

    @relying_party_entity_name.setter
    def relying_party_entity_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relying_party_entity_name", value)

    @property
    @pulumi.getter(name="relyingPartyId")
    def relying_party_id(self) -> Optional[pulumi.Input[str]]:
        """
        The WebAuthn relying party ID.
        """
        return pulumi.get(self, "relying_party_id")

    @relying_party_id.setter
    def relying_party_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relying_party_id", value)

    @property
    @pulumi.getter(name="requireResidentKey")
    def require_resident_key(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether or not a public key should be created to represent the resident key. Valid options are `not specified`, `Yes`, or `No`. Defaults to `not specified`.
        """
        return pulumi.get(self, "require_resident_key")

    @require_resident_key.setter
    def require_resident_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "require_resident_key", value)

    @property
    @pulumi.getter(name="signatureAlgorithms")
    def signature_algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of signature algorithms that should be used for the authentication assertion. Valid options at the time these docs were written are `ES256`, `ES384`, `ES512`, `RS256`, `RS384`, `RS512`, and `RS1`.
        """
        return pulumi.get(self, "signature_algorithms")

    @signature_algorithms.setter
    def signature_algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "signature_algorithms", value)

    @property
    @pulumi.getter(name="userVerificationRequirement")
    def user_verification_requirement(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the policy for verifying a user logging in via WebAuthn. Valid options are `not specified`, `required`, `preferred`, or `discouraged`. Defaults to `not specified`.
        """
        return pulumi.get(self, "user_verification_requirement")

    @user_verification_requirement.setter
    def user_verification_requirement(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_verification_requirement", value)


@pulumi.input_type
class UserFederatedIdentityArgs:
    def __init__(__self__, *,
                 identity_provider: pulumi.Input[str],
                 user_id: pulumi.Input[str],
                 user_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] identity_provider: The name of the identity provider
        :param pulumi.Input[str] user_id: The ID of the user defined in the identity provider
        :param pulumi.Input[str] user_name: The user name of the user defined in the identity provider
        """
        UserFederatedIdentityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity_provider=identity_provider,
            user_id=user_id,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity_provider: Optional[pulumi.Input[str]] = None,
             user_id: Optional[pulumi.Input[str]] = None,
             user_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if identity_provider is None and 'identityProvider' in kwargs:
            identity_provider = kwargs['identityProvider']
        if identity_provider is None:
            raise TypeError("Missing 'identity_provider' argument")
        if user_id is None and 'userId' in kwargs:
            user_id = kwargs['userId']
        if user_id is None:
            raise TypeError("Missing 'user_id' argument")
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']
        if user_name is None:
            raise TypeError("Missing 'user_name' argument")

        _setter("identity_provider", identity_provider)
        _setter("user_id", user_id)
        _setter("user_name", user_name)

    @property
    @pulumi.getter(name="identityProvider")
    def identity_provider(self) -> pulumi.Input[str]:
        """
        The name of the identity provider
        """
        return pulumi.get(self, "identity_provider")

    @identity_provider.setter
    def identity_provider(self, value: pulumi.Input[str]):
        pulumi.set(self, "identity_provider", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> pulumi.Input[str]:
        """
        The ID of the user defined in the identity provider
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[str]:
        """
        The user name of the user defined in the identity provider
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class UserInitialPasswordArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 temporary: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] value: The initial password.
        :param pulumi.Input[bool] temporary: If set to `true`, the initial password is set up for renewal on first use. Default to `false`.
        """
        UserInitialPasswordArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
            temporary=temporary,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[str]] = None,
             temporary: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("value", value)
        if temporary is not None:
            _setter("temporary", temporary)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The initial password.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def temporary(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to `true`, the initial password is set up for renewal on first use. Default to `false`.
        """
        return pulumi.get(self, "temporary")

    @temporary.setter
    def temporary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "temporary", value)


@pulumi.input_type
class UsersPermissionsImpersonateScopeArgs:
    def __init__(__self__, *,
                 decision_strategy: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        UsersPermissionsImpersonateScopeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decision_strategy=decision_strategy,
            description=description,
            policies=policies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decision_strategy: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if decision_strategy is None and 'decisionStrategy' in kwargs:
            decision_strategy = kwargs['decisionStrategy']

        if decision_strategy is not None:
            _setter("decision_strategy", decision_strategy)
        if description is not None:
            _setter("description", description)
        if policies is not None:
            _setter("policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "decision_strategy")

    @decision_strategy.setter
    def decision_strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "decision_strategy", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)


@pulumi.input_type
class UsersPermissionsManageGroupMembershipScopeArgs:
    def __init__(__self__, *,
                 decision_strategy: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        UsersPermissionsManageGroupMembershipScopeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decision_strategy=decision_strategy,
            description=description,
            policies=policies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decision_strategy: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if decision_strategy is None and 'decisionStrategy' in kwargs:
            decision_strategy = kwargs['decisionStrategy']

        if decision_strategy is not None:
            _setter("decision_strategy", decision_strategy)
        if description is not None:
            _setter("description", description)
        if policies is not None:
            _setter("policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "decision_strategy")

    @decision_strategy.setter
    def decision_strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "decision_strategy", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)


@pulumi.input_type
class UsersPermissionsManageScopeArgs:
    def __init__(__self__, *,
                 decision_strategy: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        UsersPermissionsManageScopeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decision_strategy=decision_strategy,
            description=description,
            policies=policies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decision_strategy: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if decision_strategy is None and 'decisionStrategy' in kwargs:
            decision_strategy = kwargs['decisionStrategy']

        if decision_strategy is not None:
            _setter("decision_strategy", decision_strategy)
        if description is not None:
            _setter("description", description)
        if policies is not None:
            _setter("policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "decision_strategy")

    @decision_strategy.setter
    def decision_strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "decision_strategy", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)


@pulumi.input_type
class UsersPermissionsMapRolesScopeArgs:
    def __init__(__self__, *,
                 decision_strategy: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        UsersPermissionsMapRolesScopeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decision_strategy=decision_strategy,
            description=description,
            policies=policies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decision_strategy: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if decision_strategy is None and 'decisionStrategy' in kwargs:
            decision_strategy = kwargs['decisionStrategy']

        if decision_strategy is not None:
            _setter("decision_strategy", decision_strategy)
        if description is not None:
            _setter("description", description)
        if policies is not None:
            _setter("policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "decision_strategy")

    @decision_strategy.setter
    def decision_strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "decision_strategy", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)


@pulumi.input_type
class UsersPermissionsUserImpersonatedScopeArgs:
    def __init__(__self__, *,
                 decision_strategy: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        UsersPermissionsUserImpersonatedScopeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decision_strategy=decision_strategy,
            description=description,
            policies=policies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decision_strategy: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if decision_strategy is None and 'decisionStrategy' in kwargs:
            decision_strategy = kwargs['decisionStrategy']

        if decision_strategy is not None:
            _setter("decision_strategy", decision_strategy)
        if description is not None:
            _setter("description", description)
        if policies is not None:
            _setter("policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "decision_strategy")

    @decision_strategy.setter
    def decision_strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "decision_strategy", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)


@pulumi.input_type
class UsersPermissionsViewScopeArgs:
    def __init__(__self__, *,
                 decision_strategy: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        UsersPermissionsViewScopeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decision_strategy=decision_strategy,
            description=description,
            policies=policies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decision_strategy: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if decision_strategy is None and 'decisionStrategy' in kwargs:
            decision_strategy = kwargs['decisionStrategy']

        if decision_strategy is not None:
            _setter("decision_strategy", decision_strategy)
        if description is not None:
            _setter("description", description)
        if policies is not None:
            _setter("policies", policies)

    @property
    @pulumi.getter(name="decisionStrategy")
    def decision_strategy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "decision_strategy")

    @decision_strategy.setter
    def decision_strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "decision_strategy", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)


@pulumi.input_type
class GetRealmInternationalizationArgs:
    def __init__(__self__, *,
                 default_locale: str,
                 supported_locales: Sequence[str]):
        GetRealmInternationalizationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_locale=default_locale,
            supported_locales=supported_locales,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_locale: Optional[str] = None,
             supported_locales: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_locale is None and 'defaultLocale' in kwargs:
            default_locale = kwargs['defaultLocale']
        if default_locale is None:
            raise TypeError("Missing 'default_locale' argument")
        if supported_locales is None and 'supportedLocales' in kwargs:
            supported_locales = kwargs['supportedLocales']
        if supported_locales is None:
            raise TypeError("Missing 'supported_locales' argument")

        _setter("default_locale", default_locale)
        _setter("supported_locales", supported_locales)

    @property
    @pulumi.getter(name="defaultLocale")
    def default_locale(self) -> str:
        return pulumi.get(self, "default_locale")

    @default_locale.setter
    def default_locale(self, value: str):
        pulumi.set(self, "default_locale", value)

    @property
    @pulumi.getter(name="supportedLocales")
    def supported_locales(self) -> Sequence[str]:
        return pulumi.get(self, "supported_locales")

    @supported_locales.setter
    def supported_locales(self, value: Sequence[str]):
        pulumi.set(self, "supported_locales", value)


@pulumi.input_type
class GetRealmOtpPolicyArgs:
    def __init__(__self__, *,
                 algorithm: str,
                 digits: int,
                 initial_counter: int,
                 look_ahead_window: int,
                 period: int,
                 type: str):
        GetRealmOtpPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            algorithm=algorithm,
            digits=digits,
            initial_counter=initial_counter,
            look_ahead_window=look_ahead_window,
            period=period,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             algorithm: Optional[str] = None,
             digits: Optional[int] = None,
             initial_counter: Optional[int] = None,
             look_ahead_window: Optional[int] = None,
             period: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if algorithm is None:
            raise TypeError("Missing 'algorithm' argument")
        if digits is None:
            raise TypeError("Missing 'digits' argument")
        if initial_counter is None and 'initialCounter' in kwargs:
            initial_counter = kwargs['initialCounter']
        if initial_counter is None:
            raise TypeError("Missing 'initial_counter' argument")
        if look_ahead_window is None and 'lookAheadWindow' in kwargs:
            look_ahead_window = kwargs['lookAheadWindow']
        if look_ahead_window is None:
            raise TypeError("Missing 'look_ahead_window' argument")
        if period is None:
            raise TypeError("Missing 'period' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("algorithm", algorithm)
        _setter("digits", digits)
        _setter("initial_counter", initial_counter)
        _setter("look_ahead_window", look_ahead_window)
        _setter("period", period)
        _setter("type", type)

    @property
    @pulumi.getter
    def algorithm(self) -> str:
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: str):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter
    def digits(self) -> int:
        return pulumi.get(self, "digits")

    @digits.setter
    def digits(self, value: int):
        pulumi.set(self, "digits", value)

    @property
    @pulumi.getter(name="initialCounter")
    def initial_counter(self) -> int:
        return pulumi.get(self, "initial_counter")

    @initial_counter.setter
    def initial_counter(self, value: int):
        pulumi.set(self, "initial_counter", value)

    @property
    @pulumi.getter(name="lookAheadWindow")
    def look_ahead_window(self) -> int:
        return pulumi.get(self, "look_ahead_window")

    @look_ahead_window.setter
    def look_ahead_window(self, value: int):
        pulumi.set(self, "look_ahead_window", value)

    @property
    @pulumi.getter
    def period(self) -> int:
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: int):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)


@pulumi.input_type
class GetRealmSecurityDefenseArgs:
    def __init__(__self__, *,
                 brute_force_detections: Sequence['GetRealmSecurityDefenseBruteForceDetectionArgs'],
                 headers: Sequence['GetRealmSecurityDefenseHeaderArgs']):
        GetRealmSecurityDefenseArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            brute_force_detections=brute_force_detections,
            headers=headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             brute_force_detections: Optional[Sequence['GetRealmSecurityDefenseBruteForceDetectionArgs']] = None,
             headers: Optional[Sequence['GetRealmSecurityDefenseHeaderArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if brute_force_detections is None and 'bruteForceDetections' in kwargs:
            brute_force_detections = kwargs['bruteForceDetections']
        if brute_force_detections is None:
            raise TypeError("Missing 'brute_force_detections' argument")
        if headers is None:
            raise TypeError("Missing 'headers' argument")

        _setter("brute_force_detections", brute_force_detections)
        _setter("headers", headers)

    @property
    @pulumi.getter(name="bruteForceDetections")
    def brute_force_detections(self) -> Sequence['GetRealmSecurityDefenseBruteForceDetectionArgs']:
        return pulumi.get(self, "brute_force_detections")

    @brute_force_detections.setter
    def brute_force_detections(self, value: Sequence['GetRealmSecurityDefenseBruteForceDetectionArgs']):
        pulumi.set(self, "brute_force_detections", value)

    @property
    @pulumi.getter
    def headers(self) -> Sequence['GetRealmSecurityDefenseHeaderArgs']:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Sequence['GetRealmSecurityDefenseHeaderArgs']):
        pulumi.set(self, "headers", value)


@pulumi.input_type
class GetRealmSecurityDefenseBruteForceDetectionArgs:
    def __init__(__self__, *,
                 failure_reset_time_seconds: int,
                 max_failure_wait_seconds: int,
                 max_login_failures: int,
                 minimum_quick_login_wait_seconds: int,
                 permanent_lockout: bool,
                 quick_login_check_milli_seconds: int,
                 wait_increment_seconds: int):
        GetRealmSecurityDefenseBruteForceDetectionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_reset_time_seconds=failure_reset_time_seconds,
            max_failure_wait_seconds=max_failure_wait_seconds,
            max_login_failures=max_login_failures,
            minimum_quick_login_wait_seconds=minimum_quick_login_wait_seconds,
            permanent_lockout=permanent_lockout,
            quick_login_check_milli_seconds=quick_login_check_milli_seconds,
            wait_increment_seconds=wait_increment_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_reset_time_seconds: Optional[int] = None,
             max_failure_wait_seconds: Optional[int] = None,
             max_login_failures: Optional[int] = None,
             minimum_quick_login_wait_seconds: Optional[int] = None,
             permanent_lockout: Optional[bool] = None,
             quick_login_check_milli_seconds: Optional[int] = None,
             wait_increment_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if failure_reset_time_seconds is None and 'failureResetTimeSeconds' in kwargs:
            failure_reset_time_seconds = kwargs['failureResetTimeSeconds']
        if failure_reset_time_seconds is None:
            raise TypeError("Missing 'failure_reset_time_seconds' argument")
        if max_failure_wait_seconds is None and 'maxFailureWaitSeconds' in kwargs:
            max_failure_wait_seconds = kwargs['maxFailureWaitSeconds']
        if max_failure_wait_seconds is None:
            raise TypeError("Missing 'max_failure_wait_seconds' argument")
        if max_login_failures is None and 'maxLoginFailures' in kwargs:
            max_login_failures = kwargs['maxLoginFailures']
        if max_login_failures is None:
            raise TypeError("Missing 'max_login_failures' argument")
        if minimum_quick_login_wait_seconds is None and 'minimumQuickLoginWaitSeconds' in kwargs:
            minimum_quick_login_wait_seconds = kwargs['minimumQuickLoginWaitSeconds']
        if minimum_quick_login_wait_seconds is None:
            raise TypeError("Missing 'minimum_quick_login_wait_seconds' argument")
        if permanent_lockout is None and 'permanentLockout' in kwargs:
            permanent_lockout = kwargs['permanentLockout']
        if permanent_lockout is None:
            raise TypeError("Missing 'permanent_lockout' argument")
        if quick_login_check_milli_seconds is None and 'quickLoginCheckMilliSeconds' in kwargs:
            quick_login_check_milli_seconds = kwargs['quickLoginCheckMilliSeconds']
        if quick_login_check_milli_seconds is None:
            raise TypeError("Missing 'quick_login_check_milli_seconds' argument")
        if wait_increment_seconds is None and 'waitIncrementSeconds' in kwargs:
            wait_increment_seconds = kwargs['waitIncrementSeconds']
        if wait_increment_seconds is None:
            raise TypeError("Missing 'wait_increment_seconds' argument")

        _setter("failure_reset_time_seconds", failure_reset_time_seconds)
        _setter("max_failure_wait_seconds", max_failure_wait_seconds)
        _setter("max_login_failures", max_login_failures)
        _setter("minimum_quick_login_wait_seconds", minimum_quick_login_wait_seconds)
        _setter("permanent_lockout", permanent_lockout)
        _setter("quick_login_check_milli_seconds", quick_login_check_milli_seconds)
        _setter("wait_increment_seconds", wait_increment_seconds)

    @property
    @pulumi.getter(name="failureResetTimeSeconds")
    def failure_reset_time_seconds(self) -> int:
        return pulumi.get(self, "failure_reset_time_seconds")

    @failure_reset_time_seconds.setter
    def failure_reset_time_seconds(self, value: int):
        pulumi.set(self, "failure_reset_time_seconds", value)

    @property
    @pulumi.getter(name="maxFailureWaitSeconds")
    def max_failure_wait_seconds(self) -> int:
        return pulumi.get(self, "max_failure_wait_seconds")

    @max_failure_wait_seconds.setter
    def max_failure_wait_seconds(self, value: int):
        pulumi.set(self, "max_failure_wait_seconds", value)

    @property
    @pulumi.getter(name="maxLoginFailures")
    def max_login_failures(self) -> int:
        return pulumi.get(self, "max_login_failures")

    @max_login_failures.setter
    def max_login_failures(self, value: int):
        pulumi.set(self, "max_login_failures", value)

    @property
    @pulumi.getter(name="minimumQuickLoginWaitSeconds")
    def minimum_quick_login_wait_seconds(self) -> int:
        return pulumi.get(self, "minimum_quick_login_wait_seconds")

    @minimum_quick_login_wait_seconds.setter
    def minimum_quick_login_wait_seconds(self, value: int):
        pulumi.set(self, "minimum_quick_login_wait_seconds", value)

    @property
    @pulumi.getter(name="permanentLockout")
    def permanent_lockout(self) -> bool:
        return pulumi.get(self, "permanent_lockout")

    @permanent_lockout.setter
    def permanent_lockout(self, value: bool):
        pulumi.set(self, "permanent_lockout", value)

    @property
    @pulumi.getter(name="quickLoginCheckMilliSeconds")
    def quick_login_check_milli_seconds(self) -> int:
        return pulumi.get(self, "quick_login_check_milli_seconds")

    @quick_login_check_milli_seconds.setter
    def quick_login_check_milli_seconds(self, value: int):
        pulumi.set(self, "quick_login_check_milli_seconds", value)

    @property
    @pulumi.getter(name="waitIncrementSeconds")
    def wait_increment_seconds(self) -> int:
        return pulumi.get(self, "wait_increment_seconds")

    @wait_increment_seconds.setter
    def wait_increment_seconds(self, value: int):
        pulumi.set(self, "wait_increment_seconds", value)


@pulumi.input_type
class GetRealmSecurityDefenseHeaderArgs:
    def __init__(__self__, *,
                 content_security_policy: str,
                 content_security_policy_report_only: str,
                 strict_transport_security: str,
                 x_content_type_options: str,
                 x_frame_options: str,
                 x_robots_tag: str,
                 x_xss_protection: str):
        GetRealmSecurityDefenseHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content_security_policy=content_security_policy,
            content_security_policy_report_only=content_security_policy_report_only,
            strict_transport_security=strict_transport_security,
            x_content_type_options=x_content_type_options,
            x_frame_options=x_frame_options,
            x_robots_tag=x_robots_tag,
            x_xss_protection=x_xss_protection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content_security_policy: Optional[str] = None,
             content_security_policy_report_only: Optional[str] = None,
             strict_transport_security: Optional[str] = None,
             x_content_type_options: Optional[str] = None,
             x_frame_options: Optional[str] = None,
             x_robots_tag: Optional[str] = None,
             x_xss_protection: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if content_security_policy is None and 'contentSecurityPolicy' in kwargs:
            content_security_policy = kwargs['contentSecurityPolicy']
        if content_security_policy is None:
            raise TypeError("Missing 'content_security_policy' argument")
        if content_security_policy_report_only is None and 'contentSecurityPolicyReportOnly' in kwargs:
            content_security_policy_report_only = kwargs['contentSecurityPolicyReportOnly']
        if content_security_policy_report_only is None:
            raise TypeError("Missing 'content_security_policy_report_only' argument")
        if strict_transport_security is None and 'strictTransportSecurity' in kwargs:
            strict_transport_security = kwargs['strictTransportSecurity']
        if strict_transport_security is None:
            raise TypeError("Missing 'strict_transport_security' argument")
        if x_content_type_options is None and 'xContentTypeOptions' in kwargs:
            x_content_type_options = kwargs['xContentTypeOptions']
        if x_content_type_options is None:
            raise TypeError("Missing 'x_content_type_options' argument")
        if x_frame_options is None and 'xFrameOptions' in kwargs:
            x_frame_options = kwargs['xFrameOptions']
        if x_frame_options is None:
            raise TypeError("Missing 'x_frame_options' argument")
        if x_robots_tag is None and 'xRobotsTag' in kwargs:
            x_robots_tag = kwargs['xRobotsTag']
        if x_robots_tag is None:
            raise TypeError("Missing 'x_robots_tag' argument")
        if x_xss_protection is None and 'xXssProtection' in kwargs:
            x_xss_protection = kwargs['xXssProtection']
        if x_xss_protection is None:
            raise TypeError("Missing 'x_xss_protection' argument")

        _setter("content_security_policy", content_security_policy)
        _setter("content_security_policy_report_only", content_security_policy_report_only)
        _setter("strict_transport_security", strict_transport_security)
        _setter("x_content_type_options", x_content_type_options)
        _setter("x_frame_options", x_frame_options)
        _setter("x_robots_tag", x_robots_tag)
        _setter("x_xss_protection", x_xss_protection)

    @property
    @pulumi.getter(name="contentSecurityPolicy")
    def content_security_policy(self) -> str:
        return pulumi.get(self, "content_security_policy")

    @content_security_policy.setter
    def content_security_policy(self, value: str):
        pulumi.set(self, "content_security_policy", value)

    @property
    @pulumi.getter(name="contentSecurityPolicyReportOnly")
    def content_security_policy_report_only(self) -> str:
        return pulumi.get(self, "content_security_policy_report_only")

    @content_security_policy_report_only.setter
    def content_security_policy_report_only(self, value: str):
        pulumi.set(self, "content_security_policy_report_only", value)

    @property
    @pulumi.getter(name="strictTransportSecurity")
    def strict_transport_security(self) -> str:
        return pulumi.get(self, "strict_transport_security")

    @strict_transport_security.setter
    def strict_transport_security(self, value: str):
        pulumi.set(self, "strict_transport_security", value)

    @property
    @pulumi.getter(name="xContentTypeOptions")
    def x_content_type_options(self) -> str:
        return pulumi.get(self, "x_content_type_options")

    @x_content_type_options.setter
    def x_content_type_options(self, value: str):
        pulumi.set(self, "x_content_type_options", value)

    @property
    @pulumi.getter(name="xFrameOptions")
    def x_frame_options(self) -> str:
        return pulumi.get(self, "x_frame_options")

    @x_frame_options.setter
    def x_frame_options(self, value: str):
        pulumi.set(self, "x_frame_options", value)

    @property
    @pulumi.getter(name="xRobotsTag")
    def x_robots_tag(self) -> str:
        return pulumi.get(self, "x_robots_tag")

    @x_robots_tag.setter
    def x_robots_tag(self, value: str):
        pulumi.set(self, "x_robots_tag", value)

    @property
    @pulumi.getter(name="xXssProtection")
    def x_xss_protection(self) -> str:
        return pulumi.get(self, "x_xss_protection")

    @x_xss_protection.setter
    def x_xss_protection(self, value: str):
        pulumi.set(self, "x_xss_protection", value)


@pulumi.input_type
class GetRealmSmtpServerArgs:
    def __init__(__self__, *,
                 auths: Sequence['GetRealmSmtpServerAuthArgs'],
                 envelope_from: str,
                 from_: str,
                 from_display_name: str,
                 host: str,
                 port: str,
                 reply_to: str,
                 reply_to_display_name: str,
                 ssl: bool,
                 starttls: bool):
        GetRealmSmtpServerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auths=auths,
            envelope_from=envelope_from,
            from_=from_,
            from_display_name=from_display_name,
            host=host,
            port=port,
            reply_to=reply_to,
            reply_to_display_name=reply_to_display_name,
            ssl=ssl,
            starttls=starttls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auths: Optional[Sequence['GetRealmSmtpServerAuthArgs']] = None,
             envelope_from: Optional[str] = None,
             from_: Optional[str] = None,
             from_display_name: Optional[str] = None,
             host: Optional[str] = None,
             port: Optional[str] = None,
             reply_to: Optional[str] = None,
             reply_to_display_name: Optional[str] = None,
             ssl: Optional[bool] = None,
             starttls: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auths is None:
            raise TypeError("Missing 'auths' argument")
        if envelope_from is None and 'envelopeFrom' in kwargs:
            envelope_from = kwargs['envelopeFrom']
        if envelope_from is None:
            raise TypeError("Missing 'envelope_from' argument")
        if from_ is None and 'from' in kwargs:
            from_ = kwargs['from']
        if from_ is None:
            raise TypeError("Missing 'from_' argument")
        if from_display_name is None and 'fromDisplayName' in kwargs:
            from_display_name = kwargs['fromDisplayName']
        if from_display_name is None:
            raise TypeError("Missing 'from_display_name' argument")
        if host is None:
            raise TypeError("Missing 'host' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")
        if reply_to is None and 'replyTo' in kwargs:
            reply_to = kwargs['replyTo']
        if reply_to is None:
            raise TypeError("Missing 'reply_to' argument")
        if reply_to_display_name is None and 'replyToDisplayName' in kwargs:
            reply_to_display_name = kwargs['replyToDisplayName']
        if reply_to_display_name is None:
            raise TypeError("Missing 'reply_to_display_name' argument")
        if ssl is None:
            raise TypeError("Missing 'ssl' argument")
        if starttls is None:
            raise TypeError("Missing 'starttls' argument")

        _setter("auths", auths)
        _setter("envelope_from", envelope_from)
        _setter("from_", from_)
        _setter("from_display_name", from_display_name)
        _setter("host", host)
        _setter("port", port)
        _setter("reply_to", reply_to)
        _setter("reply_to_display_name", reply_to_display_name)
        _setter("ssl", ssl)
        _setter("starttls", starttls)

    @property
    @pulumi.getter
    def auths(self) -> Sequence['GetRealmSmtpServerAuthArgs']:
        return pulumi.get(self, "auths")

    @auths.setter
    def auths(self, value: Sequence['GetRealmSmtpServerAuthArgs']):
        pulumi.set(self, "auths", value)

    @property
    @pulumi.getter(name="envelopeFrom")
    def envelope_from(self) -> str:
        return pulumi.get(self, "envelope_from")

    @envelope_from.setter
    def envelope_from(self, value: str):
        pulumi.set(self, "envelope_from", value)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> str:
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: str):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter(name="fromDisplayName")
    def from_display_name(self) -> str:
        return pulumi.get(self, "from_display_name")

    @from_display_name.setter
    def from_display_name(self, value: str):
        pulumi.set(self, "from_display_name", value)

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: str):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> str:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: str):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="replyTo")
    def reply_to(self) -> str:
        return pulumi.get(self, "reply_to")

    @reply_to.setter
    def reply_to(self, value: str):
        pulumi.set(self, "reply_to", value)

    @property
    @pulumi.getter(name="replyToDisplayName")
    def reply_to_display_name(self) -> str:
        return pulumi.get(self, "reply_to_display_name")

    @reply_to_display_name.setter
    def reply_to_display_name(self, value: str):
        pulumi.set(self, "reply_to_display_name", value)

    @property
    @pulumi.getter
    def ssl(self) -> bool:
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: bool):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter
    def starttls(self) -> bool:
        return pulumi.get(self, "starttls")

    @starttls.setter
    def starttls(self, value: bool):
        pulumi.set(self, "starttls", value)


@pulumi.input_type
class GetRealmSmtpServerAuthArgs:
    def __init__(__self__, *,
                 password: str,
                 username: str):
        GetRealmSmtpServerAuthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: str):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: str):
        pulumi.set(self, "username", value)


@pulumi.input_type
class GetRealmWebAuthnPasswordlessPolicyArgs:
    def __init__(__self__, *,
                 acceptable_aaguids: Sequence[str],
                 attestation_conveyance_preference: str,
                 authenticator_attachment: str,
                 avoid_same_authenticator_register: bool,
                 create_timeout: int,
                 relying_party_entity_name: str,
                 relying_party_id: str,
                 require_resident_key: str,
                 signature_algorithms: Sequence[str],
                 user_verification_requirement: str):
        GetRealmWebAuthnPasswordlessPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acceptable_aaguids=acceptable_aaguids,
            attestation_conveyance_preference=attestation_conveyance_preference,
            authenticator_attachment=authenticator_attachment,
            avoid_same_authenticator_register=avoid_same_authenticator_register,
            create_timeout=create_timeout,
            relying_party_entity_name=relying_party_entity_name,
            relying_party_id=relying_party_id,
            require_resident_key=require_resident_key,
            signature_algorithms=signature_algorithms,
            user_verification_requirement=user_verification_requirement,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acceptable_aaguids: Optional[Sequence[str]] = None,
             attestation_conveyance_preference: Optional[str] = None,
             authenticator_attachment: Optional[str] = None,
             avoid_same_authenticator_register: Optional[bool] = None,
             create_timeout: Optional[int] = None,
             relying_party_entity_name: Optional[str] = None,
             relying_party_id: Optional[str] = None,
             require_resident_key: Optional[str] = None,
             signature_algorithms: Optional[Sequence[str]] = None,
             user_verification_requirement: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if acceptable_aaguids is None and 'acceptableAaguids' in kwargs:
            acceptable_aaguids = kwargs['acceptableAaguids']
        if acceptable_aaguids is None:
            raise TypeError("Missing 'acceptable_aaguids' argument")
        if attestation_conveyance_preference is None and 'attestationConveyancePreference' in kwargs:
            attestation_conveyance_preference = kwargs['attestationConveyancePreference']
        if attestation_conveyance_preference is None:
            raise TypeError("Missing 'attestation_conveyance_preference' argument")
        if authenticator_attachment is None and 'authenticatorAttachment' in kwargs:
            authenticator_attachment = kwargs['authenticatorAttachment']
        if authenticator_attachment is None:
            raise TypeError("Missing 'authenticator_attachment' argument")
        if avoid_same_authenticator_register is None and 'avoidSameAuthenticatorRegister' in kwargs:
            avoid_same_authenticator_register = kwargs['avoidSameAuthenticatorRegister']
        if avoid_same_authenticator_register is None:
            raise TypeError("Missing 'avoid_same_authenticator_register' argument")
        if create_timeout is None and 'createTimeout' in kwargs:
            create_timeout = kwargs['createTimeout']
        if create_timeout is None:
            raise TypeError("Missing 'create_timeout' argument")
        if relying_party_entity_name is None and 'relyingPartyEntityName' in kwargs:
            relying_party_entity_name = kwargs['relyingPartyEntityName']
        if relying_party_entity_name is None:
            raise TypeError("Missing 'relying_party_entity_name' argument")
        if relying_party_id is None and 'relyingPartyId' in kwargs:
            relying_party_id = kwargs['relyingPartyId']
        if relying_party_id is None:
            raise TypeError("Missing 'relying_party_id' argument")
        if require_resident_key is None and 'requireResidentKey' in kwargs:
            require_resident_key = kwargs['requireResidentKey']
        if require_resident_key is None:
            raise TypeError("Missing 'require_resident_key' argument")
        if signature_algorithms is None and 'signatureAlgorithms' in kwargs:
            signature_algorithms = kwargs['signatureAlgorithms']
        if signature_algorithms is None:
            raise TypeError("Missing 'signature_algorithms' argument")
        if user_verification_requirement is None and 'userVerificationRequirement' in kwargs:
            user_verification_requirement = kwargs['userVerificationRequirement']
        if user_verification_requirement is None:
            raise TypeError("Missing 'user_verification_requirement' argument")

        _setter("acceptable_aaguids", acceptable_aaguids)
        _setter("attestation_conveyance_preference", attestation_conveyance_preference)
        _setter("authenticator_attachment", authenticator_attachment)
        _setter("avoid_same_authenticator_register", avoid_same_authenticator_register)
        _setter("create_timeout", create_timeout)
        _setter("relying_party_entity_name", relying_party_entity_name)
        _setter("relying_party_id", relying_party_id)
        _setter("require_resident_key", require_resident_key)
        _setter("signature_algorithms", signature_algorithms)
        _setter("user_verification_requirement", user_verification_requirement)

    @property
    @pulumi.getter(name="acceptableAaguids")
    def acceptable_aaguids(self) -> Sequence[str]:
        return pulumi.get(self, "acceptable_aaguids")

    @acceptable_aaguids.setter
    def acceptable_aaguids(self, value: Sequence[str]):
        pulumi.set(self, "acceptable_aaguids", value)

    @property
    @pulumi.getter(name="attestationConveyancePreference")
    def attestation_conveyance_preference(self) -> str:
        return pulumi.get(self, "attestation_conveyance_preference")

    @attestation_conveyance_preference.setter
    def attestation_conveyance_preference(self, value: str):
        pulumi.set(self, "attestation_conveyance_preference", value)

    @property
    @pulumi.getter(name="authenticatorAttachment")
    def authenticator_attachment(self) -> str:
        return pulumi.get(self, "authenticator_attachment")

    @authenticator_attachment.setter
    def authenticator_attachment(self, value: str):
        pulumi.set(self, "authenticator_attachment", value)

    @property
    @pulumi.getter(name="avoidSameAuthenticatorRegister")
    def avoid_same_authenticator_register(self) -> bool:
        return pulumi.get(self, "avoid_same_authenticator_register")

    @avoid_same_authenticator_register.setter
    def avoid_same_authenticator_register(self, value: bool):
        pulumi.set(self, "avoid_same_authenticator_register", value)

    @property
    @pulumi.getter(name="createTimeout")
    def create_timeout(self) -> int:
        return pulumi.get(self, "create_timeout")

    @create_timeout.setter
    def create_timeout(self, value: int):
        pulumi.set(self, "create_timeout", value)

    @property
    @pulumi.getter(name="relyingPartyEntityName")
    def relying_party_entity_name(self) -> str:
        return pulumi.get(self, "relying_party_entity_name")

    @relying_party_entity_name.setter
    def relying_party_entity_name(self, value: str):
        pulumi.set(self, "relying_party_entity_name", value)

    @property
    @pulumi.getter(name="relyingPartyId")
    def relying_party_id(self) -> str:
        return pulumi.get(self, "relying_party_id")

    @relying_party_id.setter
    def relying_party_id(self, value: str):
        pulumi.set(self, "relying_party_id", value)

    @property
    @pulumi.getter(name="requireResidentKey")
    def require_resident_key(self) -> str:
        return pulumi.get(self, "require_resident_key")

    @require_resident_key.setter
    def require_resident_key(self, value: str):
        pulumi.set(self, "require_resident_key", value)

    @property
    @pulumi.getter(name="signatureAlgorithms")
    def signature_algorithms(self) -> Sequence[str]:
        return pulumi.get(self, "signature_algorithms")

    @signature_algorithms.setter
    def signature_algorithms(self, value: Sequence[str]):
        pulumi.set(self, "signature_algorithms", value)

    @property
    @pulumi.getter(name="userVerificationRequirement")
    def user_verification_requirement(self) -> str:
        return pulumi.get(self, "user_verification_requirement")

    @user_verification_requirement.setter
    def user_verification_requirement(self, value: str):
        pulumi.set(self, "user_verification_requirement", value)


@pulumi.input_type
class GetRealmWebAuthnPolicyArgs:
    def __init__(__self__, *,
                 acceptable_aaguids: Sequence[str],
                 attestation_conveyance_preference: str,
                 authenticator_attachment: str,
                 avoid_same_authenticator_register: bool,
                 create_timeout: int,
                 relying_party_entity_name: str,
                 relying_party_id: str,
                 require_resident_key: str,
                 signature_algorithms: Sequence[str],
                 user_verification_requirement: str):
        GetRealmWebAuthnPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acceptable_aaguids=acceptable_aaguids,
            attestation_conveyance_preference=attestation_conveyance_preference,
            authenticator_attachment=authenticator_attachment,
            avoid_same_authenticator_register=avoid_same_authenticator_register,
            create_timeout=create_timeout,
            relying_party_entity_name=relying_party_entity_name,
            relying_party_id=relying_party_id,
            require_resident_key=require_resident_key,
            signature_algorithms=signature_algorithms,
            user_verification_requirement=user_verification_requirement,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acceptable_aaguids: Optional[Sequence[str]] = None,
             attestation_conveyance_preference: Optional[str] = None,
             authenticator_attachment: Optional[str] = None,
             avoid_same_authenticator_register: Optional[bool] = None,
             create_timeout: Optional[int] = None,
             relying_party_entity_name: Optional[str] = None,
             relying_party_id: Optional[str] = None,
             require_resident_key: Optional[str] = None,
             signature_algorithms: Optional[Sequence[str]] = None,
             user_verification_requirement: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if acceptable_aaguids is None and 'acceptableAaguids' in kwargs:
            acceptable_aaguids = kwargs['acceptableAaguids']
        if acceptable_aaguids is None:
            raise TypeError("Missing 'acceptable_aaguids' argument")
        if attestation_conveyance_preference is None and 'attestationConveyancePreference' in kwargs:
            attestation_conveyance_preference = kwargs['attestationConveyancePreference']
        if attestation_conveyance_preference is None:
            raise TypeError("Missing 'attestation_conveyance_preference' argument")
        if authenticator_attachment is None and 'authenticatorAttachment' in kwargs:
            authenticator_attachment = kwargs['authenticatorAttachment']
        if authenticator_attachment is None:
            raise TypeError("Missing 'authenticator_attachment' argument")
        if avoid_same_authenticator_register is None and 'avoidSameAuthenticatorRegister' in kwargs:
            avoid_same_authenticator_register = kwargs['avoidSameAuthenticatorRegister']
        if avoid_same_authenticator_register is None:
            raise TypeError("Missing 'avoid_same_authenticator_register' argument")
        if create_timeout is None and 'createTimeout' in kwargs:
            create_timeout = kwargs['createTimeout']
        if create_timeout is None:
            raise TypeError("Missing 'create_timeout' argument")
        if relying_party_entity_name is None and 'relyingPartyEntityName' in kwargs:
            relying_party_entity_name = kwargs['relyingPartyEntityName']
        if relying_party_entity_name is None:
            raise TypeError("Missing 'relying_party_entity_name' argument")
        if relying_party_id is None and 'relyingPartyId' in kwargs:
            relying_party_id = kwargs['relyingPartyId']
        if relying_party_id is None:
            raise TypeError("Missing 'relying_party_id' argument")
        if require_resident_key is None and 'requireResidentKey' in kwargs:
            require_resident_key = kwargs['requireResidentKey']
        if require_resident_key is None:
            raise TypeError("Missing 'require_resident_key' argument")
        if signature_algorithms is None and 'signatureAlgorithms' in kwargs:
            signature_algorithms = kwargs['signatureAlgorithms']
        if signature_algorithms is None:
            raise TypeError("Missing 'signature_algorithms' argument")
        if user_verification_requirement is None and 'userVerificationRequirement' in kwargs:
            user_verification_requirement = kwargs['userVerificationRequirement']
        if user_verification_requirement is None:
            raise TypeError("Missing 'user_verification_requirement' argument")

        _setter("acceptable_aaguids", acceptable_aaguids)
        _setter("attestation_conveyance_preference", attestation_conveyance_preference)
        _setter("authenticator_attachment", authenticator_attachment)
        _setter("avoid_same_authenticator_register", avoid_same_authenticator_register)
        _setter("create_timeout", create_timeout)
        _setter("relying_party_entity_name", relying_party_entity_name)
        _setter("relying_party_id", relying_party_id)
        _setter("require_resident_key", require_resident_key)
        _setter("signature_algorithms", signature_algorithms)
        _setter("user_verification_requirement", user_verification_requirement)

    @property
    @pulumi.getter(name="acceptableAaguids")
    def acceptable_aaguids(self) -> Sequence[str]:
        return pulumi.get(self, "acceptable_aaguids")

    @acceptable_aaguids.setter
    def acceptable_aaguids(self, value: Sequence[str]):
        pulumi.set(self, "acceptable_aaguids", value)

    @property
    @pulumi.getter(name="attestationConveyancePreference")
    def attestation_conveyance_preference(self) -> str:
        return pulumi.get(self, "attestation_conveyance_preference")

    @attestation_conveyance_preference.setter
    def attestation_conveyance_preference(self, value: str):
        pulumi.set(self, "attestation_conveyance_preference", value)

    @property
    @pulumi.getter(name="authenticatorAttachment")
    def authenticator_attachment(self) -> str:
        return pulumi.get(self, "authenticator_attachment")

    @authenticator_attachment.setter
    def authenticator_attachment(self, value: str):
        pulumi.set(self, "authenticator_attachment", value)

    @property
    @pulumi.getter(name="avoidSameAuthenticatorRegister")
    def avoid_same_authenticator_register(self) -> bool:
        return pulumi.get(self, "avoid_same_authenticator_register")

    @avoid_same_authenticator_register.setter
    def avoid_same_authenticator_register(self, value: bool):
        pulumi.set(self, "avoid_same_authenticator_register", value)

    @property
    @pulumi.getter(name="createTimeout")
    def create_timeout(self) -> int:
        return pulumi.get(self, "create_timeout")

    @create_timeout.setter
    def create_timeout(self, value: int):
        pulumi.set(self, "create_timeout", value)

    @property
    @pulumi.getter(name="relyingPartyEntityName")
    def relying_party_entity_name(self) -> str:
        return pulumi.get(self, "relying_party_entity_name")

    @relying_party_entity_name.setter
    def relying_party_entity_name(self, value: str):
        pulumi.set(self, "relying_party_entity_name", value)

    @property
    @pulumi.getter(name="relyingPartyId")
    def relying_party_id(self) -> str:
        return pulumi.get(self, "relying_party_id")

    @relying_party_id.setter
    def relying_party_id(self, value: str):
        pulumi.set(self, "relying_party_id", value)

    @property
    @pulumi.getter(name="requireResidentKey")
    def require_resident_key(self) -> str:
        return pulumi.get(self, "require_resident_key")

    @require_resident_key.setter
    def require_resident_key(self, value: str):
        pulumi.set(self, "require_resident_key", value)

    @property
    @pulumi.getter(name="signatureAlgorithms")
    def signature_algorithms(self) -> Sequence[str]:
        return pulumi.get(self, "signature_algorithms")

    @signature_algorithms.setter
    def signature_algorithms(self, value: Sequence[str]):
        pulumi.set(self, "signature_algorithms", value)

    @property
    @pulumi.getter(name="userVerificationRequirement")
    def user_verification_requirement(self) -> str:
        return pulumi.get(self, "user_verification_requirement")

    @user_verification_requirement.setter
    def user_verification_requirement(self, value: str):
        pulumi.set(self, "user_verification_requirement", value)


