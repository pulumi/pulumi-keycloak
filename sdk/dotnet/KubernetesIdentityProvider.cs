// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Keycloak
{
    /// <summary>
    /// Allows for creating and managing Kubernetes Identity Providers within Keycloak. Workloads inside a Kubernetes cluster can authenticate using service account tokens.
    /// 
    /// &gt; **NOTICE:**
    /// This is part of a preview keycloak feature. You need to enable this feature to be able to use this resource.
    /// More information about enabling the preview feature can be found here: https://www.keycloak.org/docs/latest/server_admin/index.html#_identity_broker_kubernetes
    /// 
    /// ## Example Usage
    /// 
    /// ### With An OpenID Client
    /// 
    /// ### With A Kubernetes Workload Authentication
    /// 
    /// ### Keycloak configuration
    /// 
    /// ### Kubernetes workload
    /// 
    /// In your Kubernetes workload, you need to mount a service account token with the right audience pointing to your Keycloak instance
    /// 
    /// 1. Issuer URL of the Keycloak realm.
    /// 2. Maximum time allowed by Kubernetes is 3600 seconds
    /// 
    /// ### In the Pod, use curl to authenticate to Keycloak:
    /// 
    /// ### And the response should look something like:
    /// 
    /// &gt; **NOTICE:**
    /// Changing authentication flow bindings in your Realm settings can break existing clients' ability to authenticate, if not configured properly!
    /// 
    /// ## Import
    /// 
    /// Identity providers can be imported using the format `{{realm_id}}/{{idp_alias}}`, where `IdpAlias` is the identity provider alias.
    /// 
    /// Example:
    /// </summary>
    [KeycloakResourceType("keycloak:index/kubernetesIdentityProvider:KubernetesIdentityProvider")]
    public partial class KubernetesIdentityProvider : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.
        /// </summary>
        [Output("addReadTokenRoleOnCreate")]
        public Output<bool?> AddReadTokenRoleOnCreate { get; private set; } = null!;

        /// <summary>
        /// The alias uniquely identifies an identity provider, and it is also used to build the redirect uri.
        /// </summary>
        [Output("alias")]
        public Output<string> Alias { get; private set; } = null!;

        /// <summary>
        /// Enable/disable authenticate users by default.
        /// </summary>
        [Output("authenticateByDefault")]
        public Output<bool?> AuthenticateByDefault { get; private set; } = null!;

        /// <summary>
        /// Friendly name for Identity Providers.
        /// </summary>
        [Output("displayName")]
        public Output<string?> DisplayName { get; private set; } = null!;

        /// <summary>
        /// Enable/disable this identity provider.
        /// </summary>
        [Output("enabled")]
        public Output<bool?> Enabled { get; private set; } = null!;

        [Output("extraConfig")]
        public Output<ImmutableDictionary<string, string>?> ExtraConfig { get; private set; } = null!;

        /// <summary>
        /// Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that there is not yet existing Keycloak account linked with the authenticated identity provider account.
        /// </summary>
        [Output("firstBrokerLoginFlowAlias")]
        public Output<string?> FirstBrokerLoginFlowAlias { get; private set; } = null!;

        /// <summary>
        /// GUI Order
        /// </summary>
        [Output("guiOrder")]
        public Output<string?> GuiOrder { get; private set; } = null!;

        /// <summary>
        /// This is always set to true for Kubernetes identity provider.
        /// </summary>
        [Output("hideOnLoginPage")]
        public Output<bool> HideOnLoginPage { get; private set; } = null!;

        /// <summary>
        /// Internal Identity Provider Id
        /// </summary>
        [Output("internalId")]
        public Output<string> InternalId { get; private set; } = null!;

        /// <summary>
        /// The Kubernetes issuer URL of service account tokens. The URL &lt;ISSUER&gt;/.well-known/openid-configuration must be available to Keycloak.
        /// </summary>
        [Output("issuer")]
        public Output<string> Issuer { get; private set; } = null!;

        /// <summary>
        /// If true, users cannot log in through this provider.  They can only link to this provider.  This is useful if you don't want to allow login from the provider, but want to integrate with a provider
        /// </summary>
        [Output("linkOnly")]
        public Output<bool?> LinkOnly { get; private set; } = null!;

        [Output("orgDomain")]
        public Output<string?> OrgDomain { get; private set; } = null!;

        [Output("orgRedirectModeEmailMatches")]
        public Output<bool?> OrgRedirectModeEmailMatches { get; private set; } = null!;

        /// <summary>
        /// ID of organization with which this identity is linked.
        /// </summary>
        [Output("organizationId")]
        public Output<string?> OrganizationId { get; private set; } = null!;

        /// <summary>
        /// Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it.
        /// </summary>
        [Output("postBrokerLoginFlowAlias")]
        public Output<string?> PostBrokerLoginFlowAlias { get; private set; } = null!;

        /// <summary>
        /// Provider ID, is always kubernetes.
        /// </summary>
        [Output("providerId")]
        public Output<string?> ProviderId { get; private set; } = null!;

        /// <summary>
        /// The name of the realm. This is unique across Keycloak.
        /// </summary>
        [Output("realm")]
        public Output<string> Realm { get; private set; } = null!;

        /// <summary>
        /// Enable/disable if tokens must be stored after authenticating users.
        /// </summary>
        [Output("storeToken")]
        public Output<bool?> StoreToken { get; private set; } = null!;

        /// <summary>
        /// Sync Mode
        /// </summary>
        [Output("syncMode")]
        public Output<string?> SyncMode { get; private set; } = null!;

        /// <summary>
        /// If enabled then email provided by this provider is not verified even if verification is enabled for the realm.
        /// </summary>
        [Output("trustEmail")]
        public Output<bool?> TrustEmail { get; private set; } = null!;


        /// <summary>
        /// Create a KubernetesIdentityProvider resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public KubernetesIdentityProvider(string name, KubernetesIdentityProviderArgs args, CustomResourceOptions? options = null)
            : base("keycloak:index/kubernetesIdentityProvider:KubernetesIdentityProvider", name, args ?? new KubernetesIdentityProviderArgs(), MakeResourceOptions(options, ""))
        {
        }

        private KubernetesIdentityProvider(string name, Input<string> id, KubernetesIdentityProviderState? state = null, CustomResourceOptions? options = null)
            : base("keycloak:index/kubernetesIdentityProvider:KubernetesIdentityProvider", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing KubernetesIdentityProvider resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static KubernetesIdentityProvider Get(string name, Input<string> id, KubernetesIdentityProviderState? state = null, CustomResourceOptions? options = null)
        {
            return new KubernetesIdentityProvider(name, id, state, options);
        }
    }

    public sealed class KubernetesIdentityProviderArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.
        /// </summary>
        [Input("addReadTokenRoleOnCreate")]
        public Input<bool>? AddReadTokenRoleOnCreate { get; set; }

        /// <summary>
        /// The alias uniquely identifies an identity provider, and it is also used to build the redirect uri.
        /// </summary>
        [Input("alias", required: true)]
        public Input<string> Alias { get; set; } = null!;

        /// <summary>
        /// Enable/disable authenticate users by default.
        /// </summary>
        [Input("authenticateByDefault")]
        public Input<bool>? AuthenticateByDefault { get; set; }

        /// <summary>
        /// Friendly name for Identity Providers.
        /// </summary>
        [Input("displayName")]
        public Input<string>? DisplayName { get; set; }

        /// <summary>
        /// Enable/disable this identity provider.
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        [Input("extraConfig")]
        private InputMap<string>? _extraConfig;
        public InputMap<string> ExtraConfig
        {
            get => _extraConfig ?? (_extraConfig = new InputMap<string>());
            set => _extraConfig = value;
        }

        /// <summary>
        /// Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that there is not yet existing Keycloak account linked with the authenticated identity provider account.
        /// </summary>
        [Input("firstBrokerLoginFlowAlias")]
        public Input<string>? FirstBrokerLoginFlowAlias { get; set; }

        /// <summary>
        /// GUI Order
        /// </summary>
        [Input("guiOrder")]
        public Input<string>? GuiOrder { get; set; }

        /// <summary>
        /// The Kubernetes issuer URL of service account tokens. The URL &lt;ISSUER&gt;/.well-known/openid-configuration must be available to Keycloak.
        /// </summary>
        [Input("issuer", required: true)]
        public Input<string> Issuer { get; set; } = null!;

        /// <summary>
        /// If true, users cannot log in through this provider.  They can only link to this provider.  This is useful if you don't want to allow login from the provider, but want to integrate with a provider
        /// </summary>
        [Input("linkOnly")]
        public Input<bool>? LinkOnly { get; set; }

        [Input("orgDomain")]
        public Input<string>? OrgDomain { get; set; }

        [Input("orgRedirectModeEmailMatches")]
        public Input<bool>? OrgRedirectModeEmailMatches { get; set; }

        /// <summary>
        /// ID of organization with which this identity is linked.
        /// </summary>
        [Input("organizationId")]
        public Input<string>? OrganizationId { get; set; }

        /// <summary>
        /// Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it.
        /// </summary>
        [Input("postBrokerLoginFlowAlias")]
        public Input<string>? PostBrokerLoginFlowAlias { get; set; }

        /// <summary>
        /// Provider ID, is always kubernetes.
        /// </summary>
        [Input("providerId")]
        public Input<string>? ProviderId { get; set; }

        /// <summary>
        /// The name of the realm. This is unique across Keycloak.
        /// </summary>
        [Input("realm", required: true)]
        public Input<string> Realm { get; set; } = null!;

        /// <summary>
        /// Enable/disable if tokens must be stored after authenticating users.
        /// </summary>
        [Input("storeToken")]
        public Input<bool>? StoreToken { get; set; }

        /// <summary>
        /// Sync Mode
        /// </summary>
        [Input("syncMode")]
        public Input<string>? SyncMode { get; set; }

        /// <summary>
        /// If enabled then email provided by this provider is not verified even if verification is enabled for the realm.
        /// </summary>
        [Input("trustEmail")]
        public Input<bool>? TrustEmail { get; set; }

        public KubernetesIdentityProviderArgs()
        {
        }
        public static new KubernetesIdentityProviderArgs Empty => new KubernetesIdentityProviderArgs();
    }

    public sealed class KubernetesIdentityProviderState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.
        /// </summary>
        [Input("addReadTokenRoleOnCreate")]
        public Input<bool>? AddReadTokenRoleOnCreate { get; set; }

        /// <summary>
        /// The alias uniquely identifies an identity provider, and it is also used to build the redirect uri.
        /// </summary>
        [Input("alias")]
        public Input<string>? Alias { get; set; }

        /// <summary>
        /// Enable/disable authenticate users by default.
        /// </summary>
        [Input("authenticateByDefault")]
        public Input<bool>? AuthenticateByDefault { get; set; }

        /// <summary>
        /// Friendly name for Identity Providers.
        /// </summary>
        [Input("displayName")]
        public Input<string>? DisplayName { get; set; }

        /// <summary>
        /// Enable/disable this identity provider.
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        [Input("extraConfig")]
        private InputMap<string>? _extraConfig;
        public InputMap<string> ExtraConfig
        {
            get => _extraConfig ?? (_extraConfig = new InputMap<string>());
            set => _extraConfig = value;
        }

        /// <summary>
        /// Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that there is not yet existing Keycloak account linked with the authenticated identity provider account.
        /// </summary>
        [Input("firstBrokerLoginFlowAlias")]
        public Input<string>? FirstBrokerLoginFlowAlias { get; set; }

        /// <summary>
        /// GUI Order
        /// </summary>
        [Input("guiOrder")]
        public Input<string>? GuiOrder { get; set; }

        /// <summary>
        /// This is always set to true for Kubernetes identity provider.
        /// </summary>
        [Input("hideOnLoginPage")]
        public Input<bool>? HideOnLoginPage { get; set; }

        /// <summary>
        /// Internal Identity Provider Id
        /// </summary>
        [Input("internalId")]
        public Input<string>? InternalId { get; set; }

        /// <summary>
        /// The Kubernetes issuer URL of service account tokens. The URL &lt;ISSUER&gt;/.well-known/openid-configuration must be available to Keycloak.
        /// </summary>
        [Input("issuer")]
        public Input<string>? Issuer { get; set; }

        /// <summary>
        /// If true, users cannot log in through this provider.  They can only link to this provider.  This is useful if you don't want to allow login from the provider, but want to integrate with a provider
        /// </summary>
        [Input("linkOnly")]
        public Input<bool>? LinkOnly { get; set; }

        [Input("orgDomain")]
        public Input<string>? OrgDomain { get; set; }

        [Input("orgRedirectModeEmailMatches")]
        public Input<bool>? OrgRedirectModeEmailMatches { get; set; }

        /// <summary>
        /// ID of organization with which this identity is linked.
        /// </summary>
        [Input("organizationId")]
        public Input<string>? OrganizationId { get; set; }

        /// <summary>
        /// Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you don't want any additional authenticators to be triggered after login with this identity provider. Also note, that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it.
        /// </summary>
        [Input("postBrokerLoginFlowAlias")]
        public Input<string>? PostBrokerLoginFlowAlias { get; set; }

        /// <summary>
        /// Provider ID, is always kubernetes.
        /// </summary>
        [Input("providerId")]
        public Input<string>? ProviderId { get; set; }

        /// <summary>
        /// The name of the realm. This is unique across Keycloak.
        /// </summary>
        [Input("realm")]
        public Input<string>? Realm { get; set; }

        /// <summary>
        /// Enable/disable if tokens must be stored after authenticating users.
        /// </summary>
        [Input("storeToken")]
        public Input<bool>? StoreToken { get; set; }

        /// <summary>
        /// Sync Mode
        /// </summary>
        [Input("syncMode")]
        public Input<string>? SyncMode { get; set; }

        /// <summary>
        /// If enabled then email provided by this provider is not verified even if verification is enabled for the realm.
        /// </summary>
        [Input("trustEmail")]
        public Input<bool>? TrustEmail { get; set; }

        public KubernetesIdentityProviderState()
        {
        }
        public static new KubernetesIdentityProviderState Empty => new KubernetesIdentityProviderState();
    }
}
