// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package openid

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Allows for creating and managing audience protocol mappers within Keycloak.
//
// Audience protocol mappers allow you add audiences to the `aud` claim within issued tokens. The audience can be a custom
// string, or it can be mapped to the ID of a pre-existing client.
//
// ## Example Usage
// ### Client)
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak"
// 	"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		realm, err := keycloak.NewRealm(ctx, "realm", &keycloak.RealmArgs{
// 			Realm:   pulumi.String("my-realm"),
// 			Enabled: pulumi.Bool(true),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		openidClient, err := openid.NewClient(ctx, "openidClient", &openid.ClientArgs{
// 			RealmId:    realm.ID(),
// 			ClientId:   pulumi.String("client"),
// 			Enabled:    pulumi.Bool(true),
// 			AccessType: pulumi.String("CONFIDENTIAL"),
// 			ValidRedirectUris: pulumi.StringArray{
// 				pulumi.String("http://localhost:8080/openid-callback"),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = openid.NewAudienceProtocolMapper(ctx, "audienceMapper", &openid.AudienceProtocolMapperArgs{
// 			RealmId:                realm.ID(),
// 			ClientId:               openidClient.ID(),
// 			IncludedCustomAudience: pulumi.String("foo"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ### Client Scope)
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak"
// 	"github.com/pulumi/pulumi-keycloak/sdk/v4/go/keycloak/openid"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		realm, err := keycloak.NewRealm(ctx, "realm", &keycloak.RealmArgs{
// 			Realm:   pulumi.String("my-realm"),
// 			Enabled: pulumi.Bool(true),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		clientScope, err := openid.NewClientScope(ctx, "clientScope", &openid.ClientScopeArgs{
// 			RealmId: realm.ID(),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = openid.NewAudienceProtocolMapper(ctx, "audienceMapper", &openid.AudienceProtocolMapperArgs{
// 			RealmId:                realm.ID(),
// 			ClientScopeId:          clientScope.ID(),
// 			IncludedCustomAudience: pulumi.String("foo"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// Protocol mappers can be imported using one of the following formats- Client`{{realm_id}}/client/{{client_keycloak_id}}/{{protocol_mapper_id}}` - Client Scope`{{realm_id}}/client-scope/{{client_scope_keycloak_id}}/{{protocol_mapper_id}}` Examplebash
//
// ```sh
//  $ pulumi import keycloak:openid/audienceProtocolMapper:AudienceProtocolMapper audience_mapper my-realm/client/a7202154-8793-4656-b655-1dd18c181e14/71602afa-f7d1-4788-8c49-ef8fd00af0f4
// ```
//
// ```sh
//  $ pulumi import keycloak:openid/audienceProtocolMapper:AudienceProtocolMapper audience_mapper my-realm/client-scope/b799ea7e-73ee-4a73-990a-1eafebe8e20a/71602afa-f7d1-4788-8c49-ef8fd00af0f4
// ```
type AudienceProtocolMapper struct {
	pulumi.CustomResourceState

	// Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.
	AddToAccessToken pulumi.BoolPtrOutput `pulumi:"addToAccessToken"`
	// Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.
	AddToIdToken pulumi.BoolPtrOutput `pulumi:"addToIdToken"`
	// The client this protocol mapper should be attached to. Conflicts with `clientScopeId`. One of `clientId` or `clientScopeId` must be specified.
	ClientId pulumi.StringPtrOutput `pulumi:"clientId"`
	// The client scope this protocol mapper should be attached to. Conflicts with `clientId`. One of `clientId` or `clientScopeId` must be specified.
	ClientScopeId pulumi.StringPtrOutput `pulumi:"clientScopeId"`
	// A client ID to include within the token's `aud` claim. Conflicts with `includedCustomAudience`. One of `includedClientAudience` or `includedCustomAudience` must be specified.
	IncludedClientAudience pulumi.StringPtrOutput `pulumi:"includedClientAudience"`
	// A custom audience to include within the token's `aud` claim. Conflicts with `includedClientAudience`. One of `includedClientAudience` or `includedCustomAudience` must be specified.
	IncludedCustomAudience pulumi.StringPtrOutput `pulumi:"includedCustomAudience"`
	// The display name of this protocol mapper in the GUI.
	Name pulumi.StringOutput `pulumi:"name"`
	// The realm this protocol mapper exists within.
	RealmId pulumi.StringOutput `pulumi:"realmId"`
}

// NewAudienceProtocolMapper registers a new resource with the given unique name, arguments, and options.
func NewAudienceProtocolMapper(ctx *pulumi.Context,
	name string, args *AudienceProtocolMapperArgs, opts ...pulumi.ResourceOption) (*AudienceProtocolMapper, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.RealmId == nil {
		return nil, errors.New("invalid value for required argument 'RealmId'")
	}
	var resource AudienceProtocolMapper
	err := ctx.RegisterResource("keycloak:openid/audienceProtocolMapper:AudienceProtocolMapper", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAudienceProtocolMapper gets an existing AudienceProtocolMapper resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAudienceProtocolMapper(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AudienceProtocolMapperState, opts ...pulumi.ResourceOption) (*AudienceProtocolMapper, error) {
	var resource AudienceProtocolMapper
	err := ctx.ReadResource("keycloak:openid/audienceProtocolMapper:AudienceProtocolMapper", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AudienceProtocolMapper resources.
type audienceProtocolMapperState struct {
	// Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.
	AddToAccessToken *bool `pulumi:"addToAccessToken"`
	// Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.
	AddToIdToken *bool `pulumi:"addToIdToken"`
	// The client this protocol mapper should be attached to. Conflicts with `clientScopeId`. One of `clientId` or `clientScopeId` must be specified.
	ClientId *string `pulumi:"clientId"`
	// The client scope this protocol mapper should be attached to. Conflicts with `clientId`. One of `clientId` or `clientScopeId` must be specified.
	ClientScopeId *string `pulumi:"clientScopeId"`
	// A client ID to include within the token's `aud` claim. Conflicts with `includedCustomAudience`. One of `includedClientAudience` or `includedCustomAudience` must be specified.
	IncludedClientAudience *string `pulumi:"includedClientAudience"`
	// A custom audience to include within the token's `aud` claim. Conflicts with `includedClientAudience`. One of `includedClientAudience` or `includedCustomAudience` must be specified.
	IncludedCustomAudience *string `pulumi:"includedCustomAudience"`
	// The display name of this protocol mapper in the GUI.
	Name *string `pulumi:"name"`
	// The realm this protocol mapper exists within.
	RealmId *string `pulumi:"realmId"`
}

type AudienceProtocolMapperState struct {
	// Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.
	AddToAccessToken pulumi.BoolPtrInput
	// Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.
	AddToIdToken pulumi.BoolPtrInput
	// The client this protocol mapper should be attached to. Conflicts with `clientScopeId`. One of `clientId` or `clientScopeId` must be specified.
	ClientId pulumi.StringPtrInput
	// The client scope this protocol mapper should be attached to. Conflicts with `clientId`. One of `clientId` or `clientScopeId` must be specified.
	ClientScopeId pulumi.StringPtrInput
	// A client ID to include within the token's `aud` claim. Conflicts with `includedCustomAudience`. One of `includedClientAudience` or `includedCustomAudience` must be specified.
	IncludedClientAudience pulumi.StringPtrInput
	// A custom audience to include within the token's `aud` claim. Conflicts with `includedClientAudience`. One of `includedClientAudience` or `includedCustomAudience` must be specified.
	IncludedCustomAudience pulumi.StringPtrInput
	// The display name of this protocol mapper in the GUI.
	Name pulumi.StringPtrInput
	// The realm this protocol mapper exists within.
	RealmId pulumi.StringPtrInput
}

func (AudienceProtocolMapperState) ElementType() reflect.Type {
	return reflect.TypeOf((*audienceProtocolMapperState)(nil)).Elem()
}

type audienceProtocolMapperArgs struct {
	// Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.
	AddToAccessToken *bool `pulumi:"addToAccessToken"`
	// Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.
	AddToIdToken *bool `pulumi:"addToIdToken"`
	// The client this protocol mapper should be attached to. Conflicts with `clientScopeId`. One of `clientId` or `clientScopeId` must be specified.
	ClientId *string `pulumi:"clientId"`
	// The client scope this protocol mapper should be attached to. Conflicts with `clientId`. One of `clientId` or `clientScopeId` must be specified.
	ClientScopeId *string `pulumi:"clientScopeId"`
	// A client ID to include within the token's `aud` claim. Conflicts with `includedCustomAudience`. One of `includedClientAudience` or `includedCustomAudience` must be specified.
	IncludedClientAudience *string `pulumi:"includedClientAudience"`
	// A custom audience to include within the token's `aud` claim. Conflicts with `includedClientAudience`. One of `includedClientAudience` or `includedCustomAudience` must be specified.
	IncludedCustomAudience *string `pulumi:"includedCustomAudience"`
	// The display name of this protocol mapper in the GUI.
	Name *string `pulumi:"name"`
	// The realm this protocol mapper exists within.
	RealmId string `pulumi:"realmId"`
}

// The set of arguments for constructing a AudienceProtocolMapper resource.
type AudienceProtocolMapperArgs struct {
	// Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.
	AddToAccessToken pulumi.BoolPtrInput
	// Indicates if the audience should be included in the `aud` claim for the id token. Defaults to `true`.
	AddToIdToken pulumi.BoolPtrInput
	// The client this protocol mapper should be attached to. Conflicts with `clientScopeId`. One of `clientId` or `clientScopeId` must be specified.
	ClientId pulumi.StringPtrInput
	// The client scope this protocol mapper should be attached to. Conflicts with `clientId`. One of `clientId` or `clientScopeId` must be specified.
	ClientScopeId pulumi.StringPtrInput
	// A client ID to include within the token's `aud` claim. Conflicts with `includedCustomAudience`. One of `includedClientAudience` or `includedCustomAudience` must be specified.
	IncludedClientAudience pulumi.StringPtrInput
	// A custom audience to include within the token's `aud` claim. Conflicts with `includedClientAudience`. One of `includedClientAudience` or `includedCustomAudience` must be specified.
	IncludedCustomAudience pulumi.StringPtrInput
	// The display name of this protocol mapper in the GUI.
	Name pulumi.StringPtrInput
	// The realm this protocol mapper exists within.
	RealmId pulumi.StringInput
}

func (AudienceProtocolMapperArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*audienceProtocolMapperArgs)(nil)).Elem()
}

type AudienceProtocolMapperInput interface {
	pulumi.Input

	ToAudienceProtocolMapperOutput() AudienceProtocolMapperOutput
	ToAudienceProtocolMapperOutputWithContext(ctx context.Context) AudienceProtocolMapperOutput
}

func (*AudienceProtocolMapper) ElementType() reflect.Type {
	return reflect.TypeOf((**AudienceProtocolMapper)(nil)).Elem()
}

func (i *AudienceProtocolMapper) ToAudienceProtocolMapperOutput() AudienceProtocolMapperOutput {
	return i.ToAudienceProtocolMapperOutputWithContext(context.Background())
}

func (i *AudienceProtocolMapper) ToAudienceProtocolMapperOutputWithContext(ctx context.Context) AudienceProtocolMapperOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AudienceProtocolMapperOutput)
}

// AudienceProtocolMapperArrayInput is an input type that accepts AudienceProtocolMapperArray and AudienceProtocolMapperArrayOutput values.
// You can construct a concrete instance of `AudienceProtocolMapperArrayInput` via:
//
//          AudienceProtocolMapperArray{ AudienceProtocolMapperArgs{...} }
type AudienceProtocolMapperArrayInput interface {
	pulumi.Input

	ToAudienceProtocolMapperArrayOutput() AudienceProtocolMapperArrayOutput
	ToAudienceProtocolMapperArrayOutputWithContext(context.Context) AudienceProtocolMapperArrayOutput
}

type AudienceProtocolMapperArray []AudienceProtocolMapperInput

func (AudienceProtocolMapperArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AudienceProtocolMapper)(nil)).Elem()
}

func (i AudienceProtocolMapperArray) ToAudienceProtocolMapperArrayOutput() AudienceProtocolMapperArrayOutput {
	return i.ToAudienceProtocolMapperArrayOutputWithContext(context.Background())
}

func (i AudienceProtocolMapperArray) ToAudienceProtocolMapperArrayOutputWithContext(ctx context.Context) AudienceProtocolMapperArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AudienceProtocolMapperArrayOutput)
}

// AudienceProtocolMapperMapInput is an input type that accepts AudienceProtocolMapperMap and AudienceProtocolMapperMapOutput values.
// You can construct a concrete instance of `AudienceProtocolMapperMapInput` via:
//
//          AudienceProtocolMapperMap{ "key": AudienceProtocolMapperArgs{...} }
type AudienceProtocolMapperMapInput interface {
	pulumi.Input

	ToAudienceProtocolMapperMapOutput() AudienceProtocolMapperMapOutput
	ToAudienceProtocolMapperMapOutputWithContext(context.Context) AudienceProtocolMapperMapOutput
}

type AudienceProtocolMapperMap map[string]AudienceProtocolMapperInput

func (AudienceProtocolMapperMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AudienceProtocolMapper)(nil)).Elem()
}

func (i AudienceProtocolMapperMap) ToAudienceProtocolMapperMapOutput() AudienceProtocolMapperMapOutput {
	return i.ToAudienceProtocolMapperMapOutputWithContext(context.Background())
}

func (i AudienceProtocolMapperMap) ToAudienceProtocolMapperMapOutputWithContext(ctx context.Context) AudienceProtocolMapperMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AudienceProtocolMapperMapOutput)
}

type AudienceProtocolMapperOutput struct{ *pulumi.OutputState }

func (AudienceProtocolMapperOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AudienceProtocolMapper)(nil)).Elem()
}

func (o AudienceProtocolMapperOutput) ToAudienceProtocolMapperOutput() AudienceProtocolMapperOutput {
	return o
}

func (o AudienceProtocolMapperOutput) ToAudienceProtocolMapperOutputWithContext(ctx context.Context) AudienceProtocolMapperOutput {
	return o
}

type AudienceProtocolMapperArrayOutput struct{ *pulumi.OutputState }

func (AudienceProtocolMapperArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AudienceProtocolMapper)(nil)).Elem()
}

func (o AudienceProtocolMapperArrayOutput) ToAudienceProtocolMapperArrayOutput() AudienceProtocolMapperArrayOutput {
	return o
}

func (o AudienceProtocolMapperArrayOutput) ToAudienceProtocolMapperArrayOutputWithContext(ctx context.Context) AudienceProtocolMapperArrayOutput {
	return o
}

func (o AudienceProtocolMapperArrayOutput) Index(i pulumi.IntInput) AudienceProtocolMapperOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AudienceProtocolMapper {
		return vs[0].([]*AudienceProtocolMapper)[vs[1].(int)]
	}).(AudienceProtocolMapperOutput)
}

type AudienceProtocolMapperMapOutput struct{ *pulumi.OutputState }

func (AudienceProtocolMapperMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AudienceProtocolMapper)(nil)).Elem()
}

func (o AudienceProtocolMapperMapOutput) ToAudienceProtocolMapperMapOutput() AudienceProtocolMapperMapOutput {
	return o
}

func (o AudienceProtocolMapperMapOutput) ToAudienceProtocolMapperMapOutputWithContext(ctx context.Context) AudienceProtocolMapperMapOutput {
	return o
}

func (o AudienceProtocolMapperMapOutput) MapIndex(k pulumi.StringInput) AudienceProtocolMapperOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AudienceProtocolMapper {
		return vs[0].(map[string]*AudienceProtocolMapper)[vs[1].(string)]
	}).(AudienceProtocolMapperOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AudienceProtocolMapperInput)(nil)).Elem(), &AudienceProtocolMapper{})
	pulumi.RegisterInputType(reflect.TypeOf((*AudienceProtocolMapperArrayInput)(nil)).Elem(), AudienceProtocolMapperArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AudienceProtocolMapperMapInput)(nil)).Elem(), AudienceProtocolMapperMap{})
	pulumi.RegisterOutputType(AudienceProtocolMapperOutput{})
	pulumi.RegisterOutputType(AudienceProtocolMapperArrayOutput{})
	pulumi.RegisterOutputType(AudienceProtocolMapperMapOutput{})
}
