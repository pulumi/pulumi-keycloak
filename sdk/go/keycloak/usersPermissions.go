// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package keycloak

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-keycloak/sdk/v6/go/keycloak/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Allows you to manage fine-grained permissions for all users in a realm: https://www.keycloak.org/docs/latest/server_admin/#_users-permissions
//
// This is part of a preview Keycloak feature: `adminFineGrainedAuthz` (see https://www.keycloak.org/docs/latest/server_admin/#_fine_grain_permissions).
// This feature can be enabled with the Keycloak option `-Dkeycloak.profile.feature.admin_fine_grained_authz=enabled`. See the
// example `docker-compose.yml` file for an example.
//
// When enabling fine-grained permissions for users, Keycloak does several things automatically:
// 1. Enable Authorization on built-in `realm-management` client (if not already enabled).
// 2. Create a resource representing the users permissions.
// 3. Create scopes `view`, `manage`, `map-roles`, `manage-group-membership`, `impersonate`, and `user-impersonated`.
// 4. Create all scope based permission for the scopes and users resources.
//
// > This resource should only be created once per realm.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-keycloak/sdk/v6/go/keycloak"
//	"github.com/pulumi/pulumi-keycloak/sdk/v6/go/keycloak/openid"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			realm, err := keycloak.NewRealm(ctx, "realm", &keycloak.RealmArgs{
//				Realm: pulumi.String("my-realm"),
//			})
//			if err != nil {
//				return err
//			}
//			realmManagement := openid.LookupClientOutput(ctx, openid.GetClientOutputArgs{
//				RealmId:  realm.ID(),
//				ClientId: pulumi.String("realm-management"),
//			}, nil)
//			// enable permissions for realm-management client
//			realmManagementPermission, err := openid.NewClientPermissions(ctx, "realm_management_permission", &openid.ClientPermissionsArgs{
//				RealmId: realm.ID(),
//				ClientId: pulumi.String(realmManagement.ApplyT(func(realmManagement openid.GetClientResult) (*string, error) {
//					return &realmManagement.Id, nil
//				}).(pulumi.StringPtrOutput)),
//				Enabled: true,
//			})
//			if err != nil {
//				return err
//			}
//			// creating a user to use with the keycloak_openid_client_user_policy resource
//			test, err := keycloak.NewUser(ctx, "test", &keycloak.UserArgs{
//				RealmId:   realm.ID(),
//				Username:  pulumi.String("test-user"),
//				Email:     pulumi.String("test-user@fakedomain.com"),
//				FirstName: pulumi.String("Testy"),
//				LastName:  pulumi.String("Tester"),
//			})
//			if err != nil {
//				return err
//			}
//			testClientUserPolicy, err := openid.NewClientUserPolicy(ctx, "test", &openid.ClientUserPolicyArgs{
//				RealmId: realm.ID(),
//				ResourceServerId: pulumi.String(realmManagement.ApplyT(func(realmManagement openid.GetClientResult) (*string, error) {
//					return &realmManagement.Id, nil
//				}).(pulumi.StringPtrOutput)),
//				Name: pulumi.String("client_user_policy_test"),
//				Users: pulumi.StringArray{
//					test.ID(),
//				},
//				Logic:            pulumi.String("POSITIVE"),
//				DecisionStrategy: pulumi.String("UNANIMOUS"),
//			}, pulumi.DependsOn([]pulumi.Resource{
//				realmManagementPermission,
//			}))
//			if err != nil {
//				return err
//			}
//			_, err = keycloak.NewUsersPermissions(ctx, "users_permissions", &keycloak.UsersPermissionsArgs{
//				RealmId: realm.ID(),
//				ViewScope: &keycloak.UsersPermissionsViewScopeArgs{
//					Policies: pulumi.StringArray{
//						testClientUserPolicy.ID(),
//					},
//					Description:      pulumi.String("description"),
//					DecisionStrategy: pulumi.String("UNANIMOUS"),
//				},
//				ManageScope: &keycloak.UsersPermissionsManageScopeArgs{
//					Policies: pulumi.StringArray{
//						testClientUserPolicy.ID(),
//					},
//					Description:      pulumi.String("description"),
//					DecisionStrategy: pulumi.String("UNANIMOUS"),
//				},
//				MapRolesScope: &keycloak.UsersPermissionsMapRolesScopeArgs{
//					Policies: pulumi.StringArray{
//						testClientUserPolicy.ID(),
//					},
//					Description:      pulumi.String("description"),
//					DecisionStrategy: pulumi.String("UNANIMOUS"),
//				},
//				ManageGroupMembershipScope: &keycloak.UsersPermissionsManageGroupMembershipScopeArgs{
//					Policies: pulumi.StringArray{
//						testClientUserPolicy.ID(),
//					},
//					Description:      pulumi.String("description"),
//					DecisionStrategy: pulumi.String("UNANIMOUS"),
//				},
//				ImpersonateScope: &keycloak.UsersPermissionsImpersonateScopeArgs{
//					Policies: pulumi.StringArray{
//						testClientUserPolicy.ID(),
//					},
//					Description:      pulumi.String("description"),
//					DecisionStrategy: pulumi.String("UNANIMOUS"),
//				},
//				UserImpersonatedScope: &keycloak.UsersPermissionsUserImpersonatedScopeArgs{
//					Policies: pulumi.StringArray{
//						testClientUserPolicy.ID(),
//					},
//					Description:      pulumi.String("description"),
//					DecisionStrategy: pulumi.String("UNANIMOUS"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Argument Reference
//
// The following arguments are supported:
//
// - `realmId` - (Required) The realm in which to manage fine-grained user permissions.
//
// Each of the scopes that can be managed are defined below:
//
// - `viewScope` - (Optional) When specified, set the scope based view permission.
// - `manageScope` - (Optional) When specified, set the scope based manage permission.
// - `mapRolesScope` - (Optional) When specified, set the scope based mapRoles permission.
// - `manageGroupMembershipScope` - (Optional) When specified, set the scope based manageGroupMembership permission.
// - `impersonateScope` - (Optional) When specified, set the scope based impersonate permission.
// - `userImpersonatedScope` - (Optional) When specified, set the scope based userImpersonated permission.
//
// The configuration block for each of these scopes supports the following arguments:
//
// - `policies` - (Optional) Assigned policies to the permission. Each element within this list should be a policy ID.
// - `description` - (Optional) Description of the permission.
// - `decisionStrategy` - (Optional) Decision strategy of the permission.
//
// ### Attributes Reference
//
// In addition to the arguments listed above, the following computed attributes are exported:
//
// - `enabled` - When true, this indicates that fine-grained user permissions are enabled. This will always be `true`.
// - `authorizationResourceServerId` - Resource server id representing the realm management client on which these permissions are managed.
type UsersPermissions struct {
	pulumi.CustomResourceState

	// Resource server id representing the realm management client on which this permission is managed
	AuthorizationResourceServerId pulumi.StringOutput                                 `pulumi:"authorizationResourceServerId"`
	Enabled                       pulumi.BoolOutput                                   `pulumi:"enabled"`
	ImpersonateScope              UsersPermissionsImpersonateScopePtrOutput           `pulumi:"impersonateScope"`
	ManageGroupMembershipScope    UsersPermissionsManageGroupMembershipScopePtrOutput `pulumi:"manageGroupMembershipScope"`
	ManageScope                   UsersPermissionsManageScopePtrOutput                `pulumi:"manageScope"`
	MapRolesScope                 UsersPermissionsMapRolesScopePtrOutput              `pulumi:"mapRolesScope"`
	RealmId                       pulumi.StringOutput                                 `pulumi:"realmId"`
	UserImpersonatedScope         UsersPermissionsUserImpersonatedScopePtrOutput      `pulumi:"userImpersonatedScope"`
	ViewScope                     UsersPermissionsViewScopePtrOutput                  `pulumi:"viewScope"`
}

// NewUsersPermissions registers a new resource with the given unique name, arguments, and options.
func NewUsersPermissions(ctx *pulumi.Context,
	name string, args *UsersPermissionsArgs, opts ...pulumi.ResourceOption) (*UsersPermissions, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.RealmId == nil {
		return nil, errors.New("invalid value for required argument 'RealmId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource UsersPermissions
	err := ctx.RegisterResource("keycloak:index/usersPermissions:UsersPermissions", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetUsersPermissions gets an existing UsersPermissions resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetUsersPermissions(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *UsersPermissionsState, opts ...pulumi.ResourceOption) (*UsersPermissions, error) {
	var resource UsersPermissions
	err := ctx.ReadResource("keycloak:index/usersPermissions:UsersPermissions", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering UsersPermissions resources.
type usersPermissionsState struct {
	// Resource server id representing the realm management client on which this permission is managed
	AuthorizationResourceServerId *string                                     `pulumi:"authorizationResourceServerId"`
	Enabled                       *bool                                       `pulumi:"enabled"`
	ImpersonateScope              *UsersPermissionsImpersonateScope           `pulumi:"impersonateScope"`
	ManageGroupMembershipScope    *UsersPermissionsManageGroupMembershipScope `pulumi:"manageGroupMembershipScope"`
	ManageScope                   *UsersPermissionsManageScope                `pulumi:"manageScope"`
	MapRolesScope                 *UsersPermissionsMapRolesScope              `pulumi:"mapRolesScope"`
	RealmId                       *string                                     `pulumi:"realmId"`
	UserImpersonatedScope         *UsersPermissionsUserImpersonatedScope      `pulumi:"userImpersonatedScope"`
	ViewScope                     *UsersPermissionsViewScope                  `pulumi:"viewScope"`
}

type UsersPermissionsState struct {
	// Resource server id representing the realm management client on which this permission is managed
	AuthorizationResourceServerId pulumi.StringPtrInput
	Enabled                       pulumi.BoolPtrInput
	ImpersonateScope              UsersPermissionsImpersonateScopePtrInput
	ManageGroupMembershipScope    UsersPermissionsManageGroupMembershipScopePtrInput
	ManageScope                   UsersPermissionsManageScopePtrInput
	MapRolesScope                 UsersPermissionsMapRolesScopePtrInput
	RealmId                       pulumi.StringPtrInput
	UserImpersonatedScope         UsersPermissionsUserImpersonatedScopePtrInput
	ViewScope                     UsersPermissionsViewScopePtrInput
}

func (UsersPermissionsState) ElementType() reflect.Type {
	return reflect.TypeOf((*usersPermissionsState)(nil)).Elem()
}

type usersPermissionsArgs struct {
	ImpersonateScope           *UsersPermissionsImpersonateScope           `pulumi:"impersonateScope"`
	ManageGroupMembershipScope *UsersPermissionsManageGroupMembershipScope `pulumi:"manageGroupMembershipScope"`
	ManageScope                *UsersPermissionsManageScope                `pulumi:"manageScope"`
	MapRolesScope              *UsersPermissionsMapRolesScope              `pulumi:"mapRolesScope"`
	RealmId                    string                                      `pulumi:"realmId"`
	UserImpersonatedScope      *UsersPermissionsUserImpersonatedScope      `pulumi:"userImpersonatedScope"`
	ViewScope                  *UsersPermissionsViewScope                  `pulumi:"viewScope"`
}

// The set of arguments for constructing a UsersPermissions resource.
type UsersPermissionsArgs struct {
	ImpersonateScope           UsersPermissionsImpersonateScopePtrInput
	ManageGroupMembershipScope UsersPermissionsManageGroupMembershipScopePtrInput
	ManageScope                UsersPermissionsManageScopePtrInput
	MapRolesScope              UsersPermissionsMapRolesScopePtrInput
	RealmId                    pulumi.StringInput
	UserImpersonatedScope      UsersPermissionsUserImpersonatedScopePtrInput
	ViewScope                  UsersPermissionsViewScopePtrInput
}

func (UsersPermissionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*usersPermissionsArgs)(nil)).Elem()
}

type UsersPermissionsInput interface {
	pulumi.Input

	ToUsersPermissionsOutput() UsersPermissionsOutput
	ToUsersPermissionsOutputWithContext(ctx context.Context) UsersPermissionsOutput
}

func (*UsersPermissions) ElementType() reflect.Type {
	return reflect.TypeOf((**UsersPermissions)(nil)).Elem()
}

func (i *UsersPermissions) ToUsersPermissionsOutput() UsersPermissionsOutput {
	return i.ToUsersPermissionsOutputWithContext(context.Background())
}

func (i *UsersPermissions) ToUsersPermissionsOutputWithContext(ctx context.Context) UsersPermissionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UsersPermissionsOutput)
}

// UsersPermissionsArrayInput is an input type that accepts UsersPermissionsArray and UsersPermissionsArrayOutput values.
// You can construct a concrete instance of `UsersPermissionsArrayInput` via:
//
//	UsersPermissionsArray{ UsersPermissionsArgs{...} }
type UsersPermissionsArrayInput interface {
	pulumi.Input

	ToUsersPermissionsArrayOutput() UsersPermissionsArrayOutput
	ToUsersPermissionsArrayOutputWithContext(context.Context) UsersPermissionsArrayOutput
}

type UsersPermissionsArray []UsersPermissionsInput

func (UsersPermissionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*UsersPermissions)(nil)).Elem()
}

func (i UsersPermissionsArray) ToUsersPermissionsArrayOutput() UsersPermissionsArrayOutput {
	return i.ToUsersPermissionsArrayOutputWithContext(context.Background())
}

func (i UsersPermissionsArray) ToUsersPermissionsArrayOutputWithContext(ctx context.Context) UsersPermissionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UsersPermissionsArrayOutput)
}

// UsersPermissionsMapInput is an input type that accepts UsersPermissionsMap and UsersPermissionsMapOutput values.
// You can construct a concrete instance of `UsersPermissionsMapInput` via:
//
//	UsersPermissionsMap{ "key": UsersPermissionsArgs{...} }
type UsersPermissionsMapInput interface {
	pulumi.Input

	ToUsersPermissionsMapOutput() UsersPermissionsMapOutput
	ToUsersPermissionsMapOutputWithContext(context.Context) UsersPermissionsMapOutput
}

type UsersPermissionsMap map[string]UsersPermissionsInput

func (UsersPermissionsMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*UsersPermissions)(nil)).Elem()
}

func (i UsersPermissionsMap) ToUsersPermissionsMapOutput() UsersPermissionsMapOutput {
	return i.ToUsersPermissionsMapOutputWithContext(context.Background())
}

func (i UsersPermissionsMap) ToUsersPermissionsMapOutputWithContext(ctx context.Context) UsersPermissionsMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UsersPermissionsMapOutput)
}

type UsersPermissionsOutput struct{ *pulumi.OutputState }

func (UsersPermissionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UsersPermissions)(nil)).Elem()
}

func (o UsersPermissionsOutput) ToUsersPermissionsOutput() UsersPermissionsOutput {
	return o
}

func (o UsersPermissionsOutput) ToUsersPermissionsOutputWithContext(ctx context.Context) UsersPermissionsOutput {
	return o
}

// Resource server id representing the realm management client on which this permission is managed
func (o UsersPermissionsOutput) AuthorizationResourceServerId() pulumi.StringOutput {
	return o.ApplyT(func(v *UsersPermissions) pulumi.StringOutput { return v.AuthorizationResourceServerId }).(pulumi.StringOutput)
}

func (o UsersPermissionsOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *UsersPermissions) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

func (o UsersPermissionsOutput) ImpersonateScope() UsersPermissionsImpersonateScopePtrOutput {
	return o.ApplyT(func(v *UsersPermissions) UsersPermissionsImpersonateScopePtrOutput { return v.ImpersonateScope }).(UsersPermissionsImpersonateScopePtrOutput)
}

func (o UsersPermissionsOutput) ManageGroupMembershipScope() UsersPermissionsManageGroupMembershipScopePtrOutput {
	return o.ApplyT(func(v *UsersPermissions) UsersPermissionsManageGroupMembershipScopePtrOutput {
		return v.ManageGroupMembershipScope
	}).(UsersPermissionsManageGroupMembershipScopePtrOutput)
}

func (o UsersPermissionsOutput) ManageScope() UsersPermissionsManageScopePtrOutput {
	return o.ApplyT(func(v *UsersPermissions) UsersPermissionsManageScopePtrOutput { return v.ManageScope }).(UsersPermissionsManageScopePtrOutput)
}

func (o UsersPermissionsOutput) MapRolesScope() UsersPermissionsMapRolesScopePtrOutput {
	return o.ApplyT(func(v *UsersPermissions) UsersPermissionsMapRolesScopePtrOutput { return v.MapRolesScope }).(UsersPermissionsMapRolesScopePtrOutput)
}

func (o UsersPermissionsOutput) RealmId() pulumi.StringOutput {
	return o.ApplyT(func(v *UsersPermissions) pulumi.StringOutput { return v.RealmId }).(pulumi.StringOutput)
}

func (o UsersPermissionsOutput) UserImpersonatedScope() UsersPermissionsUserImpersonatedScopePtrOutput {
	return o.ApplyT(func(v *UsersPermissions) UsersPermissionsUserImpersonatedScopePtrOutput {
		return v.UserImpersonatedScope
	}).(UsersPermissionsUserImpersonatedScopePtrOutput)
}

func (o UsersPermissionsOutput) ViewScope() UsersPermissionsViewScopePtrOutput {
	return o.ApplyT(func(v *UsersPermissions) UsersPermissionsViewScopePtrOutput { return v.ViewScope }).(UsersPermissionsViewScopePtrOutput)
}

type UsersPermissionsArrayOutput struct{ *pulumi.OutputState }

func (UsersPermissionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*UsersPermissions)(nil)).Elem()
}

func (o UsersPermissionsArrayOutput) ToUsersPermissionsArrayOutput() UsersPermissionsArrayOutput {
	return o
}

func (o UsersPermissionsArrayOutput) ToUsersPermissionsArrayOutputWithContext(ctx context.Context) UsersPermissionsArrayOutput {
	return o
}

func (o UsersPermissionsArrayOutput) Index(i pulumi.IntInput) UsersPermissionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *UsersPermissions {
		return vs[0].([]*UsersPermissions)[vs[1].(int)]
	}).(UsersPermissionsOutput)
}

type UsersPermissionsMapOutput struct{ *pulumi.OutputState }

func (UsersPermissionsMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*UsersPermissions)(nil)).Elem()
}

func (o UsersPermissionsMapOutput) ToUsersPermissionsMapOutput() UsersPermissionsMapOutput {
	return o
}

func (o UsersPermissionsMapOutput) ToUsersPermissionsMapOutputWithContext(ctx context.Context) UsersPermissionsMapOutput {
	return o
}

func (o UsersPermissionsMapOutput) MapIndex(k pulumi.StringInput) UsersPermissionsOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *UsersPermissions {
		return vs[0].(map[string]*UsersPermissions)[vs[1].(string)]
	}).(UsersPermissionsOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*UsersPermissionsInput)(nil)).Elem(), &UsersPermissions{})
	pulumi.RegisterInputType(reflect.TypeOf((*UsersPermissionsArrayInput)(nil)).Elem(), UsersPermissionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UsersPermissionsMapInput)(nil)).Elem(), UsersPermissionsMap{})
	pulumi.RegisterOutputType(UsersPermissionsOutput{})
	pulumi.RegisterOutputType(UsersPermissionsArrayOutput{})
	pulumi.RegisterOutputType(UsersPermissionsMapOutput{})
}
